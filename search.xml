<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo使用指南</title>
      <link href="/2023/09/07/hexo-shi-yong-zhi-nan/"/>
      <url>/2023/09/07/hexo-shi-yong-zhi-nan/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java系列-设计模式</title>
      <link href="/2023/07/30/she-ji-mo-shi-zhi-shi-dian-zong-jie/"/>
      <url>/2023/07/30/she-ji-mo-shi-zhi-shi-dian-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h1><h2 id="0-1、软件设计基本原则"><a href="#0-1、软件设计基本原则" class="headerlink" title="0.1、软件设计基本原则"></a>0.1、软件设计基本原则</h2><ol><li>高内聚，低耦合；</li><li>面向抽象编程；</li><li>多用组合少用继承；</li><li>遵循开闭原则；</li></ol><h2 id="0-2、设计模式引入"><a href="#0-2、设计模式引入" class="headerlink" title="0.2、设计模式引入"></a>0.2、设计模式引入</h2><p>设计模式是计算机软件领域较抽象的东西，设计模式的作用：使 软件系统 变得 更加稳定、更易扩展、更易维护。</p><h2 id="0-3、设计模式简介"><a href="#0-3、设计模式简介" class="headerlink" title="0.3、设计模式简介"></a>0.3、设计模式简介</h2><p><font color='orange'>设计模式不分语言，共23种，分3种类型：创建型、行为型、结构型。</font></p><h1 id="1、设计模式"><a href="#1、设计模式" class="headerlink" title="1、设计模式"></a>1、设计模式</h1><h2 id="1-1、创建型（5种）"><a href="#1-1、创建型（5种）" class="headerlink" title="1.1、创建型（5种）"></a>1.1、创建型（5种）</h2><h3 id="1-1-1、Singleton（单例模式）"><a href="#1-1-1、Singleton（单例模式）" class="headerlink" title="1.1.1、Singleton（单例模式）"></a>1.1.1、Singleton（单例模式）</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>保证一个类仅有一个实例，并提供一个访问它的全局访问点。常见单例模式实现有：饿汉式、懒汉式、枚举式等。</font></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ol><li>构造方法设为私有，禁止它人创建对象。</li></ol><h4 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h4><p>当您想控制实例数目，节省系统资源的时候。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>优点：</p><ol><li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li><li>避免对资源的多重占用（比如写文件操作）。</li></ol></li><li><p>缺点：</p><p>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p></li></ul><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>一个班级只有一个班主任。</li><li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li><li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li></ol><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ol><li>要求生产唯一序列号。</li><li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li><li>创建一个对象消耗资源过多时可通过单例降低多次创建带来的消耗，比如 I&#x2F;O 与数据库的连接等。</li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><font color='red'>注意序列化对单例的破坏；</font></li><li><font color='red'>注意反射对单例的破坏；</font></li></ol><h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 实例一：基于双重校验锁方式实现单例 * * - 优点：懒加载，效率较好。 * * - 缺点：反序列化会对单例造成破坏 *   应对方案：要想防止序列化对单例的破坏，只要添加readResolve方法就可避免。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 实例二：基于 CAS 实现单例 * * - 优点： *   - 不需要使用传统的锁机制来保证线程安全； *   - 相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度； * * - 缺点： *   - 如果等待一直执行不成功(一直在死循环中)，会对CPU造成较大的执行开销； */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonByCAS</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SingletonByCAS</span><span class="token punctuation">></span></span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SingletonByCAS</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">SingletonByCAS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SingletonByCAS</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">SingletonByCAS</span> single <span class="token operator">=</span> <span class="token constant">INSTANCE</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> single<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> single<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            single <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonByCAS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">INSTANCE</span><span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> single<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> single<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 实例三：基于 枚举 实现单例 */</span><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">SingletonByEnum</span> <span class="token punctuation">&#123;</span>    <span class="token constant">INSTANCE</span><span class="token punctuation">;</span>    <span class="token comment">// 其它方法</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 实例四：基于双重校验锁方式实现单例（优化版） * * - 优点：懒加载，利用局部变量提高效率； * * - 缺点：反序列化会对单例造成破坏 *   应对方案：要想防止序列化对单例的破坏，只要添加readResolve方法就可避免。 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonByLocalVariable</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">SingletonByLocalVariable</span> singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">SingletonByLocalVariable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SingletonByLocalVariable</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SingletonByLocalVariable</span> tmp <span class="token operator">=</span> singleton<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">SingletonByLocalVariable</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                tmp <span class="token operator">=</span> singleton<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonByLocalVariable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    singleton <span class="token operator">=</span> tmp<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 实例五：基于静态内部类实现单例 * * - 原理：利用了classloder的机制来保证初始化instance时只有一个线程。 * * - 优点：这是一种懒加载，就是说Singleton类被装载了，instance不一定被初始化。 *        因为SingletonHolder类没有被主动使用，只有显式调用getInstance方法时， *        才会装载SingletonHolder类，从而实例化instance。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonByStaticInnerClass</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 私有构造，禁止通过new创建对象。</span>    <span class="token keyword">private</span> <span class="token class-name">SingletonByStaticInnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHholder</span><span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">SingletonByStaticInnerClass</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonByStaticInnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">SingletonByStaticInnerClass</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">SingletonHholder</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-2、AbstractFactory（抽象工厂）"><a href="#1-1-2、AbstractFactory（抽象工厂）" class="headerlink" title="1.1.2、AbstractFactory（抽象工厂）"></a>1.1.2、AbstractFactory（抽象工厂）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><font color='orange'>任何可以生成对象的方法或类，都可以称之为工厂。单例也是一个工厂。</font>主要解决接口选择问题。</p><h4 id="何时使用-1"><a href="#何时使用-1" class="headerlink" title="何时使用"></a>何时使用</h4><p>系统产品有多于一个的产品族，而系统只消费其中某一族的产品。</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ol><li>可以实现从工厂得到的产品彼此兼容。</li><li>可以避免具体产品和客户端代码之间的紧密耦合。</li><li>符合单一职责原则。</li><li>符合开闭原则。</li></ol></li><li>缺点<ol><li>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体实现中加代码。</li></ol></li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>QQ 换皮肤，一整套一起换。</li><li>生成不同操作系统对应的程序。</li></ol><h4 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h4><p>为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些都是成套的，即一系列具体产品。</p><p>假设一种情况，在您的家中，某一个衣柜（具体工厂）只能存放某一种衣服（成套，一系列具体产品），每次拿这种成套衣服时自然要从这个衣柜中取出。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><p>产品族难扩展，产品等级易扩展。</p><h4 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h4><ol><li><p>为何还需要工厂?</p><ol><li>灵活控制生产过程。</li><li>权限、修饰、日志等。</li></ol></li></ol><h4 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 抽象工厂模式 * * 抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供 * 方便，但不能为新的产品等级结构的增加提供这样的方便。 * * 三种工厂模式之间的关系： *      当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存 *      在一个产品等级结构时，抽象工厂模式退化成工厂方法模式； * *      抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是 *      一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。 * *      当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创 *      建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模 *      式退化成简单工厂模式。 * * 总结： *      抽象工厂模式是所有工厂模式中最为抽象和最具一般性的一种形态。 * *      抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知 *      道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个 *      对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方 *      便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和 *      所有具体工厂类，对“开闭原则”的支持呈现倾斜性。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">CarFactory</span> sportCarFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SportCarFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">TeslaCar</span> teslaCar <span class="token operator">=</span> sportCarFactory<span class="token punctuation">.</span><span class="token function">getTeslaCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BenzCar</span> benzCar <span class="token operator">=</span> sportCarFactory<span class="token punctuation">.</span><span class="token function">getBenzCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        teslaCar<span class="token punctuation">.</span><span class="token function">charge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        benzCar<span class="token punctuation">.</span><span class="token function">gasUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-3、FactoryMethod（工厂方法）"><a href="#1-1-3、FactoryMethod（工厂方法）" class="headerlink" title="1.1.3、FactoryMethod（工厂方法）"></a>1.1.3、FactoryMethod（工厂方法）</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟到了子类。</font></p><h4 id="何时使用-2"><a href="#何时使用-2" class="headerlink" title="何时使用"></a>何时使用</h4><p>明确地计划不同条件下创建不同实例。</p><h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>优点</p><ol><li>将具体产品和创建者解耦。</li><li>符合单一职责原则。</li><li>符合开闭原则。</li></ol></li><li><p>缺点</p><p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</p></li></ul><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。</li><li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。</li><li>设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</li></ol><h4 id="应用实例-2"><a href="#应用实例-2" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是如何生产出来的。</li><li>Hibernate 换数据库只需换驱动就可以。</li></ol><h4 id="源码应用"><a href="#源码应用" class="headerlink" title="源码应用"></a>源码应用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Calendar</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>text<span class="token punctuation">.</span></span>NumberFormat</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>ResourceBundle</span><span class="token punctuation">.</span><span class="token function">getBundle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span>URLStreamHandlerFactory</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>bind<span class="token punctuation">.</span></span>JAXBContext</span><span class="token punctuation">.</span>createMarshaller<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><p><font color='red'>在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意：复杂对象适合使用工厂模式，而简单对象不适合。</font></p><h4 id="代码实例-2"><a href="#代码实例-2" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 计算器 - 工厂方法模式 * * 工厂方法模式优点： *    1、使用工厂来创建对象，隐藏了具体产品类将被实例化的细节。 *    2、能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全 *       封装在具体工厂内部。 *    3、每种对象对应单独一个工厂，其目的主要为了解耦。 * * 工厂方法模式缺点： *    1、在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂 *       类，系统中类的个数将成对增加，这增加了系统的复杂度。 *    2、考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义， *       增加了系统的抽象性和理解难度。且在实现时可能需要用到DOM、反射等技术， *       增加了系统的实现难度。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FactoryMethodApp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">IFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AddFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Operation</span> operationAdd <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        operationAdd<span class="token punctuation">.</span><span class="token function">setVal1</span><span class="token punctuation">(</span><span class="token number">15.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        operationAdd<span class="token punctuation">.</span><span class="token function">setVal2</span><span class="token punctuation">(</span><span class="token number">19.3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>operationAdd<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 计算器 - 简单工厂模式 * * 简单工厂模式优点: *    1、一个调用者想创建一个对象，只要知道其名称就行了。 *    2、屏蔽产品的具体实现，调用者只关心产品的接口。 * * 简单工厂模式缺点： *    1、增加新算法时，需要编写一个新类并继承Operation。 *    2、同时需要修改OperationFactory类的代码，这违反了“开闭原则”。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleFactoryApp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Operation</span> operationAdd <span class="token operator">=</span> <span class="token class-name">OperationFactory</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        operationAdd<span class="token punctuation">.</span><span class="token function">setVal1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        operationAdd<span class="token punctuation">.</span><span class="token function">setVal2</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>operationAdd<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-4、Builder（建造者模式）"><a href="#1-1-4、Builder（建造者模式）" class="headerlink" title="1.1.4、Builder（建造者模式）"></a>1.1.4、Builder（建造者模式）</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>将一个复杂对象的创建与它的表示分离，使得同样的构建过程可以创建不同的表示。</font></p><h4 id="何时使用-3"><a href="#何时使用-3" class="headerlink" title="何时使用"></a>何时使用</h4><p>一些基本部件不会变，而其组合经常变化的时候。</p><h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ol><li>建造者独立，易扩展。</li><li>便于控制细节风险。</li></ol></li><li>缺点<ol><li>产品必须有共同点，范围有限制。</li><li>内部变化复杂，有很多建造类。</li></ol></li></ul><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>需要生成的对象具有复杂的内部结构。</li><li>需要生成的对象内部属性本身相互依赖。</li><li>与不可变对象配合使用。</li></ol><h4 id="应用实例-3"><a href="#应用实例-3" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的 “套餐”。</li><li>JAVA 中的 StringBuilder。</li></ol><h4 id="源码应用-1"><a href="#源码应用-1" class="headerlink" title="源码应用"></a>源码应用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>service<span class="token punctuation">.</span>mvc<span class="token punctuation">.</span>method<span class="token punctuation">.</span></span>RequestMappingInfo</span><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>benas<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>support<span class="token punctuation">.</span></span>BeanDefinitionBuilder</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h4><p><font color='red'>与工厂模式的区别：建造者模式更加关注零件装配的顺序。</font></p><h4 id="代码实例-3"><a href="#代码实例-3" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Role</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> head<span class="token punctuation">;</span> <span class="token comment">//头部</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> face<span class="token punctuation">;</span> <span class="token comment">//脸部（脸部依赖于头部）</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> body<span class="token punctuation">;</span> <span class="token comment">//身体</span>    <span class="token keyword">private</span> <span class="token class-name">Double</span> hp<span class="token punctuation">;</span>   <span class="token comment">//生命值</span>    <span class="token keyword">private</span> <span class="token class-name">Double</span> sp<span class="token punctuation">;</span>   <span class="token comment">//能量值</span>    <span class="token keyword">private</span> <span class="token class-name">Double</span> mp<span class="token punctuation">;</span>   <span class="token comment">//魔法值</span>        <span class="token comment">// get/set/toString methods ...</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Builder</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token class-name">Role</span> role <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Role</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildHead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildFace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildHp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildSp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildMp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Role</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> role<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommonRoleBuilder</span> <span class="token keyword">extends</span> <span class="token class-name">Builder</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Role</span> role <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Role</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildHead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        role<span class="token punctuation">.</span><span class="token function">setHead</span><span class="token punctuation">(</span><span class="token string">"common head"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildFace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        role<span class="token punctuation">.</span><span class="token function">setFace</span><span class="token punctuation">(</span><span class="token string">"common face"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        role<span class="token punctuation">.</span><span class="token function">setBody</span><span class="token punctuation">(</span><span class="token string">"common body"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildHp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        role<span class="token punctuation">.</span><span class="token function">setHp</span><span class="token punctuation">(</span><span class="token number">100d</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildSp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        role<span class="token punctuation">.</span><span class="token function">setSp</span><span class="token punctuation">(</span><span class="token number">100d</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildMp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        role<span class="token punctuation">.</span><span class="token function">setMp</span><span class="token punctuation">(</span><span class="token number">100d</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Role</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> role<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Director</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Role</span> <span class="token function">constructAndGet</span><span class="token punctuation">(</span><span class="token class-name">Builder</span> builder<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        builder<span class="token punctuation">.</span><span class="token function">buildBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">buildHead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">buildFace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">buildHp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">buildMp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">buildSp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> builder<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 建造者模式 * * 定义： *      建造者模式（英：Builder Pattern）是一种创建型设计模式，又名： *      生成器模式。GOF 给建造者模式的定义为：将一个复杂对象的构建与 *      它的表示分离，使得同样的构建过程可以创建不同的表示。这句话说的 *      比较抽象，其实解释一下就是：将建造复杂对象的过程和组成对象的部 *      件解耦。 * * 建造者模式包含如下角色： *      Builder：抽象建造者 *      ConcreteBuilder：具体建造者 *      Director：指挥者 *      Product：产品角色 * * 优缺点： *      -优点：较好封装性、客户端无需知道产品内部组成的细节、 *            可以更精细控制产品的创建过程、容易扩展。 *      -缺点：不适合产品间差异大的场景、使用范围受到影响、 *             产品内部变化大，可能需要定义很多具体建造者 *             来适应，这可能导致系统很庞大。 * * 适用场景： *      1、需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个 *         成员属性。 *      2、需要生成的产品对象的属性相互依赖，需要指定其生成顺序。 *      3、对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥 *         者类，将创建过程封装在指挥者类中，而不在建造者类中。 *      4、隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的 *         产品。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Builder</span> commonBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CommonRoleBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Director</span> director <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Director</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Role</span> commonRole <span class="token operator">=</span> director<span class="token punctuation">.</span><span class="token function">constructAndGet</span><span class="token punctuation">(</span>commonBuilder<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>commonRole<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-5、Prototype（原型模式）"><a href="#1-1-5、Prototype（原型模式）" class="headerlink" title="1.1.5、Prototype（原型模式）"></a>1.1.5、Prototype（原型模式）</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>原型实例 指定 创建对象的种类，且通过 拷贝原型 创建 新对象。</font></p><p>相关知识点：Cloneable接口&#x2F;Object.clone方法；浅拷贝&#x2F;深拷贝；序列化实现深拷贝。</p><h4 id="何时使用-4"><a href="#何时使用-4" class="headerlink" title="何时使用"></a>何时使用</h4><ol><li>当一个系统应该独立于它的产品创建，构成和表示时。</li><li>当要实例化的类是在运行时刻指定时，例如，通过动态装载。</li><li>为了避免创建一个与产品类层次平行的工厂类层次时。</li><li>当一个类的实例只能由几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li></ol><h4 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ol><li>性能提高。</li><li>逃避构造函数的约束。</li><li>可以不耦合具体类的情况下克隆对象。</li><li>避免重复的初始化代码。</li><li>更方便的构建复杂对象。</li></ol></li><li>缺点<ol><li>设计克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构时。</li><li>必须实现 Cloneable 接口。</li></ol></li></ul><h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>资源优化场景；</li><li>类初始化需要消化非常多的资源；</li><li>性能和安全要求的场景；</li><li>通过 new 创建对象需要繁杂步骤时；</li><li>一个对象有多个修改；</li><li>当多个对象需要对同一对象执行操作时，可以将共享对象拷贝多个来应付每一个调用者对象；</li><li>实际开发中，原型模式一般和工厂方法一起使用。工厂方法可以将 原型模式拷贝生成的对象提供给调用者；</li></ol><h4 id="应用实例-4"><a href="#应用实例-4" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>细胞分裂。</li><li>JAVA 中的 Object clone() 方法。</li></ol><h4 id="源码中的应用"><a href="#源码中的应用" class="headerlink" title="源码中的应用"></a>源码中的应用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>support<span class="token punctuation">.</span></span>AbstracBeanDefinition</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Arrays</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h4><p><font color='red'>原型模式是通过 拷贝现有对象 来生成 新对象。浅拷贝实现 Cloneable，重写，深拷贝通过实现 Serializable 读取二进制流。</font></p><h4 id="代码实例-4"><a href="#代码实例-4" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 深拷贝/浅拷贝 测试注意事项： * 1、测试浅拷贝时，去掉Cloneable接口 和 clone方法。 * 2、测试深拷贝时，加上Cloneable接口 和 clone方法。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PeopleInfo</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">PeopleInfo</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"PeopleInfo&#123;"</span> <span class="token operator">+</span>                <span class="token string">"age="</span> <span class="token operator">+</span> age <span class="token operator">+</span>                <span class="token char">'&#125;'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/** 测试 浅拷贝 时去掉该方法 */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">PeopleInfo</span> peopleInfo<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> type<span class="token punctuation">;</span> <span class="token comment">// 0 / 1</span>    <span class="token keyword">public</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token class-name">PeopleInfo</span> peopleInfo<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>peopleInfo <span class="token operator">=</span> peopleInfo<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">PeopleInfo</span> <span class="token function">getPeopleInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> peopleInfo<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPeopleInfo</span><span class="token punctuation">(</span><span class="token class-name">PeopleInfo</span> peopleInfo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>peopleInfo <span class="token operator">=</span> peopleInfo<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> type<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setType</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"People&#123;"</span> <span class="token operator">+</span>                <span class="token string">"peopleInfo="</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPeopleInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                <span class="token string">", type="</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                <span class="token char">'&#125;'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/** 浅复制 clone方法实现 */</span><span class="token comment">//    @Override</span><span class="token comment">//    protected People clone() throws CloneNotSupportedException &#123;</span><span class="token comment">//        return (People) super.clone();</span><span class="token comment">//    &#125;</span>    <span class="token comment">/** 深复制 clone方法实现 */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token class-name">People</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">People</span> people <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">People</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        people<span class="token punctuation">.</span>peopleInfo <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">PeopleInfo</span><span class="token punctuation">)</span> people<span class="token punctuation">.</span><span class="token function">getPeopleInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> people<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 设计模式 - 原型模式 *  * 深拷贝：引用和基本数据类型 都会拷贝； * 浅拷贝：只会拷贝基本数据类型； */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrototypeApp</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** 浅拷贝 测试 */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shallowReplication</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">PeopleInfo</span> peopleInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PeopleInfo</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">People</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span>peopleInfo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">People</span> p2 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"p1-1: "</span> <span class="token operator">+</span> p1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 30 0</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"p2-1: "</span> <span class="token operator">+</span> p2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 30 0</span>        p1<span class="token punctuation">.</span><span class="token function">setType</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        peopleInfo<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"p1-2: "</span> <span class="token operator">+</span> p1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 35 1</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"p2-2: "</span> <span class="token operator">+</span> p2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 35 0</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/** 深拷贝 测试 */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deepReplication</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">PeopleInfo</span> peopleInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PeopleInfo</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">People</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span>peopleInfo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">People</span> p2 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"p1-1: "</span> <span class="token operator">+</span> p1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 30 0</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"p2-1: "</span> <span class="token operator">+</span> p2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 30 0</span>        p1<span class="token punctuation">.</span><span class="token function">setType</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        peopleInfo<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"p1-2: "</span> <span class="token operator">+</span> p1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 35 1</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"p2-2: "</span> <span class="token operator">+</span> p2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 30 0</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2、行为型（11种）"><a href="#1-2、行为型（11种）" class="headerlink" title="1.2、行为型（11种）"></a>1.2、行为型（11种）</h2><h3 id="1-2-1、Iterator（迭代器模式）"><a href="#1-2-1、Iterator（迭代器模式）" class="headerlink" title="1.2.1、Iterator（迭代器模式）"></a>1.2.1、Iterator（迭代器模式）</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>在不暴露对象内部的前提下，可以顺序访问对象的内部元素。</font></p><h4 id="何时使用-5"><a href="#何时使用-5" class="headerlink" title="何时使用"></a>何时使用</h4><p>需要对容器&#x2F;集合遍历时，可以使用迭代器模式。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><ul><li>数组实现</li><li>链表实现</li></ul><h4 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>优点</p><ol><li>它支持以不同方式遍历一个聚合对象；</li><li>迭代器简化了聚合类；</li><li>在同一聚合上可以有多个遍历；</li><li>迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码；</li></ol></li><li><p>缺点</p><p>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p></li></ul><h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>访问一个聚合对象的内部元素而无须暴露其内部表示。</li><li>需要为聚合对象提供多种遍历方式。</li><li>为遍历不同的聚合结构提供一个统一的接口。</li></ol><h4 id="应用实例-5"><a href="#应用实例-5" class="headerlink" title="应用实例"></a>应用实例</h4><p>JAVA 中的 iterator。</p><h4 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h4><p><font color='red'>迭代器模式分离了集合对象的遍历行为，抽象出一个迭代器类，可实现不爆露对象内部就可访问其内部元素；</font></p><h4 id="代码实例-5"><a href="#代码实例-5" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterator</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IPerson</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getPersonInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IPersonList</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IPerson</span><span class="token punctuation">></span></span> <span class="token function">getPersonList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Iterator</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造器进来了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PersonIterator</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IPerson</span><span class="token punctuation">></span></span> personList<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">PersonIterator</span><span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IPerson</span><span class="token punctuation">></span></span> personList<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>personList <span class="token operator">=</span> personList<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>personList <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token boolean">false</span> <span class="token operator">:</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>personList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>personList <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>personList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>personList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">++</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>personList <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>personList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PersonList</span> <span class="token keyword">implements</span> <span class="token class-name">IPersonList</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IPerson</span><span class="token punctuation">></span></span> personList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IPerson</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">PersonList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">IPerson</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"孙悟空"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>personList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IPerson</span><span class="token punctuation">></span></span> <span class="token function">getPersonList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>personList<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Iterator</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PersonIterator</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>personList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IteratorApp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">IPersonList</span> personList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PersonList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IPerson</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> personList<span class="token punctuation">.</span><span class="token function">getPersonList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPersonInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Iterator</span> iterator <span class="token operator">=</span> personList<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">IPerson</span> person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IPerson</span><span class="token punctuation">)</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>person <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">getPersonInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-2、Observer（观察者模式）"><a href="#1-2-2、Observer（观察者模式）" class="headerlink" title="1.2.2、Observer（观察者模式）"></a>1.2.2、Observer（观察者模式）</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>多个参与者对象同时监听参考对象A，当参考对象A发生变化时，所有参与者对象依据该变化会做出相应的改变；</font></p><h4 id="何时使用-6"><a href="#何时使用-6" class="headerlink" title="何时使用"></a>何时使用</h4><p>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。</p><h4 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ol><li>观察者和被观察者是抽象耦合的。</li><li>建立一套触发机制。</li></ol></li><li>缺点<ol><li>参与者太多 导致 参照者发送通知会消耗很多资源；</li><li>参与者和参照者中间发生 循坏依赖可能导致系统崩溃。</li><li>参与者只知道参照者发生了变化，而如何变化却不知道；</li></ol></li></ul><h4 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A 对象的行为将影响 B 对象，B 对象的行为将影响 C 对象……，可以使用观察者模式创建一种链式触发机制。</li></ol><h4 id="应用实例-6"><a href="#应用实例-6" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。</li><li>西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</li></ol><h4 id="源码应用-2"><a href="#源码应用-2" class="headerlink" title="源码应用"></a>源码应用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Observable</span><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span>ApplicationListener</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><font color='red'>JAVA 中存在相关支持类；</font></li><li><font color='red'>应该避免循环引用；</font></li><li><font color='red'>顺序执行将导致某一观察者错误进而导致系统卡壳，故一般采用异步方式；</font></li></ol><h4 id="代码实例-6"><a href="#代码实例-6" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Observable</span></span><span class="token punctuation">;</span><span class="token comment">/** * 观察目标 * * 观察目标的逻辑是先发表文章，再改变观察目标的状态，再通知观察者。 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObserverTarget</span> <span class="token keyword">extends</span> <span class="token class-name">Observable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> article<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getArticle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> article<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">publish</span><span class="token punctuation">(</span><span class="token class-name">String</span> article<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>article <span class="token operator">=</span> article<span class="token punctuation">;</span>        <span class="token comment">// 改变状态</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 作用：通知所有观察者；内部逻辑：先获取同步锁，判断状态是否更新，若更新了则清空         * 观察目标状态，然后再使用for循环遍历所有观察者，一一调用观察者的更新方法通知观         * 察者更新。 **/</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Observable</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Observer</span></span><span class="token punctuation">;</span><span class="token comment">/** * 观察者：读者 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReaderObserver</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> article<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ReaderObserver</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">Observable</span> o<span class="token punctuation">,</span> <span class="token class-name">Object</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">updateArticle</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">updateArticle</span><span class="token punctuation">(</span><span class="token class-name">Observable</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ObserverTarget</span> target <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ObserverTarget</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>article <span class="token operator">=</span> <span class="token class-name">ObserverTarget</span><span class="token punctuation">.</span><span class="token function">getArticle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"读者 %s，你好，文章已更新：%s\n"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>article<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObserverApp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 创建一个观察目标</span>        <span class="token class-name">ObserverTarget</span> target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObserverTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 添加观察者</span>        target<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ReaderObserver</span><span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        target<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ReaderObserver</span><span class="token punctuation">(</span><span class="token string">"小王"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        target<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ReaderObserver</span><span class="token punctuation">(</span><span class="token string">"小张"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 发表文章</span>        target<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span><span class="token string">"啥是观察者模式。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-3、TemplateMethod（模板方法）"><a href="#1-2-3、TemplateMethod（模板方法）" class="headerlink" title="1.2.3、TemplateMethod（模板方法）"></a>1.2.3、TemplateMethod（模板方法）</h3><h4 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>也称钩子函数，其定义一个操作算法骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结果，即可重定义该算法的某些特定步骤。</font></p><h4 id="何时使用-7"><a href="#何时使用-7" class="headerlink" title="何时使用"></a>何时使用</h4><p>系统中存在一部分通用方法。</p><h4 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>优点</p><ol><li>封装不变部分，扩展可变部分。</li><li>提取公共代码，便于维护。</li><li>行为由父类控制，子类实现。</li></ol></li><li><p>缺点</p><p>每一个不同的实现都需要一个子类来实现，类的数量增加导致系统愈加庞大。</p></li></ul><h4 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>有多个子类共有的方法，且逻辑相同。</li><li>重要的、复杂的方法，可以考虑作为模板方法。</li></ol><h4 id="应用实例-7"><a href="#应用实例-7" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>在造房子的时候，地基、走线、水管都一样，只有后期加壁橱加栅栏等差异。 </li><li>西游记中的 81 难，就是一个顶层逻辑骨架。</li><li>spring 对 Hibernate 的支持，将一些规定好的方法封装起来，编程人员直接使用即可。</li></ol><h4 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h4><p><font color='red'>为防止恶意操作，模板方法一般会使用 final 修饰。</font></p><h4 id="代码实例-7"><a href="#代码实例-7" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractTemplate</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 模板方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">templateMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 重点</span>        <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 可以作为钩子方法</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"init 抽象层已经实现，子类也可以选择覆写"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 留给子类实现</span>    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteTemplate</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractTemplate</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类实现抽象方法 apply"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TemplateMethodApp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">AbstractTemplate</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 调用模板方法</span>        t<span class="token punctuation">.</span><span class="token function">templateMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-4、Strategy（策略模式）"><a href="#1-2-4、Strategy（策略模式）" class="headerlink" title="1.2.4、Strategy（策略模式）"></a>1.2.4、Strategy（策略模式）</h3><h4 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>一个类的行为或算法可在运行时修改。创建各种策略对象和一个随策略对象改变而会改变行为的context对象。策略对象会改变context对象的执行算法。</font></p><h4 id="何时使用-8"><a href="#何时使用-8" class="headerlink" title="何时使用"></a>何时使用</h4><p>一个系统有许多类，而区分它们的只是他们直接的行为。</p><h4 id="优缺点-8"><a href="#优缺点-8" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ol><li>算法可以自由切换。</li><li>避免使用多重条件判断。</li><li>扩展性良好。</li></ol></li><li>缺点<ol><li>策略类会增多。</li><li>所有策略类都需要对外暴露。</li></ol></li></ul><h4 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>一个系统中的许多类只存在行为上的区别时，该模式可以动态让一个对象在许多行为中选择一种行为。</li><li>一个系统需要动态地在几种算法中选择一种。</li><li>如果一个对象有很多行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li></ol><h4 id="应用实例-8"><a href="#应用实例-8" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>诸葛亮的锦囊妙计，每一个锦囊就是一个策略。</li><li>旅行的交通方式可以选择骑自行车、开汽车等，每一种旅行方式都是一个策略。</li><li>JAVA AWT 中的 LayoutManager。</li></ol><h4 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h4><p><font color='red'>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</font>、</p><h4 id="代码实例-8"><a href="#代码实例-8" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 会员接口 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Member</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 计算应付价格     * @param bookPrice 书籍原价(针对金额,建议使用BigDecimal,double会损失精度)     * @return 应付金额     */</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">calPrice</span><span class="token punctuation">(</span><span class="token keyword">double</span> bookPrice<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 初级会员 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrimaryMember</span> <span class="token keyword">implements</span> <span class="token class-name">Member</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">calPrice</span><span class="token punctuation">(</span><span class="token keyword">double</span> bookPrice<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"对于初级会员的没有折扣"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bookPrice<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 中级会员，买书打九折 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IntermediateMember</span> <span class="token keyword">implements</span> <span class="token class-name">Member</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">calPrice</span><span class="token punctuation">(</span><span class="token keyword">double</span> bookPrice<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"对于中级会员的折扣为10%"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bookPrice <span class="token operator">*</span> <span class="token number">0.9</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 高级会员，买书打八折 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdvancedMember</span> <span class="token keyword">implements</span> <span class="token class-name">Member</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">calPrice</span><span class="token punctuation">(</span><span class="token keyword">double</span> bookPrice<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"对于高级会员的折扣为20%"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bookPrice <span class="token operator">*</span> <span class="token number">0.8</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 书籍价格类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cashier</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 会员,策略对象     */</span>    <span class="token keyword">private</span> <span class="token class-name">Member</span> member<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Cashier</span><span class="token punctuation">(</span><span class="token class-name">Member</span> member<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>member <span class="token operator">=</span> member<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 计算应付价格     * @param booksPrice     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">quote</span><span class="token punctuation">(</span><span class="token keyword">double</span> booksPrice<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>member<span class="token punctuation">.</span><span class="token function">calPrice</span><span class="token punctuation">(</span>booksPrice<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookStoreApp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//选择并创建需要使用的策略对象</span>        <span class="token class-name">Member</span> strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AdvancedMember</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建环境</span>        <span class="token class-name">Cashier</span> cashier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cashier</span><span class="token punctuation">(</span>strategy<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//计算价格</span>        <span class="token keyword">double</span> quote <span class="token operator">=</span> cashier<span class="token punctuation">.</span><span class="token function">quote</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"高级会员图书的最终价格为："</span> <span class="token operator">+</span> quote<span class="token punctuation">)</span><span class="token punctuation">;</span>        strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntermediateMember</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cashier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cashier</span><span class="token punctuation">(</span>strategy<span class="token punctuation">)</span><span class="token punctuation">;</span>        quote <span class="token operator">=</span> cashier<span class="token punctuation">.</span><span class="token function">quote</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"中级会员图书的最终价格为："</span> <span class="token operator">+</span> quote<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-5、ChainOfResponsibility（职责链模式）"><a href="#1-2-5、ChainOfResponsibility（职责链模式）" class="headerlink" title="1.2.5、ChainOfResponsibility（职责链模式）"></a>1.2.5、ChainOfResponsibility（职责链模式）</h3><h4 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>创建一个请求接收者链，每一个请求接收者通过一个引用与其它接收者相连。请求发送者发送的请求会经过 接收者链，链中的每一个接收者都有机会处理该请求。实现了发送者与接收者的解耦。</font></p><h4 id="何时使用-9"><a href="#何时使用-9" class="headerlink" title="何时使用"></a>何时使用</h4><p>过滤消息中各种不雅内容；</p><h4 id="优缺点-9"><a href="#优缺点-9" class="headerlink" title="优缺点"></a>优缺点</h4><ol><li>请求的发送者和接收者解耦。</li><li>可以执行控制顺序。</li><li>符合开闭原则和单一职责原则。</li></ol><h4 id="应用场景-8"><a href="#应用场景-8" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>多个对象都能处理同一个请求，具体由哪个对象处理该请求则在运行时自动确定。</li><li>在不明确指定接收者的情况下，向多个对象中的某个对象发送一个请求。</li><li>动态指定一组对象处理请求的场景。</li></ol><h4 id="应用实例-9"><a href="#应用实例-9" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>红楼梦中的 “击鼓传花”。</li><li>JS 中的事件冒泡。</li><li>JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</li></ol><h4 id="源码应用-3"><a href="#源码应用-3" class="headerlink" title="源码应用"></a>源码应用</h4><pre class="line-numbers language-none"><code class="language-none">javax.servlet.Filterjavax.servlet.FilterChain<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="注意事项-9"><a href="#注意事项-9" class="headerlink" title="注意事项"></a>注意事项</h4><p><font color='red'>JAVA WEB 中有很多应用。</font></p><h4 id="代码实例-9"><a href="#代码实例-9" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ProcessHandler</span> processHandler <span class="token operator">=</span> <span class="token class-name">ProcessHandler</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Random</span> random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> radom <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">IStudent</span> student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span>radom<span class="token punctuation">,</span> <span class="token string">"学生"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"生病了，需要请假。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            processHandler<span class="token punctuation">.</span><span class="token function">sendMsg</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-6、Mediator（中介者模式）"><a href="#1-2-6、Mediator（中介者模式）" class="headerlink" title="1.2.6、Mediator（中介者模式）"></a>1.2.6、Mediator（中介者模式）</h3><h4 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>创建一个中介类来处理不同类之间的通信，且支持松耦合，代码易维护。</font></p><h4 id="何时使用-10"><a href="#何时使用-10" class="headerlink" title="何时使用"></a>何时使用</h4><p>多个类相互耦合，形成了网状结构。</p><h4 id="优缺点-10"><a href="#优缺点-10" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>优点</p><ol><li>降低了类的复杂度，将一对多转化成了一对一。</li><li>实现了类之间的解耦。</li><li>符合迪米特原则。</li></ol></li><li><p>缺点</p><p>中介者会庞大，变得复杂难以维护。</p></li></ul><h4 id="应用场景-9"><a href="#应用场景-9" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>对象间存在复杂引用关系，内部结构复杂难以使用；</li><li>通过一个中间类来封装多个类中的行为，而又不想生成太多的子类；</li></ol><h4 id="应用实例-10"><a href="#应用实例-10" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。</li><li>机场调度系统。</li><li>MVC 框架中 C（控制器）就是 M（模型）和 V（视图）的中介者。</li></ol><h4 id="注意事项-10"><a href="#注意事项-10" class="headerlink" title="注意事项"></a>注意事项</h4><p><font color='red'>不应当在职责混乱时使用。</font></p><h4 id="代码实例-10"><a href="#代码实例-10" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 用户接口 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IUser</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">receiveMsg</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMsg</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 中介者接口 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IMediator</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">regist</span><span class="token punctuation">(</span><span class="token class-name">IUser</span> iUser<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notifyAllMsg</span><span class="token punctuation">(</span><span class="token class-name">IUser</span> iUser<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractUser</span> <span class="token keyword">implements</span> <span class="token class-name">IUser</span><span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token class-name">IMediator</span> mediator<span class="token punctuation">;</span>    <span class="token keyword">protected</span>  <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> msg<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AbstractUser</span><span class="token punctuation">(</span><span class="token class-name">IMediator</span> mediator<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mediator <span class="token operator">=</span> mediator<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMsg</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">"说： "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">notifyAllMsg</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> msg<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteMediator</span> <span class="token keyword">implements</span> <span class="token class-name">IMediator</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IUser</span><span class="token punctuation">></span></span> userList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IUser</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">regist</span><span class="token punctuation">(</span><span class="token class-name">IUser</span> iUser<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>iUser <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>userList<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>iUser<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            userList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>iUser<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notifyAllMsg</span><span class="token punctuation">(</span><span class="token class-name">IUser</span> iUser<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IUser</span><span class="token punctuation">></span></span> iterator <span class="token operator">=</span> userList<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">IUser</span> tmp <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            tmp <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>tmp<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>iUser<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                tmp<span class="token punctuation">.</span><span class="token function">receiveMsg</span><span class="token punctuation">(</span>iUser<span class="token punctuation">.</span><span class="token function">getMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserA</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractUser</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">UserA</span><span class="token punctuation">(</span><span class="token class-name">IMediator</span> mediator<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>mediator<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">regist</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">receiveMsg</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"UserA received msg: "</span> <span class="token operator">+</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserB</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractUser</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">UserB</span><span class="token punctuation">(</span><span class="token class-name">IMediator</span> mediator<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>mediator<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">regist</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">receiveMsg</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"UserB received msg: "</span> <span class="token operator">+</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserC</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractUser</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">UserC</span><span class="token punctuation">(</span><span class="token class-name">IMediator</span> mediator<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>mediator<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">regist</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">receiveMsg</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"UserC received msg: "</span> <span class="token operator">+</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MediatorApp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">IMediator</span> mediator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteMediator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">IUser</span> userA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserA</span><span class="token punctuation">(</span>mediator<span class="token punctuation">,</span> <span class="token string">"孙悟空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">IUser</span> userB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserB</span><span class="token punctuation">(</span>mediator<span class="token punctuation">,</span> <span class="token string">"猪八戒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">IUser</span> userC <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserC</span><span class="token punctuation">(</span>mediator<span class="token punctuation">,</span> <span class="token string">"沙和尚"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userA<span class="token punctuation">.</span><span class="token function">sendMsg</span><span class="token punctuation">(</span><span class="token string">"大家好，我乃齐天大圣 孙悟空！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userB<span class="token punctuation">.</span><span class="token function">sendMsg</span><span class="token punctuation">(</span><span class="token string">"大家好，我乃高老庄 猪八戒！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userC<span class="token punctuation">.</span><span class="token function">sendMsg</span><span class="token punctuation">(</span><span class="token string">"大家好，我乃 沙和尚！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-7、Interpreter（解释器模式）"><a href="#1-2-7、Interpreter（解释器模式）" class="headerlink" title="1.2.7、Interpreter（解释器模式）"></a>1.2.7、Interpreter（解释器模式）</h3><h4 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>实现一个表达式接口，该接口解释一个特定上下文。该模式在SQL解析、符号处理引擎中有使用。</font></p><h4 id="何时使用-11"><a href="#何时使用-11" class="headerlink" title="何时使用"></a>何时使用</h4><p>某一个类型的问题发送频率特高，可以将该类型问题的各实例封装成一个简单描述，然后通过解释器来解释处理该描述。</p><h4 id="优缺点-11"><a href="#优缺点-11" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ol><li>可扩展性比较好，灵活。</li><li>增加了新的解释表达式的方式。</li><li>易于实现简单文法。</li></ol></li><li>缺点<ol><li>可利用场景比较少。</li><li>对于复杂的文法比较难维护。</li><li>解释器模式会引起类膨胀。</li><li>解释器模式采用递归调用方法。</li></ol></li></ul><h4 id="应用场景-10"><a href="#应用场景-10" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>将一个解释执行语言中的句子表示为一个抽象语法树。</li><li>重复出现的问题可以用一种简单的语言来进行表达。</li><li>简单语法需要解释的场景。</li></ol><h4 id="应用实例-11"><a href="#应用实例-11" class="headerlink" title="应用实例"></a>应用实例</h4><p>编译器、运算表达式计算。</p><h4 id="注意事项-11"><a href="#注意事项-11" class="headerlink" title="注意事项"></a>注意事项</h4><p><font color='red'>可利用场景比较少，JAVA 中可以用 expression4J 代替。</font></p><h4 id="代码实例-11"><a href="#代码实例-11" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 上下文环境 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">StringTokenizer</span> stringTokenizer<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> currentToken<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>stringTokenizer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringTokenizer</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stringTokenizer<span class="token punctuation">.</span><span class="token function">hasMoreTokens</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            currentToken <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stringTokenizer<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            currentToken <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> currentToken<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equalsWithCommand</span><span class="token punctuation">(</span><span class="token class-name">String</span> command<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>command<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentToken<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getCurrentToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>currentToken<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getTokenContext</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> str <span class="token operator">=</span> text<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> iterator <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token class-name">String</span> key <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Object</span> obj <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> obj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> str<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IExpressions</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">interpret</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListExpression</span> <span class="token keyword">implements</span> <span class="token class-name">IExpressions</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Context</span> context<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IExpressions</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IExpressions</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> context<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">getCurrentToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Error: the experssion missing end! "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">equalsWithCommand</span><span class="token punctuation">(</span><span class="token string">"END"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">IExpressions</span> expressions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CommandExperssion</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>expressions<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">interpret</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IExpressions</span><span class="token punctuation">></span></span> iterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interpret</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrimitiveExpression</span> <span class="token keyword">implements</span> <span class="token class-name">IExpressions</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Context</span> context<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> tokenName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> text<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">PrimitiveExpression</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> context<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>tokenName <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">getCurrentToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"PRINTLN"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>tokenName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">getCurrentToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">interpret</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"PRINTLN"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>tokenName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">getTokenContext</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProgramExpression</span> <span class="token keyword">implements</span> <span class="token class-name">IExpressions</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Context</span> context<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token constant">COMMAND</span> <span class="token operator">=</span> <span class="token string">"PROGRAM"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">IExpressions</span> expressions<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ProgramExpression</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">interpret</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">equalsWithCommand</span><span class="token punctuation">(</span><span class="token constant">COMMAND</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"the "</span> <span class="token operator">+</span> <span class="token constant">COMMAND</span> <span class="token operator">+</span> <span class="token string">"is Excepted for start!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>expressions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListExpression</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>expressions<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>expressions<span class="token punctuation">.</span><span class="token function">interpret</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ForExpression</span> <span class="token keyword">implements</span> <span class="token class-name">IExpressions</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Context</span> context<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> variable<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> start_index<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> end_index<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">IExpressions</span> expressions<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ForExpression</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> context<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">equalsWithCommand</span><span class="token punctuation">(</span><span class="token string">"FROM"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token class-name">String</span> nextStr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>start_index <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>nextStr<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">equalsWithCommand</span><span class="token punctuation">(</span><span class="token string">"TO"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token class-name">String</span> nextStr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>end_index <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>nextStr<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>variable <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>variable <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">getCurrentToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>expressions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListExpression</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>expressions<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">interpret</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>start_index<span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>end_index<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>variable<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>expressions<span class="token punctuation">.</span><span class="token function">interpret</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>variable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommandExperssion</span> <span class="token keyword">implements</span> <span class="token class-name">IExpressions</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Context</span> context<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">IExpressions</span> expressions<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">CommandExperssion</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> context<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">equalsWithCommand</span><span class="token punctuation">(</span><span class="token string">"FOR"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            expressions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForExpression</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            expressions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrimitiveExpression</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">interpret</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>expressions<span class="token punctuation">.</span><span class="token function">interpret</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterpreterApp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"PROGRAM PRINTLN start... FOR i FROM 90 TO 100 PRINTLN i END PRINTLN end... END"</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"str: "</span> <span class="token operator">+</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">IExpressions</span> expressions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProgramExpression</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        expressions<span class="token punctuation">.</span><span class="token function">interpret</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-8、Command（命令模式）"><a href="#1-2-8、Command（命令模式）" class="headerlink" title="1.2.8、Command（命令模式）"></a>1.2.8、Command（命令模式）</h3><h4 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>将请求以 命令形式 封装至对象A中，然后调用对象B将对象A传递给 能处理A对象中命令的 对象C，对象C拿到A对象后执行其中的命令。</font></p><h4 id="何时使用-12"><a href="#何时使用-12" class="headerlink" title="何时使用"></a>何时使用</h4><p>在某些场合，比如要对行为进行 “记录、撤销 &#x2F; 重做、事务” 等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将 “行为请求者” 与 “行为实现者” 解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p><h4 id="优缺点-12"><a href="#优缺点-12" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>优点</p><ol><li>降低了系统耦合度。</li><li>新命令可以很容易添加到系统中去。</li></ol></li><li><p>缺点</p><p>可能会导致某些系统有过多的具体命令类。</p></li></ul><h4 id="应用场景-11"><a href="#应用场景-11" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>GUI 中每一个按钮都是一条命令。</li><li>模拟 CMD。</li></ol><h4 id="应用实例-12"><a href="#应用实例-12" class="headerlink" title="应用实例"></a>应用实例</h4><p>struts 1 中 action 的核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层也会有对应不同的模型类，相当于具体的 Command。</p><h4 id="注意事项-12"><a href="#注意事项-12" class="headerlink" title="注意事项"></a>注意事项</h4><p><font color='red'>需要支持命令的撤销 (Undo) 操作和恢复 (Redo) 操作。</font></p><h4 id="代码实例-12"><a href="#代码实例-12" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 邮局接口 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IPost</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMail</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IReceiver</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readMail</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 邮局实现 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Post</span> <span class="token keyword">implements</span> <span class="token class-name">IPost</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">IReceiver</span> receiver<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Post</span><span class="token punctuation">(</span><span class="token class-name">IReceiver</span> receiver<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver <span class="token operator">=</span> receiver<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMail</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"邮局发送信件给收件人......"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver<span class="token punctuation">.</span><span class="token function">readMail</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 发信人 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Invoker</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">IPost</span> iPost<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setiPost</span><span class="token punctuation">(</span><span class="token class-name">IPost</span> iPost<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>iPost <span class="token operator">=</span> iPost<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postMail</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发信人投递邮件给邮局......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>iPost<span class="token punctuation">.</span><span class="token function">sendMail</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 接收人 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Receiver</span>  <span class="token keyword">implements</span> <span class="token class-name">IReceiver</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readMail</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"收件人收到信件，开始读取消息: "</span> <span class="token operator">+</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommandApp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Receiver</span> receiver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Receiver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">IPost</span> iPost <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Post</span><span class="token punctuation">(</span>receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Invoker</span> invoker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Invoker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        invoker<span class="token punctuation">.</span><span class="token function">setiPost</span><span class="token punctuation">(</span>iPost<span class="token punctuation">)</span><span class="token punctuation">;</span>        invoker<span class="token punctuation">.</span><span class="token function">postMail</span><span class="token punctuation">(</span><span class="token string">"好久不见，近来如何？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-9、State（状态模式）"><a href="#1-2-9、State（状态模式）" class="headerlink" title="1.2.9、State（状态模式）"></a>1.2.9、State（状态模式）</h3><h4 id="简介-12"><a href="#简介-12" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>状态模式下 会创建各种状态对象 和 一个会随状态对象改变而改变其行为的context对象。</font></p><h4 id="何时使用-13"><a href="#何时使用-13" class="headerlink" title="何时使用"></a>何时使用</h4><p>代码中包含大量与对象状态有关的条件语句。</p><h4 id="优缺点-13"><a href="#优缺点-13" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ol><li>封装了转换规则。</li><li>枚举可能的状态，在枚举状态之前需要确定状态种类。</li><li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li><li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li><li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li></ol></li><li>缺点<ol><li>状态模式的使用必然会增加系统类和对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li><li>状态模式对 “开闭原则” 的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</li></ol></li></ul><h4 id="应用场景-12"><a href="#应用场景-12" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>行为随状态改变而改变的场景。</li><li>条件、分支语句的代替者。</li></ol><h4 id="应用实例-13"><a href="#应用实例-13" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>打篮球的时候运动员可以有正常状态. 不正常状态和超常状态。</li><li>‘曾侯乙编钟’是具体环境(Context)，钟是抽象接口，钟 A是具体状态。</li></ol><h4 id="注意事项-13"><a href="#注意事项-13" class="headerlink" title="注意事项"></a>注意事项</h4><p><font color='red'>行为受状态约束时使用状态模式，而且状态不超过 5 个。</font></p><h4 id="代码实例-13"><a href="#代码实例-13" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">State</span> state<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token class-name">State</span> state<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">State</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">State</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAction</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeductState</span> <span class="token keyword">implements</span> <span class="token class-name">State</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"Deduct State"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAction</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"商品卖出，准备减库存"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//... 执行减库存的具体操作</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RevertState</span> <span class="token keyword">implements</span> <span class="token class-name">State</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAction</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"给此商品补库存"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//... 执行加库存的具体操作</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"Revert State"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StateApp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 我们需要操作的是 iPhone X</span>        <span class="token class-name">Context</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token string">"iPhone X"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 看看怎么进行补库存操作</span>        <span class="token class-name">State</span> revertState <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RevertState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        revertState<span class="token punctuation">.</span><span class="token function">doAction</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 同样的，减库存操作也非常简单</span>        <span class="token class-name">State</span> deductState <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DeductState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        deductState<span class="token punctuation">.</span><span class="token function">doAction</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果需要我们可以获取当前的状态</span>        <span class="token comment">// context.getState().toString();</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-10、Visitor（访问者模式）"><a href="#1-2-10、Visitor（访问者模式）" class="headerlink" title="1.2.10、Visitor（访问者模式）"></a>1.2.10、Visitor（访问者模式）</h3><h4 id="简介-13"><a href="#简介-13" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>元素类的执行算法可以随着访问者改变而改变。访问者对象可以处理元素对象上的操作。</font></p><h4 id="何时使用-14"><a href="#何时使用-14" class="headerlink" title="何时使用"></a>何时使用</h4><p>对一个对象执行多种不同操作，且要避免这些操作影响对象关联的类，可以使用该模式将这些操作封装到类中。</p><h4 id="优缺点-14"><a href="#优缺点-14" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ol><li>符合单一职责原则。</li><li>优秀的扩展性。</li><li>灵活性。</li></ol></li><li>缺点<ol><li>具体元素对访问者公布细节，违反了迪米特原则。</li><li>具体元素变更比较困难。</li><li>违反了依赖倒置原则，依赖具体类，没有依赖抽象。</li></ol></li></ul><h4 id="应用场景-13"><a href="#应用场景-13" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>对象对应的类很少改变，但需要在对象上添加新操作。</li><li>需要对一个对象执行多种不同操作，且要避免这些操作影响对象对应的类，且在添加新操作时也不想修改该类的场景；</li></ol><h4 id="应用实例-14"><a href="#应用实例-14" class="headerlink" title="应用实例"></a>应用实例</h4><p>你去朋友家做客，您是访问者，朋友接受您的访问，然后对朋友的描述做出一个判断，这就是访问者模式。</p><h4 id="注意事项-14"><a href="#注意事项-14" class="headerlink" title="注意事项"></a>注意事项</h4><p><font color='red'>访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</font></p><h4 id="代码实例-14"><a href="#代码实例-14" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 访问者接口 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IVisitor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token class-name">Manager</span> manager<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token class-name">Employees</span> employees<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 计算薪资访问者 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ISalaryVisitor</span> <span class="token keyword">extends</span> <span class="token class-name">IVisitor</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printManagerTotalSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printEmployeesTotalSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printTotalSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 抽象员工类 */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Staff</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> no<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> position<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">float</span> salary<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> length<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Staff</span><span class="token punctuation">(</span><span class="token class-name">String</span> no<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> position<span class="token punctuation">,</span> <span class="token keyword">float</span> salary<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>no <span class="token operator">=</span> no<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>position <span class="token operator">=</span> position<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">=</span> salary<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">+=</span> <span class="token punctuation">(</span>no <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>no<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> no<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">+=</span> <span class="token punctuation">(</span>no <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> name<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">+=</span> <span class="token punctuation">(</span>no <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>position<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> position<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">+=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printUserBaseInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>no <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>position <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>salary<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Staff</span> staff<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">Staff</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">String</span> no<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token class-name">IVisitor</span> visitor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// set/get methods ...</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Staff</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Staff</span><span class="token punctuation">></span></span> staffList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Staff</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token class-name">String</span> no<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> position<span class="token punctuation">,</span> <span class="token keyword">float</span> salary<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>no<span class="token punctuation">,</span> name<span class="token punctuation">,</span> position<span class="token punctuation">,</span> salary<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Staff</span> staff<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>staffList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>staff<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Staff</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">String</span> no<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Staff</span> staff <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>no <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>no<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>staffList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>staffList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>no<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>staffList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getNo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    staff <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>staffList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> staff<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token class-name">IVisitor</span> visitor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        visitor<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>staffList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>staffList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>staffList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employees</span> <span class="token keyword">extends</span> <span class="token class-name">Staff</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Employees</span><span class="token punctuation">(</span><span class="token class-name">String</span> no<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> position<span class="token punctuation">,</span> <span class="token keyword">float</span> salary<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>no<span class="token punctuation">,</span> name<span class="token punctuation">,</span> position<span class="token punctuation">,</span> salary<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Staff</span> staff<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Staff</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">String</span> no<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token class-name">IVisitor</span> visitor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        visitor<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 打印基本信息访问者 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintBaseInfoVisitor</span> <span class="token keyword">implements</span> <span class="token class-name">IVisitor</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token class-name">Manager</span> manager<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"管理者: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        manager<span class="token punctuation">.</span><span class="token function">printUserBaseInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token class-name">Employees</span> employees<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"普通员工: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        employees<span class="token punctuation">.</span><span class="token function">printUserBaseInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SalaryVisitor</span> <span class="token keyword">implements</span> <span class="token class-name">ISalaryVisitor</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">float</span> managerSalary<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">float</span> employeesSalary<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">SalaryVisitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        managerSalary <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        employeesSalary <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printManagerTotalSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"管理者薪资总和："</span> <span class="token operator">+</span> managerSalary<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printEmployeesTotalSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"一般员工薪资总和："</span> <span class="token operator">+</span> employeesSalary<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printTotalSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"员工薪资总和："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>managerSalary <span class="token operator">+</span> employeesSalary<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token class-name">Manager</span> manager<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        managerSalary <span class="token operator">+=</span> manager<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token class-name">Employees</span> employees<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        employeesSalary <span class="token operator">+=</span> employees<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VisitorApp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Staff</span> boss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"大老板"</span><span class="token punctuation">,</span> <span class="token string">"CEO"</span><span class="token punctuation">,</span> <span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Staff</span> financeManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">"11"</span><span class="token punctuation">,</span> <span class="token string">"张总"</span><span class="token punctuation">,</span> <span class="token string">"财务部经理"</span><span class="token punctuation">,</span> <span class="token number">60000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Staff</span> personnelManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">"12"</span><span class="token punctuation">,</span> <span class="token string">"王总"</span><span class="token punctuation">,</span> <span class="token string">"人事部经理"</span><span class="token punctuation">,</span> <span class="token number">60000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Staff</span> technicalManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">"13"</span><span class="token punctuation">,</span> <span class="token string">"陈总"</span><span class="token punctuation">,</span> <span class="token string">"技术部经理"</span><span class="token punctuation">,</span> <span class="token number">60000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Staff</span> deptAssistant <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">"1301"</span><span class="token punctuation">,</span> <span class="token string">"王助理"</span><span class="token punctuation">,</span> <span class="token string">"技术部助理"</span><span class="token punctuation">,</span> <span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Staff</span> deptManager1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">"1302"</span><span class="token punctuation">,</span> <span class="token string">"主管1"</span><span class="token punctuation">,</span> <span class="token string">"技术部主管"</span><span class="token punctuation">,</span> <span class="token number">30000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Staff</span> softwareEngineer1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employees</span><span class="token punctuation">(</span><span class="token string">"1302001"</span><span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token string">"软件工程师"</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Staff</span> softwareEngineer2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employees</span><span class="token punctuation">(</span><span class="token string">"1302002"</span><span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">,</span> <span class="token string">"软件工程师"</span><span class="token punctuation">,</span> <span class="token number">5500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Staff</span> softwareEngineer3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employees</span><span class="token punctuation">(</span><span class="token string">"1302003"</span><span class="token punctuation">,</span> <span class="token string">"王五"</span><span class="token punctuation">,</span> <span class="token string">"软件工程师"</span><span class="token punctuation">,</span> <span class="token number">4500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        deptManager1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>softwareEngineer1<span class="token punctuation">)</span><span class="token punctuation">;</span>        deptManager1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>softwareEngineer2<span class="token punctuation">)</span><span class="token punctuation">;</span>        deptManager1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>softwareEngineer3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Staff</span> deptManager2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">"1302"</span><span class="token punctuation">,</span> <span class="token string">"主管2"</span><span class="token punctuation">,</span> <span class="token string">"技术部主管"</span><span class="token punctuation">,</span> <span class="token number">30000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        technicalManager<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>deptAssistant<span class="token punctuation">)</span><span class="token punctuation">;</span>        technicalManager<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>deptManager1<span class="token punctuation">)</span><span class="token punctuation">;</span>        technicalManager<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>deptManager2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Staff</span> marketingManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">"14"</span><span class="token punctuation">,</span> <span class="token string">"吴总"</span><span class="token punctuation">,</span> <span class="token string">"市场部经理"</span><span class="token punctuation">,</span> <span class="token number">60000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        boss<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>financeManager<span class="token punctuation">)</span><span class="token punctuation">;</span>        boss<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>personnelManager<span class="token punctuation">)</span><span class="token punctuation">;</span>        boss<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>technicalManager<span class="token punctuation">)</span><span class="token punctuation">;</span>        boss<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>marketingManager<span class="token punctuation">)</span><span class="token punctuation">;</span>        boss<span class="token punctuation">.</span><span class="token function">printUserBaseInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        boss<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrintBaseInfoVisitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">SalaryVisitor</span> visitor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SalaryVisitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        boss<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span>        visitor<span class="token punctuation">.</span><span class="token function">printManagerTotalSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        visitor<span class="token punctuation">.</span><span class="token function">printEmployeesTotalSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        visitor<span class="token punctuation">.</span><span class="token function">printTotalSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-11、Memento（备忘录模式）"><a href="#1-2-11、Memento（备忘录模式）" class="headerlink" title="1.2.11、Memento（备忘录模式）"></a>1.2.11、Memento（备忘录模式）</h3><h4 id="简介-14"><a href="#简介-14" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>在不破坏封装性的前提下捕获一个对象的内部状态，并将该状态存于对象外。后续可恢复对象至该状态；</font></p><h4 id="何时使用-15"><a href="#何时使用-15" class="headerlink" title="何时使用"></a>何时使用</h4><p>用户需要取消不确定或者错误的操作时，能够恢复到他原先的状态，使得他有 “后悔药” 可吃。</p><h4 id="优缺点-15"><a href="#优缺点-15" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>优点</p><ol><li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。</li><li>实现了信息的封装，使得用户不需要关心状态的保存细节。</li></ol></li><li><p>缺点</p><p>消耗资源。类成员数量多导致占用大量资源，且保存时会占用内存。</p></li></ul><h4 id="应用场景-14"><a href="#应用场景-14" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>需要保存 &#x2F; 恢复数据的相关状态场景。</li><li>提供一个可回滚的操作。</li></ol><h4 id="应用实例-15"><a href="#应用实例-15" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>后悔药。</li><li>打游戏时的存档。</li><li>Windows 里的 ctri + z。</li><li>IE 中的后退。</li><li>数据库的事务管理。</li></ol><h4 id="注意事项-15"><a href="#注意事项-15" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><font color='red'>为了符合迪米特原则，还要增加一个管理备忘录的类。</font></li><li><font color='red'>为了节约内存，可使用原型模式 + 备忘录模式。</font></li></ol><h4 id="代码实例-15"><a href="#代码实例-15" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">INarrowMemento</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hero</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> blood<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> sword<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Random</span> random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>blood <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>sword <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">INarrowMemento</span> <span class="token function">createMemento</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"创建备忘录..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Memento</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>blood<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sword<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">restoreFromMemento</span><span class="token punctuation">(</span><span class="token class-name">INarrowMemento</span> memento<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"修改备忘录的状态..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>memento <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">Memento</span> memento2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Memento</span><span class="token punctuation">)</span> memento<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>blood <span class="token operator">=</span> memento2<span class="token punctuation">.</span><span class="token function">getBlood</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>sword <span class="token operator">=</span> memento2<span class="token punctuation">.</span><span class="token function">getSword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">koBoss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>blood <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sword <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"挑战BOSS失败！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">double</span> win <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>win <span class="token operator">&lt;=</span> <span class="token number">0.02</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"恭喜您，挑战BOSS成功。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"继续攻击BOSS..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> blood_sub <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> sword_sub <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>blood <span class="token operator">-=</span> blood_sub<span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>sword <span class="token operator">-=</span> sword_sub<span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"当前血量："</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>blood <span class="token operator">+</span> <span class="token string">", 当前力量："</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sword<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Memento</span> <span class="token keyword">implements</span> <span class="token class-name">INarrowMemento</span><span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> blood<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> sword<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Memento</span><span class="token punctuation">(</span><span class="token keyword">int</span> blood<span class="token punctuation">,</span> <span class="token keyword">int</span> sword<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>blood <span class="token operator">=</span> blood<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>sword <span class="token operator">=</span> sword<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getBlood</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> blood<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSword</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> sword<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Caretaker</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">INarrowMemento</span> memento<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">INarrowMemento</span> <span class="token function">getMemento</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> memento<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMemento</span><span class="token punctuation">(</span><span class="token class-name">INarrowMemento</span> memento<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>memento <span class="token operator">=</span> memento<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MementoOfBlackApp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Hero</span> hero <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Caretaker</span> caretaker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Caretaker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        caretaker<span class="token punctuation">.</span><span class="token function">setMemento</span><span class="token punctuation">(</span>hero<span class="token punctuation">.</span><span class="token function">createMemento</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ko <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>ko <span class="token operator">!=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> cnt <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第 "</span> <span class="token operator">+</span> cnt <span class="token operator">+</span> <span class="token string">" 次挑战！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ko <span class="token operator">=</span> hero<span class="token punctuation">.</span><span class="token function">koBoss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ko <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    hero<span class="token punctuation">.</span><span class="token function">restoreFromMemento</span><span class="token punctuation">(</span>caretaker<span class="token punctuation">.</span><span class="token function">getMemento</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    cnt <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ko <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    ko <span class="token operator">=</span> hero<span class="token punctuation">.</span><span class="token function">koBoss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ko <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3、结构型（7种）"><a href="#1-3、结构型（7种）" class="headerlink" title="1.3、结构型（7种）"></a>1.3、结构型（7种）</h2><h3 id="1-3-1、Composite（组合模式）"><a href="#1-3-1、Composite（组合模式）" class="headerlink" title="1.3.1、Composite（组合模式）"></a>1.3.1、Composite（组合模式）</h3><h4 id="简介-15"><a href="#简介-15" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>将对象组合成树形结构以表示 部分和整体 的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。</font></p><h4 id="何时使用-16"><a href="#何时使用-16" class="headerlink" title="何时使用"></a>何时使用</h4><ol><li>想表示对象部分 - 整体的层次结构（树形结构）。</li><li>忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li></ol><h5 id="优缺点-16"><a href="#优缺点-16" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li><p>优点</p><ol><li>高层模块调用简单。</li><li>节点自由增加。</li></ol></li><li><p>缺点</p><p>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p></li></ul><h4 id="应用场景-15"><a href="#应用场景-15" class="headerlink" title="应用场景"></a>应用场景</h4><p>部分. 整体场景，如树形菜单，文件. 文件夹的管理。</p><h4 id="应用实例-16"><a href="#应用实例-16" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>算术表达式包括操作数. 操作符和另一个操作数，其中，另一个操作符也可以是操作数. 操作符和另一个操作数。</li><li>在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</li></ol><h4 id="注意事项-16"><a href="#注意事项-16" class="headerlink" title="注意事项"></a>注意事项</h4><p><font color='red'>定义时 为 具体类。</font></p><h4 id="代码实例-16"><a href="#代码实例-16" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> dept<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> salary<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">></span></span> subordinates<span class="token punctuation">;</span> <span class="token comment">// 下属</span>    <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token class-name">String</span> dept<span class="token punctuation">,</span> <span class="token keyword">int</span> sal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dept <span class="token operator">=</span> dept<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">=</span> sal<span class="token punctuation">;</span>        subordinates <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Employee</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        subordinates<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Employee</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        subordinates<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">></span></span> <span class="token function">getSubordinates</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> subordinates<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token string">"Employee :[ Name : "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">", dept : "</span> <span class="token operator">+</span> dept <span class="token operator">+</span> <span class="token string">", salary :"</span> <span class="token operator">+</span> salary<span class="token operator">+</span><span class="token string">" ]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-2、Facade（外观模式）"><a href="#1-3-2、Facade（外观模式）" class="headerlink" title="1.3.2、Facade（外观模式）"></a>1.3.2、Facade（外观模式）</h3><h4 id="简介-16"><a href="#简介-16" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>为子系统内部一系列小接口提供一个高层接口，通过高层接口来统一访问操作系统，提高了使用子系统的便利性；</font></p><h4 id="何时使用-17"><a href="#何时使用-17" class="headerlink" title="何时使用"></a>何时使用</h4><ol><li>无需知道系统内部，只需提供一个系统 “接待员” 即可。</li><li>定义系统的入口。</li></ol><h4 id="优缺点-17"><a href="#优缺点-17" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>优点</p><ol><li>减少系统相互依赖。</li><li>提高灵活性。</li><li>提高了安全性。</li></ol></li><li><p>缺点</p><p>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p></li></ul><h4 id="应用场景-16"><a href="#应用场景-16" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>为复杂的模块或子系统提供外界访问的模块。</li><li>子系统相对独立。</li><li>预防低水平人员带来的风险。</li></ol><h4 id="应用实例-17"><a href="#应用实例-17" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。</li><li>JAVA 的三层开发模式。</li></ol><h4 id="注意事项-17"><a href="#注意事项-17" class="headerlink" title="注意事项"></a>注意事项</h4><p><font color='red'>在层次化结构中，可以使用外观模式定义系统每一层的入口。</font></p><h4 id="代码实例-17"><a href="#代码实例-17" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Shape</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token keyword">implements</span> <span class="token class-name">Shape</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Circle::draw()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token keyword">implements</span> <span class="token class-name">Shape</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Rectangle::draw()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FacadeApp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 画一个圆形</span>        <span class="token class-name">Shape</span> circle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        circle<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 画一个长方形</span>        <span class="token class-name">Shape</span> rectangle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rectangle<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShapeMaker</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Shape</span> circle<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Shape</span> rectangle<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Shape</span> square<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ShapeMaker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        circle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rectangle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        square <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Square</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drawCircle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        circle<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drawRectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        rectangle<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drawSquare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        square<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShapeMakerApp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ShapeMaker</span> shapeMaker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ShapeMaker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 客户端调用现在更加清晰了</span>        shapeMaker<span class="token punctuation">.</span><span class="token function">drawCircle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        shapeMaker<span class="token punctuation">.</span><span class="token function">drawRectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        shapeMaker<span class="token punctuation">.</span><span class="token function">drawSquare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-3、Proxy（代理模式）"><a href="#1-3-3、Proxy（代理模式）" class="headerlink" title="1.3.3、Proxy（代理模式）"></a>1.3.3、Proxy（代理模式）</h3><h4 id="简介-17"><a href="#简介-17" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>为某个动作生成一个代理，用来控制对目标对象的访问。</font></p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><ul><li>静态代理</li><li>动态代理</li></ul><h4 id="何时使用-18"><a href="#何时使用-18" class="headerlink" title="何时使用"></a>何时使用</h4><p>想在访问一个类时做一些控制。</p><h4 id="优缺点-18"><a href="#优缺点-18" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ol><li>职责清晰。</li><li>高扩展性。</li><li>智能化。</li></ol></li><li>缺点<ol><li>由于增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</li><li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li></ol></li></ul><h4 id="应用场景-17"><a href="#应用场景-17" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>远程代理。</li><li>虚拟代理。</li><li>Copy-on-Write 代理。</li><li>保护（Protect or Access）代理。</li><li>Cache 代理。</li><li>防火墙（Firewall）代理。</li><li>同步化（Synchronization）代理。</li><li>智能引用（Smart Reference）代理。</li></ol><h4 id="应用实例-18"><a href="#应用实例-18" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>Windows 中的快捷方式。</li><li>猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。</li><li>买火车票不一定在火车站买，也可以去代售点。</li><li>一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。</li><li>spring aop。</li></ol><h4 id="注意事项-18"><a href="#注意事项-18" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><font color='red'>与适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</font></li><li><font color='red'>与装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</font></li></ol><h4 id="代码实例-18"><a href="#代码实例-18" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Food</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">setChicken</span><span class="token punctuation">(</span><span class="token class-name">String</span> chicken<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">setSpicy</span><span class="token punctuation">(</span><span class="token class-name">String</span> spicy<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">setNoodle</span><span class="token punctuation">(</span><span class="token class-name">String</span> noodle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">setSalt</span><span class="token punctuation">(</span><span class="token class-name">String</span> salt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FoodService</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Food</span> <span class="token function">makeChicken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Food</span> <span class="token function">makeNoodle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FoodServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">FoodService</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Food</span> <span class="token function">makeChicken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Food</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Chicken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f<span class="token punctuation">.</span><span class="token function">setChicken</span><span class="token punctuation">(</span><span class="token string">"1kg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f<span class="token punctuation">.</span><span class="token function">setSpicy</span><span class="token punctuation">(</span><span class="token string">"1g"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f<span class="token punctuation">.</span><span class="token function">setSalt</span><span class="token punctuation">(</span><span class="token string">"3g"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> f<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Food</span> <span class="token function">makeNoodle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Food</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Noodle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f<span class="token punctuation">.</span><span class="token function">setNoodle</span><span class="token punctuation">(</span><span class="token string">"500g"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f<span class="token punctuation">.</span><span class="token function">setSalt</span><span class="token punctuation">(</span><span class="token string">"5g"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> f<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Chicken</span> <span class="token keyword">extends</span> <span class="token class-name">Food</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> chicken<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> spicy<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> salt<span class="token punctuation">;</span>    <span class="token comment">// set/get methods... </span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Noodle</span> <span class="token keyword">extends</span> <span class="token class-name">Food</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> noodle<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> salt<span class="token punctuation">;</span>    <span class="token comment">// set/get methods...</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FoodServiceProxy</span> <span class="token keyword">implements</span> <span class="token class-name">FoodService</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 内部一定要有一个真实的实现类，当然也可以通过构造方法注入</span>    <span class="token keyword">private</span> <span class="token class-name">FoodService</span> foodService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FoodServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Food</span> <span class="token function">makeChicken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我们马上要开始制作鸡肉了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，</span>        <span class="token comment">// 代理只是在核心代码前后做些“无足轻重”的事情</span>        <span class="token class-name">Food</span> food <span class="token operator">=</span> foodService<span class="token punctuation">.</span><span class="token function">makeChicken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"鸡肉制作完成啦，加点胡椒粉"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 增强</span>        food<span class="token punctuation">.</span><span class="token function">addCondiment</span><span class="token punctuation">(</span><span class="token string">"pepper"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> food<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Food</span> <span class="token function">makeNoodle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"准备制作拉面~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Food</span> food <span class="token operator">=</span> foodService<span class="token punctuation">.</span><span class="token function">makeNoodle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"制作完成啦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> food<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyApp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">FoodService</span> foodService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FoodServiceProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        foodService<span class="token punctuation">.</span><span class="token function">makeChicken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-4、Adpter（适配器模式）"><a href="#1-3-4、Adpter（适配器模式）" class="headerlink" title="1.3.4、Adpter（适配器模式）"></a>1.3.4、Adpter（适配器模式）</h3><h4 id="简介-18"><a href="#简介-18" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>Adapter模式可以使得 不兼容的接口变得兼容。</font></p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><ul><li>Object Adapter</li><li>Class Adapter</li></ul><h4 id="何时使用-19"><a href="#何时使用-19" class="headerlink" title="何时使用"></a>何时使用</h4><ol><li>系统需要使用现有的类，而此类的接口不符合系统需要。</li><li>想要建立一个可以重复使用的类，可以使得不兼容的类变得兼容起来。</li><li>通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</li></ol><h4 id="优缺点-19"><a href="#优缺点-19" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ol><li>可以让任何两个没有关联的类一起运行。</li><li>提高了类的复用。</li><li>增加了类的透明度。</li><li>灵活性好。</li></ol></li><li>缺点<ol><li>过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</li><li>由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</li></ol></li></ul><h4 id="应用场景-18"><a href="#应用场景-18" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>希望使用某些现有类，但接口与代码不兼容时，可以使用适配器模式。</li><li>希望重用几个现有子类，这些子类缺少一些不能添加到超类中的公共功能时，可以使用适配器模式。</li></ol><h4 id="应用实例-19"><a href="#应用实例-19" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。</li><li>JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。</li><li>在 LINUX 上运行 WINDOWS 程序。 4. JAVA 中的 jdbc。</li></ol><h4 id="源码应用-4"><a href="#源码应用-4" class="headerlink" title="源码应用"></a>源码应用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Arrays</span>#<span class="token function">asList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Collections</span>#<span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>event<span class="token punctuation">.</span></span>GenericApplicationListenerAdapter</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="注意事项-19"><a href="#注意事项-19" class="headerlink" title="注意事项"></a>注意事项</h4><p><font color='red'>适配器不是在详细设计时添加的，而是解决正在服役的项目问题。</font></p><h4 id="代码实例-19"><a href="#代码实例-19" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 适配器模式 * * 简介： *      GOF是这样给适配器模式(Adapter)定义的：将一个类的接口转化成用户需要的 *      另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类 *      可以一起工作。 * * 实现方式-包含以下角色： *      Target：目标抽象类 *      Adapter：适配器类 *      Adaptee：适配者类 *      Client：客户类 * * 优缺点： *      - 优点：将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者 *             类，而无须修改原有代码。 *             增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客 *             户端类来说是透明的，而且提高了适配者的复用性。 *             灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配 *             器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开 *             闭原则”。 *      - 缺点：过多地使用适配器，会让系统非常零乱，不易整体进行把握。 *             对于类适配器而言，由于 JAVA 至多继承一个类，所以至多只能适配一 *             个适配者类，而且目标类必须是抽象类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Iphone6Plus</span> iphone6Plus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Iphone6Plus</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AppleCharger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        iphone6Plus<span class="token punctuation">.</span><span class="token function">charge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=============================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">GalaxyS7</span> galaxyS7 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GalaxyS7</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AndroidCharger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        galaxyS7<span class="token punctuation">.</span><span class="token function">charge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=============================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Adapter</span> adapter  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Adapter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AndroidCharger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Iphone6Plus</span> newIphone <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Iphone6Plus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newIphone<span class="token punctuation">.</span><span class="token function">setLightningInterface</span><span class="token punctuation">(</span>adapter<span class="token punctuation">)</span><span class="token punctuation">;</span>        newIphone<span class="token punctuation">.</span><span class="token function">charge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-5、Decorator（装饰模式）"><a href="#1-3-5、Decorator（装饰模式）" class="headerlink" title="1.3.5、Decorator（装饰模式）"></a>1.3.5、Decorator（装饰模式）</h3><h4 id="简介-19"><a href="#简介-19" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>动态地给一个对象添加一些额外职责。就扩展功能而言， 它比生成子类更为灵活。</font></p><h4 id="何时使用-20"><a href="#何时使用-20" class="headerlink" title="何时使用"></a>何时使用</h4><p>既想扩展类，又不想通过子类的方式实现。</p><h4 id="优缺点-20"><a href="#优缺点-20" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>优点</p><ol><li>不改变原有对象的情况下给一个对象扩展功能。</li><li>使用不同的组合可以实现不同的效果。</li><li>符合开闭原则。</li></ol></li><li><p>缺点</p><p>多层装饰比较复杂。</p></li></ul><h4 id="应用场景-19"><a href="#应用场景-19" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>扩展一个类的功能。</li><li>动态增加功能，动态撤销。</li></ol><h4 id="应用实例-20"><a href="#应用实例-20" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>孙悟空有 72 变，当他变成 “庙宇” 后，他的根本还是一只猴子，但是他又有了庙宇的功能。</li><li>不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</li></ol><h4 id="源码中的应用-1"><a href="#源码中的应用-1" class="headerlink" title="源码中的应用"></a>源码中的应用</h4><pre class="line-numbers language-none"><code class="language-none">Servlet APIjavax.servlet.http.HttpServletRequestWrapperjavax.servlet.http.HttpServletResponseWrapper<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="注意事项-20"><a href="#注意事项-20" class="headerlink" title="注意事项"></a>注意事项</h4><p><font color='red'>可代替继承。</font></p><h4 id="代码实例-20"><a href="#代码实例-20" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Beverage</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 返回描述</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">String</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回价格</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">double</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlackTea</span> <span class="token keyword">extends</span> <span class="token class-name">Beverage</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"红茶"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GreenTea</span> <span class="token keyword">extends</span> <span class="token class-name">Beverage</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"绿茶"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">11</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 调料</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Condiment</span> <span class="token keyword">extends</span> <span class="token class-name">Beverage</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Mango</span> <span class="token keyword">extends</span> <span class="token class-name">Condiment</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Beverage</span> bevarage<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Mango</span><span class="token punctuation">(</span><span class="token class-name">Beverage</span> bevarage<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>bevarage <span class="token operator">=</span> bevarage<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> bevarage<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", 加芒果"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> bevarage<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 加芒果需要 3 元</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Lemon</span> <span class="token keyword">extends</span> <span class="token class-name">Condiment</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Beverage</span> bevarage<span class="token punctuation">;</span>    <span class="token comment">// 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，</span>    <span class="token comment">// 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶</span>    <span class="token keyword">public</span> <span class="token class-name">Lemon</span><span class="token punctuation">(</span><span class="token class-name">Beverage</span> bevarage<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>bevarage <span class="token operator">=</span> bevarage<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 装饰</span>        <span class="token keyword">return</span> bevarage<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", 加柠檬"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 装饰</span>        <span class="token keyword">return</span> bevarage<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 加柠檬需要 2 元</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DecoratorApp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 首先，我们需要一个基础饮料，红茶、绿茶或咖啡</span>        <span class="token class-name">Beverage</span> beverage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GreenTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 开始装饰</span>        beverage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Lemon</span><span class="token punctuation">(</span>beverage<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 先加一份柠檬</span>        beverage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mango</span><span class="token punctuation">(</span>beverage<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 再加一份芒果</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>beverage<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 价格：￥"</span> <span class="token operator">+</span> beverage<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//"绿茶, 加柠檬, 加芒果 价格：￥16"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-6、Bridge（桥接模式）"><a href="#1-3-6、Bridge（桥接模式）" class="headerlink" title="1.3.6、Bridge（桥接模式）"></a>1.3.6、Bridge（桥接模式）</h3><h4 id="简介-20"><a href="#简介-20" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>将抽象与实现分离，使它们都可以独立地变化。</font></p><h4 id="何时使用-21"><a href="#何时使用-21" class="headerlink" title="何时使用"></a>何时使用</h4><p>系统的实现有多个方案，每一种都可能变化。</p><h4 id="优缺点-21"><a href="#优缺点-21" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><p>优点</p><ol><li>抽象和实现的分离。</li><li>优秀的扩展能力。</li><li>实现细节对客户透明。</li></ol></li><li><p>缺点</p><p>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p></li></ul><h4 id="应用场景-20"><a href="#应用场景-20" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>不希望在抽象类和它的实现之间有一个固定的绑定关系；</li><li>类的抽象和实现都应该可以通过生成子类的方法加以扩充；</li><li>对一个抽象的实现部分的修改应对客户不产生影响，即客户代码无需重新编译；</li></ol><h4 id="应用实例-21"><a href="#应用实例-21" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。</li><li>墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。</li></ol><h4 id="注意事项-21"><a href="#注意事项-21" class="headerlink" title="注意事项"></a>注意事项</h4><p><font color='red'>对于两个独立变化的维度，使用桥接模式非常合适。</font></p><h4 id="代码实例-21"><a href="#代码实例-21" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 电灯接口 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ILight</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">electricConnected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">light</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">electricClosed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 开关顶层类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BaseSwitch</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token class-name">ILight</span> light<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">BaseSwitch</span><span class="token punctuation">(</span><span class="token class-name">ILight</span> light<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>light <span class="token operator">=</span> light<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">makeLight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>light<span class="token punctuation">.</span><span class="token function">electricConnected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>light<span class="token punctuation">.</span><span class="token function">light</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>light<span class="token punctuation">.</span><span class="token function">electricClosed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 遥控开关 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RemoteControISwitch</span> <span class="token keyword">extends</span> <span class="token class-name">BaseSwitch</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">RemoteControISwitch</span><span class="token punctuation">(</span><span class="token class-name">ILight</span> light<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>light<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">makeRemoteLight</span><span class="token punctuation">(</span><span class="token keyword">int</span> operColor<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>light<span class="token punctuation">.</span><span class="token function">electricConnected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>light<span class="token punctuation">.</span><span class="token function">light</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> color <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>operColor<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>                color <span class="token operator">=</span> <span class="token string">"暖色"</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>                color <span class="token operator">=</span> <span class="token string">"蓝色"</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>                color <span class="token operator">=</span> <span class="token string">"红色"</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">default</span><span class="token operator">:</span>                color <span class="token operator">=</span> <span class="token string">"白色"</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前灯光颜色为："</span> <span class="token operator">+</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>light<span class="token punctuation">.</span><span class="token function">electricClosed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 白炽灯实现 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IncandescentLight</span> <span class="token keyword">implements</span> <span class="token class-name">ILight</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">electricConnected</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"白炽灯被打开了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">light</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"白炽灯在照明！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">electricClosed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"白炽灯被关闭了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CrystalLight</span> <span class="token keyword">implements</span> <span class="token class-name">ILight</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">electricConnected</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"水晶灯被打开了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">light</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"水晶灯在照明！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">electricClosed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"水晶灯被关闭了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BridgeApp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ILight</span> incandescentLight <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IncandescentLight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ILight</span> crystalLight <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CrystalLight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BaseSwitch</span> baseSwitch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BaseSwitch</span><span class="token punctuation">(</span>incandescentLight<span class="token punctuation">)</span><span class="token punctuation">;</span>        baseSwitch<span class="token punctuation">.</span><span class="token function">makeLight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">RemoteControISwitch</span> controISwitch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RemoteControISwitch</span><span class="token punctuation">(</span>crystalLight<span class="token punctuation">)</span><span class="token punctuation">;</span>        controISwitch<span class="token punctuation">.</span><span class="token function">makeRemoteLight</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-7、Flyweight（享元模式）"><a href="#1-3-7、Flyweight（享元模式）" class="headerlink" title="1.3.7、Flyweight（享元模式）"></a>1.3.7、Flyweight（享元模式）</h3><h4 id="简介-21"><a href="#简介-21" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>主要用于减少创建对象的数量，减少内存占用以提高性能。该模式会尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。</font></p><h4 id="何时使用-22"><a href="#何时使用-22" class="headerlink" title="何时使用"></a>何时使用</h4><ol><li>系统中有大量对象。</li><li>这些对象消耗大量内存。</li><li>这些对象的状态大部分可以外部化。</li><li>这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中拿出来时，每组对象都可用一个对象来代替。</li><li>系统不依赖于对象身份，因对象不可分辨。</li></ol><h4 id="优缺点-22"><a href="#优缺点-22" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点：减少对象创建，降低内存消耗，效率提高。</li><li>缺点：提高了系统复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统混乱。</li></ul><h4 id="应用场景-21"><a href="#应用场景-21" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>系统有大量相似对象。</li><li>需要缓冲池的场景。</li></ol><h4 id="应用实例-22"><a href="#应用实例-22" class="headerlink" title="应用实例"></a>应用实例</h4><ol><li>JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。</li><li>数据库的数据池。</li></ol><h4 id="源码应用-5"><a href="#源码应用-5" class="headerlink" title="源码应用"></a>源码应用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> <span class="token operator">/</span> <span class="token class-name">Integer</span> <span class="token operator">/</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>bcel<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>generic<span class="token punctuation">.</span></span>InstructionConstants</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="注意事项-22"><a href="#注意事项-22" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><font color='red'>注意划分外部状态和内部状态，否则可能会引起线程安全问题。</font></li><li><font color='red'>这些类必须有一个工厂对象加以控制。</font></li></ol><h4 id="代码实例-22"><a href="#代码实例-22" class="headerlink" title="代码实例"></a>代码实例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractChessman</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> chess<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AbstractChessman</span><span class="token punctuation">(</span><span class="token class-name">String</span> chess<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>chess <span class="token operator">=</span> chess<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>chess <span class="token operator">+</span> <span class="token string">": "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlackChessman</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractChessman</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">BlackChessman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"BlackChessman construction exec!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WhiteChessman</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractChessman</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">WhiteChessman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">"o"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"WhiteChessman construction exec!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FiveChessmanFactory</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">FiveChessmanFactory</span> fiveChessmanFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FiveChessmanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Hashtable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">AbstractChessman</span><span class="token punctuation">></span></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hashtable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">AbstractChessman</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">FiveChessmanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">FiveChessmanFactory</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> fiveChessmanFactory<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">AbstractChessman</span> <span class="token function">getChessmanObject</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">AbstractChessman</span> chessman <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>chessman <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">switch</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">case</span> <span class="token char">'B'</span><span class="token operator">:</span>                    chessman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BlackChessman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token char">'W'</span><span class="token operator">:</span>                    chessman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WhiteChessman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">default</span><span class="token operator">:</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>chessman <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> chessman<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> chessman<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlyweightApp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">FiveChessmanFactory</span> fiveChessmanFactory <span class="token operator">=</span> <span class="token class-name">FiveChessmanFactory</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Random</span> random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> radom <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token class-name">AbstractChessman</span> abstractChessman <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            radom <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">switch</span> <span class="token punctuation">(</span>radom<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>                    abstractChessman <span class="token operator">=</span> fiveChessmanFactory<span class="token punctuation">.</span><span class="token function">getChessmanObject</span><span class="token punctuation">(</span><span class="token char">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>                    abstractChessman <span class="token operator">=</span> fiveChessmanFactory<span class="token punctuation">.</span><span class="token function">getChessmanObject</span><span class="token punctuation">(</span><span class="token char">'W'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>abstractChessman <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                abstractChessman<span class="token punctuation">.</span><span class="token function">point</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-4、设计模式间的关系"><a href="#1-4、设计模式间的关系" class="headerlink" title="1.4、设计模式间的关系"></a>1.4、设计模式间的关系</h2><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210420203056818.png" alt="image-20210420203056818"></p><h1 id="2、设计模式原则"><a href="#2、设计模式原则" class="headerlink" title="2、设计模式原则"></a>2、设计模式原则</h1><h2 id="2-1、开闭原则（OCP）"><a href="#2-1、开闭原则（OCP）" class="headerlink" title="2.1、开闭原则（OCP）"></a>2.1、开闭原则（OCP）</h2><h3 id="2-1-1、简介"><a href="#2-1-1、简介" class="headerlink" title="2.1.1、简介"></a>2.1.1、简介</h3><p><font color='orange'>开闭原则规定：软件中的对象（类，模块，函数等）对于扩展应该开放，对于修改应该封闭。</font>也就是说，应该在不修改类源代码前提下来更改类的行为。</p><h3 id="2-1-2、分类"><a href="#2-1-2、分类" class="headerlink" title="2.1.2、分类"></a>2.1.2、分类</h3><ul><li><p><font color='orange'>梅耶开闭原则</font></p><p>梅耶原则 提倡继承实现。具体实现可以通过继承来重用，但是接口规格不必如此。已存在的实现对于修改是封闭的，但是新的实现不必实现原有接口。</p></li><li><p><font color='orange'>多态开闭原则</font></p><p>多态开闭原则 倡导继承抽象类。接口规约可以通过继承来重用，但是实现不必如此。已存在的接口对于修改是封闭的，并且新的实现必须至少实现那个接口。</p></li></ul><h2 id="2-2、单一职责原则（SRP）"><a href="#2-2、单一职责原则（SRP）" class="headerlink" title="2.2、单一职责原则（SRP）"></a>2.2、单一职责原则（SRP）</h2><h3 id="2-2-1、简介"><a href="#2-2-1、简介" class="headerlink" title="2.2.1、简介"></a>2.2.1、简介</h3><p>面向对象五个基本原则（SOLID）之一。</p><p><font color='orange'>单一职责原则（SRP：Single responsibility principle）又称单一功能原则。该原则规定：一个类或者模块应该有且只有一个改变原因。</font></p><p>单一职责原则由罗伯特·C·马丁（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》一书中给出。马丁表示此原则是基于汤姆·狄马克(Tom DeMarco)和Meilir Page-Jones的&#x3D;著作中的 内聚性原则 来实现。</p><p><font color='orange'>所谓职责是指类变化的原因。如果类改变的原因多于一个，那就违反了该职责。</font></p><h3 id="2-2-2、问题由来"><a href="#2-2-2、问题由来" class="headerlink" title="2.2.2、问题由来"></a>2.2.2、问题由来</h3><p>之所以会出现单一职责原则就是因为在软件设计时会出现以下类似场景：</p><p>T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。也就是说职责P1和P2耦合在了一起。</p><h3 id="2-2-3、产生原因"><a href="#2-2-3、产生原因" class="headerlink" title="2.2.3、产生原因"></a>2.2.3、产生原因</h3><p><font color='orange'>很多耦合常常发生在不经意之间，原因就是 职责扩散：因为某种原因，某一职责被分化为颗粒度更细多个职责。</font></p><h3 id="2-2-4、解决方法"><a href="#2-2-4、解决方法" class="headerlink" title="2.2.4、解决方法"></a>2.2.4、解决方法</h3><p>遵守单一职责原则，将不同的职责封装到不同的类或模块中。</p><h2 id="2-3、依赖倒置原则（DIP）"><a href="#2-3、依赖倒置原则（DIP）" class="headerlink" title="2.3、依赖倒置原则（DIP）"></a>2.3、依赖倒置原则（DIP）</h2><h3 id="2-3-1、简介"><a href="#2-3-1、简介" class="headerlink" title="2.3.1、简介"></a>2.3.1、简介</h3><p><font color='orange'>开闭原则的基础。依赖倒置原则（Dependence Inversion Principle）是指：程序要依赖于抽象接口，不要依赖于具体实现。</font>简单说就是一定要面向抽象编程，而不要面向实现编程，这样就降低了客户与实现模块间的耦合。</p><h3 id="2-3-2、意图"><a href="#2-3-2、意图" class="headerlink" title="2.3.2、意图"></a>2.3.2、意图</h3><p><font color='orange'>面向过程开发，上层调用下层，上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会降低模块的复用性且大大提高了开发成本</font></p><p>面向对象开发解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。</p><h3 id="2-3-3、注意事项"><a href="#2-3-3、注意事项" class="headerlink" title="2.3.3、注意事项"></a>2.3.3、注意事项</h3><ol><li>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。</li><li>抽象不应该依赖于具体，而是具体应该依赖于抽象。</li></ol><h2 id="2-4、接口隔离原则（ISP）"><a href="#2-4、接口隔离原则（ISP）" class="headerlink" title="2.4、接口隔离原则（ISP）"></a>2.4、接口隔离原则（ISP）</h2><h3 id="2-4-1、简介"><a href="#2-4-1、简介" class="headerlink" title="2.4.1、简介"></a>2.4.1、简介</h3><p>接口隔离原则（Interface Segregation Principle，ISP）是面向对象设计中的一个原则，它强调的是 <em><strong>客户端不应该依赖它不需要的接口，将臃肿的接口拆分为更小、更具体的接口，避免接口的冗余</strong></em>。</p><p>接口隔离原则的核心思想是 <em><strong>定义接口时要精简、单一，不应该包含不需要的方法，这样可以减少类与接口之间的耦合，提高代码可读性、可维护性、可扩展性</strong></em>。</p><p>接口隔离原则可以参考如下几点来实现：</p><ul><li>将庞大的接口拆分为多个小接口。</li><li>根据需要只使用特定的接口。</li><li>接口的职责要单一。</li></ul><h3 id="2-4-2、优点"><a href="#2-4-2、优点" class="headerlink" title="2.4.2、优点"></a>2.4.2、优点</h3><p>接口隔离原则可以使得系统的接口设计更加灵活、可扩展和易于维护。能降低类与接口之间的耦合度，减少不必要的依赖关系，使得系统的各个模块能够独立地发展与演化。</p><h2 id="2-5、里氏替换原则（LSP）"><a href="#2-5、里氏替换原则（LSP）" class="headerlink" title="2.5、里氏替换原则（LSP）"></a>2.5、里氏替换原则（LSP）</h2><h3 id="2-5-1、简介"><a href="#2-5-1、简介" class="headerlink" title="2.5.1、简介"></a>2.5.1、简介</h3><p>里氏代换原则（Liskov Substitution Principle LSP）是指：<em><strong>基类可以出现的地方，子类也可以出现</strong></em>。</p><p>LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。<em><strong>里氏代换原则是对“开闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化</strong></em>。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><h3 id="2-5-2、注意事项"><a href="#2-5-2、注意事项" class="headerlink" title="2.5.2、注意事项"></a>2.5.2、注意事项</h3><p><font color='orange'>设计时，尽量继承抽象类，而不要继承具体类。</font>如果从继承等级树来看，所有叶子节点应当是具体类，而所有的树枝节点应当是抽象类或者接口。当然这只是一般性的指导原则，使用时还需具体情况具体分析。</p><p>简单的理解为一个软件实体如果使用的是一个父类，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，软件里面，把父类都替换成它的子类，程序的行为没有变化。</p><h2 id="2-6、迪米特原则（LOD）"><a href="#2-6、迪米特原则（LOD）" class="headerlink" title="2.6、迪米特原则（LOD）"></a>2.6、迪米特原则（LOD）</h2><h3 id="2-6-1、简介"><a href="#2-6-1、简介" class="headerlink" title="2.6.1、简介"></a>2.6.1、简介</h3><p>迪米特原则（Law Of Demeter）也被称为最少知道原则，是面向对象设计中的一个原则。迪米特原则的核心思想是 <em><strong>降低对象之间的耦合，使得对象之间的通信变得简单和直接</strong></em>。</p><p>迪米特原则的目标是 实现高内聚、低耦合。具体包括如下几点：</p><ul><li>减少对象之间的耦合</li><li>保护对象的隐私</li><li>提高代码可维护性</li></ul><p>迪米特原则可以参考如下几个方面来实现：</p><ul><li>在类中尽量减少对其它类的引用，不应该直接引用与本类关系较远的类。</li><li>通过封装和信息隐藏，将对象的内部细节隐藏起来，只暴漏必要的接口。</li><li>使用中介者模式或外观模式来降低对象之间的直接依赖关系。</li></ul><h2 id="2-7、合成复用原则（CRP）"><a href="#2-7、合成复用原则（CRP）" class="headerlink" title="2.7、合成复用原则（CRP）"></a>2.7、合成复用原则（CRP）</h2><h3 id="2-7-1、简介"><a href="#2-7-1、简介" class="headerlink" title="2.7.1、简介"></a>2.7.1、简介</h3><p>合成复用原则是设计模式中的一个原则，也称之为CRP原则。它指的是在软件设计中，<em><strong>优先使用对象组合而不是继承来实现代码的复用</strong></em>。</p><p>合成复用原则的核心思想是：<em><strong>通过将现有的对象组合成新的对象，实现代码复用和灵活性</strong></em>。相对于通过继承实现复用，使用对象组合可以更好的控制类之间的关系，且可以动态的改变的对象的行为。</p><h3 id="2-7-2、优点"><a href="#2-7-2、优点" class="headerlink" title="2.7.2、优点"></a>2.7.2、优点</h3><p>合成复用有如下几个优点：</p><ul><li><strong>减少类之间的耦合</strong>：继承会导致子类和父类之间的紧耦合，而对象组合可以在对象之间建立松散的关系，减少类之间的依赖。</li><li><strong>提高系统灵活性</strong>：对象组合可以动态改变对象的行为，通过替换组合中的对象，可以灵活扩展和修改系统的功能。</li><li><strong>更好地复用代码</strong>：组合现有对象，可以构建出具有不同功能的新对象，实现代码复用。</li><li><strong>更好的维护</strong>：对象组合关系松散，需要修改系统行为时，可以更容易的定位和修改相关的对象。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java系列-JVM</title>
      <link href="/2023/07/30/jvm-zhi-shi-dian-zong-jie/"/>
      <url>/2023/07/30/jvm-zhi-shi-dian-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="0、必知必会"><a href="#0、必知必会" class="headerlink" title="0、必知必会"></a>0、必知必会</h1><h2 id="0-1、Java类加载"><a href="#0-1、Java类加载" class="headerlink" title="0.1、Java类加载"></a>0.1、Java类加载</h2><h3 id="0-1-1、Class文件"><a href="#0-1-1、Class文件" class="headerlink" title="0.1.1、Class文件"></a>0.1.1、Class文件</h3><h4 id="0-1-1-1、简介"><a href="#0-1-1-1、简介" class="headerlink" title="0.1.1.1、简介"></a>0.1.1.1、简介</h4><p>Class文件是一组 以8位为基础单位 的【二进制流】，超过8位以上的会被按照 高位在前 分割成多个8位进行存储。</p><p>Class文件格式采用一种类似C语言结构体的伪结构进行数据存储，其中包含两种数据类型：【无符号数和表】。</p><ul><li><p><strong>无符号数</strong></p><p>无符号数属于【基本数据类型】，以u1、u2、u4、u8分别代表1字节、2字节、4字节、8字节的无符号数。它可以描述数字、索引引用、数量值、utf8编码后的字符串值。</p></li><li><p><strong>表</strong></p><p><em><strong>表是由 多个无符号数和其它表作为数据组成的 复合数据类型</strong></em>。所有表都以<code>_info</code>结尾，用来描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。</p></li></ul><h4 id="0-1-1-2、class文件结构"><a href="#0-1-1-2、class文件结构" class="headerlink" title="0.1.1.2、class文件结构"></a>0.1.1.2、class文件结构</h4><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210428110838690.png" alt="image-20210428110838690"></p><p>classFile结构中，各项含义如下：</p><ol><li><font color='orange'>magic</font>：魔数</li><li><font color='orange'>minor_version&#x2F;major_version</font>：class文件次版本号&#x2F;主版本号</li><li><font color='orange'>constant_pool_count</font>：常量池计数器</li><li><font color='orange'>constant_pool[constant_pool_count-1]</font>：常量池</li><li><font color='orange'>access_flags</font>：访问标志</li><li><font color='orange'>this_class</font>：类索引</li><li><font color='orange'>super_class</font>：父类索引</li><li><font color='orange'>interfaces_count</font>：接口计数器</li><li><font color='orange'>interfaces[interfaces_count]</font>：接口表</li><li><font color='orange'>fields_count</font>：字段计数器</li><li><font color='orange'>fields[fields_count]</font>：字段表</li><li><font color='orange'>methods_count</font>：方法计数器</li><li><font color='orange'>methods[methods_count]</font>：方法表</li><li><font color='orange'>attributes_count</font>：属性计数器</li><li><font color='orange'>attributes[attributes_count]</font>：属性表</li></ol><h3 id="0-1-2、类加载过程"><a href="#0-1-2、类加载过程" class="headerlink" title="0.1.2、类加载过程"></a>0.1.2、类加载过程</h3><h4 id="0-1-2-1、概述"><a href="#0-1-2-1、概述" class="headerlink" title="0.1.2.1、概述"></a>0.1.2.1、概述</h4><p>虚拟机 把 描述类的数据 从Class文件加载到内存，并对数据进行校验、转化解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p><p>整个生命周期包括：<em><strong>加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）</strong></em>。</p><p>加载分为两类：</p><ul><li><strong>显式加载</strong>：通过类加载器加载一个类。</li><li><strong>隐式加载</strong>：不直接使用类加载器加载类，而是虚拟机自动加载完成。</li></ul><blockquote><p>加载后，类的一些信息可通过工具HSDB来查看。</p><p>HSDB启动命令：<code>java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB</code></p></blockquote><h4 id="0-1-2-2、加载阶段"><a href="#0-1-2-2、加载阶段" class="headerlink" title="0.1.2.2、加载阶段"></a>0.1.2.2、加载阶段</h4><p>此阶段虚拟机会做三件事：</p><ol><li>通过一个<strong>类的全限定名</strong>来<strong>获取</strong>定义此<strong>类的二进制字节流</strong>；</li><li>将这个字节流所代表的<strong>静态存储结构转化</strong>为方法区的<strong>运行时数据结构</strong>；</li><li>在内存中<strong>生成</strong>一个代表该类的 <strong>java.lang.Class对象</strong>，<strong>作为</strong>方法区中该类各种数据的<strong>访问入口</strong>；</li></ol><p>获取二进制字节流可以通过Class文件、ZIP包、网络、运行时（动态代理）、JSP生成、数据库等途径获取。</p><p>那些二进制字节流加载完后，按指定格式存放于方法区内（Java7及以前方法区位于永久代，Java8位于Metaspace（元空间））。然后在方法区生成一个比较特殊的<code>java.lang.Class</code>对象，用来作为 访问方法区中这些类型数据的 外部接口。</p><p><font color='red'>注意：数组类不通过类加载器加载，而是由Java虚拟机直接创建，但数组类的元素还是要依靠类加载器进行加载。</font></p><h4 id="0-1-2-3、链接阶段"><a href="#0-1-2-3、链接阶段" class="headerlink" title="0.1.2.3、链接阶段"></a>0.1.2.3、链接阶段</h4><h5 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h5><p>验证的目的是确保Class文件字节流中包含的<em><strong>信息符合当前虚拟机的要求</strong></em>，并且<em><strong>不会危害虚拟机</strong></em>自身的安全。</p><p>验证内容如下：</p><ol><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ol><h5 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h5><p>准备阶段主要工作：在方法区中 <em><strong>为类变量分配内存、设置默认值</strong></em>。</p><p>类变量指的是被static修饰的变量，不包含实例变量，实例变量在对象实例化阶段分配在堆中。并且，变量的初始化值并非类中定义的值，而是该变量所属类型的默认值。</p><p><font color='red'>注意：变量被final修饰时，该字段属性为ConstantValue，它会在 准备阶段 初始化为指定的值。</font></p><h5 id="解析阶段"><a href="#解析阶段" class="headerlink" title="解析阶段"></a>解析阶段</h5><p>解析阶段主要工作：虚拟机将常量池内的 <em><strong>符号引用替换为直接引用</strong></em>。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用 进行解析。</p><h4 id="0-1-2-4、初始化阶段"><a href="#0-1-2-4、初始化阶段" class="headerlink" title="0.1.2.4、初始化阶段"></a>0.1.2.4、初始化阶段</h4><p>初始化阶段主要工作：<em><strong>执行类构造器的<code>clinit()</code>方法</strong></em>。</p><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并而成。编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问其之前的变量，之后的变量只能赋值但不能访问。</p><p><font color='red'>注意：<code>&lt;clinit&gt;()</code>方法 与 实例构造器() 不同，其不需要 显式调用 父类构造器，虚拟机会保证在子类的clinit()方法执行之前，父类的clinit()方法已经执行完毕。虚拟机会保证一个类的clinit()方法在多线程下被同步加锁。</font></p><h3 id="0-1-3、类加载器"><a href="#0-1-3、类加载器" class="headerlink" title="0.1.3、类加载器"></a>0.1.3、类加载器</h3><h4 id="0-1-3-1、简介"><a href="#0-1-3-1、简介" class="headerlink" title="0.1.3.1、简介"></a>0.1.3.1、简介</h4><p><em><strong>通过 类的全限定名 获取该类二进制字节流的代码块叫 类加载器</strong></em>。</p><h4 id="0-1-3-2、类加载器分类"><a href="#0-1-3-2、类加载器分类" class="headerlink" title="0.1.3.2、类加载器分类"></a>0.1.3.2、类加载器分类</h4><p>JVM规范中规定，将派生于抽象类<code>ClassLoader</code>的类加载器都称为 自定义类加载器。</p><p>实际开发中，通常会将类加载器分为如下几种：</p><ol><li><p><strong>启动类加载器（Bootstrap ClassLoader）</strong></p><p>使用C&#x2F;C++语言实现，并不继承java.lang.ClassLoader。为安全起见，主要负责加载Java核心类库，比如：<code>%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar</code>和class等。</p></li><li><p><strong>扩展类加载器（Extensions ClassLoader）</strong></p><p>使用Java语言实现，派生于抽象类ClassLoader，父类是启动类加载器。</p><p>主要负责加载<code>%JRE_HOME%\lib\ext</code>目录下的jar包和class文件。</p></li><li><p><strong>应用程序&#x2F;系统类加载器（App ClassLoader）</strong></p><p>使用Java语言实现，派生于抽象类ClassLoader，父类是扩展类加载器。</p><p>加载 CLASSPATH 或 java.class.path 指定路径下的类库。</p></li><li><p><strong>自定义类加载器（Custom ClassLoader）</strong></p><p>自定义类加载器可以扩展加载源、修改类加载方式，隔离加载类、防止源码泄露。JDK1.2之前，实现自定义类加载需要继承抽象类ClassLoader并重写loadClass方法，而JDK1.2之后建议重写findClass方法来代替重写loadClass方法。</p><p>若无特别需求，则建议直接继承URLClassLoader类，可避免编写findClass方法及获取字节流的方式。</p></li></ol><p><font color="red">注意：这些类加载器之间是包含（复合）关系，而并非是继承关系。</font></p><h4 id="0-1-3-3、常用命令"><a href="#0-1-3-3、常用命令" class="headerlink" title="0.1.3.3、常用命令"></a>0.1.3.3、常用命令</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> -Xbootclasspath/a:. cn.shh.xxx.Test bootstrap F init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>Xbootclasspath</code>：表示设置bootclasspath。</li><li><code>/a</code>：表示将当前目录追加至bootclass之后。</li></ul><p>常用命令：</p><ul><li><code>java -Xbootclasspath:&lt;new bootclasspath&gt;</code></li><li><code>java -Xbootclasspath/a:&lt;追加路径&gt;</code></li><li><code>java -Xbootclasspath/p:&lt;追加路径&gt;</code></li></ul><h3 id="0-1-4、双亲委派模型"><a href="#0-1-4、双亲委派模型" class="headerlink" title="0.1.4、双亲委派模型"></a>0.1.4、双亲委派模型</h3><h4 id="0-1-4-1、简介"><a href="#0-1-4-1、简介" class="headerlink" title="0.1.4.1、简介"></a>0.1.4.1、简介</h4><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20201224173439957.png" alt="image-20201224173439957"></p><p>上图所示，类加载器间的关系 就称为 【类加载器的双亲委派模型（Parents Delegation Mode）】。</p><p>类加载器的 双亲委派模型 在 JDK 1.2 期间被引入。它并不是一个强制性约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。</p><h4 id="0-1-4-2、工作机制"><a href="#0-1-4-2、工作机制" class="headerlink" title="0.1.4.2、工作机制"></a>0.1.4.2、工作机制</h4><p><font color='orange'>双亲委派机制是指：一个类加载器收到了类加载请求时会先请求自己的父加载器去加载，如果父加载器无法加载该类，那么才会交给当前类加载器来加载。</font></p><h4 id="0-1-4-3、特点"><a href="#0-1-4-3、特点" class="headerlink" title="0.1.4.3、特点"></a>0.1.4.3、特点</h4><ol><li><p>Java类随它的类加载器一起具备了一种带有优先级的层次关系。</p></li><li><p>保证Java程序的稳定运行。</p></li><li><p>避免类被重复加载。</p></li><li><p>保证了安全。</p></li></ol><h4 id="0-1-4-4、实现原理"><a href="#0-1-4-4、实现原理" class="headerlink" title="0.1.4.4、实现原理"></a>0.1.4.4、实现原理</h4><p><font color='orange'>双亲委派模型的实现代码体现在抽象类<code>java.lang.ClassLoader</code>的<code>loadClass()</code>方法中。逻辑如下：</font></p><ol><li>先检查一个类是否被加载过，若没有被加载，则调用父加载器的 loadClass() 方法进行加载。</li><li>若父加载器为空，则默认使用启动类加载器作为父加载器。</li><li>如果父加载器加载失败，抛出 ClassNotFoundException 异常后，再调用自己的 findClass() 方法进行加载。</li></ol><h4 id="0-1-4-5、破坏双亲模型"><a href="#0-1-4-5、破坏双亲模型" class="headerlink" title="0.1.4.5、破坏双亲模型"></a>0.1.4.5、破坏双亲模型</h4><p>到目前为止，双亲委派模型主要出现过3次 较大规模的 破坏情况：</p><ol><li>由于 JDK 1.2 才发布双亲委派模型，类加载器和抽象类 ClassLoader 则在 JDK 1.0 时代就已经存在，为了兼容已经存在的自定义类加载器实现，JDK 1.2之后添加了一个新的 protected方法 findClass() 。JDK 1.2之后已不在提倡覆盖 loadClass() 方法，而应当把自己的类加载逻辑写入 findClass() 方法中，在 loadClass() 中如果父类加载失败，则会调用自己的 findClass() 方法来完成加载。</li><li>基础类之所以称为“基础类”，是因为它们会作为API来被用户代码调用，但是，如果基础类反过来需要调用用户代码时，该怎么办？于是线程上下文类加载器就出现了。有了线程上下文类加载器，JNDI服务可以去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为打破了双亲委派模型的层次结构来逆向使用类加载器，这实际上违背了双亲委派模型的一般性原则。</li><li>第三次破坏是由于 用户对程序动态性的追求而导致的，动态性是指：代码热替换、模块热部署等。比如 OSGI 中的类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更复杂的网状结构。</li><li>Tomcat等web容器的出现。</li><li>OSGI、Jigsaw等模块化技术的应用。</li></ol><h4 id="0-1-4-6、重要方法"><a href="#0-1-4-6、重要方法" class="headerlink" title="0.1.4.6、重要方法"></a>0.1.4.6、重要方法</h4><ul><li><font color='orange'>loadClass()</font>：类加载的主要方法。双亲委派机制l的体现就是该方法。</li><li><font color='orange'>findClass()</font>：根据名称或位置加载.class字节码。</li><li><font color='orange'>definclass()</font>：把字节码转化为Class。</li></ul><p><font color='red'>注意：自定义类加载器需要破坏双亲委派原则时，就重写loadClass方法。如果只想自定义类加载器，不想破坏双亲委派模型，那就继承ClassLoader并重写findClass方法。</font></p><p><code>findClass()</code>方法是JDK1.2之后 ClassLoader 新添加的一个方法。</p><blockquote><p>JDK1.2 后不提倡覆盖loadClass()方法，而建议把自己的逻辑写到<code>findClass()</code>方法中。因为<code>loadClass()</code>方法无法完成类加载逻辑时最终还是会调用<code>findClass()</code>方法来完成加载。</p></blockquote><h4 id="0-1-4-7、JNDI-JDBC破坏双亲委派"><a href="#0-1-4-7、JNDI-JDBC破坏双亲委派" class="headerlink" title="0.1.4.7、JNDI&#x2F;JDBC破坏双亲委派"></a>0.1.4.7、JNDI&#x2F;JDBC破坏双亲委派</h4><p><font color='orange'>Java的基础类会被Bootstrap加载，且会通过API方式调用这些基础类。但是，除了API方式调用，还有一种SPI方式调用，如JDBC服务。</font></p><p>创建数据库连接的方式如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/mysql"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">,</span> <span class="token string">"1234"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>java.sql.DriverManager</code>类位于rt.jar中 ，故会被根加载器加载。类加载时，会执行该类的静态方法。其中有一段关键的代码是：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ServiceLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Driver</span><span class="token punctuation">></span></span> loadedDrivers <span class="token operator">=</span> <span class="token class-name">ServiceLoader</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Driver</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这段代码，会尝试加载classpath下实现了Driver接口的所有实现类。</p><p>那么，问题就来了。</p><p><font color='orange'>DriverManager会被根加载器加载，但在加载时遇到以上代码，会尝试加载Driver的所有实现类，但这些实现类基本都是第三方提供，根据双亲委派原则，第三方的类不能被根加载器加载。</font></p><p>那么，怎么解决这个问题呢？</p><p><font color='orange'>在JDBC中引入ThreadContextClassLoader（线程上下文加载器，默认情况下是AppClassLoader）来破坏双亲委派原则。</font></p><p>我们深入到<code>ServiceLoader.load</code>方法就可以看到：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">></span></span> <span class="token class-name">ServiceLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">></span></span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">></span></span> service<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ClassLoader</span> cl <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">ServiceLoader</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span> cl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第一行，获取当前线程的线程上下⽂类加载器 AppClassLoader，⽤于加载 classpath 下的具体实现类。</p><h4 id="0-1-4-8、Tomcat破坏双亲委派"><a href="#0-1-4-8、Tomcat破坏双亲委派" class="headerlink" title="0.1.4.8、Tomcat破坏双亲委派"></a>0.1.4.8、Tomcat破坏双亲委派</h4><p>Tomcat中可能会部署多个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，如果采用默认的双亲委派类加载机制，那么无法加载多个相同类。所以，Tomcat破坏双亲委派原则，提供隔离的机制，为web容器中每一个应用单独提供一个WebAppClassLoader加载器。</p><p>Tomcat类加载机制：<font color='orange'>为了实现隔离性，优先加载 Web 应用自己定义的类，所以没有遵照双亲委派约定，每一个WebAppClassLoader负责加载自己目录下的class文件，加载不到时再交给CommonClassLoader加载，这和双亲委派刚好相反。</font></p><h4 id="0-1-4-9、总结"><a href="#0-1-4-9、总结" class="headerlink" title="0.1.4.9、总结"></a>0.1.4.9、总结</h4><h5 id="父子加载器之间是继承关系吗？"><a href="#父子加载器之间是继承关系吗？" class="headerlink" title="父子加载器之间是继承关系吗？"></a>父子加载器之间是继承关系吗？</h5><p><font color='orange'>双亲委派模型中，类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是使用 【组合（Composition）关系】 来复用父加载器代码。</font></p><p>如下为ClassLoader中父加载器的定义：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// The parent class loader for delegation</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ClassLoader</span> parent<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Java中继承和组合的区别是什么？</p><ol><li>组合(has-a)关系可以<font color='orange'>显式获得被包含类（继承中称为父类）对象</font>，而继承(is-a)则是<font color='orange'>隐式获得父类对象，</font>被包含类和父类对应，而组合外部类和子类对应。</li><li>组合关系在<font color='orange'>运行期决定</font>，而继承关系在<font color='orange'>编译期决定</font>。</li><li>组合是组合类和被包含类之间的一种<font color='orange'>松耦合关系</font>，而继承则是父类和子类之间的一种<font color='orange'>紧耦合关系。</font></li><li>组合类中包含了外部类的对象，组合类<font color='orange'>可以调用外部类方法；</font>而使用继承关系时，父类的所有方法和变量都被子类<font color='orange'>无条件继承，子类不能选择。</font></li><li>继承可以实现<font color='orange'>类型回溯</font>，即用父类变量引用子类对象，这样便可以实现多态，而组合没有这个特性。</li><li>如果你确定复用另外一个类的方法永远不需要改变时，应该使用组合，因为组合只是<font color='orange'>简单复用被包含类的接口</font>，而继承除了复用父类接口外，它还<font color='orange'>可以覆盖这些接口</font>，修改父类接口的默认实现，这个特性是组合没有的。</li><li>组合体现的是整体和部分的思想，例如电脑类是由内存类，CPU类，硬盘类等组成，而继承则体现的是一种可回溯的父子关系，子类也是父类的一个对象。</li><li><font color='orange'>两者区别主要体现在类的抽象阶段</font>，在分析类之间的关系时就应该确定是采用组合还是采用继承。</li></ol></blockquote><h2 id="0-2、JVM运行时数据区"><a href="#0-2、JVM运行时数据区" class="headerlink" title="0.2、JVM运行时数据区"></a>0.2、JVM运行时数据区</h2><p><img src="/%5Cimgs%5Cjavadev%5C2.1.1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%89%8D%E8%A8%80-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86.png"></p><h3 id="0-1-1、程序计数器（私有）"><a href="#0-1-1、程序计数器（私有）" class="headerlink" title="0.1.1、程序计数器（私有）"></a>0.1.1、程序计数器（私有）</h3><h4 id="0-1-1-1、简介-1"><a href="#0-1-1-1、简介-1" class="headerlink" title="0.1.1.1、简介"></a>0.1.1.1、简介</h4><p>JVM的程序计数寄存器，是物理PC寄存器的一种抽象模拟。</p><p><font color='orange'>程序计数器 主要存储 要执行的程序指令的地址信息，确保程序正确执行。</font></p><h4 id="0-1-1-2、作用"><a href="#0-1-1-2、作用" class="headerlink" title="0.1.1.2、作用"></a>0.1.1.2、作用</h4><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码的地址。由执行引擎读取下一条指令。</p><h3 id="0-1-2、方法区（公有）"><a href="#0-1-2、方法区（公有）" class="headerlink" title="0.1.2、方法区（公有）"></a>0.1.2、方法区（公有）</h3><h4 id="0-1-2-1、简介"><a href="#0-1-2-1、简介" class="headerlink" title="0.1.2.1、简介"></a>0.1.2.1、简介</h4><p>方法区存储类的结构信息：<em><strong>运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容</strong></em>，还包含一些<em><strong>类、实例、接口初始化时用到的特殊方法</strong></em>。</p><p><font color='red'>注意事项：方法区内存不足时会导致内存溢出错误。</font></p><p>方法区内存溢出的场景：Spring、MyBatis。</p><h4 id="0-1-2-2、实现"><a href="#0-1-2-2、实现" class="headerlink" title="0.1.2.2、实现"></a>0.1.2.2、实现</h4><ul><li><font color='orange'>PermSpace（JDK1.7）</font><ol><li>JDK1.7时，方法区实现为永久代。</li><li>字符串常量池位于永久代中。</li><li>FGC不会清理。</li><li>-XX:PermSize默认值为20.75M，<code>-XX:MaxPermSize</code>默认值在32位是64M，64位是82M。</li></ol></li><li><font color='orange'>MetaSpace（JDK1.8）</font><ol><li>JDK1.8时，方法区实现为元空间，使用的是物理内存。</li><li>字符串常量池位于堆中。</li><li>会触发FGC清理。</li><li>windows下，<code>-XX:MetaspaceSize</code>是21M，<code>-XX:MaxMetaspaceSize</code>的值是-1，表示没有限制。</li></ol></li></ul><h4 id="0-1-2-3、方法区演变"><a href="#0-1-2-3、方法区演变" class="headerlink" title="0.1.2.3、方法区演变"></a>0.1.2.3、方法区演变</h4><p><img src="/%5Cimgs%5Cjavadev%5C2.5.10-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E6%96%B9%E6%B3%95%E5%8C%BA-%E6%96%B9%E6%B3%95%E5%8C%BA%E6%BC%94%E8%BF%9B.png"></p><h4 id="0-1-2-4、运行时常量池"><a href="#0-1-2-4、运行时常量池" class="headerlink" title="0.1.2.4、运行时常量池"></a>0.1.2.4、运行时常量池</h4><h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>常量池是Class文件的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将会在类被加载后放到方法区的运行时常量池中。</p><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p><em><strong>加载 类或接口 到 虚拟机后就会创建对应的运行时常量池</strong></em>。</p><p>运行时常量池是方法区的一部分。运行时常量池 是 常量池表的【运行时表示形式】，它包含多种常量，从编译期可知的 数字字面量 到必须运行且解析后才能获得的 方法或字段引用。（类似于符号表，但比符号表要更广泛。）</p><h3 id="0-1-3、虚拟机栈（私有）"><a href="#0-1-3、虚拟机栈（私有）" class="headerlink" title="0.1.3、虚拟机栈（私有）"></a>0.1.3、虚拟机栈（私有）</h3><h4 id="0-1-3-1、简介-1"><a href="#0-1-3-1、简介-1" class="headerlink" title="0.1.3.1、简介"></a>0.1.3.1、简介</h4><p>每个线程都有自己的栈，栈中的数据都是以 栈帧 的格式存在。每个线程在执行一个方法时会在栈中对应一个栈帧。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种信息。</p><p><font color='red'>注意事项：虚拟机栈内存不足时会导致内存溢出错误。</font></p><h4 id="0-1-3-2、内部结构"><a href="#0-1-3-2、内部结构" class="headerlink" title="0.1.3.2、内部结构"></a>0.1.3.2、内部结构</h4><p>Java虚拟机中主要存储的是栈帧，而栈帧由以下几部分组成：</p><ul><li><strong>局部变量表</strong></li><li><strong>操作数栈</strong></li><li><strong>动态链接</strong></li><li><strong>方法出口</strong></li><li><strong>一些附加信息</strong></li></ul><h4 id="0-1-3-3、其它"><a href="#0-1-3-3、其它" class="headerlink" title="0.1.3.3、其它"></a>0.1.3.3、其它</h4><p>问题分析：</p><ul><li>栈内存越大越好吗？</li><li>垃圾回收是否设计栈内存？</li><li>方法中的局部变量是否是线程安全的？</li></ul><h3 id="0-1-4、本地方法栈（私有）"><a href="#0-1-4、本地方法栈（私有）" class="headerlink" title="0.1.4、本地方法栈（私有）"></a>0.1.4、本地方法栈（私有）</h3><h4 id="0-1-4-1、简介-1"><a href="#0-1-4-1、简介-1" class="headerlink" title="0.1.4.1、简介"></a>0.1.4.1、简介</h4><p>本地方法栈使用C语言实现，线程私有，主要服务于本地方法的调用。</p><p>本地方法栈中存储本地方法，执行引擎工作时会加载本地方法库。</p><p><font color='red'>注意事项：本地方法栈内存不足时会导致内存溢出错误。</font></p><h4 id="0-1-4-2、注意事项"><a href="#0-1-4-2、注意事项" class="headerlink" title="0.1.4.2、注意事项"></a>0.1.4.2、注意事项</h4><ul><li>可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li><li>直接使用本地处理器中的寄存器。</li><li>直接从本地内存的堆中分配任意内存。</li><li>并非所有JVM都支持本地方法，JVM规范并没有要求本地方法栈使用的语言、具体实现方式、数据结构等，也可以选择不实现本地方法栈。</li><li>Hotspot中直接将本地方法栈和虚拟机栈合二为一。</li></ul><h3 id="0-1-5、堆（公有）"><a href="#0-1-5、堆（公有）" class="headerlink" title="0.1.5、堆（公有）"></a>0.1.5、堆（公有）</h3><h4 id="0-1-5-1、简介"><a href="#0-1-5-1、简介" class="headerlink" title="0.1.5.1、简介"></a>0.1.5.1、简介</h4><p>堆是各个线程公有的区域，该区域主要存储对象加载创建过程中生成的对象数据。</p><p><font color='red'>注意事项：堆空间不足时会导致内存溢出错误。</font></p><h4 id="0-1-5-2、分代模型"><a href="#0-1-5-2、分代模型" class="headerlink" title="0.1.5.2、分代模型"></a>0.1.5.2、分代模型</h4><p>逻辑上将堆分为以下几个部分：</p><ul><li>年轻代<ul><li>Eden区</li><li>Surivor from区</li><li>Surivor to区</li></ul></li><li>老年代</li><li>永久代&#x2F;元空间（JDK7及之前是永久代，之后是元空间）</li></ul><h4 id="0-1-5-3、空间大小"><a href="#0-1-5-3、空间大小" class="headerlink" title="0.1.5.3、空间大小"></a>0.1.5.3、空间大小</h4><h5 id="堆大小"><a href="#堆大小" class="headerlink" title="堆大小"></a>堆大小</h5><p>可以通过Xms、Xmx来设置堆内存初始内存和最大内存，堆大小在JVM启动时已经设定好了。</p><p>默认情况下：初始内存大小为物理内存&#x2F;64，最大内存为物理内存&#x2F;4。</p><p><font color='red'>注意事项：堆内存大小超过 最大内存 限制时会抛出OOM异常。</font></p><h5 id="新生代老年代"><a href="#新生代老年代" class="headerlink" title="新生代老年代"></a>新生代老年代</h5><p>默认参数<code>-XX:NewRatio=2</code>表示新生代占比1，老年代占比2，新生代占整个堆内存的1&#x2F;3。同理<code>-XX:NewRatio=4</code>表示新生代占比1，老年代占比4，新生代占整个堆内存的1&#x2F;5。</p><p><font color='red'>注意事项：参数<code>-XX:NewRatio=2</code>的实际效果会受参数<code>-XX:UseAdaptiveSizePolicy</code>的影响，后者参数表示 开启关闭自适应内存分配策略。</font>如果想要达到指定的具体效果，需要使用参数<code>-XX:SurvivorRatio</code>来设置，该参数表示新生代中Eden区与Survivor区的比例。</p><p>使用参数<code>-Xmn</code>设置新生代的空间大小。</p><h3 id="0-1-6、直接内存"><a href="#0-1-6、直接内存" class="headerlink" title="0.1.6、直接内存"></a>0.1.6、直接内存</h3><p>直接内存在堆外，不会受限于-Xmx设置的最大堆大小。但系统内存也是有限的，Java堆和直接内存的总和依然受限于操作系统能提供的最大内存。</p><p>直接内存有如下缺点：</p><ul><li>分配回收成本较高。</li><li>不受JVM内存回收管理。</li></ul><p><em><strong>直接内存大小可以通过参数MaxDirectMemorySize来设置，如果不指定，则默认与堆的最大值-Xmx参数值一致。</strong></em></p><h3 id="0-1-7、字符串常量池"><a href="#0-1-7、字符串常量池" class="headerlink" title="0.1.7、字符串常量池"></a>0.1.7、字符串常量池</h3><h4 id="0-1-7-1、简介"><a href="#0-1-7-1、简介" class="headerlink" title="0.1.7.1、简介"></a>0.1.7.1、简介</h4><p>String Pool是一个固定大小的Hashtable，默认大小为1009。如果String Pool中字符串太多，会造成链表过长，进而导致在调用String的intern方法时性能会大幅下降。</p><p>JDK6及以前版本，字符串常量池在方法区中，JDK7及之后版本，字符串常量池转移到堆中。</p><h4 id="0-1-7-2、参数设置"><a href="#0-1-7-2、参数设置" class="headerlink" title="0.1.7.2、参数设置"></a>0.1.7.2、参数设置</h4><p>使用参数<code>-XX:StringTableSize</code>可设置StringTable的长度。</p><blockquote><p>JDK6中StringTable大小固定为1009。JDK7中StringTable大小默认为60013。JDK8中最小有效值为1009。</p></blockquote><h2 id="0-3、执行引擎"><a href="#0-3、执行引擎" class="headerlink" title="0.3、执行引擎"></a>0.3、执行引擎</h2><h3 id="0-3-1、即时编译器"><a href="#0-3-1、即时编译器" class="headerlink" title="0.3.1、即时编译器"></a>0.3.1、即时编译器</h3><h5 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h5><p>当程序需要迅速启动和执行时，解释器先运行，然后编译器逐渐发挥作用。如果编译器优化后类发生了变化，那么可以立即通过解释器来运行。所以说解释器和编译器是互相配合来执行代码的。</p><p>HotSpot虚拟机内置了三个即时编译器：<em><strong>客户端编译器（C1编译器）、服务端编译器（C2编译器）、Graal编译器（JDK 10中正式引入）。Graal编译器的目标是替换C2编译器</strong></em>。</p><p>JVM执行代码时可采用多种模式，现分为三种：</p><ul><li><p><strong>混合模式（默认方式）</strong></p><p>使用参数<code>-Xmixed</code>可以设置JVM运行于混合模式。</p></li><li><p><strong>解释器（Intepreter）模式</strong></p><p>使用参数<code>-Xint</code>可以设置JVM运行于“解释模式”。</p></li><li><p><strong>JIT（Just In-Time）模式：即时编译器</strong></p><p>使用参数<code>-Xcomp</code>可以设置JVM运行于“编译模式”，但要注意，当编译器无法继续工作时解释器依然会介入执行。</p></li></ul><p><em><strong>分层编译在JDK 6中被初步实现，后一直处于改进阶段，最终在JDK 7服务端模式中作为默认编译策略被开启</strong></em>。分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其包括：</p><ul><li>第0层：程序纯解释执行，并且解释器不开启性能监控功能（Profiling）。</li><li>第1层：使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启 性能监控功能。</li><li>第2层：使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。</li><li>第3层：使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。</li><li>第4层：使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启 用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。</li></ul><p>分层编译后，解释器、客户端编译器、服务端编译器可同时工作，在服务端编译器采用高复杂度优化算法时，客户端编译器可先采用简单优化来为之争取更多编译时间。</p><blockquote><p><font color="orange">疑问：既然编译到本地效率更高，为啥不全部编译到本地呢？</font></p><ol><li>现在的Java解释器执行效率已经很高，几乎可以和编译器相媲美。</li><li>类库或class很多时，采用编译到本地的方式会导致启动过程非常慢。</li></ol></blockquote><h5 id="热点代码"><a href="#热点代码" class="headerlink" title="热点代码"></a>热点代码</h5><p>被即时编译器编译的目标是“热点代码”，热点代码主要有两类： </p><ul><li><strong>被多次调用的方法</strong>。 </li><li><strong>被多次执行的循环体</strong>。</li></ul><p>某段代码是不是热点代码，是否触发即时编译需要执行“热点探测”（Hot Spot Code Detection），热点探测并不一定要知道方法具体被调用多少次，目前主流的热点探测判定方式有两种，分别是：</p><ul><li><p><strong>基于采样的热点探测</strong></p><p>采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。这种探测方式的好处是实现简单高效，可以很容易获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而 扰乱热点探测。</p></li><li><p><strong>基于计数器的热点探测</strong></p><p>采用这种方法的虚拟机会为 每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为 它是“热点方法”。这种统计方法实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。</p></li></ul><h5 id="调用计数器"><a href="#调用计数器" class="headerlink" title="调用计数器"></a>调用计数器</h5><p>方法被调用时会先查看是否存在该方法编译后的代码，存在则先执行编译后的代码，不存在则会将方法调用计时器值加1，然后判断方法调用计数器值与回边计数器值之和是否超过调用计数器的阈值，超过阈值会向即时编译器发送方法代码编译请求，在代码被即时编译器编译完成前会暂时先使用解释器来解释执行，当编译完成后，该方法的调用入口地址就会被自动修改为新值，后期调用该方法时就可以执行编译后的代码了。</p><blockquote><p>方法调用计数器的默认阈值在客户端模式下是1500次，在服务端模式下是10000次，这个阈值可以通过虚拟机参数<code>-XX:CompileThreshold</code>来人为设定。</p></blockquote><p>默认设置下，方法调用计数器统计的是一段时间内方法被调用的次数，该时间段内，如果方法的调用次数不足以触发即时编译器来编译，那方法调用计数器数值会减少一半，该过程被称为方法调用计数器<font color='orange'>热度衰减（Counter Decay）</font>，而这段时间称为此方法统计的<font color='orange'>半衰周期（Counter Half Life Time）</font>。</p><blockquote><p><font color='orange'>热度衰减操作在垃圾收集时进行</font>，可使用参数<code>-XX:-UseCounterDecay</code>来关闭热度衰减，让方法调用计数器统计方法调用的绝对次数。可使用参数<code>-XX:CounterHalfLifeTime</code>设置半衰周期的时间，单位秒。</p></blockquote><h5 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h5><p><font color='orange'>回边计数器会统计一个方法中循环体代码的执行次数，在字节码中遇到控制流向后跳转的指令就称为“回边（Back Edge）”，回边计数器统计的目的是为了触发栈上替换编译。</font></p><p>回边计数器阈值计算分以下两种情况：</p><ul><li>客户端模式下回边计数器阈值计算公式为：方法调用计数器阈值（-XX:CompileThreshold）乘以OSR比率（-XX:OnStackReplacePercentage）除以100。其中-XX:OnStackReplacePercentage默认值为933，如果都取默认值，那客户端模式下的回边计数器的阈值为 13995。</li><li>服务端模式下回边计数器阈值的计算公式为：方法调用计数器阈值（-XX:CompileThreshold）乘以（OSR比率（-XX:OnStackReplacePercentage）减去解释器监控比率（-XX:InterpreterProfilePercentage）的差值）除以100。其中-XX：OnStack ReplacePercentage默认值为140，- XX:InterpreterProfilePercentage默认值为33，如果都取默认值，那服务端模式的回边计数器的阈值为10700。</li></ul><p>当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有的话，它将会优先执行已编译的代码，否则就把回边计数器的值加一，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。超过阈值时会提交一个栈上替换编译请求， 并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。</p><p>与方法计数器不同，回边计数器没有计算热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出时会把方法计数器的值也调整到溢出状态，这样下次再进入该方法时就会执行标准编译过程。</p><blockquote><p><font color='red'>注意：回边次数 不等于 循环次数，因为并不是所有的循环都是回边，如空循环并不算控制流向后跳转，也不会被回边计数器统计。</font></p></blockquote><h3 id="0-3-2、提前编译器"><a href="#0-3-2、提前编译器" class="headerlink" title="0.3.2、提前编译器"></a>0.3.2、提前编译器</h3><p><em><strong>JDK 9引入了可对 Class文件 和 模块 进行提前编译的工具Jaotc</strong></em>，它可以减少程序的启动时间和到达全速性能的预热时间。该功能需要特定的物理机器和虚拟机参数，限制太多。</p><h3 id="0-3-3、编译器优化"><a href="#0-3-3、编译器优化" class="headerlink" title="0.3.3、编译器优化"></a>0.3.3、编译器优化</h3><h5 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h5><p><font color='orange'>内联被称为优化之母，消除方法调用成本外，也为 其它优化手段 提供了良好基础。</font></p><p><font color='orange'>方法内联就是把目标方法代码“复制”到发起调用的方法之中，避免发生真实方法调用。</font>该功能得益于即时编译器的付出。</p><blockquote><p>Java中默认的实例方法是虚方法。只有使用 invokespecial指令调用的私有方法、实例构造器、父类方法和使用invokestatic指令调用的静态方法才会在编译期进行解析。被final修饰的方法使用invokevirtual指令调用，它是非虚方法，《Java语言规范》中明确说明了这点。</p></blockquote><p>内联与 虚方法之间会产生“矛盾”，C和C++是通过使用final关键字来修饰方法解决的，但Java在虚拟机中解决这个问题。</p><p>Java虚拟机首先引入了一种名为<font color='orange'>类型继承关系分析（Class Hierarchy Analysis，CHA）的技术</font>，用于确定目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法 等信息。</p><p>编译器进行内联时会根据不同情况采取不同处理：非虚方法直接进行内联就可以；对于虚方法，会向CHA查询此方法下是否有多个目标版本可供选择，如果只有一个版本，那可以内联，这种内联称为<font color='orange'>守护内联（Guarded Inlining）</font>。由于Java程序是动态连接的，说不准什么时候就会加载到新的类型从而改变CHA结论，因此这种内联属于【激进预测性优化】。假如在程序的后续执行过程中，虚拟机一直没有加载到会导致方法接收者继承关系发生变化的类，那这个内联优化的代码就可以一直使用。如果加载了导致继承关系发生变化的新类，那么就必须抛弃已编译的代码，退回到解释状态执行，或重新进行编译。</p><p>如果被调用的方法确实有多个版本可供选择，那即时编译器还将进行最后一次努力，使用内联缓存（Inline Cache）的方式来缩减方法调用的开销。这种状态下方法调用真正发生，比起直接查虚方法表还要快一些。</p><h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p>逃逸分析（Escape Analysis）与类型继承关系分析一 样，并不是直接优化代码的手段，而是<em><strong>为其他优化措施提供依据的分析技术</strong></em>。</p><p>逃逸分析基本原理：分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，这种称为方法逃逸；甚至还有可能被外部线程访问，这种称为线程逃逸；不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。</p><p><font color='red'>注意：JDK 6u23版本之后，Hotspot默认开启了逃逸分析。</font></p><h6 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h6><p>如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径 访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例采取不同程度的优化。比如：</p><ul><li><p><font color='orange'>栈上分配</font></p><p>如果确定一个对 象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存 空间就可以随栈帧出栈而销毁。栈上分配可以支持方法逃逸，但不能支持线程逃逸。</p></li><li><p><font color='orange'>标量替换</font></p><p>若一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据 就可以被称为标量。相对的，如果一个数据可以继续分解，那它就被称为聚合量（Aggregate），Java 中的对象就是典型的聚合量。如果把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量 恢复为原始类型来访问，这个过程就称为标量替换。</p><p>标量替换可以视作栈上分配的一种特例，实现更简单（不用考虑整个对象完整结构的分配），但对逃逸程度的要求更高，它不允许对象逃逸出方法范围内。</p></li><li><p><font color='orange'>同步消除</font></p><p>线程同步本身是一个相对耗时的过程，如果逃逸分析 能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争， 对这个变量实施的同步措施也就可以安全地消除掉。</p></li></ul><h6 id="功能开启"><a href="#功能开启" class="headerlink" title="功能开启"></a>功能开启</h6><ul><li>-XX:+DoEscapeAnalysis：开启逃逸分析。</li><li>-XX:+PrintEscapeAnalysis：查看逃逸分析筛选结果。</li></ul><h5 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h5><p>公共子表达式消除的含义是：<font color='orange'>如果一 个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E 的这次出现就称为公共子表达式。对于这种表达式，没有必要花时间再对它重新进行计算，可直接使用计算过的表达式结果代替E。</font>如果这种优化仅限于程序基本块内，便可称为局部公共子表达式消除（Local Common Subexpression Elimination），如果这种优化的范围涵盖了多个基本块，那就称 为全局公共子表达式消除（Global Common Subexpression Elimination）。</p><h5 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h5><p>数组边界检查消除（Array Bounds Checking Elimination）是即时编译器中的一项语言相关的经典优化技术。如果有一个数组foo[]，在Java语言中访问数组元素foo[i]的时候系统将会自动进行上下界 的范围检查，即i必须满足“i&gt;&#x3D;0&amp;&amp;i&lt;&#x3D;foo.length”的访问条件，否则将抛出一个运行时异常： java.lang.ArrayIndexOutOfBoundsException。对于虚拟机执行子系统来说，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这必定是一种性能负担。</p><p>无论如何，为了安全，数组边界检查肯定是要做的，但数组边界检查是不是必须在运行期间一次 不漏地进行则是可以“商量”的事情。<font color='orange'>如果对于数组的访问在编译期根据数据流分析就能确定没有越界，执行时就无须判断了。</font>更常见的是数组访问发生在循环中，且使用循环变量来访问数组。那么在循环中就可以把整个数组的上下界检查消除掉，这可以减少很多次的条件判断操作。</p><h3 id="0-3-4、Graal编译器"><a href="#0-3-4、Graal编译器" class="headerlink" title="0.3.4、Graal编译器"></a>0.3.4、Graal编译器</h3><p><font color='orange'>从JDK 10起，Graal 编译器可以替换服务端编译器，成为HotSpot分层编译中最顶层的即时编译器。</font></p><p>Java虚拟机编译器接口（Java-Level JVM Compiler Interface，JVMCI）（JDK 9时发布的JEP 243）使得Graal可以从HotSpot的代码中分离出来。</p><p>通过Java虚拟机编译器接口就可以把一个在HotSpot虚拟机外部的、用Java语言实现的即时编译器（不局限于Graal）集成到HotSpot中，响应HotSpot发出的最顶层的编译请求，并将编译后的二进制代码 部署到 HotSpot代码缓存中。此外，又可以绕开HotSpot的即时编译系统，让该编译器直接为应用的类库编译出二进制机器码，将该编译器当作一个提前编译器去使用 （如Jaotc）。</p><h3 id="0-3-5、总结"><a href="#0-3-5、总结" class="headerlink" title="0.3.5、总结"></a>0.3.5、总结</h3><p><font color='orange'>HotSpot VM采用 解释器与即时编译器并存 的架构。</font>Java虚拟机运行时会采用解释器和即时编译器协调工作的方式来达到相对较好的工作状态。</p><h2 id="0-4、本地方法接口"><a href="#0-4、本地方法接口" class="headerlink" title="0.4、本地方法接口"></a>0.4、本地方法接口</h2><h3 id="0-4-1、本地方法"><a href="#0-4-1、本地方法" class="headerlink" title="0.4.1、本地方法"></a>0.4.1、本地方法</h3><h4 id="0-4-1-1、定义"><a href="#0-4-1-1、定义" class="headerlink" title="0.4.1.1、定义"></a>0.4.1.1、定义</h4><p>被关键字native修饰的没有方法体的方法就是一个本地方法，本地方法是java调用非java代码的接口。</p><h2 id="0-5、对象管理"><a href="#0-5、对象管理" class="headerlink" title="0.5、对象管理"></a>0.5、对象管理</h2><h3 id="0-5-1、对象创建"><a href="#0-5-1、对象创建" class="headerlink" title="0.5.1、对象创建"></a>0.5.1、对象创建</h3><p>创建对象一般遵循以下6大步骤：</p><ol><li>判断对象对应的类是否已经被加载、连接、初始化。</li><li>为对象分配内存。<ul><li>如果内存规整，通过【指针碰撞】方式来分配内存。</li><li>如果内存不规整，通过【空想列表】方式来分配内存。</li></ul></li><li>处理并发安全问题。<ul><li>采用CAS失败重试，区域加锁保证更新原子性。</li><li>每个线程预先分配一个TLAB。</li></ul></li><li>初始化分配到的空间。</li><li>设置对象的对象头。</li><li>执行init方法进行初始化。</li></ol><h3 id="0-5-2、对象定位"><a href="#0-5-2、对象定位" class="headerlink" title="0.5.2、对象定位"></a>0.5.2、对象定位</h3><h4 id="0-5-2-1、简介"><a href="#0-5-2-1、简介" class="headerlink" title="0.5.2.1、简介"></a>0.5.2.1、简介</h4><p>对象访问有两种方式：句柄访问和直接指针。<em><strong>Java中使用的是直接指针</strong></em>。</p><h4 id="0-5-2-2、句柄访问"><a href="#0-5-2-2、句柄访问" class="headerlink" title="0.5.2.2、句柄访问"></a>0.5.2.2、句柄访问</h4><p><img src="/%5Cimgs%5Cjavadev%5C%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86-1.1-%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%BD%8D-%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%9B%BE%E7%A4%BA.png"></p><h4 id="0-5-2-3、直接指针"><a href="#0-5-2-3、直接指针" class="headerlink" title="0.5.2.3、直接指针"></a>0.5.2.3、直接指针</h4><p><img src="/%5Cimgs%5Cjavadev%5C%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86-1.2-%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png"></p><h1 id="1、JVM基础"><a href="#1、JVM基础" class="headerlink" title="1、JVM基础"></a>1、JVM基础</h1><h2 id="1-1、概述"><a href="#1-1、概述" class="headerlink" title="1.1、概述"></a>1.1、概述</h2><h3 id="1-1-1、简介"><a href="#1-1-1、简介" class="headerlink" title="1.1.1、简介"></a>1.1.1、简介</h3><p>JVM全称为Java Virtual Machine，意为Java虚拟机。</p><p>JVM、JRE、JDK、JAVASE、JAVAEE等的关系：JVM &lt; JRE &lt; JDK &lt; JAVASE &lt; JAVAEE。它们之间是包含与被包含的关系。详情介绍如下：</p><ul><li><strong>JVM</strong>：Java Virtual Machine，意为Java虚拟机。</li><li><strong>JRE</strong>：Java Runtime Environment，意为Java运行时环境。</li><li><strong>JDK</strong>：Java Development Kit，意为Java开发工具集。</li><li><strong>JAVAME</strong>：Java Micro Edition，意为Micro版，之前称J2ME。是一个技术和规范的集合，它为移动设备（包括消费类产品、嵌入式设备、高级移动设备等）提供了基于Java环境的开发与应用平台。Java ME分为两类配置，一类是面向小型移动设备的<em>CLDC</em>（Connected Limited Device Profile），一类是面向功能更强大的移动设备如智能手机和机顶盒，称为<em>CDC</em>（Connected Device Profile CDC）。Java ME有自己的类库，其中<em>CLDC</em>使用的是专用的Java虚拟机叫做J<em>VM</em>。</li><li><strong>JAVASE</strong>：Java Standard Edition，意为Java标准版，之前称为J2SE。JAVASE是Java技术的核心和基础，是Java ME和Java EE编程的基础。</li><li><strong>JAVAEE</strong>：Java Enterprise Edition，意为 Java企业版，之前也称为J2EE。Java EE 是在 Java SE 的基础上构建的，它提供Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 3.0应用程序。</li></ul><p>JVM在垃圾回收层面与C++的区别：</p><ul><li>JAVA：系统自动处理，开发效率高，执行效率低。</li><li>C++：手工处理，开发效率低，执行效率高。容易出现忘记回收、内存泄漏。回收多次、非法访问等问题。</li></ul><h3 id="1-1-2、优点"><a href="#1-1-2、优点" class="headerlink" title="1.1.2、优点"></a>1.1.2、优点</h3><p>JVM优点如下：</p><ul><li>一次编译，到处运行。</li><li>自动垃圾回收。</li><li>多态特性。</li><li>数组下标越界检查。</li></ul><h3 id="1-1-3、常见虚拟机"><a href="#1-1-3、常见虚拟机" class="headerlink" title="1.1.3、常见虚拟机"></a>1.1.3、常见虚拟机</h3><ul><li><p>Hotspot</p></li><li><p>JRockit（BEA）</p><p>JRockit专注于服务端应用，据行业基准测试显示，其是世界上最快的JVM。2008年BEA被Oracle收购，Oracle计划将整合两大优秀的虚拟机，整合方式是在Hotspot基础上加入JRockit的新特性。</p></li><li><p>J9（IBM）</p><p>市场定位与HotSpot相似，适用于服务器端、桌面应用、嵌入式应用等场景。2017年左右，IBM开源了J9 VM，命名为OpenJ9，交给Eclipse基金会管理。</p></li><li><p>KVM</p></li><li><p>Azul VM</p></li><li><p>Liquid VM（BEA）</p></li><li><p>Graal VM</p><p>2018年Oracle公开Graal VM，号称“Run Programs Faster Anywhere”，其与1995年宣称的“Write Once, Run Anywhere”遥相呼应。Graal VM是在HotSpot VM基础上增强而成的跨语言全栈虚拟机，适用于多种语言。</p></li></ul><h3 id="1-1-4、虚拟机退出"><a href="#1-1-4、虚拟机退出" class="headerlink" title="1.1.4、虚拟机退出"></a>1.1.4、虚拟机退出</h3><p>导致虚拟机退出的情况分以下几种：</p><ul><li>程序正常结束。</li><li>程序执行过程中遇到了异常或错误，进而导致虚拟机退出。</li><li>因操作系统出现错误导致虚拟机退出。</li><li>调用了Runtime类或System类的exit方法，或Runtime类的halt方法，且Java安全管理器也允许这种操作。</li></ul><h2 id="1-2、认识垃圾"><a href="#1-2、认识垃圾" class="headerlink" title="1.2、认识垃圾"></a>1.2、认识垃圾</h2><h3 id="1-2-1、垃圾定义"><a href="#1-2-1、垃圾定义" class="headerlink" title="1.2.1、垃圾定义"></a>1.2.1、垃圾定义</h3><p><font color='orange'>没有引用指向的任何对象都称为垃圾，且应该被回收。</font></p><h2 id="1-3、识别垃圾"><a href="#1-3、识别垃圾" class="headerlink" title="1.3、识别垃圾"></a>1.3、识别垃圾</h2><h3 id="1-3-1、引用计数算法"><a href="#1-3-1、引用计数算法" class="headerlink" title="1.3.1、引用计数算法"></a>1.3.1、引用计数算法</h3><h4 id="1-3-1-1、简介"><a href="#1-3-1-1、简介" class="headerlink" title="1.3.1.1、简介"></a>1.3.1.1、简介</h4><p><font color='orange'>当一个对象被引用时，该对象的引用计数器数值会加1，这被称为引用计数算法。</font></p><h4 id="1-3-1-2、缺点"><a href="#1-3-1-2、缺点" class="headerlink" title="1.3.1.2、缺点"></a>1.3.1.2、缺点</h4><ol><li><p><font color='red'>需要一个单独字段来存储计数器，增加了存储开销。</font></p></li><li><p><font color='red'>每次赋值都需要更新计数器，增加了时间开销。</font></p></li><li><p><font color='red'>不能解决“循环引用”问题。</font></p><p>循环引用问题指：有对象A和对象B，对象A中含有对象B的引用，对象B中含有对象A的引用。此时，对象A和对象B的引用计数器都不为0，但是在系统中却不存在任何第3个对象引用了A或B。也就是说A和B是应该被回收的垃圾对象，但由于垃圾对象间相互引用，从而使垃圾回收器无法识别，引起内存泄漏。</p></li></ol><h3 id="1-3-2、根可达性算法"><a href="#1-3-2、根可达性算法" class="headerlink" title="1.3.2、根可达性算法"></a>1.3.2、根可达性算法</h3><h4 id="1-3-2-1、简介"><a href="#1-3-2-1、简介" class="headerlink" title="1.3.2.1、简介"></a>1.3.2.1、简介</h4><p><font color='orange'>根搜索算法 有 实现简单、执行高效等特点，可有效解决循环引用问题，防止内存泄漏发生。</font></p><p>根搜索算法 是以 根对象集合为起始点，按照从上至下的方式 搜索 被根对象集合所连接的目标对象 是否可达，如果目标对象不可达就表明该对象己死亡，便可以在 instanceOopDesc Mark World 中将其标记为垃圾对象。在根搜索算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</p><h4 id="1-3-2-2、根对象"><a href="#1-3-2-2、根对象" class="headerlink" title="1.3.2.2、根对象"></a>1.3.2.2、根对象</h4><p><font color='orange'>当一个程序刚启动时需要的那些对象就称为根对象。</font>比如：</p><ol><li>main线程栈帧中的那些对象。</li><li>静态变量访问到的对象。</li><li>常量池：一个class用到其它class的那些类的对象称为根对象。</li><li>JNI：调用C和C++那些方法所使用到的那些类或对象。</li></ol><p><font color='orange'>在 Hotspot 中，根对象集合中包含5个元素：</font></p><ol><li>Java 对象引用。</li><li>本地方法内的对象引用。</li><li>运行时常量池中的对象引用。</li><li>方法区中类静态属性的对象引用。</li><li>与一个类对应的唯一数据类型的 Class 对象。</li></ol><h4 id="1-3-2-3、总结"><a href="#1-3-2-3、总结" class="headerlink" title="1.3.2.3、总结"></a>1.3.2.3、总结</h4><p><em><strong>根搜索算法中的不可达对象最初处于缓刑阶段，真正死亡要经历两次标记</strong></em>：</p><ol><li>如果一个对象没有与GCRoot相连，那么该对象会被第一次标记并判断是否执行该对象的finaliz()方法。如果该对象没有覆盖finalize()方法或finalize()方法已经执行过了，那么无需操作，否则会将该对象放入F-Queue中，然后通过一个低优先级的finalizer线程来执行该对象的finalize()方法。</li><li>稍后 GC 将对 F- Queue 中的对象进行第二次标记，第二次标记之前，如果该对象与其它对象建立了引用关系，那么第二次标记时会将该对象移出即将回收的集合。如果第二次标记之前，该对象没有发生引用变化，那么它将会被真正回收。</li></ol><h2 id="1-4、垃圾回收"><a href="#1-4、垃圾回收" class="headerlink" title="1.4、垃圾回收"></a>1.4、垃圾回收</h2><h3 id="1-4-1、垃圾回收算法"><a href="#1-4-1、垃圾回收算法" class="headerlink" title="1.4.1、垃圾回收算法"></a>1.4.1、垃圾回收算法</h3><h4 id="1-4-1-1、标记清除（Mark-Sweep）"><a href="#1-4-1-1、标记清除（Mark-Sweep）" class="headerlink" title="1.4.1.1、标记清除（Mark-Sweep）"></a>1.4.1.1、标记清除（Mark-Sweep）</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>标记存活对象然后清除未被标记的垃圾对象的算法称为：标记清除算法。该算法将垃圾回收分两个阶段，标记阶段和清除阶段。</p><ol><li><p><font color='orange'>标记阶段</font></p><p>Collector从引用根节点开始遍历，标记可以被根对象关联到的对象，这些对象都是可达对象。</p></li><li><p><font color='orange'>清除阶段</font></p><p>Collector对堆内存从头到尾进行线性遍历，如果发现某个对象在其Header中没有被标记为可达对象，则将其回收。</p><p>这里的清除并非是真的清除，而是将待清除对象的地址保存在空闲地址列表中，为新对象分配内存时，可以直接覆盖使用。</p></li></ol><p>标记-清除算法不需要运行环境监测每一次内存分配和指针操作，而只要在“标记”阶段中跟踪每个指针变量的指向，用类似思路实现的垃圾收集器常被称为 跟踪收集器。</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li>优点：效率较高、成本较低。</li><li>缺点：会产生内存碎片、执行效率低。</li></ul><h4 id="1-4-1-2、复制（Copying）"><a href="#1-4-1-2、复制（Copying）" class="headerlink" title="1.4.1.2、复制（Copying）"></a>1.4.1.2、复制（Copying）</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>将内存空间分为两块，每次只使用其中一块。垃圾回收时会将当前使用内存（假如为区域A）中的存活对象拷贝至另一空闲内存中（假如为区域B），然后清掉区域A中剩下的死亡对象并交换两个内存区域的角色，最后完成垃圾回收，这种算法称之为：复制算法。</p><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li>优点：<font color='orang'>只扫描一次，效率高且没有碎片；</font></li><li>缺点：<font color='red'>每次只使用一半内存，造成空间浪费；移动复制对象需要调整对象引用；</font></li></ul><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>适用于存活对象较少的情况。</p><h4 id="1-4-1-3、标记压缩（Mark-Compact）"><a href="#1-4-1-3、标记压缩（Mark-Compact）" class="headerlink" title="1.4.1.3、标记压缩（Mark-Compact）"></a>1.4.1.3、标记压缩（Mark-Compact）</h4><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><p>标记压缩算法思想：<font color='orange'>从根节点标记所有被引用对象，然后将存活对象压缩到内存一端，按顺序排放，之后清理边界外所有的空间。</font></p><p>空间压缩后，内存较为规整，此种情况下可以通过 指针碰撞 算法为新对象分配空间。</p><h5 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li>优点：<font color='orang'>不会 产生碎片；</font></li><li>缺点：<font color='red'>两遍扫描，第一遍先找出有用的，第二遍才进行移动，如果是多线程还需要进行同步，效率低。</font></li></ul><h4 id="1-4-1-4、增量算法-（Incremental-Collecting"><a href="#1-4-1-4、增量算法-（Incremental-Collecting" class="headerlink" title="1.4.1.4、增量算法 （Incremental Collecting )"></a>1.4.1.4、增量算法 （Incremental Collecting )</h4><p>增量算法思想：<font color='orange'>垃圾收集线程和应用程序线程【交替执行】</font>，每次垃圾收集线程只收集小片内存空间，然后切换到应用程序线程执行。依次反复，直到垃圾收集完成。</p><p>垃圾回收线程 和 应用程序线程同时执行，可以减少停顿时间，但因线程切换、上下文转换等开销会降低吞吐量。</p><h4 id="1-4-1-5、Card-Table（卡表）"><a href="#1-4-1-5、Card-Table（卡表）" class="headerlink" title="1.4.1.5、Card Table（卡表）"></a>1.4.1.5、Card Table（卡表）</h4><p>官方解释：A kind of remembered set that records where oops have changed in a generation.</p><p>Card Table 是一种数组结构，底层由BitMap实现，每个位置代表一个Card，其大小为1byte。1byte有八位，通过约定每一位的含义就可区分不同的使用场景。</p><p>卡表作用：将老年代空间分成多个大小相同的块（一般为 <code>128~512bytes</code> ），叫做卡片（Card）。对象放在不同的card中，如果老年代的某个Card中的对象引用了年轻代中的对象，写屏障逻辑就会将之标记为Dirty，下次扫描时只需扫描Dirty Card即可。</p><h3 id="1-4-2、垃圾回收触发机制"><a href="#1-4-2、垃圾回收触发机制" class="headerlink" title="1.4.2、垃圾回收触发机制"></a>1.4.2、垃圾回收触发机制</h3><h4 id="1-4-2-1、年轻代GC"><a href="#1-4-2-1、年轻代GC" class="headerlink" title="1.4.2.1、年轻代GC"></a>1.4.2.1、年轻代GC</h4><ul><li>年轻代空间不足时会触发Minor GC，Survivor区满并不会触发GC。</li><li>Minor GC会引发STW，暂停其它用户线程，当垃圾线程执行完毕后用户线程才会恢复。</li></ul><h4 id="1-4-2-2、老年代GC"><a href="#1-4-2-2、老年代GC" class="headerlink" title="1.4.2.2、老年代GC"></a>1.4.2.2、老年代GC</h4><ul><li>出现了Major GC前通常会先执行一次Minor GC（非绝对，Parallel Scavenge收集器可以直接执行Major GC。）。</li><li>Major GC 速度一般比Minor GC慢10倍以上。</li><li>Major GC后内存依然不足，那么就报OOM。</li></ul><h4 id="1-4-2-3、FUll-GC"><a href="#1-4-2-3、FUll-GC" class="headerlink" title="1.4.2.3、FUll GC"></a>1.4.2.3、FUll GC</h4><p>触发FGC的情况有如下几种：</p><ul><li>老年代空间不足。</li><li>方法区空间不足。</li><li>通过Minor GC后进入老年代对象的平均大小大于老年代可用空间。</li><li>由Eden区、Survivor from区向Survivor to区复制对象时，对象大小大于to区可用内存，则把该对象放进老年代，且老年代可用内存小于该对象大小。</li><li>调用System.gc()方法时，通知系统执行Full GC，但不保证一定执行。</li></ul><h2 id="1-5、堆内存逻辑分区模型"><a href="#1-5、堆内存逻辑分区模型" class="headerlink" title="1.5、堆内存逻辑分区模型"></a>1.5、堆内存逻辑分区模型</h2><ul><li>除了Epsilon、ZGC、Shenandoah之外，其它GC都使用逻辑分代模型。</li><li>G1是逻辑分代，物理不分代。</li><li>除此之外，不仅逻辑分代，物理也分代。</li></ul><h2 id="1-6、新老年代划分"><a href="#1-6、新老年代划分" class="headerlink" title="1.6、新老年代划分"></a>1.6、新老年代划分</h2><h3 id="1-6-1、新生代"><a href="#1-6-1、新生代" class="headerlink" title="1.6.1、新生代"></a>1.6.1、新生代</h3><ul><li><font color='orange'>eden（伊甸）</font>：默认比例为8，存放刚new出来的对象。</li><li><font color='orange'>survivor from</font>：默认比例为1，回收一次后要存储对象的区域。</li><li><font color='orange'>survivor to</font>：默认比例为1，回收一次后要存储对象的区域。</li></ul><h3 id="1-6-2、老年代"><a href="#1-6-2、老年代" class="headerlink" title="1.6.2、老年代"></a>1.6.2、老年代</h3><ul><li><font color='orange'>tenured（终身）</font>：默认与新生代的比例为2:1，存放大对象和生命力较强的对象。</li></ul><h2 id="1-7、对象生命周期"><a href="#1-7、对象生命周期" class="headerlink" title="1.7、对象生命周期"></a>1.7、对象生命周期</h2><h3 id="1-7-1、生命周期"><a href="#1-7-1、生命周期" class="headerlink" title="1.7.1、生命周期"></a>1.7.1、生命周期</h3><p><font color='orange'>对象产生后会优先栈上分配；如果不能分配，就判断其大小，如果太大直接放进老年代，如果不大，就在TLAB中分配；如果还是分配不下，就直接在eden区分配。</font></p><p>eden区经过一次垃圾回收之后，未被回收的对象会进入surivor from区，eden区和surivor from区再经过一次回收后，未被回收的对象会被移动到survivor to区（注意：移动完成后 from区和to区交换角色，即 from变to，to变from，为的是下次再回收后来存储alive对象），以此反复执行，直到年龄达到阈值时就进入老年代。</p><p><font color='red'>注意：from &lt;—&gt; to区中对象间的移动超过阈值就会进入老年代，这个阈值可通过如下参数进行设置：</font></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-XX:MaxTenuringThreshold</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>栈上分配前提条件：</p><ul><li><font color='orange'>线程私有小对象。</font></li><li><font color='orange'>无逃逸</font>：在某一段代码中使用，代码外无法使用。</li><li><font color='orange'>支持标量替换</font>：用普通的类型代替对象（若仅仅使用一个对象中的1至2个属性，那么就无需先拿到对象再获取对应属性，而是直接使用这两个属性代替这个对象）。</li><li><font color='orange'>无需调整。</font></li></ul><h3 id="1-7-2、TLAB"><a href="#1-7-2、TLAB" class="headerlink" title="1.7.2、TLAB"></a>1.7.2、TLAB</h3><h4 id="1-7-2-1、简介"><a href="#1-7-2-1、简介" class="headerlink" title="1.7.2.1、简介"></a>1.7.2.1、简介</h4><p>TLAB意为【线程本地分配缓冲区】，TLAB是堆内存eden区中划分出的一块线程专用空间。线程初始化时，虚拟机会为每一个线程分配一块TLAB空间，该空间线程独有。如果要分配内存，优先在该空间上分配，这样就避免了竞争，大大提高内存分配效率和线程安全。</p><p><font color='red'>注意：TLAB的独占只限于“内存分配”这个动作，而对于TLAB的读取、内存回收等操作依然属于线程共享。</font></p><h4 id="1-7-2-2、TLAB问题"><a href="#1-7-2-2、TLAB问题" class="headerlink" title="1.7.2.2、TLAB问题"></a>1.7.2.2、TLAB问题</h4><p>假如一个线程的TLAB空间大小为100KB，已经使用80KB，当再分配一个30KB的对象时，就无法在TLAB中分配，遇到此种情况，有两种处理方案：</p><ol><li><font color='orange'>直接在堆内存中分配对象。</font></li><li><font color='orange'>废弃当前TLAB，重新申请TLAB并在其中为对象分配内存。</font></li></ol><p>为解决这两个问题，虚拟机设定了一个参数<code>refill_waste</code>，称为【最大浪费空间】。当请求分配的内存大于该参数值，则在堆内存中分配对象，当小于该值时则废弃当前TLAB并重新申请TLAB，然后在其中进行对象分配。</p><h4 id="1-7-2-3、TLAB相关参数"><a href="#1-7-2-3、TLAB相关参数" class="headerlink" title="1.7.2.3、TLAB相关参数"></a>1.7.2.3、TLAB相关参数</h4><ul><li><font color='orange'>手动指定tlab大小</font>：-XX：TLABSize</li><li><font color='orange'>tlab功能开启&#x2F;关闭</font>：XX:+&#x2F;-UseTLAB</li><li><font color='orange'>tlab占eden空间百分比</font>：-XX:TLABWasteTargetPercent</li><li><font color='orange'>禁用tlab运行时动态自动调整大小功能</font>：-XX:-ResizeTLAB</li><li><font color='orange'>tlab的refill_waste值</font>：-XX：TLABRefillWasteFraction（默认大小64，表示使用约为1&#x2F;64空间大小作为refill_waste）</li><li><font color='orange'>观察tlab使用情况</font>：-XX+PringTLAB</li></ul><h3 id="1-7-3、何时进入老年代"><a href="#1-7-3、何时进入老年代" class="headerlink" title="1.7.3、何时进入老年代"></a>1.7.3、何时进入老年代</h3><h4 id="1-7-3-1、参数指定"><a href="#1-7-3-1、参数指定" class="headerlink" title="1.7.3.1、参数指定"></a>1.7.3.1、参数指定</h4><p><font color='orange'>年龄达到参数<code>-XX:MaxTenuringThreshold</code> 设置的值，如果不指定，默认参考如下：</font></p><ul><li>Parallel Scavenge：15</li><li>CMS：6</li><li>G1：15</li></ul><h4 id="1-7-3-2、动态年龄"><a href="#1-7-3-2、动态年龄" class="headerlink" title="1.7.3.2、动态年龄"></a>1.7.3.2、动态年龄</h4><ul><li>from -&gt; to后超过to内存总量50%。form + eden区的存活对象全部移到to区后，若此时to区中相同年龄对象的内存大小 总和 占用to区内存总量的一半时，则将这些年龄相同的对象和超过该年龄的对象直接放入老年代。所以说也不一定非得到了15岁&#x2F;6岁才行。</li><li>把年龄最大的直接放入老年代。</li></ul><h2 id="1-8、垃圾收集器"><a href="#1-8、垃圾收集器" class="headerlink" title="1.8、垃圾收集器"></a>1.8、垃圾收集器</h2><h3 id="1-8-1、Serial（JDK1-3）"><a href="#1-8-1、Serial（JDK1-3）" class="headerlink" title="1.8.1、Serial（JDK1.3）"></a>1.8.1、Serial（JDK1.3）</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>JDK1.3.1引入Serial GC，适用于 存储器小，CPU少的环境。</p><p>Serial 收集器工作于<strong>年轻代</strong>，采用<strong>复制算法</strong>、串行回收和“ Stop-the-World ”机制的方式执行内存回收。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li><font color='orange'>-XX:+UseSerialGC</font>：年轻代、老年代分别使用Serial、Serial Old收集器。</li></ul><h3 id="1-8-2、Serial-Old"><a href="#1-8-2、Serial-Old" class="headerlink" title="1.8.2、Serial Old"></a>1.8.2、Serial Old</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>Serial Old收集器工作于<strong>老年代</strong>，采用 单线程 <strong>标记压缩算法</strong>。</p><blockquote><p>Serial Old是运行在Client模式下默认的老年代垃圾回收器。Serial Old在Server模式下主要有两个用途：与新生代的Parallel Scavenge配合使用；作为老年代CMS收集器的后备方案。</p></blockquote><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul><li><font color='orange'>-XX:+UseSerialGC</font>：年轻代、老年代分别使用Serial、Serial Old收集器。</li></ul><h3 id="1-8-3、Parallel-Scavenge（JDK1-4）"><a href="#1-8-3、Parallel-Scavenge（JDK1-4）" class="headerlink" title="1.8.3、Parallel Scavenge（JDK1.4）"></a>1.8.3、Parallel Scavenge（JDK1.4）</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>JDK1.4.2引入Parallel GC，JDK6中成为默认垃圾回收器。</p><p>Parallel Scavenge收集器工作在<strong>年轻代</strong>，采用<strong>复制算法</strong>，关注吞吐量。与并行收集器一样都是多线程、独占式的收集器。</p><p>自适应调节策略是Parallel Scavenge与ParNew的一个重要区别。</p><blockquote><p>如果没有优化，JDK1.8默认使用Parallel Scavenge和Parallel Old，简称PS+PO。</p></blockquote><h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><ul><li><font color='orange'>-XX:+UseParallelGC </font>：年轻代使用并行回收收集器，老年代使用串行收集器。</li><li><font color='orange'>-XX:+UseParallelOldGC</font>：年轻代和老年代都使用井行垃圾回收器。</li><li>-XX:ParallelGCThreads：年轻代并行收集器的线程数量。默认，当CPU数量小于8时线程数量等于CPU数量。当CPU数量大于8时，线程数量值为：3+[5*cpu数量&#x2F;8]。</li><li><font color='orange'>-XX MaxGCPauseMills</font>：最大垃圾收集停顿时间（单位毫秒），它的值是一个大于0的整数。</li><li><font color='orange'>-XX:+GCTimeRatio</font>：垃圾收集时间占总时间的比例。取值范围为0~100，默认值为99，也就是垃圾回收时间占用不超过1%。与参数<code>-XX MaxGCPauseMills</code>有一定矛盾性。</li><li>-XX:+UseAdaptiveSizePolicy：开启自适应调节策略。在这种模式下，年轻代的大小、 Eden的比例、晋升老年代的对象年龄等参数会被自动调整，己达到在堆大小、吞吐量和停顿时间之间的平衡点。仅指定虚拟机的最大堆、目标的吞吐量（ GCTimeRatio ）和停顿时间（ MaxGCPauseMills) , 让虚拟机自己完成调优工作。</li></ul><h3 id="1-8-4、Parallel-Old"><a href="#1-8-4、Parallel-Old" class="headerlink" title="1.8.4、Parallel Old"></a>1.8.4、Parallel Old</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>Parallel Old收集器工作于【老年代】，它既是多线程并发收集器，也是关注吞吐量的收集器。它采用标记压缩算法，基于并行回收和“Stop-the-World”机制，JDK 1.6 之后开始启用。</p><h4 id="如何开启？"><a href="#如何开启？" class="headerlink" title="如何开启？"></a>如何开启？</h4><ul><li><font color='orange'>-XX:+UseParallelOldGC</font>：年轻代和老年代中都使用并行回收收集器；</li><li><font color='orange'>-XX :ParallelGCThreads</font>：垃圾回收时的线程数量；</li></ul><h3 id="1-8-5、ParNew"><a href="#1-8-5、ParNew" class="headerlink" title="1.8.5、ParNew"></a>1.8.5、ParNew</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><p>ParNew收集器是Serial收集器的多线程版本。</p><p>ParNew收集器工作于<strong>年轻代</strong>，采用<strong>复制算法</strong>和<strong>Stop-the-World机制</strong>，并采用井行回收的方式执行内存回收。</p><blockquote><p>ParNew是大多数JVM运行在Server模式下新生代的默认垃圾回收器。</p><p>目前来说，ParNew只能与CMS配合工作。</p></blockquote><h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ol><li><font color='orange'>单CPU环境下， ParNew 收集器不见得比 Serial 收集器更高效；</font></li><li><font color='orange'>ParNew收集器可充分利用多CPU、多核心等物理硬件优势，可以更快速地完成垃圾收集，提升程序吞吐量；</font></li></ol></li><li>缺点</li></ul><h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><ul><li>-XX:+UseParNewGC：使用 ParNew 收集器；</li><li>-XX:ParallelGCThreads：并发线程数量，默认与CPU数量相同。</li></ul><h4 id="ParNew-vs-Paraller-Scavenge"><a href="#ParNew-vs-Paraller-Scavenge" class="headerlink" title="ParNew vs Paraller Scavenge"></a>ParNew vs Paraller Scavenge</h4><ol><li>PN响应时间优先，可配合CMS。</li><li>PS吞吐量优先。</li></ol><p>ParNew是Parallel Scavenge的变种。</p><h3 id="1-8-6、CMS（JDK1-4）"><a href="#1-8-6、CMS（JDK1-4）" class="headerlink" title="1.8.6、CMS（JDK1.4）"></a>1.8.6、CMS（JDK1.4）</h3><h4 id="1-8-6-1、简介"><a href="#1-8-6-1、简介" class="headerlink" title="1.8.6.1、简介"></a>1.8.6.1、简介</h4><p>CMS 是 concurrent mark sweep的首字母，意为并发标记回收。工作线程和垃圾回收线程可同时工作。CMS 天生井发、低延迟。CMS采用<strong>标记清除算法</strong>和<strong>STW机制</strong>。</p><p><font color='red'>注意：HotSpot 中， 除了 CMS收集器外的任何老年代垃圾收集器都会执行Full GC，只有G1收集器较为特殊。</font></p><blockquote><p>JDK 1.4.2引入CMS，JDK 14中删除了CMS。</p></blockquote><h4 id="1-8-6-2、回收过程"><a href="#1-8-6-2、回收过程" class="headerlink" title="1.8.6.2、回收过程"></a>1.8.6.2、回收过程</h4><ol><li><p><font color='orange'>初始标记</font>：有STW；单线程；</p></li><li><p><font color='orange'>并发标记</font>：工作线程和回收线程同时工作；多线程；会产生漏标问题。</p><p>最耗时的阶段，且并发执行、不产生STW、响应较好，如何做到？它会从根对象往下找，寻找过程中可能出现 垃圾被引用后又变成不是垃圾的情况。如果该情况发生在并发标记阶段，此时就会进入重新标记阶段，标记上一阶段标记后又发生变化的那些对象，因为变化不多，故重新标记也有STW，不过时间不长，故它可以控制暂停时间。</p></li><li><p><font color='orange'>重新标记</font>：STW；多线程；</p><p>对 起死回生对象、漏标对象 进行重新标记。</p></li><li><p><font color='orange'>并发清理</font>：会产生浮动垃圾（新垃圾）</p><p>回收垃圾对象过程中产生的新垃圾称为浮动垃圾。</p></li></ol><h4 id="1-8-6-3、优缺点"><a href="#1-8-6-3、优缺点" class="headerlink" title="1.8.6.3、优缺点"></a>1.8.6.3、优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>CMS优点：<strong>并发收集、低延迟</strong>。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>CMS存在如下缺点：</p><ul><li><p><strong>会产生内存碎片</strong></p><p>并发清除后，存在内存碎片，可用空间不足，无法分配大对象，不得不提前触发FULL GC。</p></li><li><p><strong>对CPU资源较敏感</strong></p><p>并发执行过程占用了一部分的资源导致程序一定程度上变慢，总吞吐量会降低。</p></li><li><p><strong>无法处理浮动垃圾</strong></p><p>程序线程与垃圾收集线程同时运行，并发标记阶段可能出现一些新的垃圾对象，而这些新的垃圾对象无法在这一时刻被及时处理，只能留给下一次GC来处理。</p></li></ul><p><font color='red'>CMS无法处理时会采用 单线程Serial Old收集器 进行标记压缩，速度会非常慢，应避免该情况发生。</font></p><h4 id="1-8-6-4、参数"><a href="#1-8-6-4、参数" class="headerlink" title="1.8.6.4、参数"></a>1.8.6.4、参数</h4><ul><li><strong>-XX:+UseConcMarkSweepGC</strong>：使用 CMS 收集器。开启该参数时会自动开启参数-XX:+UserParNewGC，最终的组合就是年轻代使用ParNew，老年代使用CMS和Serial Old。</li><li><strong>-XX:CMSInitiatingOccupanyFraction</strong>：堆内存使用率阈值，达到该阈值会触发垃圾回收。JDK5及之前版本默认值为68，即堆内存使用率达到68%时触发一次垃圾回收。JDK6及之后版本默认值为92。</li><li><strong>-XX:+UseCMSInitiatingOccupancyOnly</strong>： 只使用设定的回收阈值(-XX:CMSInitiatingOccupanyFraction值)。如果不开启该功能，则JVM仅在第一次使用设定值，后续会自动调整；</li><li><strong>-XX:+UseCMSCompactAtFullCollection</strong>：执行完Full GC后是否对内存进行压缩，压缩可避免内存碎片但停顿时间会更长。</li><li><strong>-XX:CMSFullGCsBeforeCompaction</strong>：执行多少次Full GC后对内存进行压缩。</li><li><strong>-XX:ParallelCMSThreads</strong>：CMS线程数量。默认线程数量为**(ParallelGCThreads + 3) &#x2F; 4**，</li></ul><h4 id="1-8-6-6、扩展"><a href="#1-8-6-6、扩展" class="headerlink" title="1.8.6.6、扩展"></a>1.8.6.6、扩展</h4><h5 id="Card-Table"><a href="#Card-Table" class="headerlink" title="Card Table"></a>Card Table</h5><p>Card Table是一种用于辅助处理跨代垃圾回收的数据结构。它的作用是跟踪对象引用在堆内存中的位置变化，以便准确的标记和回收垃圾对象。</p><p>Java堆内存通常被划分为多个连续的内存块，称之为卡片（Card）。每个卡片的大小通常为512字节或更小。Java堆中的每个对象引用都被映射到一个或多个卡片上。</p><p>Card Table通过位图（Bitmap）来表示堆内存的卡片状态。这个位图的每个位对应一个卡片，用于标记卡片上的引用是否发生变化。位图通常被分为两个部分，一个称为“dirty card”位图，用于标记引用变为非空；另一个称为“clean card”位图，用于标记引用变为空。</p><p>对象引用发生变化时，对应的卡片状态会发生改变。GC进行垃圾回收时会先扫描“dirty card”位图，找到与该位图相关的对象并对之进行检查，确保其准确性。</p><p>Card Table提供了一种增量标记的方式，即只对发生变化的卡片进行标记和处理，减少垃圾回收停顿时间，提供吞吐量。</p><p>Card Table只是垃圾回收机制的一部分，它与其它组件合作来实现高效垃圾回收。Card Table的实现会因不同的垃圾回收器而有所差异。</p><h5 id="Rememvered-Set"><a href="#Rememvered-Set" class="headerlink" title="Rememvered Set"></a>Rememvered Set</h5><p>Remembered Set是一种用于<em><strong>跟踪堆内存中对象应用的数据结构</strong></em>。<em><strong>与Card Table一起工作，帮助其准确地标记和回收垃圾对象</strong></em>。</p><p>Remembered Set的主要作用是<em><strong>记录老年代中对象对年轻代中对象的引用关系</strong></em>。</p><p>Remembered Set使用一种特殊的数据结构，通常是一个位图，或其它类似位图的结构。位图的每个位对应一个引用，用于标记引用是否存在。当对象引用发生变化时，对响应的位进行标记或清除。</p><p>Card Table会标记发生变化的卡片，而 Remembered Set会根据这些卡片信息来确定哪些引用需要被记录下来。</p><p>垃圾回收器执行垃圾回收时会先扫描Remembered Set中标记的引用，垃圾回收器会根据这些引用关系进行标记和处理，确保引用链的完整性和准确性。</p><h5 id="CMS中的使用"><a href="#CMS中的使用" class="headerlink" title="CMS中的使用"></a>CMS中的使用</h5><p>Card Table 在 CMS GC 中也有使用，使用一块区域用来记录老年代中的每个 Card 指向新生代的引用（<code>points-out</code> 结构），YGC执行时会将该区域的对象作为 GC roots，而不需要扫描整个老年代。</p><p>并发标记时，如果某个对象的引用发生了变化，那么标记该对象所在的 Card 为 Dirty Card（通过 write-barrier）。在重新标记时，只需要重新扫描 Dirty Cards 即可，同时【清除 Dirty 标记】。</p><h3 id="1-8-7、G1（JDK7）"><a href="#1-8-7、G1（JDK7）" class="headerlink" title="1.8.7、G1（JDK7）"></a>1.8.7、G1（JDK7）</h3><h4 id="1-8-7-1、简介"><a href="#1-8-7-1、简介" class="headerlink" title="1.8.7.1、简介"></a>1.8.7.1、简介</h4><p><em><strong>JDK 1.7u4中引入G1，JDK9中G1成为默认垃圾收集器，JDK12中增强了G1</strong></em>。</p><p>G1是一款服务器式垃圾回收器，适用于 大内存多处理器 的服务器。可以尽可能满足设定的垃圾回收暂定目标，同时提高吞吐量。</p><p>如果你的应用程序符合以下几点，那么使用G1将变得非常合适：</p><ul><li>超过50%的堆内存被实时数据占用。</li><li>对象分配率和晋升率有很大差异。</li></ul><p>G1有如下特点：</p><ol><li><strong>并发收集；</strong></li><li><strong>压缩空闲空间不会延长GC暂停时间</strong>；</li><li><strong>更易预测的GC暂停时间</strong>；</li><li><strong>适用于 低吞吐量 场景</strong>；</li></ol><h4 id="1-8-7-2、Region"><a href="#1-8-7-2、Region" class="headerlink" title="1.8.7.2、Region"></a>1.8.7.2、Region</h4><p><em><strong>G1 会把整个 Java 堆划分为不超过2048个大小独立的Region，每个 Region 大小要满足2的N次幂，范围在1MB-32MB 之间</strong></em>。Region的大小在 JVM 生命周期内不会被改变。</p><p>每一个Region在逻辑上属于某一个分代，该分代分为四种：</p><ol><li><strong>Eden区存放新对象</strong>；</li><li><strong>Survivor区放存活对象</strong>；</li><li><strong>old区存放老对象</strong>；</li><li><strong>Humongoous区存放大对象</strong>；（G1中通常会将H区作为老年代的一部分来看待。）</li></ol><blockquote><p>G1内存区域不是固定的E或O。G1新老年代比例动态变化无需显式指定，因为G1有预测停顿时间的基准。G1会跟踪每一次STW，据此动态设置各个Regin的大小。</p><p>一个对象大小超过了1个Region的一半则称该对象为大对象。如果一个H区无法容纳一个大对象，那么会使用连续的H区来存储这个大对象。为了能找到连续的H区，有时不得不执行Full GC。G1不会复制巨型对象，巨型对象没有被引用时会在YGC阶段被回收。</p></blockquote><h4 id="1-8-7-3、重要概念"><a href="#1-8-7-3、重要概念" class="headerlink" title="1.8.7.3、重要概念"></a>1.8.7.3、重要概念</h4><h5 id="RSet"><a href="#RSet" class="headerlink" title="RSet"></a>RSet</h5><p><em><strong>RSet是Remembered Set的缩写，意为记录集合。G1中的每个Region都有一个RSet，它是一个hash表（表中存储card table），记录了其它Region中的对象对本Region中对象的引用</strong></em>。</p><p>***RSet大小和Region数量有直接关系，一般来说 RSet 的大小占整个 Java 堆空间的1%~20%***。</p><blockquote><p>每次引用类型数据写操作时，会产生一个写屏障来中断当前操作。然后检查要写入的引用指向的对象与当前引用类型是否在不同的Regin中，如果确实在不同的Region，那么通过CardTable把相关引用信息记录到引用所指对象所在的Regin的RSet中。</p></blockquote><p><em><strong>G1中RSet使用的是point-in机制，而CMS使用的是point-out机制</strong></em>。</p><blockquote><p>point-in是指：哪些分区引用了当前分区中的对象，则仅仅将这些对象当做根来扫描就避免了无效的扫描。</p></blockquote><p>对于G1来说，当引用发生变化时赋值器会对引用做处理，引用较多时赋值器开销会很大，为解决开销大问题，G1 中又引入了卡表（Card Table）。</p><blockquote><p>当 Region 被引用较多时，RSet 占用空间会上升，因此为RSet 的存储划分了三种粒度：</p><ul><li><font color='orange'>稀疏表（Sparse）</font>：直接通过哈希表来存储，key 是 region index，value 是 card 数组（记录 card index）。</li><li><font color='orange'>细粒度（Fine）</font>：当一个 region 的 card 数量超过阈值时，退化为一个 bitmap，每一位对应一个card（index）。如果bit为0表示该bit对应的内存分段中没有引用，为1表示有引用。</li><li><font color='orange'>粗粒度（Coarse）</font>：当引用 region 数量超过阈值时，退化为只记录 regin 引用，由 bitmap 存储，每一位对应一个 region（index）。</li></ul><p>因为某些Region中的对象可能会被其它许多对象引用，为避免保存太多数据，故会以更大粒度保存引用，这种方式会减少RS数据，但会增加扫描和标记开销，因为需要扫描所有bit为1的内存分段中的对象以确定具体是来自哪个对象的引用。 </p></blockquote><h5 id="Card-Table-1"><a href="#Card-Table-1" class="headerlink" title="Card Table"></a>Card Table</h5><p>Card Table会将一个分区在逻辑上划分为多个固定大小的连续区域，每个区域称之为卡。卡通常较小，介于128到512字节之间，堆中每 512byte 映射 card table 1 byte。Card Table通常为字节数组，数组的索引（即数组下标）会用来标识每个卡的空间地址。当一个卡被引用时，该卡对应数组索引下的值会被标记为0，即标记为脏被引用，RSet会将该下标记录下来。<font color='orange'>RSet一般是一个Hash Table，Key是其它Region的起始地址，Value是一个集合，集合中存储的是Card Table的Index。</font></p><blockquote><p>JVM会对程序中的每一个引用赋值语句进行记录和处理，把引用关系更新到RS中。RS更新并非实时性，RS处理需要线程同步，开销会很大，所以为了性能需要，G1维护了一个Dirty Card Queue。对于引用赋值语句，JVM会在之前和之后执行特殊操作以在dirty card queue中加入一个保存了对象引用信息的card。YGC时G1会对Dirty Card Queue中所有的card进行处理并更新RS，以保证RS实时准确的反映引用关系。</p></blockquote><h5 id="CSet"><a href="#CSet" class="headerlink" title="CSet"></a>CSet</h5><p><font color='orange'>CSet意为回收集合，记录了需要回收的内存区域。</font></p><p><font color='orange'>一个CSet 中包含多少 Region 取决于有多少空间可以被释放、G1停顿目标时间这两个因素。</font>G1只关注是否有存活对象，如果没有，则无论你属于老年代，还是年轻代，你都会被回收井放入可用 Region 队列，下一次被分配到哪里是无法确定的。</p><p>CSet 包含了大量Region ，每个Region中有一个RSet。</p><h5 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h5><p><font color='orange'>TLAB是Thread Local Allocation Buffer的首字母，意为 线程本地分配缓冲。</font></p><p>堆内存是线程共享的，多个线程分配内存时需要加锁同步。为了避免加锁，提高性能，每一个线程会被分配一个私有TLAB。TLAB中的内存来自于G1年轻代中的内存分段。当对象是Humongous对象，TLAB也能装下的时候，对象会被优先分配在线程的TLAB中。因为TLAB属于线程，不需要加锁，效率高。</p><h5 id="PLAB"><a href="#PLAB" class="headerlink" title="PLAB"></a>PLAB</h5><p><font color='orange'>PLAB是Promotion Local Allocation Buffer的首字母，意为晋升本地分配缓冲。</font></p><p>G1是多线程并发回收，为避免多线程将对象向同一个内存分段拷贝，那么复制过程也需加锁。为避免加锁，G1的每个线程都关联一个PLAB，这样就不需要进行加锁了。</p><p>多线程环境下最好使用<code>-XX:-ResizePLAB</code>来关闭PLAB大小的自动调整功能，避免大量线程通信导致的性能下降。</p><h5 id="SATB"><a href="#SATB" class="headerlink" title="SATB"></a>SATB</h5><p><font color='orange'>SATB是Snapshot At The Beginning的首字母，意为开始时快照。</font></p><h4 id="1-8-7-4、GC回收过程"><a href="#1-8-7-4、GC回收过程" class="headerlink" title="1.8.7.4、GC回收过程"></a>1.8.7.4、GC回收过程</h4><p>G1垃圾回收过程图示如下：</p><p><img src="/%5Cimgs%5Cjavadev%5C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-1.1-G1-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.png"></p><h5 id="YGC阶段（标记复制-STW）"><a href="#YGC阶段（标记复制-STW）" class="headerlink" title="YGC阶段（标记复制 &#x2F; STW）"></a>YGC阶段（标记复制 &#x2F; STW）</h5><p>对象被创建后首先放到Eden区，<font color='orange'>当所有Eden区都满了，G1会启动一次年轻代垃圾回收</font>：首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），将要被回收的内存放到回收集中，然后执行回收操作。</p><p><font color='red'>注意</font>：YGC只会回收Eden区和Survivor区。回收集是指需要被回收的内存分段的集合，年轻代回收集 包含年轻代Eden区和Survivor区所有的内存分段。</p><p>年轻代回收过程如下：</p><ol><li><font color='orange'>根扫描</font>：根指的是静态变量指向的对象，正在执行的方法链条上的局部变量等。根引用和RSet记录的外部引用将作为扫描存活对象的入口。</li><li><font color='orange'>更新RS</font>：处理Dirty Card队列，更新RS。（RS可以反映老年代中的对象对年轻代对象的引用）</li><li><font color='orange'>处理RS</font>：识别老年代对象对Eden区中对象的引用，被指向的Eden区对象都被认为是存活对象。</li><li><font color='orange'>对象拷贝</font>：将Eden中的存活对象复制到survivor中，Survivor中存活对象年龄未达阈值则将年龄加1，达到阈值则复制到老年代中。如果Survivor空间不足，Eden中部分数据会直接晋升至老年代。</li><li><font color='orange'>处理引用</font>：处理软引用，弱引用，虚引用、Final等引用。最终Eden中空间为空，GC停止，目标内存中对象连续，没有内存碎片，所以复制过程可以达到整理内存的效果。</li></ol><h5 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h5><p><font color='orange'>年轻代回收后或 houmongous对象 分配后会检测当前堆内存使用情况，当堆内存（包括老年代和新生代）使用率达到参数<code>-XX:InitiatingHeapOccupancyPercent</code>（默认是45%）设置的百分比时会触发老年代回收。</font></p><p>老年代回收包含 <font color='orange'>标记老年代内对象是否存活的过程</font>，标记过程和应用程序并发运行（不需要Stop-The-World），所以应用程序会改变指针指向，进而导致对象丢失。G1处理对象丢失的方法是使用【开始时快照技术（SATB，Snapshot At The Begging）】，这种技术会造成 某些垃圾对象也被当做是存活对象，所以G1会使得占用的内存比实际需要的内存大。</p><p>并发标记过程如下：</p><ol><li><p><font color='orange'>初始标记（STW）</font><br>标记从根节点直接可达的对象。该阶段存在STW，且会触发一次YGC。</p></li><li><p><font color='orange'>根区域扫描</font><br>扫描Survivor区直接可达的老年代对象，并标记被引用的对象。该过程必须在YGC之前完成。</p></li><li><p><font color='orange'>并发标记</font><br>在整个堆中进行并发标记（可与应用程序并发执行），该过程可能被YGC中断。并发标记阶段，若区域中的对象都是垃圾，那么这个区域会被立即回收。同时，会计算每个区域对象的活性（区域中存活对象的比例）。</p></li><li><p><font color='orange'>再次标记（STW）</font><br>由于并发标记阶段是GC和应用程序同时执行，可能存在漏标情况，所以需要执行STW式的再次标记。G1中采用了SATB（开始时快照技术）算法。</p></li><li><p><font color='orange'>独占清除（STW）</font><br>计算各个区域存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。该阶段不会做垃圾收集。</p></li><li><p><font color='orange'>并发清理</font></p><p>识别并清理完全空闲的区域。</p></li></ol><h5 id="混合回收（Mixed-GC）"><a href="#混合回收（Mixed-GC）" class="headerlink" title="混合回收（Mixed GC）"></a>混合回收（Mixed GC）</h5><p><font color='orange'>越来越多的对象晋升到老年代Regin后，为避免堆内存被耗尽，会触发一次混合回收（Mixed GC）。</font>该算法并非是Old GC，除了回收【整个】年轻代Regin，还会回收【一部分】老年代Regin。选择收集不同的老年代Regin（并发标记阶段中的独占清理阶段已经排序过了），可以一定程度上控制垃圾回收的消耗时间。</p><p>并发标记结束以后，老年代中百分百为垃圾的内存被回收了，部分为垃圾的内存也计算了出来。</p><ul><li><font color='orange'>-XX:G1MixedGCCountTarget</font>：该参数表示 老年代内存分段会分多少次来回收，默认8次。</li><li><font color='orange'>-XX:G1MixedGCLiveThresholdPercent</font>：表示垃圾占内存分段比例要达到该参数值设定的百分比时才会被回收，默认为65%。垃圾占内存分段比例越高的，越优先被回收。老年代、Eden、Survivor from区中要被回收的内存分段合起来称为Collection Set，也即 回收集合。混合回收回收集（Collection Set）包括八分之一的老年代内存分段、Eden区内存分段、Survivor区内存分段，下次mixed GC 的evacuation阶段会把他们都一并清理。混合回收的算法和年轻代完全一样，只是回收集多了老年代的内存分段。混合回收并不一定要进行8次。具体执行逻辑与参数-XX:G1HeapWastePercent有关，详情如下。</li><li><font color='orange'>-XX:G1HeapWastePercent</font>：默认为10%，表示允许浪费整个堆内存10%的空间。也就是说 若垃圾占堆内存的比例低于10%，就不再执行混合回收，因为性价比很低。</li></ul><p><font color='red'>注意：Mixed GC 并不是 Full GC。G1 GC回收足够数量的老年代区域 (通过多次混合回收) 后，G1将恢复到年轻代回收、全局并发标记、混合回收，以此逻辑循环执行。</font></p><h5 id="FGC"><a href="#FGC" class="headerlink" title="FGC"></a>FGC</h5><p>G1初衷是避免Full GC出现，但如果上述方式不能正常工作时会停止应用程序，使用单线程Serial收集器来完成垃圾清理工作，性能会非常差。</p><p>导致Full GC的原因有两个：</p><ul><li><em><strong>Evacuation时没有足够的to-space来存放晋升对象</strong></em>。</li><li><em><strong>并发处理过程完成之前空间耗尽</strong></em>。</li></ul><h4 id="1-8-7-5、三色标记算法"><a href="#1-8-7-5、三色标记算法" class="headerlink" title="1.8.7.5、三色标记算法"></a>1.8.7.5、三色标记算法</h4><p>并发标记使用的是三色标记算法。它是描述追踪式回收器的一种有效方法，利用它可以推演回收器的正确性。 三色标记会将对象分成三种类型：</p><ul><li><strong>黑色</strong>：根对象，或者该对象与它的子对象都被扫描过。</li><li><strong>灰色</strong>：对象本身已被扫描过，但还没扫描完该对象的子对象。</li><li><strong>白色</strong>：未扫描过的对象，扫描完所有对象之后，最终为白色的就是不可达对象，即为垃圾对象。</li></ul><h4 id="1-8-7-8、G1优化"><a href="#1-8-7-8、G1优化" class="headerlink" title="1.8.7.8、G1优化"></a>1.8.7.8、G1优化</h4><p>优化和注意事项分析如下：</p><ul><li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小。固定年轻代大小会覆盖暂停时间目标。</li><li>评估G1 GC吞吐量时，暂停时间目标不需要太严格，否则会直接影响吞吐量。</li></ul><h4 id="1-8-7-9、参数"><a href="#1-8-7-9、参数" class="headerlink" title="1.8.7.9、参数"></a>1.8.7.9、参数</h4><ul><li>-XX:+UseG1GC：使用G1垃圾回收器。</li><li>-XX:G1HeapRegionSize：每个Region的大小。值是2的幂，范围1m~32m之间。目标是根据最小Java堆大小划分处约2048个区域，默认是堆内存的1&#x2F;2000。</li><li>-XX:MaxGCPauseMillis：最大GC停顿时间指标。默认200ms。</li><li>-XX:ParallelGCThread：STW工作线程的数量，最多8个。</li><li>-XX:ConcGCThreads：并发标记的线程数量。建议该值为并行垃圾回收线程数量(ParallelGCThreads)的1&#x2F;4左右。</li><li>-XX:InitiatingHeapOccupancyPercent：触发并发GC周期的堆占用率阈值。默认是45。</li></ul><h3 id="1-8-8、ZGC-（JDK11）"><a href="#1-8-8、ZGC-（JDK11）" class="headerlink" title="1.8.8、ZGC （JDK11）"></a>1.8.8、ZGC （JDK11）</h3><h4 id="1-8-8-1、简介"><a href="#1-8-8-1、简介" class="headerlink" title="1.8.8.1、简介"></a>1.8.8.1、简介</h4><p><font color='orange'>ZGC是JDK11中 新加入的 具有实验性质的低延迟垃圾收集器，目前仅支持Linux&#x2F;x86-64。ZGC收集器是一款基于Region内存布局，（暂时）不设分代，使用读屏障、染色指针和内存多重映射等技术来实现可并发的标记整理算法，首要目标是实现低延迟。</font></p><blockquote><p>JDK11中引入ZGC，JDK13中增强ZGC。</p></blockquote><h4 id="1-8-8-2、内存布局"><a href="#1-8-8-2、内存布局" class="headerlink" title="1.8.8.2、内存布局"></a>1.8.8.2、内存布局</h4><p>与Shenandoah和G1一样，ZGC也采取基于Region的堆内存布局，但是ZGC的Region具有动态性（动态的创建和销毁，以及动态的区域容量大小）。</p><p>ZGC的Region可以分为三类：</p><ul><li><font color='orange'>小型Region</font>：容量固定为2MB，用于放置小于256KB的小对象。</li><li><font color='orange'>中型Region</font>：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。</li><li><font color='orange'>大型Region</font>：容量不固定，可以动态变化，但必须为2MB的整数倍，用于存放4MB或以上的大对象。并且每个大型Region只会存放一个对象。</li></ul><h4 id="1-8-8-3、染色指针"><a href="#1-8-8-3、染色指针" class="headerlink" title="1.8.8.3、染色指针"></a>1.8.8.3、染色指针</h4><h5 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h5><p>HotSpot的垃圾收集器，有几种不同的标记实现方案。</p><ul><li>把标记直接记录在对象头上（Serial 收集器）。</li><li>把标记记录在于对象相互独立的数据结构上（G1、Shenandoah使用了一种相当于堆内存的1&#x2F;64大小的BitMap结构来记录标记信息）。</li><li>ZGC染色指针直接把标记信息记录到引用对象的指针上。</li></ul><p>染色指针是一种直接<em><strong>将少量额外信息存储在指针上的技术</strong></em>。目前Linux下64位指针的高18位不能用来寻址，但剩余的46位指针所能支持的4TB内存仍然可以满足需要。</p><p><img src="/%5Cimgs%5Cjavadev%5CZGC%E9%A2%9C%E8%89%B2%E6%8C%87%E9%92%8801.png"></p><p>ZGC将使用剩下46位的高4位来存储四个标志信息：</p><ol><li><font color='orange'>Finalizable</font>：是否只能通过finalize()方法才能被访问到。</li><li><font color='orange'>Remapped</font>：是否进入了重分配集。</li><li><font color='orange'>Marked0</font>：通过这些标志虚拟机就可以直接从指针中看到引用对象的三色标记状态。</li><li><font color='orange'>Marked1</font>：同3。</li></ol><p><font color='red'>注意：由于这些标志位占用4位，故剩余42位空间（4TB），所以ZGC能够管理的内存不能超过4TB。</font></p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>染色指针可以使得一旦某个Region的存活对象被移走之后，该Region会立即被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。</li><li>染色指针可以减少在垃圾收集过程中内存屏障的使用数量。因为读、写内存屏障的主要目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。</li><li>染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</li></ul><h4 id="1-8-8-4、读屏障"><a href="#1-8-8-4、读屏障" class="headerlink" title="1.8.8.4、读屏障"></a>1.8.8.4、读屏障</h4><p><em><strong>当从堆中加载对象时，就会使用读屏障（Load Barrier）</strong></em>。读屏障的主要作用就是<em><strong>检查指针上的三色标记位，根据标记位判断出对象是否被移动过，如果没有则可以直接访问，如果移动过就需要进行“自愈”</strong></em>。自愈会使对象访问变慢，但“自愈”完成后访问就不会变慢了。</p><blockquote><p>当读取处于重分配集的对象时，会被读屏障拦截，通过 转发表记录 将访问转发到新复制对象上，并同时修正更新该引用的值，使其直接指向新对象。ZGC将这种行为叫做指针的“自愈能力”。</p></blockquote><h4 id="1-8-8-5、内存多重映射"><a href="#1-8-8-5、内存多重映射" class="headerlink" title="1.8.8.5、内存多重映射"></a>1.8.8.5、内存多重映射</h4><h5 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h5><p>Linux&#x2F;x86-64平台上ZGC使用了多重映射（Multi-Mapping）将多个不同的虚拟内存地址映射到同一物理内存地址上，这是一种多对一映射，意味着ZGC在虚拟内存中看到的地址空间要比实际的堆内存容量更大。把染色指针中的标志位看作是地址的分段符，那只要将这些不同的地址段都映射到同一物理内存空间，经过多重映射转换后，就可以使用染色指针进行正常寻址。</p><p><img src="/%5Cimgs%5Cjavadev%5CZGC%E5%86%85%E5%AD%98%E5%A4%9A%E9%87%8D%E6%98%A0%E5%B0%8401.png"></p><h4 id="1-8-8-6、ZGC工作过程"><a href="#1-8-8-6、ZGC工作过程" class="headerlink" title="1.8.8.6、ZGC工作过程"></a>1.8.8.6、ZGC工作过程</h4><p>ZGC工作过程大致可划分为以下四个阶段。四个阶段都可以并发执行，仅是两个阶段中间会存在短暂的小阶段停顿。</p><p><img src="/%5Cimgs%5Cjavadev%5CZGC%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B01" alt="ZGC运行过程"></p><ol><li><font color='orange'>并发标记（Concurrent Mark）</font>：与G1、Shenandoah一样，并发标记是遍历对象图做可达性分析的阶段，前后也要经过类似于G1、Shenandoah的初始标记、最终标记的短暂停顿，而且这些停顿阶段所做的事情在目标上也是类似的。</li><li><font color='orange'>并发预备重分配（ Concurrent Prepare for Relocate）</font>：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。</li><li><font color='orange'>并发重分配（Concurrent Relocate）</font>：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table）,记录从旧对象到新对象的转向关系。</li><li><font color='orange'>并发重映射（Concurrent Remap）</font>：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，ZGC的并发映射并不是以一个必须要“迫切”去完成的任务。ZGC很巧妙地把并发重映射阶段要做的工作，合并到下一次垃圾收集循环中的并发标记阶段里去完成，反正他们都是要遍历所有对象的，这样合并节省了一次遍历的开销。</li></ol><h4 id="1-8-8-7、ZGC优缺点"><a href="#1-8-8-7、ZGC优缺点" class="headerlink" title="1.8.8.7、ZGC优缺点"></a>1.8.8.7、ZGC优缺点</h4><h5 id="优点（高吞吐量、低延迟）"><a href="#优点（高吞吐量、低延迟）" class="headerlink" title="优点（高吞吐量、低延迟）"></a>优点（高吞吐量、低延迟）</h5><p>ZGC是支持<code>NUMA-Aware</code>的内存分配。MUMA（Non-Uniform Memory Access，非统一内存访问架构）是一种多处理器或多核处理器计算机所设计的内存架构。</p><p>现在多CPU插槽的服务器都是Numa架构，比如两颗CPU插槽(24核)，64G内存的服务器，那一颗CPU 12个核，访问从属于它的32G本地内存，要比访问另外32G远端内存要快得多。</p><p>ZGC默认支持NUMA架构，在创建对象时，根据当前线程在哪个CPU执行，优先在靠近这个CPU的内存进行分配，这样可以显著的提高性能，在SPEC JBB 2005 基准测试里获得40%的提升。</p><h5 id="缺点（浮动垃圾）"><a href="#缺点（浮动垃圾）" class="headerlink" title="缺点（浮动垃圾）"></a>缺点（浮动垃圾）</h5><p>当ZGC准备要对一个很大的堆做一次完整的并发收集，则全过程要持续十分钟以上，由于应用的对象分配速率很高，将创造大量的新对象，这些新对象很难进入当次收集的标记范围，通常就只能全部作为存活对象来看待（尽管其中绝大部分对象都是朝生夕灭），这就产生了大量的浮动垃圾。</p><p>目前唯一的办法就是尽可能地去增加堆容量大小，获取更多喘息的时间。但若要从根本上解决，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后针对这个区域进行更频繁、更快的收集。</p><h3 id="1-8-9、Epsilon（JDK11）"><a href="#1-8-9、Epsilon（JDK11）" class="headerlink" title="1.8.9、Epsilon（JDK11）"></a>1.8.9、Epsilon（JDK11）</h3><h4 id="1-8-9-1、简介"><a href="#1-8-9-1、简介" class="headerlink" title="1.8.9.1、简介"></a>1.8.9.1、简介</h4><p>JDK 11中的JEP 318添加了一个名为Epsilon的垃圾回收器实现。Epsilon（A No-Op Garbage Collector）的特点是只负责分配内存，而不做任何垃圾回收操作。当堆内存空闲空间不足时会自动触发与<code>OutOfMemoryError</code>相关的处理。</p><blockquote><p>JDK11引入Epsilon。</p></blockquote><h4 id="1-8-9-2、目标"><a href="#1-8-9-2、目标" class="headerlink" title="1.8.9.2、目标"></a>1.8.9.2、目标</h4><p>设计的目的是提供一个完全消极的GC实现，执行有限内存分配，最大限度降低内存占用量和内存吞吐时的延迟时间。一个好的实现是隔离代码变化，不影响其他GC，最小限度的改变其他的JVM代码。</p><h4 id="1-8-9-3、使用场景"><a href="#1-8-9-3、使用场景" class="headerlink" title="1.8.9.3、使用场景"></a>1.8.9.3、使用场景</h4><ul><li><font color='orange'>Performance testing</font>：什么都不执行的GC非常适合用于差异性分析。no-op GC可以用于过滤掉GC诱发的新能损耗，比如GC线程的调度，GC屏障的消耗，GC周期的不合适触发，内存位置变化等。此外有些延迟者不是由于GC引起的，比如scheduling hiccups, compiler transition hiccups，所以去除GC引发的延迟有助于统计这些延迟。</li><li><font color='orange'>Memory pressure testing</font>：在测试java代码时，确定分配内存的阈值有助于设置内存压力常量值。这时no-op就很有用，它可以简单地接受一个分配的内存分配上限，当内存超限时就失败。例如：测试需要分配小于1G的内存，就使用-Xmx1g参数来配置no-op GC，然后当内存耗尽的时候就直接crash。</li><li><font color='orange'>VM interface testing</font>：以VM开发视角，有一个简单的GC实现，有助于理解VM-GC的最小接口实现。它也用于证明VM-GC接口的健全性。</li><li><font color='orange'>Extremely short lived jobs</font>： 一个短声明周期的工作可能会依赖快速退出来释放资源，这个时候接收GC周期来清理heap其实是在浪费时间，因为heap会在退出时清理。并且GC周期可能会占用一会时间，因为它依赖heap上的数据量。</li><li><font color='orange'>Last-drop latency improvements</font>：对那些极端延迟敏感的应用，开发者十分清楚内存占用，或者是几乎没有垃圾回收的应用，此时耗时较长的GC周期将会是一件坏事。</li><li><font color='orange'>Last-drop throughput improvements</font>：即便对那些无需内存分配的工作，选择一个GC意味着选择了一系列的GC屏障，所有的OpenJDK GC都是分代的，所以他们至少会有一个写屏障。避免这些屏障可以带来一点点的吞吐量提升。</li></ul><h4 id="1-8-9-4、相关描述"><a href="#1-8-9-4、相关描述" class="headerlink" title="1.8.9.4、相关描述"></a>1.8.9.4、相关描述</h4><p>通过参数<code>-XX:+UseEpsilonGC</code>可以开启Epsilon GC。</p><p>Epsilon GC通过在分配内存的单个连续块中实现线性分配来工作。这样就可以在GC中轻松实现无锁TLAB（线程本地分配缓冲区）发行代码，然后可以重用现有VM代码处理的无锁TLAB内部分配。发出TLAB还有助于使驻留内存占用的进程受实际分配的内存限制。大量&#x2F;超出TLAB的分配由同一代码处理，因为在此方案中分配TLAB与分配大对象之间几乎没有区别。</p><p>Epsilon使用的障碍集完全为空&#x2F;无操作，因为GC不执行任何GC循环，因此不关心对象图，对象标记，对象复制等。引入一种新的障碍集实现是可能是此实现中最具破坏性的JVM更改。</p><p>由于Epsilon的运行时接口的唯一重要部分是发布TLAB的时间，因此其延迟很大程度上取决于所发布的TLAB的大小。对于任意大的TLAB和任意大的堆，延迟开销可以由任意低的正值（因此称为名称）来描述。（替代起源故事：“ epsilon”通常表示“空符号”，与该GC的禁止操作性保持一致）。</p><p>Java堆耗尽就不可能进行分配，也不能进行内存回收。此时有几种选择：</p><ul><li>抛出一条带有描述性信息的<code>OutOfMemoryError</code>异常消息。</li><li>执行堆转储（启用<code>-XX:+HeapDumpOnOutOfMemoryError</code>）</li><li>关闭JVM，并有选择地执行外部操作（通常操作<code>-XX:OnOutOfMemoryError=...</code>），例如，启动调试器或向外部监视系统通知该失败。</li></ul><h3 id="1-8-10、Shenandoah"><a href="#1-8-10、Shenandoah" class="headerlink" title="1.8.10、Shenandoah"></a>1.8.10、Shenandoah</h3><p>待补充。</p><h3 id="1-8-11、总结"><a href="#1-8-11、总结" class="headerlink" title="1.8.11、总结"></a>1.8.11、总结</h3><h4 id="1-8-11-1、垃圾收集器对比"><a href="#1-8-11-1、垃圾收集器对比" class="headerlink" title="1.8.11.1、垃圾收集器对比"></a>1.8.11.1、垃圾收集器对比</h4><p><img src="/%5Cimgs%5Cjavadev%5C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-1.2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93.png"></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210315120311771.png" alt="image-20210315120311771"></p><h4 id="1-8-11-2、ZGC-vs-Shenandoah"><a href="#1-8-11-2、ZGC-vs-Shenandoah" class="headerlink" title="1.8.11.2、ZGC vs Shenandoah"></a>1.8.11.2、ZGC vs Shenandoah</h4><p><font color='orange'>前者用的是三色标记，后者用的是染色指针。</font></p><h4 id="1-8-11-3、三色标记-颜色指针"><a href="#1-8-11-3、三色标记-颜色指针" class="headerlink" title="1.8.11.3、三色标记 &#x2F; 颜色指针"></a>1.8.11.3、三色标记 &#x2F; 颜色指针</h4><ul><li><p><strong>三色标记</strong></p><p>把对象分为三个颜色，不同的颜色代表是否被标记过，还是标记了一半，还是没有标记。</p></li><li><p><strong>染色指针</strong></p><p>染色指针是一种直接将少量额外信息存储到指针上的技术。目前Linux下64位指针的高18位不能用来寻址，但剩余的46位指针所能支持的4TB内存仍然可以满足需要。故，拿出剩下的46位中高4位来记录不同的状态信息。</p></li></ul><h4 id="1-8-11-4、Remark阶段的算法"><a href="#1-8-11-4、Remark阶段的算法" class="headerlink" title="1.8.11.4、Remark阶段的算法"></a>1.8.11.4、Remark阶段的算法</h4><p>CMS和G1中用的是同一个算法，该算法叫三色标记：</p><ol><li><strong>黑</strong>：自己和所引用的对象都标记完了。</li><li><strong>灰</strong>：自己标记完了，但所引用的其它对象还没有标记。</li><li><strong>白</strong>：自己和引用的对象都还没有标记。</li></ol><h2 id="1-9、漏标问题"><a href="#1-9、漏标问题" class="headerlink" title="1.9、漏标问题"></a>1.9、漏标问题</h2><h3 id="1-9-1、认识漏标"><a href="#1-9-1、认识漏标" class="headerlink" title="1.9.1、认识漏标"></a>1.9.1、认识漏标</h3><p>CMS和G1的核心就是并发标记的线程和工作线程同时进行，而该阶段会产生“漏标”问题。</p><p>问题：<strong>GC标记阶段中如果删除了所有灰色到白色的引用，且黑色指向了白色，则此时若不对黑色对象的子对象进行重新扫描，就会出现漏标现象，会把白色对象当作垃圾被回收</strong>。</p><h3 id="1-9-2、解决漏标"><a href="#1-9-2、解决漏标" class="headerlink" title="1.9.2、解决漏标"></a>1.9.2、解决漏标</h3><ol><li><p><strong>增量更新（Increment Update）</strong></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210314213906184.png" alt="image-20210314213906184"></p><p>如上图所示，若A指向D时，跟踪这个引用，并把A标记为灰色，这样下次扫描的时就会重新扫描A的子对象D，这就叫做增量更新。</p><p>特点：<em><strong>当产生新标记后，关注引用的增加，CMS采用 增量更新+写屏障 解决了漏标问题</strong></em>。</p></li><li><p><strong>SATB（snapshot at the beginning）</strong></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210314214048813.png" alt="image-20210314214048813"></p><p>如上图所示，刚开始做一个快照，当B和D之间的引用消失时要把这个引用推到GC的堆栈，保证D能够被扫描到。如果某一个引用消失了，我会把白色对象放到GC的堆栈中，下次扫描时直接扫描白色对象即可，这样白色就不会漏标了。</p><p>SATB有三个工作步骤：</p><ol><li>在开始标记时生成一个快照图，用来标记存活对象。</li><li>在并发标记时所有被改变的对象将会被加入到队列（在write barrier里把所有旧的引用所指向的对象都变成非白的）。</li><li>可能存在游离垃圾，将在下次被收集。</li></ol><p>特点：<em><strong>当引用被删除后，关注引用的删除，G1用 SATB+写屏障 解决了漏标问题</strong></em>。</p><blockquote><p>SATB 算法通过创建一个对象图的方式完成堆内存逻辑上的快照，即将堆内存里所有需要回收的对象全部呈现在它的这张对象图上，这个标记过程在并行标记阶段完成 。</p><p>SATB 算法维护的标记内容在数据结构上也分为两块， 一块是已经完成的标记，另一块是即将进行的标记。</p></blockquote></li></ol><h3 id="1-9-3、总结"><a href="#1-9-3、总结" class="headerlink" title="1.9.3、总结"></a>1.9.3、总结</h3><p>灰色指向白色的引用消失时，如果没有黑色指向白色，则该引用会直接被push到堆栈，下次扫描时拿到这个引用，由于RSet的存在，不需要扫描整个堆去查找指向白色的引用，效率比较高。SATB配合RSet浑然天成。</p><blockquote><p>G1为什么使用SATB，而不使用incremental update？因为变成灰色后还要重新扫描，效率太低了。</p></blockquote><h1 id="2、JVM参数"><a href="#2、JVM参数" class="headerlink" title="2、JVM参数"></a>2、JVM参数</h1><h2 id="2-1、简介"><a href="#2-1、简介" class="headerlink" title="2.1、简介"></a>2.1、简介</h2><h3 id="2-1-1、参数分类"><a href="#2-1-1、参数分类" class="headerlink" title="2.1.1、参数分类"></a>2.1.1、参数分类</h3><ul><li><p><strong>-开头</strong>：标准类型，所有HotSpot都支持。</p></li><li><p><strong>-X开头</strong>：非标准类型，特定版本才支持。</p></li><li><p><strong>-XX开头</strong>：不稳定，下个版本可能取消。</p><ol><li><p><strong>Boolean类型参数</strong></p><p>-XX:+&#x2F;- 某个属性值（+表示开启，-表示关闭）。</p></li><li><p><strong>K-V类型参数</strong></p><p>-XX: key（属性）&#x3D; value（属性值）</p></li><li><p><strong>jinfo查看当前运行时配置项</strong></p><p>jinfo -flag 配置项 进程号</p></li></ol></li></ul><blockquote><p>如何解释-Xms和-Xmx参数属于-XX参数？</p><p>-Xms &#x3D; -XX:InitialHeapSize  &#x2F;   -Xmx &#x3D; -XX:MaxHeapSize</p></blockquote><h3 id="2-1-2、查看参数值"><a href="#2-1-2、查看参数值" class="headerlink" title="2.1.2、查看参数值"></a>2.1.2、查看参数值</h3><h4 id="查看方式"><a href="#查看方式" class="headerlink" title="查看方式"></a>查看方式</h4><ol><li><p>查看java进程相关参数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jinfo <span class="token parameter variable">-flag</span> 参数项 进程号jinfo <span class="token parameter variable">-flags</span> 进程号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查看默认值和最终值</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> <span class="token parameter variable">-XX:+PrintFlagsInitial</span>   <span class="token comment"># 查看jvm未更改的默认参数</span><span class="token function">java</span> <span class="token parameter variable">-XX:+PrintFlagsFinal</span>     <span class="token comment"># 查看jvm已经更改过的参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也可以在运行java命令的同时加入打印jvm参数，如：<code>java -XX:+PrintFlagsFinal UpdateJVMParamDemo</code></p><p><font color="red">注意：<code>:=</code>表示jvm启动时修改过的参数。<code>=</code>表示jvm没有更改过的默认参数。</font></p></li><li><p>打印命令行参数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> <span class="token parameter variable">-XX:+PrintCommandLineFlags</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看可以被修改的参数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> <span class="token parameter variable">-XX:+PrintFlagsFinal</span> <span class="token parameter variable">-version</span> <span class="token operator">|</span> <span class="token function">grep</span> manageable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="2-2、系统优化参数"><a href="#2-2、系统优化参数" class="headerlink" title="2.2、系统优化参数"></a>2.2、系统优化参数</h2><ul><li><strong>-XX:-UseCompressedOops</strong>：禁用压缩指针。默认启用，当 Java 堆内存小于 32 GB 时将使用压缩指针。启用此选项后，对象引用表示为 32 位偏移量而不是 64 位指针。此选项仅适用于 64 位 JVM。当 Java 堆内存大于 32GB 时，也可以使用压缩指针。查看<code>-XX:ObjectAlignmentInBytes</code>选项。 </li><li><strong>-XX:+Inline</strong>：启用方法内联。默认开启。要禁用方法内联，请指定<code>-XX:-Inline</code>。</li><li><strong>-XX:InlineSmallCode&#x3D;大小</strong>：设置触发内联功能的已编译方法的代码大小（以字节为单位）。只有已编译代码小于指定大小时才会被内联。默认最大代码大小设置为 1000 字节：-XX:InlineSmallCode&#x3D;1000。</li><li><strong>-XX:MaxInlineSize&#x3D;大小</strong>：设置要内联的方法的最大字节码大小（以字节为单位）。默认最大字节码大小为 35 个字节：<code>-XX:MaxInlineSize=35</code>。</li><li><strong>-XX:MaxTrivialSize&#x3D;大小</strong>：设置要内联的普通方法的最大字节码大小（以字节为单位）。默认普通方法的最大字节码大小为 6 个字节：<code>-XX:MaxTrivialSize=6</code>。</li><li><strong>-XX:+PrintInlining</strong>：启用内联决策打印，可以查看哪些方法正在被内联。默认禁用且不打印内联信息。参数<code>-XX:+PrintInlining</code>必须与参数<code>-XX:+UnlockDiagnosticVMOptions</code>一起使用。</li><li><strong>-XX:+OptimizeStringConcat</strong>：启用<code>String</code>连接优化。默认启用。要禁用<code>String</code>串联优化，请指定<code>-XX:-OptimizeStringConcat</code>。只有 Java HotSpot Server VM 支持此选项。</li><li><strong>-XX:+UseStringDeduplication</strong>：启用字符串重复数据删除。默认禁用。要想启用该功能就必须启用G1 垃圾收集器。</li></ul><h2 id="2-3、类加载参数"><a href="#2-3、类加载参数" class="headerlink" title="2.3、类加载参数"></a>2.3、类加载参数</h2><ul><li><p><strong>-XX:+TraceClassLoading</strong>：启用类加载跟踪。</p></li><li><p><strong>-XX:+TraceClassLoadingPreorder</strong>：启用按引用顺序跟踪所有加载类。默认禁用且不跟踪。</p></li><li><p><strong>-XX:+TraceClassUnloading</strong>：启用类卸载跟踪。默认禁用且不跟踪。</p></li><li><p><strong>-XX:CICompilerCount&#x3D;线程</strong>：设置用于编译的编译器线程数。默认线程数为 2，客户端线程数为 1，如果使用分层编译，它会扩展到内核数。</p></li><li><p><strong>-XX:CodeCacheMinimumFreeSpace&#x3D;大小</strong>：编译所需最小空间（以字节为单位）。当剩余空间小于最小可用空间时将停止编译。默认空间大小为 500 KB。</p></li><li><p><strong>-XX:CompileOnly&#x3D;方法</strong>：设置限制编译的方法列表（以逗号分隔）。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-XX:CompileOnly</span><span class="token operator">=</span>java/lang/String.length,java/util/List.size<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>-XX:CompileThreshold&#x3D;调用</strong>：设置 编译前解释方法次数。默认情况下，在服务器 JVM 中，JIT 编译器执行 10,000 次解释方法调用来收集信息以进行高效编译。对于客户端 JVM，默认为 1,500 次调用。启用分层编译时将忽略此选项；见选项<code>-XX:+TieredCompilation</code>。</p></li><li><p><strong>-XX:+BackgroundCompilation</strong>：启用后台编译。默认启用。要禁用后台编译，请指定<code>-XX:-BackgroundCompilation</code>（这等效于指定<code>-Xbatch</code>）。</p></li><li><p><strong>-XX:MaxNodeLimit&#x3D;节点</strong>：设置单个方法编译期间要使用的最大节点数。默认情况下，最大节点数设置为 65,000：<code>-XX:MaxNodeLimit=65000</code>。</p></li><li><p><strong>-XX:+PrintCompilation</strong>：通过在每次编译方法时将消息打印到控制台来启用来自 JVM 的详细诊断输出。这可以查看实际编译了哪些方法。默认禁用该功能且不打印诊断输出。同时可以通过指定参数<code>-XX:+LogCompilation</code>将编译活动记录到文件中。</p></li><li><p><strong>-XX:ReservedCodeCacheSize&#x3D;大小</strong>：设置 JIT 编译代码的最大代码缓存大小（以字节为单位）。默认最大代码缓存为 240 MB；如果指定参数<code>-XX:-TieredCompilation</code>禁用了分层编译，则默认大小为 48 MB。该参数最大限制为 2 GB，否则报错。最大代码缓存不应小于初始代码缓存；见选项<code>-XX:InitialCodeCacheSize</code>。此选项等效于<code>-Xmaxjitcodesize</code>。</p></li><li><p><strong>-XX:-TieredCompilation</strong>：禁用分层编译。默认启用。只有 Java HotSpot Server VM 支持此选项。</p></li></ul><h2 id="2-4、运行时数据区参数"><a href="#2-4、运行时数据区参数" class="headerlink" title="2.4、运行时数据区参数"></a>2.4、运行时数据区参数</h2><h3 id="2-4-1、堆（Heap）"><a href="#2-4-1、堆（Heap）" class="headerlink" title="2.4.1、堆（Heap）"></a>2.4.1、堆（Heap）</h3><h4 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h4><ul><li><strong>-Xms &#x2F; -XX:InitialHeapSize&#x3D;大小</strong>：堆内存最小值和初始大小。此值必须是 1024 的倍数且大于 1 MB。</li><li><strong>-Xmx &#x2F; -XX:MaxHeapSize&#x3D;大小</strong>：堆内存最大值（以字节为单位）。此值必须是 1024 的倍数且大于 2 MB。通常将<code>-Xms</code>并<code>-Xmx</code>设为相同值。</li><li><strong>-XX:+AggressiveHeap</strong>：启用 Java 堆优化。根据计算机配置（RAM 和 CPU）自动设置合适的参数值。默认禁用。</li><li><strong>-XX:NewRatio&#x3D;比率</strong>：设置年轻代和年老代大小比例。默认为 2。</li><li><strong>-XX:+UseAdaptiveSizePolicy</strong>：启用自适应大小调整。默认启用。要禁用请指定参数<code>-XX:-UseAdaptiveSizePolicy</code>和 设置内存分配池的大小（请参阅<code>-XX:SurvivorRatio</code>选项）。</li><li><strong>-XX:InitialRAMPercentage&#x3D;percent</strong>：将 JVM 用于 Java 堆的初始内存量设置为 -XX:MaxRAM 选项中所述确定的最大内存量的百分比。默认值为 1.5625%。</li><li><strong>-XX:MaxRAMPercentage&#x3D;百分比</strong>：Java 堆的最大内存量，设置为 -XX:MaxRAM 选项中所述确定的最大内存量的百分比。默认值为 25%。</li></ul><h4 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h4><ul><li><strong>-XX:NewSize</strong>：年轻代初始大小。</li><li><strong>-XX:MaxNewSize</strong>：年轻代最大内存大小。</li><li><strong>-Xmn</strong>：年轻代 初始大小 和 最大大小。官方建议 年轻代大小 应在 整堆大小的一半 到 四分之一之间。</li><li><strong>-XX:SurvivorRatio</strong>：新生代中 Eden区 与 Survivor区 的占用比例，默认为8，意为eden区大小占年轻代的8&#x2F;10，而survivor from区和to区各占1&#x2F;10；</li><li><strong>-XX:+UseTLAB</strong>：在年轻代中使用TLAB。默认启用。要禁用 TLAB，请指定<code>-XX:-UseTLAB</code>。</li><li><strong>-XX:TLABSize&#x3D;大小</strong>：TLAB 初始大小（以字节为单位）。参数值为 0 时表示自动选择初始大小。</li><li><strong>-XX:TargetSurvivorRatio&#x3D;百分比</strong>：设置YGC后，幸存区使用占比。默认为 50%。</li></ul><h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><h3 id="2-4-2、方法区（MethodArea）"><a href="#2-4-2、方法区（MethodArea）" class="headerlink" title="2.4.2、方法区（MethodArea）"></a>2.4.2、方法区（MethodArea）</h3><h4 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h4><ul><li><code>-XX:PermSize=256m</code>：设置永久代初始大小。</li><li><code>-XX:MaxPermSize=256m</code>：设置永久代最大容量。</li></ul><h4 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h4><ul><li><strong>-XX:MaxMetaspaceSize&#x3D;大小</strong>：设置 类元数据 最大本机内存量。默认大小不受限制。应用程序的元数据量取决于应用程序本身、其他正在运行的应用程序以及系统上可用的内存量。</li><li><strong>-XX:MetaspaceSize&#x3D;size</strong>：设置 类元数据空间大小，该空间将在第一次超出时触发垃圾回收。根据使用的元数据量增加或减少垃圾收集的阈值。默认大小取决于平台。</li><li><code>-XX:+UseCompressedOops</code>：压缩对象指针。</li><li><code>-XX:+UseCompressedClassPointers</code>：压缩类型指针。</li><li><code>-XX:CompressedClassSpaceSize</code>：设置Klass Metaspace的大小，默认1G。</li></ul><h3 id="2-4-3、操作数栈（OperandStack）"><a href="#2-4-3、操作数栈（OperandStack）" class="headerlink" title="2.4.3、操作数栈（OperandStack）"></a>2.4.3、操作数栈（OperandStack）</h3><ul><li><strong>-Xss</strong>：设置 线程堆栈大小（以字节为单位）等价于<code>-XX:ThreadStackSize=大小</code>。默认值取决于平台。</li><li><strong>-XX:+DoEscapeAnalysis</strong>：启用逃逸分析。默认启用。要禁用请指定<code>-XX:-DoEscapeAnalysis</code>。只有 Java HotSpot Server VM 支持此选项。</li></ul><h3 id="2-4-4、本地方法栈（LocalMethodStack）"><a href="#2-4-4、本地方法栈（LocalMethodStack）" class="headerlink" title="2.4.4、本地方法栈（LocalMethodStack）"></a>2.4.4、本地方法栈（LocalMethodStack）</h3><h3 id="2-4-5、程序计数器（ProgramRegister）"><a href="#2-4-5、程序计数器（ProgramRegister）" class="headerlink" title="2.4.5、程序计数器（ProgramRegister）"></a>2.4.5、程序计数器（ProgramRegister）</h3><h3 id="2-4-6、直接内存（DirectMemory）"><a href="#2-4-6、直接内存（DirectMemory）" class="headerlink" title="2.4.6、直接内存（DirectMemory）"></a>2.4.6、直接内存（DirectMemory）</h3><ul><li><strong>-XX:MaxDirectMemorySize&#x3D;大小</strong>：设置新 I&#x2F;O（<code>java.nio</code>包）直接缓冲区分配的最大值（以字节为单位）。默认大小为 0，表示 JVM 会自动选择 NIO 直接缓冲区大小。</li></ul><h3 id="2-4-7、其它"><a href="#2-4-7、其它" class="headerlink" title="2.4.7、其它"></a>2.4.7、其它</h3><ul><li><strong>-XX:ObjectAlignmentInBytes&#x3D;对齐</strong>：设置 Java 对象的内存对齐（以字节为单位）。默认为 8 个字节。指定的值应该是 2 的幂，并且必须在 8 到 256（含）范围内。</li><li><strong>-XX:+PrintCommandLineFlags</strong>：允许 打印出现在命令行上的符合人体工程学的选定 JVM 标志。</li><li><strong>-XX:InitialCodeCacheSize&#x3D;大小</strong>：设置 初始代码缓存大小（以字节为单位）。默认为 500 KB。初始代码缓存大小应不小于系统的最小内存页大小。</li></ul><h2 id="2-5、垃圾回收参数"><a href="#2-5、垃圾回收参数" class="headerlink" title="2.5、垃圾回收参数"></a>2.5、垃圾回收参数</h2><h3 id="2-5-1、基本参数"><a href="#2-5-1、基本参数" class="headerlink" title="2.5.1、基本参数"></a>2.5.1、基本参数</h3><ul><li><p><strong>-Xnoclassgc</strong>：禁用垃圾回收 (GC)。</p></li><li><p><strong>-XX:ErrorFile&#x3D;文件名</strong>：发生错误时 将 错误数据 写入指定文件。文件默认在当前目录且并命名为 hs_err_pid pid.log，其中 pid 是导致错误的进程标识符。</p></li><li><p><strong>-XX:+HeapDumpOnOutOfMemoryError</strong>：OOM引发异常时将错误信息导出到指定文件。可使用参数<code>-XX:HeapDumpPath</code>设置文件路径和名称。默认禁用。</p></li><li><p><strong>-XX:HeapDumpPath&#x3D;路径</strong>：设置该<code>-XX:+HeapDumpOnOutOfMemoryError</code>选项时，设置用于写入堆分析器 (HPROF) 提供的堆转储的路径和文件名。默认情况下，该文件在当前工作目录中创建，并命名为<code>java_pid</code><em>pid</em><code>.hprof</code>，其中 pid 是导致错误的进程标识符。以下示例设置默认文件（<code>%p</code>代表当前进程标识符）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-XX:HeapDumpPath</span><span class="token operator">=</span>./java_pid%p.hprof<span class="token comment"># 以下示例显示如何将堆转储文件设置为/var/log/java/java_heapdump.hprof：</span><span class="token parameter variable">-XX:HeapDumpPath</span><span class="token operator">=</span>/var/log/java/java_heapdump.hprof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>-XX:ActiveProcessorCount&#x3D; x</strong>：覆盖 VM 用于计算其用于各种操作（例如垃圾收集和 ForkJoinPool）的线程池大小的 CPU 数量。</p></li><li><p><strong>-XX:MaxHeapFreeRatio&#x3D;百分比</strong>：设置 GC后堆最大空闲空间占比（0 到 100）。如果GC后空闲空间占比大于该参数值，则将堆缩小。默认为 70%。</p></li><li><p><strong>-XX:MinHeapFreeRatio&#x3D;百分比</strong>：设置 GC后堆最小空闲空间占比（0 到 100）。如果GC后空闲空间占比小于该参数值，则将堆扩大。默认为 40%。</p></li><li><p><strong>-XX:MaxTenuringThreshold&#x3D;阈值</strong>：对象晋升至老年代的最大年龄阈值为 15。并行（吞吐量）收集器默认为 15，CMS 收集器默认为 6。</p></li><li><p><strong>-XX:MinRAMPercentage&#x3D;百分比</strong>：将 JVM 可用于 Java 堆的最大内存量设置为如<code>-XX:MaxRAM</code>小堆选项中所述确定的最大内存量的百分比。小堆大约 125 MB。默认值为 50%。</p></li><li><p><strong>-XX:+ScavengeBeforeFullGC</strong>：FGC前先执行一次YGC，默认启用。Oracle 建议您不要禁用它。</p></li><li><p><strong>-XX:StringDeduplicationAgeThreshold&#x3D;阈值</strong>：<code>String</code>达到指定年龄的对象被视为重复数据删除的候选对象。一个对象的年龄是衡量它在垃圾收集中幸存下来的次数。这有时被称为任期；</p></li><li><p><strong>-XX:+UseGCOverheadLimit</strong>：允许使用限制 JVM 在<code>OutOfMemoryError</code>抛出异常之前花费在 GC 上的时间比例的策略。默认情况下启用此选项，<code>OutOfMemoryError</code>如果总时间的 98% 以上用于垃圾收集并且堆的回收少于 2%，则并行 GC 将抛出异常。当堆很小时，此功能可用于防止应用程序长时间运行而几乎没有或没有进展。要禁用此选项请指定<code>-XX:-UseGCOverheadLimit</code>。</p></li><li><p><strong>-XX:+UseNUMA</strong>：通过增加应用程序对低延迟内存的使用，在具有非统一内存架构 (NUMA) 的机器上实现应用程序的性能优化。默认情况下，此选项处于禁用状态，并且不会对 NUMA 进行优化。该选项仅在使用并行垃圾收集器 ( <code>-XX:+UseParallelGC</code>)时可用。</p></li><li><p><font color='orange'>-XX:PreTenureSizeThreshold</font>：设置大对象大小；</p></li><li><p><font color='orange'>-XX:MaxTenuringThreshold</font>：表示对象晋升到老年代的年龄阈值；（默认值15，CMS为6，G1为15。）</p><p><font color='red'>注意，年龄小于该阈值时也可能会晋升，但晋升时对象的年龄永远不会超过该阈值。因为还有对象动态晋升机制的存在，动态晋升是指：当survivor区中所有相同大小对象的大小总和超过survivor区一半时，就需要将这些相同大小的对象和大于该大小的对象全部晋升到老年代中，使得survivor区中有空闲空间来供程序正常运行来用，否则没有空闲空间，程序将会出现问题。</font></p></li></ul><h3 id="2-5-2、垃圾收集器参数"><a href="#2-5-2、垃圾收集器参数" class="headerlink" title="2.5.2、垃圾收集器参数"></a>2.5.2、垃圾收集器参数</h3><h4 id="基本参数-1"><a href="#基本参数-1" class="headerlink" title="基本参数"></a>基本参数</h4><ul><li><strong>-XX:ConcGCThreads&#x3D;线程</strong>：设置并发GC 线程数。默认值取决于 JVM 可用的 CPU 数量。</li><li><strong>-XX:+DisableExplicitGC</strong>：禁用代码块 System.gc()。</li><li><strong>-XX:InitiatingHeapOccupancyPercent&#x3D;百分比</strong>：设置启动并发 GC 周期的堆占用百分比（0 到 100）。它被垃圾收集器使用，它们根据整个堆的占用率触发并发 GC 周期，而不仅仅是其中一代（例如，G1 垃圾收集器）。默认初始值为 45%。值 0 表示不间断 GC 循环。</li><li><strong>-XX:MaxGCPauseMillis&#x3D;时间</strong>：设置 GC 最大暂停时间（以毫秒为单位）。默认 没有最大暂停时间值。</li></ul><h4 id="Serial-Old常用参数"><a href="#Serial-Old常用参数" class="headerlink" title="Serial Old常用参数"></a>Serial Old常用参数</h4><ul><li><strong>-XX:+UseSerialGC</strong>：启用串行垃圾收集器。适用于小型的简单的应用程序。默认禁用，并根据机器配置和 JVM 类型自动选择收集器。</li></ul><h4 id="Parallel常用参数"><a href="#Parallel常用参数" class="headerlink" title="Parallel常用参数"></a>Parallel常用参数</h4><ul><li><p><strong>-XX:+UseParallelGC</strong>：使用并行清理垃圾收集器（也称为吞吐量收集器）。默认禁用，并根据机器配置和 JVM 类型自动选择收集器。如果启用该选项，则默认同时启用<code>-XX:+UseParallelOldGC</code>，除非明确禁用它。</p></li><li><p><strong>-XX:+UseParallelOldGC</strong>：启用并行垃圾收集器。默认禁用。启用它会自动启用参数<code>-XX:+UseParallelGC</code>。</p></li><li><p><strong>-XX:+ParallelGCThreads&#x3D;n</strong>：设置用于年轻代和年老代并行垃圾回收的线程数。默认值取决于 JVM 可用的 CPU 数量。同样适用于CMS。*</p><p>按照逻辑处理器的数量来设置n值。n 的值应该与逻辑处理器的数量相同，最多为 8。如果逻辑处理器不止八个，则将 n 的值设置为逻辑处理器数量的 5&#x2F;8 左右。这适用于大多数情况，除非是较大的 SPARC 系统，其中 n 值可以是逻辑处理器数的 5&#x2F;16 左右。</p></li><li><p><strong>-XX:+UseAdaptiveSizePolicy</strong>：表示自动选择各区大小比例。</p></li><li><p><strong>-XX:InitialSurvivorRatio&#x3D;比率</strong>：设置吞吐量垃圾收集器使用的初始幸存者空间比率（由<code>-XX:+UseParallelGC</code>和&#x2F;或 -<code>XX:+UseParallelOldGC</code>选项启用）。默认吞吐量垃圾收集器使用<code>-XX:+UseParallelGC</code>和<code>-XX:+UseParallelOldGC</code>选项启用自适应大小调整，并根据应用程序行为调整幸存者空间大小，从初始值开始。如果禁用了自适应大小调整（使用该<code>-XX:-UseAdaptiveSizePolicy</code>选项），<code>-XX:SurvivorRatio</code>则应使用该选项为整个应用程序执行设置幸存者空间的大小。</p><p>根据年轻代的大小（Y）和初始幸存者空间比率（R），可以使用以下公式计算幸存者空间的初始大小（S）：</p><pre class="line-numbers language-none"><code class="language-none">S&#x3D;Y&#x2F;(R+2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>-XX:+ParallelRefProcEnabled</strong>：启用并行引用处理。默认禁用状态。</p></li><li><p><code>-XX:MaxGCPauseMillis</code>：设置垃圾收集器最大停顿时间。</p></li><li><p><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例。</p></li></ul><h4 id="ParNew参数"><a href="#ParNew参数" class="headerlink" title="ParNew参数"></a>ParNew参数</h4><ul><li><strong>-XX:+UseParNewGC</strong>：年轻代中使用 并行线程 进行收集。默认禁用。设置参数<code>-XX:+UseConcMarkSweepGC</code>会自动启用。使用<code>-XX:+UseParNewGC</code>不带选项<code>-XX:+UseConcMarkSweepGC</code>的选择是在JDK 8弃用。</li></ul><h4 id="CMS常用参数"><a href="#CMS常用参数" class="headerlink" title="CMS常用参数"></a>CMS常用参数</h4><ul><li><p><font color='orange'>-XX:+UseConcMarkSweepGC</font>：为老年代启用 CMS 垃圾收集器。Oracle 建议您在吞吐量 ( <code>-XX:+UseParallelGC</code>) 垃圾收集器无法满足应用程序延迟要求时使用 CMS 垃圾收集器。G1 垃圾收集器 ( <code>-XX:+UseG1GC</code>) 是另一种选择。</p><p>默认情况下，此选项处于禁用状态，并根据机器的配置和 JVM 的类型自动选择收集器。当启用该选项时，<code>-XX:+UseParNewGC</code>选项将自动设置，你不应该禁用它，因为下面的选项组合已经在JDK 8被弃用：<code>-XX:+UseConcMarkSweepGC -XX:-UseParNewGC</code>。</p></li><li><p><font color='orange'>-XX:ParallelCMSThreads</font>：CMS线程数量。</p></li><li><p><font color='orange'>-XX:CMSInitiatingOccupancyFraction</font>：老年代内存使用率达到多少时执行CMS收集（低版本的 JDK 默认值为 68%, JDK6 及以上版本默认值为 92%），这里的内存回收范围仅限于老年代，而非整个堆空间，因此通过该选项便可以有效降低 Full GC 执行次数。如果频繁发生SerialOld卡顿，应该调小，（频繁CMS回收）。默认值设置为 -1。任何负值（包括默认值）都意味着<code>-XX:CMSTriggerRatio</code>用于定义初始占用率的值。</p></li><li><p><font color='orange'>-XX:+UseCMSCompactAtFullCollection</font>：执行FGC后是否进行压缩整理。</p></li><li><p><font color='orange'>-XX:CMSFullGCsBeforeCompaction</font>：执行FGC多少次后进行压缩整理。</p></li><li><p><font color='orange'>-XX:+CMSClassUnloadingEnabled</font>：表示对永久代进行垃圾回收；</p><p>CMS收集器默认不会对永久代进行垃圾回收，如需回收设置该参数即可。在早期JVM版本中，要求设置额外的标志-XX:+CMSPermGenSweepingEnabled。注意，即使没有设置这个标志，一旦永久代耗尽空间也会尝试进行垃圾回收，但是收集不会是并行的，而再一次进行Full GC。</p></li><li><p><font color='orange'>-XX:CMSInitiatingPermOccupancyFraction</font>：达到什么比例时进行Perm回收。</p></li><li><p><font color='orange'>GCTimeRatio</font>：设置GC时间占用程序运行时间的百分比。</p></li><li><p><font color='orange'>-XX:MaxGCPauseMillis</font>：停顿时间，是一个建议时间，GC会尝试用各种手段达到这个时间，比如减小年轻代。</p></li><li><p><strong>-XX:+CMSClassUnloadingEnabled</strong>：在使用并发标记清除 (CMS) 垃圾收集器时启用类卸载。默认启用。要禁用 CMS 垃圾收集器的类卸载，请指定<code>-XX:-CMSClassUnloadingEnabled</code>。</p></li><li><p><strong>-XX:+CMSScavengeBeforeRemark</strong>：在 CMS 注释步骤之前启用清理尝试。默认禁用。</p></li><li><p><strong>-XX:CMSTriggerRatio&#x3D;百分比</strong>：设置在<code>-XX:MinHeapFreeRatio</code>CMS 收集周期开始之前分配的指定值的百分比（0 到 100）。默认值设置为 80%。</p></li><li><p><strong>-XX:+ExplicitGCInvokesConcurrent</strong>：通过使用<code>System.gc()</code>请求启用并发 GC 的调用。默认禁用，只能与<code>-XX:+UseConcMarkSweepGC</code>选项一起启用。</p></li><li><p><strong>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</strong>：通过在并发 GC 周期中使用 System.gc() 请求和卸载类来启用并发 GC 的调用。默认禁用，只能与 -XX:+UseConcMarkSweepGC 选项一起启用。</p></li><li><p><strong>-XX:+UseCMSInitiatingOccupancyOnly</strong>：允许使用占用值作为启动 CMS 收集器的唯一标准。默认禁用，可以使用其他条件。</p></li></ul><h4 id="G1常用参数"><a href="#G1常用参数" class="headerlink" title="G1常用参数"></a>G1常用参数</h4><ul><li><p><font color='orange'>-XX:+UseG1GC</font>：表示 使用G1收集器；</p></li><li><p><font color='orange'>-XX:MaxGCPauseMillis</font>：每次GC的停顿目标时间，默认值 200ms。G1会尝试调整Young区的个数来达到该值；</p></li><li><p>-<font color='orange'>XX:GCPauseIntervalMillis</font>：GC间隔时间；</p></li><li><p><font color='orange'>-XX:G1HeapRegionSize&#x3D;n</font>：分区大小，建议逐渐增大该值1、2、4、8、16、32。随着size增加，垃圾存活时间会更长，GC间隔会更长，但每次GC时间也会更长，ZGC做了改进（动态区块大小）；</p></li><li><p><font color='orange'>-XX:G1HeapWastePercent</font>：默认值5%，表示在全局并发标记结束后能够统计出所有可被回收的垃圾占Heap的比例值，如果超过5%，就会触发之后的多轮Mixed GC，mixed gc会同时回收年轻代+老年代，而这个参数可以指定mixed gc触发的时机；</p><p>注意：该参数与 <code>InitiatingHeapOccupancyPercent</code> 结合使用可以实现提前回收老年代，让老年代提前释放空间。</p></li><li><p><font color='orange'>-XX:InitiatingHeapOccupancyPercent&#x3D;45</font>：默认45%，表示在堆使用率达到该参数设定值时，就会触发 混合回收；</p></li><li><p><font color='orange'>-XX:G1NewSizePercent</font>：新生代最小比例，默认为5%。</p></li><li><p><font color='orange'>-XX:G1MaxNewSizePercent</font>：新生代最大比例，默认为60%；</p></li><li><p><font color='orange'>-XX:G1MixedGCCountTarget</font>：默认值8，表示最后的混合回收阶段会执行8次，一次只回收掉一部分Region，然后系统继续运行，过了一小段时间后，会再次进行混合回收，就这样重复8次；</p></li><li><p><font color='orange'>-XX:G1MixedGCLiveThresholdPercent</font>：默认值85%，表示 一个Region中的存活对象若大于Region大小的85%，那就无需回收这个Region，否则得不偿失；</p></li><li><p><font color='orange'>-XX:GCTimeRatio</font>：圾回收时间占程序运行时间的百分比；</p></li><li><p><font color='orange'>-XX:ConcGCThreads&#x3D;n</font>：设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1&#x2F;4 左右；</p></li><li><p><strong>-XX:G1HeapRegionSize&#x3D;大小</strong>：使用G1收集器时 Java 堆细分的区域大小。该值介于 1 MB 和 32 MB 之间。默认区域大小是根据堆大小来定。</p></li><li><p><strong>-XX:+G1PrintHeapRegions</strong>：启用打印有关哪些区域已分配以及哪些由 G1 收集器回收的信息。默认情况下，此选项处于禁用状态。</p></li><li><p><strong>-XX:G1ReservePercent&#x3D;百分比</strong>：设置保留为虚假上限的堆的百分比（0 到 50），以减少 G1 收集器升级失败的可能性。默认情况下，此选项设置为 10%。</p></li><li><p><strong>-XX:+UseStringDeduplication</strong>：启用字符串重复数据删除。默认禁用。要使用此选项，您必须启用G1垃圾收集器。</p></li></ul><h4 id="常见垃圾回收器参数"><a href="#常见垃圾回收器参数" class="headerlink" title="常见垃圾回收器参数"></a>常见垃圾回收器参数</h4><ul><li><p>设置串行收集器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-XX:+UseSerialGC</span>      <span class="token operator">=</span> Serial New<span class="token punctuation">(</span>DefNew<span class="token punctuation">)</span> + Serial Old<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置并行收集器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-XX:+UseParallelGC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同时还需要设置以下参数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-XX:ParallelGCThreads</span><span class="token operator">=</span>n     <span class="token comment"># 设置并行收集器工作时使用的CPU数量。</span><span class="token parameter variable">-XX:MaxGCPauseMillis</span><span class="token operator">=</span>n      <span class="token comment"># 设置并行收集器最大停顿时间。</span><span class="token parameter variable">-XX:GCTimeRatio</span><span class="token operator">=</span>n           <span class="token comment"># 设置垃圾回收时间占程序运行时间的百分比。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>设置老年代并行收集器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-XX:+UseParallelOldGC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置并发收集器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-XX:+UseConcMarkSweeqGC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同时还需要设置以下参数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-XX:+CMSIncrementalMode</span>     <span class="token comment"># 设置为增量模式，适用于单CPU情况。</span><span class="token parameter variable">-XX:ParallelGCThreads</span><span class="token operator">=</span>n     <span class="token comment"># 设置年轻代收集为并行收集时，并行GC线程的数量，一般最好和CPU核心数量一样。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>其它参数如下：</p><ul><li><p><font color='orange'>-XX:+UseParNewGC &#x3D; ParNew + SerialOld</font></p></li><li><p><font color='orange'>-XX:+UseConc(current)MarkSweepGC &#x3D; ParNew + CMS + SerialOld</font></p></li><li><p><font color='orange'>-XX:+UseParallelGC &#x3D; Parallel Scavenge + Parallel Old</font></p></li><li><p><font color='orange'>-XX:+UseG1GC &#x3D; G1</font></p></li><li><p>查看Linux下默认GC的方法，而Windows中会打印UseParallelGC</p><ol><li><font color='orange'>java -XX:+PrintCommandLineFlags - version</font></li><li>通过GC日志分辨。</li></ol></li><li><p>Linux下1.8版本默认垃圾收集器是啥？</p><ol><li>1.8.0_181 默认看不出，Copy MarkCompact</li><li>1.8.0_222 默认PS + PO</li></ol></li></ul><h3 id="2-5-3、GC日志参数"><a href="#2-5-3、GC日志参数" class="headerlink" title="2.5.3、GC日志参数"></a>2.5.3、GC日志参数</h3><h4 id="基本参数-2"><a href="#基本参数-2" class="headerlink" title="基本参数"></a>基本参数</h4><ul><li><strong>-XX:LogFile&#x3D;路径</strong>：设置写入日志数据的路径和文件名。默认该文件创建在当前工作目录中，并命名为<code>hotspot.log</code>.</li></ul><h4 id="日志打印参数"><a href="#日志打印参数" class="headerlink" title="日志打印参数"></a>日志打印参数</h4><ul><li><strong>-XX:+PrintGC</strong>：每次 GC 时打印消息。默认禁用。</li><li><strong>-XX:+PrintGCDetails</strong>：每次 GC 时打印详细消息。默认禁用。</li><li><strong>-XX:+PrintGCTimeStamps</strong>：每次 GC 时打印时间戳。默认禁用。</li><li><strong>-XX:+PrintGCTaskTimeStamps</strong>：为每个单独的 GC 工作线程任务启用时间戳打印。默认禁用。</li><li><strong>-XX:+PrintGCCauses</strong></li><li><strong>-XX:+PrintGCApplicationConcurrentTime</strong>：启用打印自上次暂停（例如，GC 暂停）以来经过的时间。默认禁用。</li><li><strong>-XX:+PrintGCApplicationStoppedTime</strong>：启用打印暂停（例如，GC 暂停）持续的时间。默认禁用。</li><li><strong>-XX:+PrintGCDateStamps</strong>：每次 GC 时打印日期戳。默认禁用。</li><li><strong>-XX:+PrintStringDeduplicationStatistics</strong>：打印详细重复数据，删除统计信息。默认禁用。查看<code>-XX:+UseStringDeduplication</code>选项。</li><li><strong>-XX:+PrintTenuringDistribution</strong>：启用任期年龄信息的打印。</li><li><strong>-XX:SoftRefLRUPolicyMSPerMB&#x3D;时间</strong>：软引用对象在上次被引用后在堆上保持活动的时间量（以毫秒为单位）。默认值是堆中每空闲兆字节的生命周期一秒。</li><li><strong>-XX:PrintHeapAtGC</strong>：GC执行前后打印出堆的信息；</li><li><strong>-Xloggc:filename</strong>：日志文件保存路径；</li></ul><p><font color="red">注意：total &#x3D; eden区 + 1个survivor区。</font></p><h4 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h4><ol><li><p>方式一</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log <span class="token parameter variable">-XX:+UseGCLogFileRotation</span> <span class="token parameter variable">-XX:NumberOfGCLogFiles</span><span class="token operator">=</span><span class="token number">5</span> <span class="token parameter variable">-XX:GCLogFileSize</span><span class="token operator">=</span>20M <span class="token parameter variable">-XX:+PrintGCDetails</span> <span class="token parameter variable">-XX:+PrintGCGateStamps</span> <span class="token parameter variable">-XX:+PrintGCCause</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>方式二</p><p>或者每天产生一个。</p></li></ol><h2 id="2-6、Java锁参数"><a href="#2-6、Java锁参数" class="headerlink" title="2.6、Java锁参数"></a>2.6、Java锁参数</h2><ul><li><strong>-XX:-UseBiasedLocking</strong>：禁用偏向锁。</li></ul><h2 id="2-7、JVM参数总结"><a href="#2-7、JVM参数总结" class="headerlink" title="2.7、JVM参数总结"></a>2.7、JVM参数总结</h2><h3 id="2-7-1、GC常用参数"><a href="#2-7-1、GC常用参数" class="headerlink" title="2.7.1、GC常用参数"></a>2.7.1、GC常用参数</h3><ul><li><font color='orange'>-Xms &#x2F; -Xmx &#x2F; -Xmn &#x2F; -Xss</font>：最小堆 &#x2F; 最大堆 &#x2F; 年轻代 &#x2F; 栈空间。</li><li><font color='orange'>-XX:NewSize</font>：JVM启动时分配的新生代内存大小。</li><li><font color='orange'>-XX:OldSize</font>：JVM启动时分配的老年代内存大小。</li><li><font color='orange'>-XX:PermSize 和 -XX:MaxPermSize</font>：JVM 永久代（方法区JDK7之前）大小。</li><li><font color='orange'>-XX SurvivorRatio</font>：Eden空间和另外两个Survivor空间的比例，默认比例是<code>8:1</code>。</li><li><font color='orange'>-XX:+UseTLAB</font>：使用TLAB，默认打开。</li><li><font color='orange'>-XX:+PrintTLAB</font>：打印TLAB使用情况。</li><li><font color='orange'>-XX:TLABSize</font>：设置TLAB大小。</li><li><font color='orange'>-XX:+DisableExplictGC</font>：System.gc()不管用 ，FGC。</li><li><font color='orange'>-XX:+PrintGC</font>：</li><li><font color='orange'>-XX:+PrintGCDetails</font>：</li><li><font color='orange'>-XX:+PrintHeapAtGC</font>：</li><li><font color='orange'>-XX:+PrintGCTimeStamps</font>：</li><li><font color='orange'>-XX:+PrintGCApplicationConcurrentTime (低)</font>：打印应用程序时间。</li><li><font color='orange'>-XX:+PrintGCApplicationStoppedTime（低）</font>：打印暂停时长。</li><li><font color='orange'>-XX:+PrintReferenceGC（重要性低）</font>：记录回收了多少种不同引用类型的引用。</li><li><font color='orange'>-verbose:class</font>：类加载详细过程。</li><li><font color='orange'>-XX:+PrintVMOptions</font>：</li><li><font color='orange'>-XX:+PrintFlagsFinal  -XX:+PrintFlagsInitial</font>：必须会用。</li><li><font color='orange'>-Xloggc:opt&#x2F;log&#x2F;gc.log</font>：将生成的gc日志保存于指定的文件中。</li><li><font color='orange'>-XX:MaxTenuringThreshold</font>：升代年龄，最大值15。</li><li><font color='orange'>-XX:PreBlockSpin</font>：锁自旋次数参数（默认即可，不建议设置）。</li><li><font color='orange'>-XX:CompileThreshold</font>：热点代码检测参数、逃逸分析、标量替换（默认即可，不建议设置）。</li></ul><h3 id="2-7-2、堆内存常用配置"><a href="#2-7-2、堆内存常用配置" class="headerlink" title="2.7.2、堆内存常用配置"></a>2.7.2、堆内存常用配置</h3><h4 id="类型1"><a href="#类型1" class="headerlink" title="类型1"></a>类型1</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> <span class="token parameter variable">-Xmx3550m</span> <span class="token parameter variable">-Xms3550m</span> <span class="token parameter variable">-Xmn2g</span> <span class="token parameter variable">-Xss128k</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><font color='orange'>-Xmx3550m</font>：设置JVM最大可用内存为3550M。</p></li><li><p><font color='orange'>-Xms3550m</font>：设置JVM内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p></li><li><p><font color='orange'>-Xmn2g</font>：设置年轻代大小为2G。整个JVM内存大小&#x3D;年轻代大小+老年代大小+持久代大小。持久代大小一般固定为64m，所以增大年轻代后，将会减小老年代大小。</p><p><font color='red'>注意：此值对系统性能影响较大，Sun官方推荐配置为整个堆的3&#x2F;8。</font></p></li><li><p><font color='orange'>-Xss128k</font>：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p></li></ul><h4 id="类型2"><a href="#类型2" class="headerlink" title="类型2"></a>类型2</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> <span class="token parameter variable">-Xmx3550m</span> <span class="token parameter variable">-Xms3550m</span> <span class="token parameter variable">-Xss128k</span> <span class="token parameter variable">-XX:NewRatio</span><span class="token operator">=</span><span class="token number">4</span> <span class="token parameter variable">-XX:SurvivorRatio</span><span class="token operator">=</span><span class="token number">4</span> <span class="token parameter variable">-XX:MaxPermSize</span><span class="token operator">=</span>16m <span class="token parameter variable">-XX:MaxTenuringThreshold</span><span class="token operator">=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><font color='orange'>-XX:NewRatio&#x3D;4</font>：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4表示年轻代与年老代所占比值为<code>1:4</code>，年轻代占整个堆栈的1&#x2F;5。</li><li><font color='orange'>-XX:SurvivorRatio&#x3D;4</font>：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为<code>2:4</code>，一个Survivor区占整个年轻代的1&#x2F;6。</li><li><font color='orange'>-XX:MaxPermSize&#x3D;16m</font>：设置持久代大小为16m。</li><li><font color='orange'>-XX:MaxTenuringThreshold&#x3D;0</font>：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代即被回收的机会。</li></ul><h3 id="2-8-3、回收器常用配置"><a href="#2-8-3、回收器常用配置" class="headerlink" title="2.8.3、回收器常用配置"></a>2.8.3、回收器常用配置</h3><h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 方案1</span><span class="token function">java</span> <span class="token parameter variable">-Xmx3800m</span> <span class="token parameter variable">-Xms3800m</span> <span class="token parameter variable">-Xmn2g</span> <span class="token parameter variable">-Xss128k</span> <span class="token parameter variable">-XX:+UseParallelGC</span> <span class="token parameter variable">-XX:ParallelGCThreads</span><span class="token operator">=</span><span class="token number">20</span><span class="token comment"># 方案2</span><span class="token function">java</span> <span class="token parameter variable">-Xmx3550m</span> <span class="token parameter variable">-Xms3550m</span> <span class="token parameter variable">-Xmn2g</span> <span class="token parameter variable">-Xss128k</span> <span class="token parameter variable">-XX:+UseParallelGC</span> <span class="token parameter variable">-XX:ParallelGCThreads</span><span class="token operator">=</span><span class="token number">20</span> <span class="token parameter variable">-XX:+UseParallelOldGC</span><span class="token comment"># 方案3</span><span class="token function">java</span> <span class="token parameter variable">-Xmx3550m</span> <span class="token parameter variable">-Xms3550m</span> <span class="token parameter variable">-Xmn2g</span> <span class="token parameter variable">-Xss128k</span> <span class="token parameter variable">-XX:+UseParallelGC</span> <span class="token parameter variable">-XX:MaxGCPauseMillis</span><span class="token operator">=</span><span class="token number">100</span><span class="token comment"># 方案4</span><span class="token function">java</span> <span class="token parameter variable">-Xmx3550m</span> <span class="token parameter variable">-Xms3550m</span> <span class="token parameter variable">-Xmn2g</span> <span class="token parameter variable">-Xss128k</span> <span class="token parameter variable">-XX:+UseParallelGC</span> <span class="token parameter variable">-XX:MaxGCPauseMillis</span><span class="token operator">=</span><span class="token number">100</span> <span class="token parameter variable">-XX:+UseAdaptiveSizePolicy</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 方案1</span><span class="token function">java</span> <span class="token parameter variable">-Xmx3550m</span> <span class="token parameter variable">-Xms3550m</span> <span class="token parameter variable">-Xmn2g</span> <span class="token parameter variable">-Xss128k</span> <span class="token parameter variable">-XX:ParallelGCThreads</span><span class="token operator">=</span><span class="token number">20</span> <span class="token parameter variable">-XX:+UseConcMarkSweepGC</span> <span class="token parameter variable">-XX:+UseParNewGC</span><span class="token comment"># 方案2</span><span class="token function">java</span> <span class="token parameter variable">-Xmx3550m</span> <span class="token parameter variable">-Xms3550m</span> <span class="token parameter variable">-Xmn2g</span> <span class="token parameter variable">-Xss128k</span> <span class="token parameter variable">-XX:+UseConcMarkSweepGC</span> <span class="token parameter variable">-XX:CMSFullGCsBeforeCompaction</span><span class="token operator">=</span><span class="token number">5</span> <span class="token parameter variable">-XX:+UseCMSCompactAtFullCollection</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3、JVM调优"><a href="#3、JVM调优" class="headerlink" title="3、JVM调优"></a>3、JVM调优</h1><h2 id="3-1、前言"><a href="#3-1、前言" class="headerlink" title="3.1、前言"></a>3.1、前言</h2><h3 id="3-1-1、内存泄漏和内存溢出"><a href="#3-1-1、内存泄漏和内存溢出" class="headerlink" title="3.1.1、内存泄漏和内存溢出"></a>3.1.1、内存泄漏和内存溢出</h3><ul><li><strong>内存泄漏（Memory Leak）</strong>：程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积的话后果会很严重。</li><li><strong>内存溢出（Out Of Memory）</strong>：程序在申请内存时，没有足够的内存空间供其使用，会出现Out Of Memory。</li></ul><h3 id="3-1-2、QPS和TPS"><a href="#3-1-2、QPS和TPS" class="headerlink" title="3.1.2、QPS和TPS"></a>3.1.2、QPS和TPS</h3><ul><li><p><strong>QPS</strong>：全称——Queries Per Second，意思是<em><strong>每秒查询率</strong></em>，是一台服务器每秒能够响应的查询次数（数据库中的每秒执行查询sql的次数），显然，这个不够全面，不能描述增删改，所以，不建议用qps来作为系统性能指标。</p></li><li><p><strong>TPS</strong>：全称——Transactions Per Second，意思是<em><strong>每秒事务数</strong></em>，具体事务的定义，都是人为的，可以一个接口、多个接口、一个业务流程等等。一个事务是指事务内第一个请求发送到接收到最后一个请求的响应的过程，以此来计算使用的时间和完成的事务个数。</p><p>以单接口定义的事务为例，每个事务包括了如下3个过程：</p><ol><li>向服务器发请求。</li><li>服务器自己的内部处理（包含应用服务器、数据库服务器等）。</li><li>服务器返回结果给客户端。</li></ol><p>如果每秒能够完成N次这三个过程，那么TPS就是N；</p><p>如果多个接口定义为一个事务，且1、2、3过程执行一轮为一次，那么1秒能执行多少次，TPS就是多少。</p></li></ul><h3 id="3-1-3、吞吐量和响应时间"><a href="#3-1-3、吞吐量和响应时间" class="headerlink" title="3.1.3、吞吐量和响应时间"></a>3.1.3、吞吐量和响应时间</h3><ul><li><strong>吞吐量</strong>：用户代码时间 &#x2F; (用户代码执行时间 + 垃圾回收时间)。</li><li><strong>响应时间</strong>：服务器接收到请求到返回结果给客户端这么一个过程所耗费的时间。STW时间越短，响应时间越好。</li></ul><h2 id="3-2、如何调优"><a href="#3-2、如何调优" class="headerlink" title="3.2、如何调优"></a>3.2、如何调优</h2><p>想要调优，首先要有一个目标，你的目标是追求 <em><strong>响应时间 or 吞吐量？</strong></em></p><ul><li>追求吞吐量，对于 科学计算、数据挖掘等场景，选择垃圾回收器组合：PS+PO。</li><li>追求响应时间，比如：网站、带界面的程序、对外提供API等，选择ParNew、CMS、G1。</li></ul><h2 id="3-3、调优分类"><a href="#3-3、调优分类" class="headerlink" title="3.3、调优分类"></a>3.3、调优分类</h2><p>GC调优分为三类：</p><ol><li>根据需求进行JVM规划和预调优。</li><li>优化JVM运行环境（慢、卡顿）。</li><li>解决JVM运行过程中出现的各种问题，比如说OOM。</li></ol><h2 id="3-4、调优思路"><a href="#3-4、调优思路" class="headerlink" title="3.4、调优思路"></a>3.4、调优思路</h2><h3 id="3-4-1、思路"><a href="#3-4-1、思路" class="headerlink" title="3.4.1、思路"></a>3.4.1、思路</h3><p>调优，从业务场景开始，没有业务场景的调优就是耍流氓。同时还要遵循无监控，不调优的规则</p><p>常见的调优思路如下：</p><ol><li><p>熟悉业务场景（选择垃圾收集器，垃圾收集器只有合适的，没有最好的）。</p><ul><li>响应时间：停顿时间，（推荐：CMS &#x2F; G1 &#x2F; ZGC）</li><li>吞吐量：代码时间 &#x2F; (代码时间 + GC时间)，（推荐：PS）</li></ul></li><li><p>选择回收器组合。</p></li><li><p>计算内存需求。</p></li><li><p>选定CPU（越高越好，按预算来）。</p></li><li><p>设定年代大小，升级年龄。</p></li><li><p>设定日志参数。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log <span class="token parameter variable">-XX:+UseGCLogFileRotation</span> <span class="token parameter variable">-XX:NumberOfGCLogFiles</span><span class="token operator">=</span><span class="token number">5</span> <span class="token parameter variable">-XX:GCLogFilesSize</span><span class="token operator">=</span>20m <span class="token parameter variable">-XX:+PrintGcDetails</span> <span class="token parameter variable">-XX:+PrintGCDateStamps</span> <span class="token parameter variable">-XX:PrintGCCause</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：一般记录日志时，会形成日志文件。如果只有一个日志文件，肯定不行，需要根据实际情况来定。</p></li></ol><h3 id="3-4-2、常用命令"><a href="#3-4-2、常用命令" class="headerlink" title="3.4.2、常用命令"></a>3.4.2、常用命令</h3><ol><li>java -XX:+PrintFlagsInitial：打印默认参数值；</li><li>java -XX:+PrintFlagsFinal：打印最终参数值；</li><li>java -XX:+PrintFlagsFinal | grep xxx：找到对应的参数；</li><li>java -XX:+PrintFlagsFinal -version | grep GC；</li></ol><h2 id="3-5、调优工具"><a href="#3-5、调优工具" class="headerlink" title="3.5、调优工具"></a>3.5、调优工具</h2><h3 id="3-5-1、Arthas"><a href="#3-5-1、Arthas" class="headerlink" title="3.5.1、Arthas"></a>3.5.1、Arthas</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>1、dump到指定文件（使用jhat进行分析）</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">heapdump</span> <span class="token value attr-value">/tmp/dump.hprof</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、仅dump live对象</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">heapdump</span> <span class="token value attr-value">--live /tmp/dump.hprof</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、展示当前进程信息</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">dashboard<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、打印线程ID的栈信息</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">thread</span> <span class="token value attr-value">id </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5、可以方便查看死锁</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">thread</span> <span class="token value attr-value">-b id</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>6、反编译</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">jad</span> <span class="token value attr-value">*.class    如：jad HelloGC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>反编译需要注意以下问题：</p><ol><li><font color='red'>动态代理生成类问题；</font></li><li><font color='red'>第三方类；（观察代码）</font></li><li><font color='red'>版本问题；（确定自己最新提交的版本是不是被使用）</font></li></ol><p><font color='red'>注意：配合热替换使用，但要注意热替换的限制问题。</font></p><p>7、热替换</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redefine /opt/XXX.class<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实现步骤：</p><ol><li>运行测试类A；（A中有方法m，m中打印数字1。）</li><li>现需要修改类A中方法m的逻辑，让其打印数字2；</li><li>在不停掉1步骤中类A情的况下，直接修改类A中方法m的逻辑（打印2），然后重新编译（javac A.java）；</li><li>执行arthas命令：<code>redefine /opt/A.class</code>，即可实现热替换；（命令中的A.class是修改后的最新版本）</li></ol><p>限制条件有：</p><ol><li>只能修改方法实现；（方法已经运行）</li><li>不能改方法名；</li><li>不能改属性；</li></ol><h3 id="3-5-2、VisualVM"><a href="#3-5-2、VisualVM" class="headerlink" title="3.5.2、VisualVM"></a>3.5.2、VisualVM</h3><h3 id="3-5-3、Profiler"><a href="#3-5-3、Profiler" class="headerlink" title="3.5.3、Profiler"></a>3.5.3、Profiler</h3><h3 id="3-5-4、GCEasy"><a href="#3-5-4、GCEasy" class="headerlink" title="3.5.4、GCEasy"></a>3.5.4、GCEasy</h3><h3 id="3-5-5、GCViewer"><a href="#3-5-5、GCViewer" class="headerlink" title="3.5.5、GCViewer"></a>3.5.5、GCViewer</h3><h2 id="3-6、调优案例"><a href="#3-6、调优案例" class="headerlink" title="3.6、调优案例"></a>3.6、调优案例</h2><h3 id="3-6-1、案例一"><a href="#3-6-1、案例一" class="headerlink" title="3.6.1、案例一"></a>3.6.1、案例一</h3><h4 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigDecimal</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Date</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ScheduledThreadPoolExecutor</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ThreadPoolExecutor</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FullGC_Problem01</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CardInfo</span><span class="token punctuation">&#123;</span>        <span class="token class-name">BigDecimal</span> bigDecimal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"ZhangSan"</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>        <span class="token class-name">Date</span> birthdate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ScheduledThreadPoolExecutor</span> executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>DiscardOldestPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        executor<span class="token punctuation">.</span><span class="token function">setMaximumPoolSize</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">modelFit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">modelFit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CardInfo</span><span class="token punctuation">></span></span> taskList <span class="token operator">=</span> <span class="token function">getAllCardInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        taskList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>info <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            executor<span class="token punctuation">.</span><span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>                info<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CardInfo</span><span class="token punctuation">></span></span> <span class="token function">getAllCardInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CardInfo</span><span class="token punctuation">></span></span> taskList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">CardInfo</span> ci <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CardInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            taskList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> taskList<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h4><p><strong>1）运行测试程序</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> <span class="token parameter variable">-Xms200m</span> <span class="token parameter variable">-Xmx200m</span> <span class="token parameter variable">-XX:+PrintGC</span> <span class="token parameter variable">-XX:+HeapDumpOnOutOfMemoryError</span> FullGC_Problem01<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2）查看CPU占用，拿到占比较高的进程ID。</strong></p><p>通过命令 top 查找耗费CPU最高的进程PID，比如3568。</p><p><strong>3）找到CPU占用最高的线程ID，查看线程运行情况。</strong></p><ol><li>通过命令 <code>top -Hp 3568</code> 查找当前进程中耗费CPU最高的线程PID，比如1374；</li><li>通过命令 <code>printf &quot;%x\n&quot; 1374</code>可以把线程PID转为16进制，得到 55e；</li><li>通过命令<code>jstack 3568 | grep -20 55e</code>查找当前线程阻塞的地方；</li></ol><p><strong>4）查看线程运行情况</strong>：执行<code>jinfo pid</code>命令。</p><p><strong>5）观察GC执行情况。</strong></p><p>通过命令<code>jstat -gc PID</code> 观察gc动态情况，阅读GC日志发现频繁GC，arthas观察，jconsole，jvisualVM，Jprofiler（最好用）。</p><p>通过命令<code>jstat -gc 4655 500</code>实现每500毫秒打印一次GC情况。</p><blockquote><p>注意：图形界面监控一般适用于测试阶段，线上系统监控一般使用命令行调式工具——cmdline、Arthas。</p></blockquote><p><strong>6）查看对象创建的数量。</strong></p><p>通过命令<code>jmap - histo pid | head -20</code>查看对象创建数量排名前20的对象信息。</p><p><strong>7）导出dump信息文件。</strong></p><p>通过命令<code>jmap -dump:format=b,file=D:\test\heap.hprof 6956</code>将当前堆栈信息导出到一个文件中。</p><blockquote><p>线上系统，内存特别大，jmap执行期间会对进程产生很大影响，甚至卡顿（电商不适合）</p><ol><li>设定参数HeapDump，OOM的时会自动产生堆转储文件（不是很专业，因为多有监控，内存增长就会报警。</li><li>多服务器备份（高可用），停掉这台服务器对其他服务器不影响。</li><li>在线定位(一般小点儿公司用不到)。</li><li>在测试环境中压测（产生类似内存增长问题，在堆还不是很大的时候进行转储）。</li></ol></blockquote><p><strong>8）重新运行测试程序。</strong></p><p><code>java -Xms20M -Xmx20M -XX:+UseParallelGC -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/opt/test_jvm/gc_out/ FullGC_Problem01</code></p><p><strong>9）分析dump文件。</strong></p><p>使用<code>MAT、jhat、jvisualvm</code>工具来分析dump文件。</p><p>执行命令<code>jhat -J-Xmx512M xxx.hprof</code>后会在端口7000起一个服务，通过浏览器可以访问该服务并对其执行相关操作，比如可以使用OQL查找特定问题对象。</p><p><strong>10）找出代码问题。</strong></p><h2 id="3-7、GC日志详解"><a href="#3-7、GC日志详解" class="headerlink" title="3.7、GC日志详解"></a>3.7、GC日志详解</h2><h3 id="3-7-1、准备"><a href="#3-7-1、准备" class="headerlink" title="3.7.1、准备"></a>3.7.1、准备</h3><p>测试代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">LinkedList</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloGC</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HellGC."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试一：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 命令</span><span class="token function">java</span> <span class="token parameter variable">-XX:+PrintCommandLineFlags</span> HelloGC<span class="token comment"># 输出</span><span class="token parameter variable">-XX:InitialHeapSize</span><span class="token operator">=</span><span class="token number">29592512</span> <span class="token parameter variable">-XX:MaxHeapSize</span><span class="token operator">=</span><span class="token number">473480192</span> <span class="token parameter variable">-XX:+PrintCommandLineFlags</span> <span class="token parameter variable">-XX:+UseCompressedClassPointers</span> <span class="token parameter variable">-XX:+UseCompressedOops</span> HelloGCException <span class="token keyword">in</span> thread <span class="token string">"main"</span> java.lang.OutOfMemoryError: Java heap space at HelloGC.main<span class="token punctuation">(</span>HelloGC.java:9<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试二：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 命令</span><span class="token function">java</span> <span class="token parameter variable">-Xmn10M</span> <span class="token parameter variable">-Xms40M</span> <span class="token parameter variable">-Xmx60M</span> <span class="token parameter variable">-XX:+PrintCommandLineFlags</span> <span class="token parameter variable">-XX:+PrintGC</span> HelloGC PrintGCDetails PrintGCTimeStamps PrintGCCauses<span class="token comment"># 输出</span><span class="token parameter variable">-XX:InitialHeapSize</span><span class="token operator">=</span><span class="token number">41943040</span> <span class="token parameter variable">-XX:MaxHeapSize</span><span class="token operator">=</span><span class="token number">62914560</span> <span class="token parameter variable">-XX:MaxNewSize</span><span class="token operator">=</span><span class="token number">10485760</span> <span class="token parameter variable">-XX:NewSize</span><span class="token operator">=</span><span class="token number">10485760</span> <span class="token parameter variable">-XX:+PrintCommandLineFlags</span> <span class="token parameter variable">-XX:+PrintGC</span> <span class="token parameter variable">-XX:+UseCompressedClassPointers</span> <span class="token parameter variable">-XX:+UseCompressedOops</span> HelloGC<span class="token punctuation">[</span>GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  7675K-<span class="token operator">></span>7426K<span class="token punctuation">(</span>39936K<span class="token punctuation">)</span>, <span class="token number">0.0065081</span> secs<span class="token punctuation">]</span><span class="token punctuation">[</span>GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  14756K-<span class="token operator">></span>14594K<span class="token punctuation">(</span>39936K<span class="token punctuation">)</span>, <span class="token number">0.0066781</span> secs<span class="token punctuation">]</span><span class="token punctuation">[</span>GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  21916K-<span class="token operator">></span>21762K<span class="token punctuation">(</span>39936K<span class="token punctuation">)</span>, <span class="token number">0.0082077</span> secs<span class="token punctuation">]</span><span class="token punctuation">[</span>GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  29086K-<span class="token operator">></span>28931K<span class="token punctuation">(</span>39936K<span class="token punctuation">)</span>, <span class="token number">0.0062089</span> secs<span class="token punctuation">]</span><span class="token punctuation">[</span>GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  36256K-<span class="token operator">></span>36099K<span class="token punctuation">(</span>45076K<span class="token punctuation">)</span>, <span class="token number">0.0077737</span> secs<span class="token punctuation">]</span><span class="token punctuation">[</span>Full GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  36099K-<span class="token operator">></span>36098K<span class="token punctuation">(</span>45076K<span class="token punctuation">)</span>, <span class="token number">0.0023287</span> secs<span class="token punctuation">]</span><span class="token punctuation">[</span>GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  43424K-<span class="token operator">></span>43266K<span class="token punctuation">(</span>60416K<span class="token punctuation">)</span>, <span class="token number">0.0068826</span> secs<span class="token punctuation">]</span><span class="token punctuation">[</span>GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  50592K-<span class="token operator">></span>50434K<span class="token punctuation">(</span>60416K<span class="token punctuation">)</span>, <span class="token number">0.0075865</span> secs<span class="token punctuation">]</span><span class="token punctuation">[</span>Full GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  57761K-<span class="token operator">></span>57603K<span class="token punctuation">(</span>60416K<span class="token punctuation">)</span>, <span class="token number">0.0027358</span> secs<span class="token punctuation">]</span><span class="token punctuation">[</span>Full GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  57603K-<span class="token operator">></span>57591K<span class="token punctuation">(</span>60416K<span class="token punctuation">)</span>, <span class="token number">0.0022941</span> secs<span class="token punctuation">]</span>Exception <span class="token keyword">in</span> thread <span class="token string">"main"</span> java.lang.OutOfMemoryError: Java heap space at HelloGC.main<span class="token punctuation">(</span>HelloGC.java:9<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试三：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 命令</span><span class="token function">java</span> <span class="token parameter variable">-XX:+UseConcMarkSweepGC</span> <span class="token parameter variable">-XX:+PrintCommandLineFlags</span> HelloGC <span class="token comment"># 输出</span><span class="token parameter variable">-XX:InitialHeapSize</span><span class="token operator">=</span><span class="token number">29592512</span> <span class="token parameter variable">-XX:MaxHeapSize</span><span class="token operator">=</span><span class="token number">473480192</span> <span class="token parameter variable">-XX:MaxNewSize</span><span class="token operator">=</span><span class="token number">87244800</span> <span class="token parameter variable">-XX:MaxTenuringThreshold</span><span class="token operator">=</span><span class="token number">6</span> <span class="token parameter variable">-XX:OldPLABSize</span><span class="token operator">=</span><span class="token number">16</span> <span class="token parameter variable">-XX:+PrintCommandLineFlags</span> <span class="token parameter variable">-XX:+UseCompressedClassPointers</span> <span class="token parameter variable">-XX:+UseCompressedOops</span> <span class="token parameter variable">-XX:+UseConcMarkSweepGC</span> <span class="token parameter variable">-XX:+UseParNewGC</span> HelloGCException <span class="token keyword">in</span> thread <span class="token string">"main"</span> java.lang.OutOfMemoryError: Java heap space at HelloGC.main<span class="token punctuation">(</span>HelloGC.java:9<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-7-2、示例日志1"><a href="#3-7-2、示例日志1" class="headerlink" title="3.7.2、示例日志1"></a>3.7.2、示例日志1</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">[</span><span class="token constant">GC</span> <span class="token punctuation">(</span><span class="token class-name">Allocation</span> <span class="token class-name">Failure</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token class-name">DefNew</span> <span class="token punctuation">(</span>promotion failed<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">123228</span>K<span class="token operator">-></span><span class="token function">138592K</span><span class="token punctuation">(</span><span class="token number">138816</span>K<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0698705</span> secs<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">Tenured</span><span class="token operator">:</span> <span class="token number">308488</span>K<span class="token operator">-></span><span class="token function">308488K</span><span class="token punctuation">(</span><span class="token number">308608</span>K<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0097199</span> secs<span class="token punctuation">]</span> <span class="token number">360036</span>K<span class="token operator">-></span><span class="token function">359693K</span><span class="token punctuation">(</span><span class="token number">447424</span>K<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token class-name">Metaspace</span><span class="token operator">:</span> <span class="token number">2500</span>K<span class="token operator">-></span><span class="token function">2500K</span><span class="token punctuation">(</span><span class="token number">1056768</span>K<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0.0796660</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token class-name">Times</span><span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.02</span> sys<span class="token operator">=</span><span class="token number">0.06</span><span class="token punctuation">,</span> real<span class="token operator">=</span><span class="token number">0.07</span> secs<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>GC：指YGC。</li><li>(Allocation Failure)：GC原因。</li><li>DefNew：产生的年代，这里是年轻代；后面的：123228K-&gt;138592K(138816K), 0.0698705 secs，其从左到右分别代表：回收前年轻代大小-&gt;回收后年轻代大小(整个年轻代的大小)，回收所消耗的时间；</li><li>[Tenured: 308488K-&gt;308488K(308608K), 0.0097199 secs]：从左到右分别代表：回收前堆大小-&gt;回收后堆大小(整个堆的大小)，回收消耗的时间。</li><li>[Metaspace: 2500K-&gt;2500K(1056768K)], 0.0796660 secs]：从左到右分别代表：回收前元空间大小-&gt;回收后大小(整个元空间的大小)，回收消耗的时间。</li><li>[Times: user&#x3D;0.02 sys&#x3D;0.06, real&#x3D;0.07 secs]：从左到右分别代表：用户态消耗的时间、内核态消耗的时间，整个过程实际消耗多长时间。</li></ul><h3 id="3-7-3、示例日志2"><a href="#3-7-3、示例日志2" class="headerlink" title="3.7.3、示例日志2"></a>3.7.3、示例日志2</h3><p>一旦内存溢出，就会把整个堆 heap dump出来：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Heap</span> def <span class="token keyword">new</span> generation   total <span class="token number">138816</span>K<span class="token punctuation">,</span> used <span class="token number">138753</span>K <span class="token punctuation">[</span><span class="token number">0x00000000e3c00000</span><span class="token punctuation">,</span> <span class="token number">0x00000000ed2a0000</span><span class="token punctuation">,</span> <span class="token number">0x00000000ed2a0000</span><span class="token punctuation">)</span>  eden space <span class="token number">123392</span>K<span class="token punctuation">,</span> <span class="token number">100</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000e3c00000</span><span class="token punctuation">,</span> <span class="token number">0x00000000eb480000</span><span class="token punctuation">,</span> <span class="token number">0x00000000eb480000</span><span class="token punctuation">)</span>  from space <span class="token number">15424</span>K<span class="token punctuation">,</span>  <span class="token number">99</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ec390000</span><span class="token punctuation">,</span> <span class="token number">0x00000000ed290478</span><span class="token punctuation">,</span> <span class="token number">0x00000000ed2a0000</span><span class="token punctuation">)</span>  <span class="token keyword">to</span>   <span class="token namespace">space</span> <span class="token number">15424</span>K<span class="token punctuation">,</span>   <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000eb480000</span><span class="token punctuation">,</span> <span class="token number">0x00000000eb480000</span><span class="token punctuation">,</span> <span class="token number">0x00000000ec390000</span><span class="token punctuation">)</span> tenured generation   total <span class="token number">308608</span>K<span class="token punctuation">,</span> used <span class="token number">308477</span>K <span class="token punctuation">[</span><span class="token number">0x00000000ed2a0000</span><span class="token punctuation">,</span> <span class="token number">0x0000000100000000</span><span class="token punctuation">,</span> <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>   the space <span class="token number">308608</span>K<span class="token punctuation">,</span>  <span class="token number">99</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ed2a0000</span><span class="token punctuation">,</span> <span class="token number">0x00000000fffdf618</span><span class="token punctuation">,</span> <span class="token number">0x00000000fffdf800</span><span class="token punctuation">,</span> <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span> <span class="token class-name">Metaspace</span>       used <span class="token number">2531</span>K<span class="token punctuation">,</span> capacity <span class="token number">4486</span>K<span class="token punctuation">,</span> committed <span class="token number">4864</span>K<span class="token punctuation">,</span> reserved <span class="token number">1056768</span>K  <span class="token keyword">class</span> space    used <span class="token number">272</span>K<span class="token punctuation">,</span> capacity <span class="token number">386</span>K<span class="token punctuation">,</span> committed <span class="token number">512</span>K<span class="token punctuation">,</span> reserved <span class="token number">1048576</span>K<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><font color='orange'>Metaspace  used 2531K, capacity 4486K, committed 4864K, reserved 1056768K</font></p><p>2531K表示已使用；4486K表示总容量；4864K表示虚拟内存占用；1056768K表示虚拟内存保留容量。</p></li><li><p><font color='orange'>total &#x3D; eden + 一个survivor</font></p></li><li><p><font color='orange'>年轻代大小加起来不相等？因为：除了new的对象、整个年轻代外还有其他信息。观察日志主要看的是变化。</font></p></li></ul><h2 id="3-8、OOM问题案例"><a href="#3-8、OOM问题案例" class="headerlink" title="3.8、OOM问题案例"></a>3.8、OOM问题案例</h2><h3 id="3-8-1、常见"><a href="#3-8-1、常见" class="headerlink" title="3.8.1、常见"></a>3.8.1、常见</h3><ol><li><p>线程池使用不当导致OOM。</p></li><li><p>tomcat http-head-size过大导致OOM问题。</p><p>原因分析：由于Http11OutPutBuffer对象大且多才造成OOM问题。</p></li><li><p>如果一个系统的内存使用不超10%，但观察GC日志发现FGC频繁发生，原因是什么？</p><p>原因分析：主动调用了<code>System.gc();</code></p></li></ol><h3 id="3-8-2、少见"><a href="#3-8-2、少见" class="headerlink" title="3.8.2、少见"></a>3.8.2、少见</h3><ol><li><p><strong>栈溢出问题（知道即可）</strong></p><p>原因分析：-Xss设定太小造成。</p></li><li><p><strong>lambda表达式导致方法区溢出问题（知道即可）</strong></p><p>测试前限制其方法区大小，便于快速重现问题。设置参数：</p><p><code>-XX:MaxMetaspaceSize=9M -XX:+PrintGCDeTAILS</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LambdaGC</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">I</span> i <span class="token operator">=</span> <span class="token class-name">C</span><span class="token operator">::</span><span class="token function">n</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">interface</span> <span class="token class-name">I</span><span class="token punctuation">&#123;</span>        <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">&#123;</span>        <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">n</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>直接内存溢出问题（少见，知道即可）</p><p>《深入理解虚拟机》P59，使用Unsafe分配直接内存，或使用NIO问题。</p></li><li><p>重写finalize引发频繁GC</p><p>小米云，HBase同步系统，系统通过nginx访问超时报警，最后排查结果：C++程序员重写finalize而引发的频繁GC问题。</p></li><li><p>Disruptor链长且大，对象也大且消费完不主动释放就会出现溢出问题。</p></li></ol><h2 id="3-9、垃圾回收器调优"><a href="#3-9、垃圾回收器调优" class="headerlink" title="3.9、垃圾回收器调优"></a>3.9、垃圾回收器调优</h2><h3 id="3-9-1、G1调优"><a href="#3-9-1、G1调优" class="headerlink" title="3.9.1、G1调优"></a>3.9.1、G1调优</h3><p>触发FGC的情况如下：</p><ul><li><p><strong>并发模式失败</strong></p><p>G1启动标记周期，但在Mix GC之前，老年代就被填满，此时G1会放弃标记周期。这种情形下，需要增加堆大小，或者调整周期（例如增加线程数-XX:ConcGCThreads等）。</p></li><li><p><strong>晋升失败或疏散失败</strong></p><p><font color='orange'>G1 GC时如果没有足够的内存供存活对象或晋升对象使用时会触发Full GC。可以在日志中看到（to-space exhausted）或者（to-space overflow）</font>。解决该问题的方式如下：</p><ol><li>增加<code>-XX:G1ReservePercent</code>选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存。</li><li>通过减少<code>-XX:InitiatingHeapOccupancyPercent</code>提前启动标记周期。</li><li>通过增加<code>-XX:ConcGCThreads</code>值来增加并行标记线程的数目。</li></ol></li><li><p><strong>巨型对象分配失败</strong></p><p>当巨型对象找不到空闲空间分配时会触发Full GC来释放空间。这种情况下，应该避免分配大量的巨型对象，增加内存或者增大<code>-XX:G1HeapRegionSize</code>，使巨型对象不再是巨型对象。</p></li></ul><h2 id="3-10、场景分析优化"><a href="#3-10、场景分析优化" class="headerlink" title="3.10、场景分析优化"></a>3.10、场景分析优化</h2><h3 id="3-10-1、卡慢场景"><a href="#3-10-1、卡慢场景" class="headerlink" title="3.10.1、卡慢场景"></a>3.10.1、卡慢场景</h3><p><strong>场景1</strong>：原服务器32位、1.5G内存堆，用户反馈慢。优化升级为64位、16G内存堆后，反馈更慢，反而不如从前。</p><p><strong>1）原网站为啥慢？</strong></p><p>多用户访问数据，故大量数据加载至内存，从而造成内存不足、频繁GC、STW长、响应时间慢等问题。</p><p><strong>2）为什么会卡顿？</strong></p><p>内存越大，FGC时间就会越长。</p><p><strong>3）如何应对？</strong></p><p>PS 更改为 PN + CMS 或者 G1。</p><h3 id="3-10-2、CPU消耗高问题"><a href="#3-10-2、CPU消耗高问题" class="headerlink" title="3.10.2、CPU消耗高问题"></a>3.10.2、CPU消耗高问题</h3><p>场景1：系统CPU经常100%，如何调优？</p><p>解决方案参考如下：</p><ol><li>找出消耗CPU较高的进程；可使用 top 命令查看。</li><li>该进程中哪个线程消耗CPU较高；可使用 top -Hp 命令查看。</li><li>导出该线程的堆栈；可使用 jstack 命令实现。</li><li>查找哪个方法（栈帧）的导致的问题。</li><li>工作线程占比高 | 垃圾回收线程占比高。</li></ol><h3 id="3-10-3、内存消耗高问题"><a href="#3-10-3、内存消耗高问题" class="headerlink" title="3.10.3、内存消耗高问题"></a>3.10.3、内存消耗高问题</h3><p>场景1：系统内存飙高，如何定位及应对？</p><p>参考解决方案如下：</p><ol><li>堆栈比较多，导出堆信息；可使用 jmap 命令实现。</li><li>分析之，分析工具有：jhat、jvisualvm、mat、jprofiler等。</li></ol><h3 id="3-10-4、如何监控JVM"><a href="#3-10-4、如何监控JVM" class="headerlink" title="3.10.4、如何监控JVM"></a>3.10.4、如何监控JVM</h3><p>工具：jstat、jvisualvm、jprofiler、arthas、top。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java系列-多线程与高并发</title>
      <link href="/2023/07/30/duo-xian-cheng-yu-gao-bing-fa-zhi-shi-zong-jie/"/>
      <url>/2023/07/30/duo-xian-cheng-yu-gao-bing-fa-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="1、并发编程基础"><a href="#1、并发编程基础" class="headerlink" title="1、并发编程基础"></a>1、并发编程基础</h1><h2 id="1-1、线程简介"><a href="#1-1、线程简介" class="headerlink" title="1.1、线程简介"></a>1.1、线程简介</h2><h3 id="1-1-1、重要概念"><a href="#1-1-1、重要概念" class="headerlink" title="1.1.1、重要概念"></a>1.1.1、重要概念</h3><h4 id="1-1-1-1、进程"><a href="#1-1-1-1、进程" class="headerlink" title="1.1.1.1、进程"></a>1.1.1.1、进程</h4><p><font color='orange'>系统资源分配的基本单位。</font></p><p>若要实现 多程序并发执行，操作系统需要一个 结构 来抽象和表示程序的运行。</p><ul><li>进程 是 操作系统 对正在运行程序的一种 抽象。</li><li>进程 是 由一组机器指令、数据和堆栈等组成的能独立运行的 活动实体。</li><li>操作系统 可以 同时运行多个进程，多个进程可并发执行和交换信息。</li><li>进程 在运行时 需要资源，如CPU、存储空间和I&#x2F;O设备等。</li></ul><blockquote><p>并发：同一时刻 只有一个进程或线程 在运行，但因 切换较快 而带给人的感觉像同时在运行。</p><p>并行：同一时刻 有多个进程或线程 在运行。</p></blockquote><h4 id="1-1-1-2、线程"><a href="#1-1-1-2、线程" class="headerlink" title="1.1.1.2、线程"></a>1.1.1.2、线程</h4><p><font color='orange'>CPU调度的基本单位。</font></p><p>进程调度成本较高（存储空间，CPU，I&#x2F;O资源等，进程现场保护）并发切换效率较低。为提高调度效率，提出了比进程更轻量的线程。</p><ul><li>线程较进程更轻量。</li><li>线程能独立运行，独立调度，拥有资源（CPU资源，程序计数器等）。</li><li>线程调度成本较低（相对于进程来说），线程切换 不会导致 进程切换。</li><li>线程能并发执行，进一步提高系统并发性。</li><li>同一个进程的多个线程可以共享进程资源。</li></ul><h4 id="1-1-1-3、协程（coroutine）"><a href="#1-1-1-3、协程（coroutine）" class="headerlink" title="1.1.1.3、协程（coroutine）"></a>1.1.1.3、协程（coroutine）</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p><font color='orange'>最初 多数用户线程 被设计成 协同式调度 （Cooperative Scheduling），故起名为 协程（Coroutine）。</font>由于协程会做调用栈保护、恢复工作，故又称为【有栈协程（Stackfull Coroutine）】，相反也有【无栈协程（Stackless Coroutine）】。</p><p>无栈协程的典型应用是各种语言中的await、async、yield等关键字。无栈协程本质上是一种有限状态机，状态保存在闭包里，比有栈协程恢复调用栈要轻量，但功能也相对有限。</p><p>协程主要优势是轻量，无论是有栈协程还是无栈协程，都要比传统内核线程要轻量得多。</p><blockquote><p>有栈协程有一种实现称为【纤程（Fiber）】。</p></blockquote><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>协程特点如下：</p><ul><li>协程是【用户模式】下的【轻量级线程】，操作系统内核对协程一无所知。</li><li>协程调度 由 应用程序控制。</li><li>一个线程可以包含一个或多个协程。</li><li>协程有自己的寄存器上下文和栈，协程在调度切换时会将之保存，切换回来时可恢复至保存的状态。</li><li>协程可以保存上次的调用状态。</li><li>Windows下的实现叫【纤程】。</li><li>子程序调用总是一个入口对应一次返回，调用顺序明确。而协程的调用和子程序不同。</li></ul><p>协程主要一个线程执行，与多线程比，协程有如下优势：</p><ul><li><font color='orange'>执行效率极高</font>：子程序切换由程序控制，【没有线程切换】。</li><li><font color='orange'>无需多线程锁机制</font>：因为只有一个线程，也不存在同时写变量冲突。协程中操作共享资源无需加锁，只判断状态即可，故 执行效率 较 多线程 要高。</li></ul><h4 id="1-1-1-4、仟程（fiber）"><a href="#1-1-1-4、仟程（fiber）" class="headerlink" title="1.1.1.4、仟程（fiber）"></a>1.1.1.4、仟程（fiber）</h4><p>代码移植性一直是平台间交互考虑的重点，将应用程序从Unix移植到Windows的过程中会存在一系列问题，增加了移植难度和成本。</p><p><font color='orange'>为了更正确地将代码移植到Windows，Microsoft 在操作系统中增加了纤程（Fiber）。</font>纤程与线程对比，有如下特性：</p><ul><li>线程在Windows内核中实现，操作系统会根据系统的调度算法对线程进行调度；纤程在用户模式下实现，内核对纤程一无所知。</li><li>纤程是【轻量级线程】，一个线程可包含一个或多个纤程。</li><li>内核会对线程进行抢占式调度，线程一次只能执行一个纤程代码（具体执行哪一个纤程由用户调度算法决定）。</li><li>纤程调度与线程调度没有直接关系，操作系统随时可能会夺取纤程所在线程的运行权。</li><li>正在运行的纤程显式切换到另一个纤程时这个纤程才可以运行。</li><li>Windows有一套API来实现线程转纤程或在一个线程里面创建多个纤程。</li></ul><h4 id="1-1-1-5、管程"><a href="#1-1-1-5、管程" class="headerlink" title="1.1.1.5、管程"></a>1.1.1.5、管程</h4><p>临界资源 定义如下：</p><ul><li><font color='orange'>一次只允许一个进程访问的资源；</font></li><li><font color='orange'>多个进程只能互斥访问的资源；</font></li></ul><p>访问 临界资源 需要 同步，比如 信号量 就是一种 进程同步机制。信号量 要求 每个访问临界资源的进程都具有wait和signal操作。这样使大量的同步操作分散在各个进程中，不仅给系统管理带来了麻烦，且会因同步操作使用不当而导致死锁。为了解决这些问题，管程出现了。</p><blockquote><p>操作系统中管理的各种软件和硬件资源，均可用 数据结构 抽象地描述其资源特性。利用共享数据结构抽象地表示系统中的共享资源。而把对共享数据结构实施的操作定义为一组过程，如资源的请求和释放过程request和release。进程对共享资源的申请、释放和其他操作，都是通过这组过程来实现，这组过程还可以根据资源情况来选择接受或阻塞进程的访问，确保每次仅有一个进程使用该共享资源，实现临界资源互斥访问。</p></blockquote><p>管程 就是 共享资源的数据结构 和 对该共享数据结构实施的操作 两者组成的 【资源管理程序】。管程 由 【请求和释放临界资源的进程】 所调用。</p><p><font color='orange'>管程 定义了一个数据结构 和 管理该数据结构的一组操作。</font></p><h3 id="1-1-2、超线程"><a href="#1-1-2、超线程" class="headerlink" title="1.1.2、超线程"></a>1.1.2、超线程</h3><p><font color='orange'>超线程是Intel CPU设计上的一种技术。一个ALU + 两组Registers + PC。</font></p><p>一个CPU物理核同时只能执行一个线程，而线程的切换会消耗大量时间，效率还低。超线程是一个CPU物理核在同一时间几乎可以执行两个线程的技术。</p><h3 id="1-1-3、线程优先级"><a href="#1-1-3、线程优先级" class="headerlink" title="1.1.3、线程优先级"></a>1.1.3、线程优先级</h3><p>如今的操作系统 基本采用【时间片规则】来调度运行线程，操作系统会分出一个个时间片，然后分配给每个线程，当线程的时间片用完了就会发生线程调度，并等待着下次分配。线程得到时间片的多少就决定了线程能使用处理器资源的多少，而线程优先级就可以一定程度上决定线程得到时间片的多少。</p><p><font color='orange'>Java线程可以通过整型变量<code>priority</code>来控制优先级，优先级范围从1至10。创建线程时可通过方法<code>setPriority(int)</code>来设置优先级，默认优先级为5，优先级高的线程得到时间片的数量要多于优先级低的线程。</font></p><p>针对频繁阻塞（休眠或I&#x2F;O操作）的线程需要设置较高的优先级，而偏重计算（需要较多CPU时间）的线程则可以设置较低的优先级，确保处理器不会被独占。</p><p><font color="red">注意：线程优先级的设定并非一定起作用，因为操作系统不一定会重视。</font></p><h3 id="1-1-4、线程状态"><a href="#1-1-4、线程状态" class="headerlink" title="1.1.4、线程状态"></a>1.1.4、线程状态</h3><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210426211305027.png" alt="image-20210426211305027"></p><p><font color='orange'>Java线程在整个生命周期中有6种不同的状态，某一个时间， 线程只能处于其中的一个状态。</font></p><ol><li><p><font color='orange'>NEW（初始状态）</font></p><p>线程被构建，但没有调用start方法。</p></li><li><p><font color='orange'>RUNNABLE（运行状态）</font></p><p>Java线程将就绪和运行两种状态统称为“运行中”。</p></li><li><p><font color='orange'>BLOCKED（阻塞状态）</font></p><p>表示线程阻塞于锁。</p></li><li><p><font color='orange'>WAITING（等待状态）</font></p><p>表示当前线程 需要等待 其它线程做出一些特定操作（通知或中断）。</p></li><li><p><font color='orange'>TIME_WAITING（超时等待状态）</font></p><p>该状态不同于WAITING，它可以在指定时间内自动返回。</p></li><li><p><font color='orange'>TERMINATED（终止状态）</font></p><p>表示当前线程已经执行完毕。</p></li></ol><h3 id="1-1-5、daemon线程"><a href="#1-1-5、daemon线程" class="headerlink" title="1.1.5、daemon线程"></a>1.1.5、daemon线程</h3><p>Daemon（守护）线程是一种支持型线程，因为它主要被用于 程序后台调度及支持性工作。当一个Java虚拟机中不存在非Daemon线程时，Java虚拟机将会退出。可以通过调用<code>Thread.setDaemon(true)</code>将线程设置为Daemon线程。</p><p><font color='red'>注意：Daemon属性需要 在【线程启动之前】设置。且Java虚拟机退出时Daemon线程中的finally块并不一定会执行。</font></p><h2 id="1-2、启动终止线程"><a href="#1-2、启动终止线程" class="headerlink" title="1.2、启动终止线程"></a>1.2、启动终止线程</h2><h3 id="1-2-1、启动线程"><a href="#1-2-1、启动线程" class="headerlink" title="1.2.1、启动线程"></a>1.2.1、启动线程</h3><h4 id="1-2-1-1、启动线程的方式"><a href="#1-2-1-1、启动线程的方式" class="headerlink" title="1.2.1.1、启动线程的方式"></a>1.2.1.1、启动线程的方式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Callable</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ExecutorService</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Executors</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">FutureTask</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">T02_HowToCreateThread</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello MyThread!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyRun</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello MyRun!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyCall</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello MyCall"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//启动线程的5种方式</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello Lambda!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyCall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello ThreadPool"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        service<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-1-2、Callable的使用"><a href="#1-2-1-2、Callable的使用" class="headerlink" title="1.2.1.2、Callable的使用"></a>1.2.1.2、Callable的使用</h4><h5 id="相关类结构图"><a href="#相关类结构图" class="headerlink" title="相关类结构图"></a>相关类结构图</h5><p>接口Callable是一个单独的接口，与之相关的类内部结构图可参考如下：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210706113047202.png" alt="image-20210706113047202"></p><h5 id="Callable使用实例"><a href="#Callable使用实例" class="headerlink" title="Callable使用实例"></a>Callable使用实例</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StartThreadByCallable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">MyCallable</span> callable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">FutureTask</span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Object</span> result <span class="token operator">=</span> futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result: "</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> <span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">MyCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-2、理解中断"><a href="#1-2-2、理解中断" class="headerlink" title="1.2.2、理解中断"></a>1.2.2、理解中断</h3><p>中断 可理解为是 线程的标识位属性，它表示一个运行中的线程是否被其他线程执行了中断操作。通过调用线程的interrupt() 方法可以实现中断线程的操作。</p><p>线程通过检查自身是否被中断来进行响应，方法isInterrupted()返回 线程是否被中断，静态方法Thread.interrupted() 返回当前中断状态，并将中断标识设为false。</p><p><font color='red'>注意：终结状态下的线程，即使曾经被中断过，那么方法 isInterrupted() 依旧会返回false。</font></p><h3 id="1-2-3、过期方法"><a href="#1-2-3、过期方法" class="headerlink" title="1.2.3、过期方法"></a>1.2.3、过期方法</h3><p>suspend()、resume()和stop()方法 可以实现 线程的暂停、恢复和终止。但这些API已经过期，不建议使用。</p><p><font color='red'>不推荐原因：调用方法suspend()后，线程不会释放已经占有的资源（比如锁），而会占有着资源进入睡眠状态，这样易引发死锁问题。stop()方法在终结 一个线程时 不能保证 正常释放线程资源。</font></p><blockquote><p>暂停和恢复操作可以用【等待&#x2F;通知】机制来替代。</p></blockquote><h3 id="1-2-4、安全终止线程"><a href="#1-2-4、安全终止线程" class="headerlink" title="1.2.4、安全终止线程"></a>1.2.4、安全终止线程</h3><p><font color='orange'>通过 标识位或中断操作  可以实现 线程终止时有机会清理资源，而非立即停止。这种方法更加安全和优雅。</font> </p><h3 id="1-2-5、小结"><a href="#1-2-5、小结" class="headerlink" title="1.2.5、小结"></a>1.2.5、小结</h3><p>可中断的场景如下：</p><ol><li>Lock</li><li>Object相关方法（wait）</li><li>Thread相关方法（join、sleep）</li></ol><p>不可中断场景如下：</p><ol><li>synchronized锁</li></ol><h2 id="1-3、线程间通信"><a href="#1-3、线程间通信" class="headerlink" title="1.3、线程间通信"></a>1.3、线程间通信</h2><h3 id="1-3-1、volatile-synchronized"><a href="#1-3-1、volatile-synchronized" class="headerlink" title="1.3.1、volatile &#x2F; synchronized"></a>1.3.1、volatile &#x2F; synchronized</h3><ul><li><p><font color='orange'>volatile</font></p><p>关键字volatile 可修饰字段，其作用是 访问该变量时 需要 从共享内存中获取，而对该变量的修改必须同步刷新至共享内存，它能保证所有线程对变量访问的【可见性】。</p></li><li><p><font color='orange'>synchronized</font></p><p>关键字synchronized可修饰方法 或 以同步块形式使用，可以保证 多个线程在同一时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的【可见性和排他性】。</p></li></ul><h3 id="1-3-2、等待-通知机制及范式"><a href="#1-3-2、等待-通知机制及范式" class="headerlink" title="1.3.2、等待&#x2F;通知机制及范式"></a>1.3.2、等待&#x2F;通知机制及范式</h3><h4 id="1-3-2-1、等待通知机制"><a href="#1-3-2-1、等待通知机制" class="headerlink" title="1.3.2.1、等待通知机制"></a>1.3.2.1、等待通知机制</h4><p>等待&#x2F;通知机制是指：<font color='orange'>线程A调用对象O的wait()方法后会进入等待状态，线程B 调用了 对象O的notify()或notifyAll()方法后会通知线程A从对象O的wait()方法返回，进而执行后续操作。</font></p><p>调用wait()、notify()、notifyAll()时的 注意事项 如下：</p><ol><li>使用 wait()、notify() 和 notifyAll() 时需要先对调用对象加锁。</li><li>调用wait()方法后，会将当前线程放入对象的 等待队列，线程状态由RUNNING变为WAITING。</li><li>调用notify()、notifyAll()方法的线程释放锁之后，等待线程才会从wait()返回。</li><li>notify()方法会将等待队列中的一个等待线程移到同步队列中，而notifyAll() 方法会作用于全部线程，被移动线程的状态会由WAITING变为 BLOCKED。</li><li>获得调用对象的锁后才能从wait()方法返回。</li></ol><h4 id="1-3-2-2、等待通知范式"><a href="#1-3-2-2、等待通知范式" class="headerlink" title="1.3.2.2、等待通知范式"></a>1.3.2.2、等待通知范式</h4><p><font color='orange'>范式分为两部分：等待方（消费者）、通知方（生产者）。</font></p><ul><li>等待方<ol><li>获取对象的锁；</li><li>如果条件不满足，那么调用对象的wait方法，被通知后仍要检查条件；</li><li>条件满足则执行对应的逻辑；</li></ol></li><li>通知方<ol><li>获得对象的锁；</li><li>改变条件；</li><li>通知所有等待在对象上的线程；</li></ol></li></ul><h3 id="1-3-3、管道输入-输出流"><a href="#1-3-3、管道输入-输出流" class="headerlink" title="1.3.3、管道输入&#x2F;输出流"></a>1.3.3、管道输入&#x2F;输出流</h3><p><font color='orange'>管道输入&#x2F;输出流和普通的文件输入&#x2F;输出流或者网络输入&#x2F;输出流的不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</font></p><p>管道输入&#x2F;输出流主要包括了4种具体实现：</p><ul><li>面向字节：PipedInputStream、PipedOutputStream；</li><li>面向字符：PipedReader、PipedWriter；</li></ul><h3 id="1-3-4、Thread-join"><a href="#1-3-4、Thread-join" class="headerlink" title="1.3.4、Thread.join"></a>1.3.4、Thread.join</h3><p><font color='orange'>线程A执行thread.join()方法 表示：线程A等待thread线程终止之后才从thread.join()返回。</font></p><p>除了<code>join()</code>方法外，还提供了<code>join(long millis)</code>和<code>join(long millis, int nanos)</code>两个超时方法。两个超时方法作用：如果线程在给定的超时时间内 没有终止，那么会直接返回。</p><h3 id="1-3-5、ThreadLocal"><a href="#1-3-5、ThreadLocal" class="headerlink" title="1.3.5、ThreadLocal"></a>1.3.5、ThreadLocal</h3><p>ThreadLocal是一个以ThreadLocal对象为键、任意对象为值的存储结构。该结构存在于线程上，故一个线程可以根据一个ThreadLocal对象来查询绑定在该线程上的数据。</p><p>对于线程A，可以通过A.set(T)方法来设置一个值，然后通过A.get()方法获取到原先设置的值。</p><h1 id="2、CPU"><a href="#2、CPU" class="headerlink" title="2、CPU"></a>2、CPU</h1><h2 id="2-1、缓存行"><a href="#2-1、缓存行" class="headerlink" title="2.1、缓存行"></a>2.1、缓存行</h2><h3 id="2-1-1、概述"><a href="#2-1-1、概述" class="headerlink" title="2.1.1、概述"></a>2.1.1、概述</h3><p>CPU缓存行是计算机体系架构中的一个概念，用于描述主存储器和CPU缓存之间的数据传输单位。缓存行是CPU缓存中最小的可寻址单位，也是一次从主存储器中读取数据块的大小。</p><p>缓存行的大小是固定，通常为32字节或64字节，具体取决于CPU的设计。缓存行是按连续的内存地址来分割主存储器的，且在CPU缓存中以相同的方式进行组织。</p><blockquote><p>为何CPU缓存行大小通常为64字节？原因分析有以下几点：</p><ul><li>空间局部性。相邻数据被访问的可能性较大，一次加载连续的内存数据到缓存行中，可以利用这种局部性，减少对主存储器的访问次数，提高数据访问效率。</li><li>数据传输效率。CPU与主存储器之间的数据传递是通过总线进行了，总线传输带宽是有限的，一次性加载较大的缓存行可以充分利用总线的宽度，减少数据传输的次数，提高数据传输效率。</li><li>缓存行对齐。通常来说，数据的访问需要满足对齐要求。对齐要求是指数据存储在内存中的起始地址必需是某个值（缓存行大小）的倍数。如果不满足对齐要求，CPU需要做额外的工作来获取正确的数据，这增加了访问延迟。通过设定缓存行大小为64字节，可以确保大多数数据类型都能满足对齐要求。</li><li>缓存容量与成本均衡。增加缓存行的大小可以提高缓存命中率，提高数据访问效率。但较大的缓存行也会占用更多的缓存容量。通过选择适当的缓存行大小，可以在缓存容量和性能之间取得平衡。</li></ul></blockquote><p>当CPU需要从主存储器中读取数据时，它会以缓存行为单位进行操作。如果要读取的数据位于缓存行中，CPU会一次性将整个缓存行加载到CPU缓存中，后期需要读取相邻数据时可直接从缓存中读取，提高了读取效率。</p><p>缓存行的引入是为了解决主存储器与CPU之间速度差异的问题。但缓存行的引入也带来了一些问题，第一个问题就是缓存行对内存的占用，加载到缓存的数据可能只使用了部分，而剩余的空间被浪费了，这也被称为缓存行浪费或缓存行膨胀。第二个问题就是缓存一致性问题，当多个CPU访问共享内存时，由于每个CPU都有自己的缓存，可能造成缓存的不一致，而这可以通过缓存一致性协议来解决。</p><h3 id="2-1-2、四个状态"><a href="#2-1-2、四个状态" class="headerlink" title="2.1.2、四个状态"></a>2.1.2、四个状态</h3><p><font color='orange'>Modified（修改）、Exclusive（独占）、Shared（共享）、Invalid（无效）。</font></p><h2 id="2-2、用户态与内核态"><a href="#2-2、用户态与内核态" class="headerlink" title="2.2、用户态与内核态"></a>2.2、用户态与内核态</h2><h3 id="2-2-1、概述"><a href="#2-2-1、概述" class="headerlink" title="2.2.1、概述"></a>2.2.1、概述</h3><p>用户态与内核态是操作系统中的两种执行模式，用于区分运行在不同特权级别下程序和系统内核。</p><p>用户态是为用户应用程序提供的一种执行缓存。用户态下的程序只能访问有限的资源和执行有限的操作。</p><p>内核态是操作系统的特权执行模式，拥有对操作系统核心和硬件资源的完全控制权。内核态下的系统内核程序可以执行任何指令和访问任何资源。内核态程序可以执行特权指令、管理内存、调度任务等。</p><p>当用户程序需要执行特权操作时，会触发一次用户态到内核态的转变，系统内核会接管特权并执行相关操作，操作完成后，再交给用户程序，用户程序继续执行。</p><h3 id="2-2-2、ring-0-1-2-3"><a href="#2-2-2、ring-0-1-2-3" class="headerlink" title="2.2.2、ring 0  1  2  3"></a>2.2.2、ring 0  1  2  3</h3><p>CPU Ring 0、1、2、3是一种权限级别划分，这种划分通常用于X86体系结构中的操作系统和处理器。</p><p>X86体系结构中，特权级别使用4个环（Ring）来表示，每个环对应一种特权级别，这些环被称为Ring0、1、2、3，也被称为内核态、系统态、用户态、应用态。</p><ul><li><p>Ring 0（内核态）</p><p>Ring 0 是操作系统内核运行的特权级别，拥有最高的特权和访问权限。系统内核可以执行所有指令，访问系统的所有资源和硬件设备。</p></li><li><p>Ring 1（系统态）</p><p>Rng 1 是保留给操作系统的第二特权级别，拥有较高的特权和访问权限。系统可以执行受限的指令集和访问部分授权的资源。</p></li><li><p>Ring 2（用户态）</p><p>Rng 1 是保留给操作系统的第三特权级别，比Ring 3有更高的特权。系统可以执行受限的指令集和访问部分授权的资源。</p></li><li><p>Ring 3（应用态）</p><p>Ring 3 是用户程序运行的特权级别，拥有最低的特权和访问权限。程序只能执行授权的指令集，访问有限的资源和执行授权动作。</p></li></ul><p>CPU运行级别会在 Ring3 和 Ring0 间的进行切换称为<strong>用户态和内核态的切换</strong>。   </p><h3 id="2-2-3、上下文切换"><a href="#2-2-3、上下文切换" class="headerlink" title="2.2.3、上下文切换"></a>2.2.3、上下文切换</h3><h4 id="2-2-3-1、简介"><a href="#2-2-3-1、简介" class="headerlink" title="2.2.3.1、简介"></a>2.2.3.1、简介</h4><p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个 任务。在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以<font color='orange'>任务从保存到再加载的过程就是一次上下文切换。</font></p><p>上下文切换 会影响 多线程执行速度。</p><h4 id="2-2-3-2、测试上下文切换"><a href="#2-2-3-2、测试上下文切换" class="headerlink" title="2.2.3.2、测试上下文切换"></a>2.2.3.2、测试上下文切换</h4><p>使用<code>Lmbench3</code>可以测量上下文切换时长。使用<code>vmstat</code>可以测量上下文切换次数。</p><h4 id="2-2-3-3、减少上下文切换"><a href="#2-2-3-3、减少上下文切换" class="headerlink" title="2.2.3.3、减少上下文切换"></a>2.2.3.3、减少上下文切换</h4><p>减少上下文切换的方法：<font color='orange'>无锁并发编程、CAS算法、使用最少线程和使用协程。</font></p><p>实战示例：</p><ol><li><p>用<code>jstack</code>命令 dump 线程信息，看看 pid 为 3117 的进程中的线程在做什么。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token parameter variable">-u</span> admin /opt/ifeve/java/bin/jstack <span class="token number">31177</span> <span class="token operator">></span> /home/tengfei.fangtf/dump17<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>统计所有线程分别处于什么状态，发现300多个线程处于 WAITING 状态。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> java.lang.Thread.State dump17 <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&#123;print $2$3$4$5&#125;'</span> <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> <span class="token parameter variable">-c</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>打开dump文件查看处于 WAITING 线程在做什么。发现线程池中的线程接收任务太少，大量线程都闲着。</p></li><li><p>减少线程池中的线程数量。</p></li><li><p>重新启动服务并测试查看效果。</p></li></ol><h2 id="2-3、缓存一致性协议"><a href="#2-3、缓存一致性协议" class="headerlink" title="2.3、缓存一致性协议"></a>2.3、缓存一致性协议</h2><h3 id="2-3-1、种类"><a href="#2-3-1、种类" class="headerlink" title="2.3.1、种类"></a>2.3.1、种类</h3><p>协议类型主要有：MSI、MESI、MOSI、Synapse Firefly Dragon。intel CPU 使用的是MESI协议。</p><h3 id="2-3-2、MESI"><a href="#2-3-2、MESI" class="headerlink" title="2.3.2、MESI"></a>2.3.2、MESI</h3><p>M、E、S、I 标记 高速缓存行 四种独占状态（使用两个附加位编码）：</p><ol><li><font color='orange'>修改（M）</font>：高速缓存行仅存在于当前高速缓存中，并且是脏的 - 它已从主存储器中的值修改（M状态）。在允许对（不再有效）主存储器状态的任何其他读取之前，需要高速缓存在将来的某个时间将数据写回主存储器。回写将该行更改为共享状态（S）。</li><li><font color='orange'>独占（E）</font>：缓存行仅存在于当前缓存中，但是干净 - 它与主内存匹配。它可以随时更改为共享状态，以响应读取请求。或者，可以在写入时将其改变为修改状态。</li><li><font color='orange'>共享（S）</font>：表示此高速缓存行可能存储在计算机的其他高速缓存中并且是干净的 - 它与主存储器匹配。可以随时丢弃该行（更改为无效状态）。</li><li><font color='orange'>无效（I）</font>：表示此缓存行无效（未使用）。</li></ol><p>对于任何给定的高速缓存对，给定高速缓存行的允许状态如图：</p><img src="\imgs\javadev\image-20201008205937219.png" alt="image-20201008205937219" style="float: left;" /><p><font color='orange'>当块被标记为M（已修改）时，其他高速缓存中关于该块的副本将会被标记为I（无效）。</font></p><h3 id="2-3-3、优缺点"><a href="#2-3-3、优缺点" class="headerlink" title="2.3.3、优缺点"></a>2.3.3、优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>MESI多了一个E——“独占”状态。独占状态有许多优点。</p><p>加入独占状态的缘由：</p><ol><li><font color='orange'>对于“某个处理器需要读取其他处理器没有的块然后写入它”这种情况，会导致 MSI 下发生的两个总线事务（首先是BusRd请求，然后是BusRdX请求）中的第二个请求事务失效。而 MESI 通过添加Exclusive状态解决了这个问题。</font></li><li><font color='orange'>MSI不适用于顺序执行的应用程序，而MESI适用于高度并行的应用程序。</font></li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p><font color='red'>如果由特定块上的各种高速缓存执行【连续读取和写入】操作，则必须每次都将数据刷新到总线上。MOESI协议克服了这一问题。</font></p><h2 id="2-4、内存屏障"><a href="#2-4、内存屏障" class="headerlink" title="2.4、内存屏障"></a>2.4、内存屏障</h2><h3 id="2-4-1、硬件屏障"><a href="#2-4-1、硬件屏障" class="headerlink" title="2.4.1、硬件屏障"></a>2.4.1、硬件屏障</h3><ul><li><font color='orange'>sfence</font>：sava，sfence指令前写 先于 sfence指令后写。</li><li><font color='orange'>lfence</font>：load，lfence指令前读 先于 lfence指令后读。</li><li><font color='orange'>mfence</font>：modify&#x2F;mix，mfence指令前读写 先于 mfence指令后读写。</li></ul><h3 id="2-4-2、JVM内存屏障"><a href="#2-4-2、JVM内存屏障" class="headerlink" title="2.4.2、JVM内存屏障"></a>2.4.2、JVM内存屏障</h3><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200902211143739.png" alt="image-20200902211143739"></p><h1 id="3、JAVA对象"><a href="#3、JAVA对象" class="headerlink" title="3、JAVA对象"></a>3、JAVA对象</h1><h2 id="3-1、JAVA对象组成"><a href="#3-1、JAVA对象组成" class="headerlink" title="3.1、JAVA对象组成"></a>3.1、JAVA对象组成</h2><h3 id="3-1-1、对象结构"><a href="#3-1-1、对象结构" class="headerlink" title="3.1.1、对象结构"></a>3.1.1、对象结构</h3><p>Java对象保存在内存中时，由以下三部分组成：</p><ol><li><p><font color='orange'>对象头</font></p><ul><li>普通对象头：无压缩16字节，压缩后12字节；</li><li>数组对象头：无压缩24字节，压缩后16字节；</li></ul></li><li><p><font color='orange'>实例数据</font></p><p>HotSpot中，对象的实例数据会在对象头后分配空间。</p><p>字段的分配顺序受源码声明顺序以及HotSpot分配策略的影响。无论哪种分配策略，宽度相同的字段总是相邻分配的；不同宽度间的字段可能存在对其填充；</p><p>笼统说，基类声明的实例字段会出现在派生类声明的实例字段之前。但开启指针压缩后，派生类的较窄字段可能会插入到基类实例字段之间的对其填充部分。</p><p>相关参数：FieldsAllocationStyle CompactFields。</p></li><li><p><font color='orange'>对齐填充（使得最终对象大小是8的倍数）</font></p><p>HotSpot中，GC堆上的对象要求在8字节边界上分配；也就是说对象的起始地址必须是8的倍数，对象占用的空间也必须是8的倍数。</p><p>若对象时机需要的大小不足8的倍数，则用0填充不足的部分，直到8字节边界为止。</p><p>对齐填充可能出现在不同宽度的字段之间，也可能出现在对象的末尾；或者当不存在未对齐的数据时则不会出现对齐填充。</p></li></ol><p>Java对象头由三部分组成：</p><ol><li><p><font color='orange'>Mark Word（普通对象头无压缩为8字节，压缩后不变；数组对象头为8字节；）</font></p><p>HotSpot中，GC堆上的对象需要维持一些状态信息，如：</p><ul><li>身份哈希码（identity hash code）</li><li>是否已被GC标记（GC过程中需要）</li><li>当前对象年龄</li><li>当前是否被当作锁同步</li><li>持有对象锁的线程ID（用于偏向锁）</li><li>…….</li></ul><p>该部分会根据对象当前状态有选择性的记录其中一部分。</p></li><li><p><font color='orange'>Klass Point（普通对象头无压缩为8字节，压缩后4字节；数组对象头4字节）</font></p><p>开启压缩功能参数：<code>-XX:+UseCompressedClassPointers</code>。</p><p>HotSpot中，堆中的对象从C++角度看都是oopDesc子类的实例。每个对象都有一个_klass字段，指向一个描述自身的元数据的对象。</p><p>Java对象与数组的Klass并不是Java语言级的java.lang.class。Klass用于运行，而java.lang.class用于Java的反射API；前者中有_java_mirror字段指向后者。</p></li><li><p><font color='orange'>数组长度（数组对象才会存在该项）（数组对象长度占用4字节）</font></p></li></ol><h3 id="3-1-2、Mark-Word"><a href="#3-1-2、Mark-Word" class="headerlink" title="3.1.2、Mark Word"></a>3.1.2、Mark Word</h3><p>64位如下：</p><img src="\imgs\javadev\64位Java对象内存布局图01.png" style="zoom:150%;" /><p>32位如下：</p><p><img src="/%5Cimgs%5Cjavadev%5C32%E4%BD%8DJava%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%9B%BE01.png"></p><p>对于hashcode值来说，存在两种情况：</p><ul><li><p><strong>没有重写hashcode方法</strong></p><p>没有重写过hashcode方法时调用System.identityHashCode(…)方法可以拿到由os:random生成的hashcode。</p><p>os::random生成hashcode的规则为：next_rand &#x3D; (16807seed) mod (2^31 - 1)，因此可以在对象的markword中用31位空间存储它。</p></li><li><p><strong>重写过hashcode方法</strong></p><p>重写过的hashcode方法其计算结果不会存储在这里。</p></li></ul><h3 id="3-1-3、测试案例"><a href="#3-1-3、测试案例" class="headerlink" title="3.1.3、测试案例"></a>3.1.3、测试案例</h3><p>工具：JOL &#x3D; Java Object Layout</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.openjdk.jol<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jol-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>jdk8u: markOop.hpp</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Bit-format of an object header (most significant first, big endian layout below):</span><span class="token comment">//</span><span class="token comment">//  32 bits:</span><span class="token comment">//  --------</span><span class="token comment">//             hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)</span><span class="token comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span><span class="token comment">//             size:32 ------------------------------------------>| (CMS free block)</span><span class="token comment">//             PromotedObject*:29 ---------->| promo_bits:3 ----->| (CMS promoted object)</span><span class="token comment">//</span><span class="token comment">//  64 bits:</span><span class="token comment">//  --------</span><span class="token comment">//  unused:25 hash:31 -->| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span><span class="token comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span><span class="token comment">//  PromotedObject*:61 --------------------->| promo_bits:3 ----->| (CMS promoted object)</span><span class="token comment">//  size:64 ----------------------------------------------------->| (CMS free block)</span><span class="token comment">//</span><span class="token comment">//  unused:25 hash:31 -->| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span><span class="token comment">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span><span class="token comment">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 ----->| (COOPs &amp;&amp; CMS promoted object)</span><span class="token comment">//  unused:21 size:35 -->| cms_free:1 unused:7 ------------------>| (COOPs &amp;&amp; CMS free block)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2、Java数据类型"><a href="#3-2、Java数据类型" class="headerlink" title="3.2、Java数据类型"></a>3.2、Java数据类型</h2><h3 id="3-2-1、类型占用字节"><a href="#3-2-1、类型占用字节" class="headerlink" title="3.2.1、类型占用字节"></a>3.2.1、类型占用字节</h3><h4 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h4><img src="\imgs\javadev\image-20200915220817535.png" alt="image-20200915220817535" style="zoom:80%;" /><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>32位操作系统可以寻址到4G内存，因为 2^32 &#x3D; 4 * 1024 * 1024 &#x3D; 4G。64位近似无穷大（18EB）。</p><p>使用64位会有新问题：<font color='orange'>64位过长，给我们寻址带宽和对象内引用造成了负担。故引出了指针压缩技术。</font></p><h3 id="3-2-2、指针压缩"><a href="#3-2-2、指针压缩" class="headerlink" title="3.2.2、指针压缩"></a>3.2.2、指针压缩</h3><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p><font color='orange'>JVM实现指针压缩的原理就是：不再保存所有引用，而是每隔8个字节保存一个引用。</font>例如，原来保存每个引用0、1、2…，现在只保存0、8、16…。因此，指针压缩后，并不是所有引用都保存在堆中，而是以8个字节为间隔保存引用。</p><p>当引用被存入64位寄存器时，JVM会将其左移3位（相当于末尾添加3个0），例如0x0、0x1、0x2…分别被转换为0x0、0x8、0x10。当从寄存器中读出时，JVM又可以右移3位，丢弃末尾的0。（oop在堆中是32位，在寄存器中是35位，2的35次方&#x3D;32G。也就是说，使用32位，来达到35位oop所能引用的堆内存空间）。</p><h4 id="指针压缩失效"><a href="#指针压缩失效" class="headerlink" title="指针压缩失效"></a>指针压缩失效</h4><p><font color='orange'>32G指针压缩失效问题：</font>因为寄存器中2的35次方只能寻址到32G左右(不一定是32G，可能31G就会发生指压缩失效)，所以当内存超过32G时，JVM就默认停用压缩指针，进而改用64位寻址来寻址所有内存，但要注意：改用64位寻址将导致对象变大，通过未开启和开启后的比较，发现40G内存可以存储的对象个数要比30G内存少。</p><h4 id="哪些信息会被压缩？"><a href="#哪些信息会被压缩？" class="headerlink" title="哪些信息会被压缩？"></a>哪些信息会被压缩？</h4><ol><li><font color='orange'>对象的全局静态变量(即类属性)。</font></li><li><font color='orange'>对象头信息：64位平台下，原生对象头大小为16字节，压缩后为12字节。</font></li><li><font color='orange'>对象引用：64位平台下，引用本身大小为8字节，压缩后为4字节。</font></li><li><font color='orange'>对象数组：64位平台下，数组本身大小为24字节，压缩后16字节。</font></li></ol><h4 id="哪些信息不会被压缩？"><a href="#哪些信息不会被压缩？" class="headerlink" title="哪些信息不会被压缩？"></a>哪些信息不会被压缩？</h4><ol><li><font color='orange'>指向非Heap的对象指针。</font></li><li><font color='orange'>局部变量、传参、返回值、NULL指针。</font></li></ol><h2 id="3-3、Java集合容器"><a href="#3-3、Java集合容器" class="headerlink" title="3.3、Java集合容器"></a>3.3、Java集合容器</h2><h3 id="3-3-1、前言"><a href="#3-3-1、前言" class="headerlink" title="3.3.1、前言"></a>3.3.1、前言</h3><p>Java集合容器整体结构如下图：</p><p>版本1：</p><p><img src="/%5Cimgs%5Cjavadev%5CCollection%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%8401.png"></p><p>版本2：</p><p><img src="/%5Cimgs%5Cjavadev%5C%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84%E5%9B%BE.jpg"></p><h3 id="3-3-2、Collection"><a href="#3-3-2、Collection" class="headerlink" title="3.3.2、Collection"></a>3.3.2、Collection</h3><h4 id="3-3-2-1、List"><a href="#3-3-2-1、List" class="headerlink" title="3.3.2.1、List"></a>3.3.2.1、List</h4><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><ol><li><font color='orange'>数据结构</font>：动态数组，需要连续内存。</li><li><font color='orange'>元素特点</font>：<ul><li>数组定义：<code>transient Object[] elementData;</code> 序列化时不考虑其存储元素；</li><li>允许为null值；</li></ul></li><li><font color='orange'>增删改查</font>：<ul><li>随机访问快；</li><li>首部插入速度较linkedlist要慢40%左右，尾部插入较linkedlist要快10%左右，中间插入较linkedlist要快65%左右，其它部分插入删除都会移动数据，性能较低；</li><li>可以利用CPU缓存，局部性原理。</li></ul></li><li><font color='orange'>初始容量</font>：<ul><li>JDK7：初始容量为10。</li><li>JDK8：初始为0，当第一次执行添加操作后才会扩容，扩容后容量为10；</li></ul></li><li><font color='orange'>扩容</font>：添加数据前已存在元素数量 等于 数组长度时，则扩大为原来的1.5倍，但底层并非是乘上1.5，而是根据公式：<code>原容量&gt;&gt;1+原容量</code>获得。</li><li><font color='orange'>是否同步</font>：非同步，线程不安全；但可以通过<code>Collections.synchronizedList(list)</code>返回一个线程安全的ArrayList，也可以使用concurrent包下的<code>CopyOnWriteArrayList</code>；</li><li><font color='orange'>复杂度</font>：添加n个元素需要O(n)时间；</li><li><font color='orange'>使用场景</font>：快速访问数据；单线程环境；</li></ol><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><ol><li><font color='orange'>数据结构</font>：双向链表，不需要连续内存。</li><li><font color='orange'>元素特点</font>：<ul><li>链表每个节点定义为内部类Node，变量Node first、Node last；</li><li>允许为null值；</li><li>占用内存多；</li></ul></li><li><font color='orange'>增删改查</font>：<ul><li>随机访问慢，顺序访问性能还行；</li><li>首尾插入删除快，中间插入删除慢；</li></ul></li><li><font color='orange'>初始容量</font>：不需要指定容量；</li><li><font color='orange'>扩容</font>：随插入数据数量扩大；</li><li><font color='orange'>是否同步</font>：非同步，线程不安全；</li><li><font color='orange'>复杂度</font>：</li><li><font color='orange'>使用场景</font>：快速频繁增删数据场景；按顺序访问数据的场景；单线程环境；</li><li><font color='orange'>扩展</font>：可以实现栈、队列和双向队列；</li></ol><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><ol><li><font color='orange'>底层数据结构</font>：动态数组；</li><li><font color='orange'>元素特点</font>：数组定义如：<code>Object[] elementData</code>；允许有空值；不支持序列化；</li><li><font color='orange'>增删改查</font>：插入删除效率低，查询效率高；</li><li><font color='orange'>初始容量</font>：默认10；</li><li><font color='orange'>扩容</font>：添加数据前先判断已存在元素数量 是否等于 数组长度，若等于则默认扩大为原来的2倍，如果显式设置了扩容量则按指定的扩容量来扩容，如果扩容后还是不够用，则直接根据要插入的元素数量长度来扩容；（默认容量为10，若首次发生扩容，则默认扩容后的容量为20。如果初始容量为10，然后直接一次性添加21个元素，那么扩容后的容量为21，而并非是40。容量21空闲为0的环境下，此时再添加1个元素，那么会再次扩容为原来的2倍，也即扩容为42）</li><li><font color='orange'>是否同步</font>：同步，线程安全，因其基于synchronized实现线程安全，故效率较差；可以使用concurrent包下的CopyOnWriteArrayList 来代替 Vector；</li><li><font color='orange'>复杂度</font>：</li><li><font color='orange'>使用场景</font>：多线程环境；</li></ol><h6 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h6><ol><li><p><font color='orange'>底层数据结构</font>：数组</p></li><li><p><font color='orange'>元素特点</font>：先进后出；</p></li><li><p><font color='orange'>增删改查</font>：</p><ol><li>push方法：将元素推入栈底，即数组末尾；</li><li>pop方法：取出栈顶元素后并删除栈顶元素。</li><li>peek方法：取出栈顶元素，即数组首个元素。</li><li>empty方法：判断栈是否为空。</li><li>search方法：获取指定元素在栈中的位置。</li></ol><p>注意：因其继承于Vector，所以其拥有Vector全部功能；</p></li><li><p><font color='orange'>初始容量</font>：空栈。</p></li><li><p><font color='orange'>扩容</font>：继承于vector，与之相同；</p></li><li><p><font color='orange'>是否同步</font>：线程安全；</p></li><li><p><font color='orange'>复杂度</font>：</p></li><li><p><font color='orange'>使用场景</font>：</p></li></ol><h5 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h5><ol><li><font color='orange'>简介</font>：写操作时（写操作加了锁，否则会拷贝多个副本），将原数组拷贝一份出来，然后在拷贝的新数组中执行写操作，操作完后再将原数组引用指向新数组；</li><li><font color='orange'>底层数据结构</font>：动态数组；</li><li><font color='orange'>元素特点</font>：</li><li><font color='orange'>增删改查</font>：</li><li><font color='orange'>初始容量</font>：</li><li><font color='orange'>扩容</font>：</li><li><font color='orange'>是否同步</font>：线程安全；</li><li><font color='orange'>复杂度</font>：</li><li><font color='orange'>使用场景</font>：读多写少，比如缓存；</li><li><font color='orange'>注意事项</font>：<ol><li>写操作需要拷贝数组，比较消耗内存，如果原数组容量比较大，则可能频繁发生YGC和FGC；</li><li>不能保证实时一致性，只能保证最终一致性；</li></ol></li></ol><h4 id="3-3-2-2、Set"><a href="#3-3-2-2、Set" class="headerlink" title="3.3.2.2、Set"></a>3.3.2.2、Set</h4><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><ol><li><font color='orange'>底层数据结构</font>：基于HashMap和LinkedHashMap实现。具体实现方式：通过一个HashMap存储元素，元素存放在HashMap的key中，而value统一使用一个Object对象。</li><li><font color='orange'>元素特点</font>：<ol><li>无序不重复；</li><li>只允许1个null元素；</li></ol></li><li><font color='orange'>增删改查</font>：</li><li><font color='orange'>初始容量</font>：因基于HashMap实现，故规则参考HashMap实现规则；</li><li><font color='orange'>扩容</font>：因基于HashMap实现，故规则参考HashMap实现规则；</li><li><font color='orange'>是否同步</font>：线程不安全；</li><li><font color='orange'>复杂度</font>：</li><li><font color='orange'>使用场景</font>：去重，无需排序场景；</li></ol><h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><ol><li><font color='orange'>底层数据结构</font>：<ol><li>数组+双向链表；</li><li>基于LinkedHashMap和HashSet机制实现，所以可保证迭代顺序和元素的不重复；</li></ol></li><li><font color='orange'>元素特点</font>：<ol><li>Entry结构：before&#x2F;hash&#x2F;key&#x2F;value&#x2F;next&#x2F;after；before和after用于维护整个双向链表；</li><li>元素不重复；</li><li>可以保证插入顺序和访问顺序；</li></ol></li><li><font color='orange'>增删改查</font>：</li><li><font color='orange'>初始容量</font>：因基于LinkedHashMap实现，参考其实现规则；</li><li><font color='orange'>扩容</font>：因基于LinkedHashMap实现，参考其实现规则；</li><li><font color='orange'>是否同步</font>：线程不安全；</li><li><font color='orange'>复杂度</font>：</li><li><font color='orange'>使用场景</font>：去重，需要保证插入或访问顺序；</li></ol><h5 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h5><ul><li>TreeSet<ol><li><font color='orange'>底层实现</font>：基于TreeMap实现。</li><li><font color='orange'>元素特点</font>：元素有序。支持两种排序方式：自然排序和定制排序，默认是自然排序。使用 无参构造时 默认自然排序；当需要使用定制排序时，需要使用 有参构造 来显式指定。</li><li><font color='orange'>存储</font>：通过compare和compareTo来判断是否相等。compare通过判断两个对象的id，相同id则认为是重复元素，不会加入到集合中。</li></ol></li></ul><h5 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h5><h5 id="CopyOnWriteSet"><a href="#CopyOnWriteSet" class="headerlink" title="CopyOnWriteSet"></a>CopyOnWriteSet</h5><ol><li><font color='orange'>简介</font>：写操作时（写操作加了锁，否则会拷贝多个副本），将原数组拷贝一份，然后在拷贝的那份数组中执行写操作，操作完后再将原数组引用指向新数组；</li><li><font color='orange'>数组结构</font>：动态数组；</li><li><font color='orange'>原理</font>：通过CopyOnWriteList机制实现；</li><li><font color='orange'>是否同步</font>：线程安全；</li><li><font color='orange'>使用场景</font>：读多写少，比如缓存；</li><li><font color='orange'>注意事项</font>：<ol><li>写操作需要拷贝数组，比较消耗内存，如果原数组容量比较大，则可能频繁发生YGC和FGC；</li><li>不能保证实时一致性（读取到的数据可能是旧的），只能保证最终一致性；</li></ol></li></ol><h5 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h5><ol><li><font color='orange'>底层数据结构</font>：动态数组；并非是散列表；</li><li><font color='orange'>元素特点</font>：不能存储重复元素；</li><li><font color='orange'>增删改查</font>：</li><li><font color='orange'>初始容量</font>：</li><li><font color='orange'>扩容</font>：</li><li><font color='orange'>是否同步</font>：线程安全；</li><li><font color='orange'>复杂度</font>：</li><li><font color='orange'>使用场景</font>：读多写少，比如缓存；</li></ol><h5 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h5><h4 id="3-3-2-3、Queue"><a href="#3-3-2-3、Queue" class="headerlink" title="3.3.2.3、Queue"></a>3.3.2.3、Queue</h4><p>简介：offer()-添加数据后会返回一个布尔类型来表示是否添加成功；peek()-取数据；poll()-取数据后进行remove；</p><h5 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h5><ul><li>ArrayDeque</li><li>BlockingDeque<ul><li>LinkedBlockingDeque</li></ul></li></ul><h5 id="BlockingQueue（阻塞队列）"><a href="#BlockingQueue（阻塞队列）" class="headerlink" title="BlockingQueue（阻塞队列）"></a>BlockingQueue（阻塞队列）</h5><p>简介：在Queue的基础上添加两个方法——<code>put()</code>和<code>take()</code>方法，这两个是阻塞方法。put装数据装满了会阻塞当前线程，take拿数据拿完了会阻塞当前线程。</p><ul><li><p>ArrayBlockingQueue</p><p>简介：它是一个有界阻塞队列，且可以设置有界值，也就是容器的容量。注意本类实现的offer方法可以设置时间，在指定时间过后还是添加不进去再返回。</p></li><li><p>PriorityBlockingQueue</p></li><li><p>LinkedBlockingQueue</p><p>简介：基于链表实现的无界阻塞队列，它可以一直装数据到你内存满为止。</p></li><li><p>TransferQueue</p><p>简介：传递的意思，实际上是其它各种Queue的一个组合，它可以给线程传递任务且可以通过列表传递多个。该Queue新增了一个transfer()方法——其逻辑就是装完数据得等着，有线程把它拿走我才可以回去继续干我的事。</p><p>应用场景：做了一件事，该事需要一个结果才能继续做下一件事。比如网购，我付钱成功后才能给发货，不成功不能发货。</p><ul><li>LinkedTransferQueue</li></ul></li><li><p>SynchronousQueue</p><p>简介：容量为0，它并非用来装数据，而是专门用来两个线程间传递数据和线程下达任务。该Queue用来进行阻塞式put调用，要求有线程从里面取数据时才能往里面装，相当于直接把数据递给取数据线程的手中。该Queue看似无用，其实不然，其在线程池中用处非常大，多线程取任务，互相间进行任务调度时用的就是这个Queue。</p></li></ul><h5 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h5><p>简介：内部结构是一个二叉树，该二叉树可以认为是堆排序里面的小顶堆（最小值为根节点）。PriorityQueue的特点是向里面装数据时不是按顺序装的，而是在内部进行了一个排序，按照优先级，最小的优先。</p><h5 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h5><h5 id="DelayQueue（双端队列）"><a href="#DelayQueue（双端队列）" class="headerlink" title="DelayQueue（双端队列）"></a>DelayQueue（双端队列）</h5><p>简介：DelayQueue可以基于时间排序。它是阻塞的队列的一种实现，这个阻塞队列在装数据时必须实现Delayed接口，也要实现Comparable接口并重写compareTo方法来实现任务排序的自定义逻辑；</p><h3 id="3-3-3、Map"><a href="#3-3-3、Map" class="headerlink" title="3.3.3、Map"></a>3.3.3、Map</h3><h4 id="3-3-3-1、HashMap"><a href="#3-3-3-1、HashMap" class="headerlink" title="3.3.3.1、HashMap"></a>3.3.3.1、HashMap</h4><ol><li><font color='orange'>底层数据结构</font>：</li></ol><ul><li>JDK7：数组+链表；<ul><li>JDK8：数组+链表+红黑树；</li></ul></li></ul><ol start="2"><li><p><font color='orange'>元素特点</font>：</p><ol><li>无序的key-value键值对；</li><li>允许null key和null value；</li></ol></li><li><p><font color='orange'>增删改查</font>：插入、删除、查询效率较高；</p></li><li><p><font color='orange'>初始容量</font>：默认16（2的N次方）；</p></li><li><p><font color='orange'>扩容</font>：put后判断是否需要扩容；负载因子0.75，当容量 &#x3D; (总容量*0.75)时触发扩容，扩大为原来的2倍；</p></li><li><p><font color='orange'>是否同步</font>：线程不安全；</p></li><li><p><font color='orange'>复杂度</font>：</p></li><li><p><font color='orange'>使用场景</font>：快速增删改查；随机读取；缓存；</p></li><li><p><font color='orange'>哈希冲突对策</font>：</p><ul><li>开放定址法；</li><li>再散列函数法；</li><li>链地址法（拉链法，HashMap基于此实现）；</li></ul></li></ol><h5 id="3-3-3-1-1、LinkedHashMap"><a href="#3-3-3-1-1、LinkedHashMap" class="headerlink" title="3.3.3.1.1、LinkedHashMap"></a>3.3.3.1.1、LinkedHashMap</h5><ol><li><font color='orange'>底层数据结构</font>：数组+双向链表；</li><li><font color='orange'>元素特点</font>：<ol><li>entry结构：before&#x2F;hash&#x2F;key&#x2F;value&#x2F;next&#x2F;after，before和after用于维护整个双向链表；</li><li>允许一个null key（多个覆盖），允许多个null value；</li></ol></li><li><font color='orange'>增删改查</font>：<ol><li>在HashMap基础上添加before和after两个属性保证迭代顺序；</li><li>迭代顺序可以是插入顺序，也可以是访问顺序；</li><li>使用LRU算法实现访问顺序排序；</li></ol></li><li><font color='orange'>初始容量</font>：</li><li><font color='orange'>扩容</font>：</li><li><font color='orange'>是否同步</font>：线程不安全；</li><li><font color='orange'>复杂度</font>：</li><li><font color='orange'>使用场景</font>：保证插入和访问顺序；</li></ol><h4 id="3-3-3-2、IdentityHashMap"><a href="#3-3-3-2、IdentityHashMap" class="headerlink" title="3.3.3.2、IdentityHashMap"></a>3.3.3.2、IdentityHashMap</h4><h4 id="3-3-3-3、TreeMap"><a href="#3-3-3-3、TreeMap" class="headerlink" title="3.3.3.3、TreeMap"></a>3.3.3.3、TreeMap</h4><ol><li><p><font color='orange'>底层数据结构</font>：红黑树（高效检索二叉树）；</p></li><li><p><font color='orange'>元素特点</font>：</p><ol><li>有序的key-value集合，每一个元素都存储于红黑树的一个节点上；</li><li>Entry结构：key&#x2F;value&#x2F;left&#x2F;right&#x2F;parent&#x2F;color；</li><li>不允许null key，但可允许多个null value；</li></ol></li><li><p><font color='orange'>增删改查</font>：默认自然排序，也可定制排序；</p></li><li><p><font color='orange'>初始容量</font>：</p></li><li><p><font color='orange'>扩容</font>：</p></li><li><p><font color='orange'>是否同步</font>：线程不安全；</p></li><li><p><font color='orange'>复杂度</font>：</p></li><li><p><font color='orange'>使用场景</font>：</p></li><li><p><font color='orange'>存储</font>：TreeMap存储时会进行排序，会根据key来对key-value键值对进行排序，其排序方式分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。</p><p><font color='orange'>自然排序</font>：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。</p><p><font color='orange'>定制排序</font>：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。</p></li><li><p><font color='orange'>获取</font>：</p></li><li><p><font color='orange'>检测元素异同</font>：TreeMap判断两个元素相等的标准：两个key执行equals返回true，且执行<code>compareTo()</code>方法返回0，则认为这两个key相等。</p></li><li><p><font color='orange'>是否同步</font>：非同步。</p></li><li><p><font color='orange'>注意事项</font>：如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的<code>equals()</code>方法，TreeMap中判断相等的标准是：两个key通过<code>equals()</code>方法返回为true，并且通过<code>compareTo()</code>方法比较应该返回为0。</p></li></ol><h4 id="3-3-3-4、WeakHashMap"><a href="#3-3-3-4、WeakHashMap" class="headerlink" title="3.3.3.4、WeakHashMap"></a>3.3.3.4、WeakHashMap</h4><h4 id="3-3-3-5、HashTable"><a href="#3-3-3-5、HashTable" class="headerlink" title="3.3.3.5、HashTable"></a>3.3.3.5、HashTable</h4><ol><li><font color='orange'>底层数据结构</font>：数组 + 链表；</li><li><font color='orange'>元素特点</font>：无序的key-value键值对，不允许null key 和 null value；</li><li><font color='orange'>增删改查</font>：插入、删除、查询效率较低，因为被synchronized修饰；</li><li><font color='orange'>初始容量</font>：默认11；</li><li><font color='orange'>扩容</font>：put前判断是否需要扩容；负载因子0.75，当容量 &gt;&#x3D; (总容量*0.75)时触发扩容，扩大为2倍+1；</li><li><font color='orange'>是否同步</font>：线程安全；基于重入锁synchronized实现线程安全；</li><li><font color='orange'>复杂度</font>：</li><li><font color='orange'>使用场景</font>：无序、不重复的元素的存储。</li></ol><h4 id="3-3-3-6、IdentityHashMap"><a href="#3-3-3-6、IdentityHashMap" class="headerlink" title="3.3.3.6、IdentityHashMap"></a>3.3.3.6、IdentityHashMap</h4><h4 id="3-3-3-7、ConcurrentHashMap（JDK8）"><a href="#3-3-3-7、ConcurrentHashMap（JDK8）" class="headerlink" title="3.3.3.7、ConcurrentHashMap（JDK8）"></a>3.3.3.7、ConcurrentHashMap（JDK8）</h4><ol><li><font color='orange'>底层数据结构</font>：数组+单链表+红黑树；</li><li><font color='orange'>锁实现</font>：CAS+Synchronized；</li><li><font color='orange'>元素特点</font>：Node改名为HashEntry；</li><li><font color='orange'>增删改查</font>：</li><li><font color='orange'>初始容量</font>：默认16；</li><li><font color='orange'>扩容</font>：数据等于容量3&#x2F;4时就扩容为原容量的2倍。</li><li><font color='orange'>是否同步</font>：线程安全；基于 CAS+Synchronized 实现安全；</li><li><font color='orange'>复杂度</font>：</li><li><font color='orange'>使用场景</font>：多线程，高并发场景；</li></ol><h4 id="3-3-3-8、ConcurrentKipListMap"><a href="#3-3-3-8、ConcurrentKipListMap" class="headerlink" title="3.3.3.8、ConcurrentKipListMap"></a>3.3.3.8、ConcurrentKipListMap</h4><h3 id="3-3-4、Iterator"><a href="#3-3-4、Iterator" class="headerlink" title="3.3.4、Iterator"></a>3.3.4、Iterator</h3><ul><li><p>Iterator</p><ol><li><font color='orange'>简介</font>：是接口，是集合迭代器。</li><li><font color='orange'>API</font>：<ol><li>boolean hashNext()：判断集合中是否存在下一个元素，若存在，则返回true。</li><li>Object next()：返回集合中下一个元素。</li><li>void remove()：删除集合上一次next方法返回的元素。</li></ol></li><li><font color='orange'>注意事项</font>：<ol><li>iterator()只能单向移动。</li><li>iterator.remove()可以唯一安全修改迭代过程中集合元素的方法；如果在迭代过程中以任何其它的方式修改了集合，那么将会产生未知行为。且每调用一次<code>next()</code>方法，<code>remove()</code>方法只能被调用一次，如果违反这个规则将抛出一个异常。</li></ol></li></ol><ul><li>ListIterator<ol><li><font color='orange'>简介</font>：是一个 功能更强 的迭代器，继承于Iterator接口，只能适用于List。可以通过调用<code>listIterator()</code>方法产生一个指向List开始处的ListIterator，还可以调用<code>listIterator(n)</code>方法创建一个一开始就指向列表索引为n的元素的ListIterator。</li><li><font color='orange'>特点</font>：<ol><li>双向移动（向前向后遍历）</li><li>产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引。</li><li>可以使用set方法替换它访问过的最后一个元素。</li><li>可以使用add方法在next方法返回的元素之前或previous方法返回元素之后插入一个元素。</li></ol></li></ol></li></ul></li></ul><h3 id="3-3-5、Collection-Collections"><a href="#3-3-5、Collection-Collections" class="headerlink" title="3.3.5、Collection &#x2F; Collections"></a>3.3.5、Collection &#x2F; Collections</h3><h4 id="3-3-5-1、Collection"><a href="#3-3-5-1、Collection" class="headerlink" title="3.3.5.1、Collection"></a>3.3.5.1、Collection</h4><p><font color='orange'>Collection是【集合类顶级接口】。提供 操作集合的通用方法，其继承接口有List与Set。</font></p><h4 id="3-3-5-2、Collections"><a href="#3-3-5-2、Collections" class="headerlink" title="3.3.5.2、Collections"></a>3.3.5.2、Collections</h4><p><font color='orange'>java.util.Collections 是【集合工具类】。拥有多种操作集合的静态方法，可对集合中的元素执行排序、搜索以及线程安全等操作，服务于Java的Collection框架。</font></p><h3 id="3-3-6、总结"><a href="#3-3-6、总结" class="headerlink" title="3.3.6、总结"></a>3.3.6、总结</h3><h4 id="3-3-6-1、HashMap原理"><a href="#3-3-6-1、HashMap原理" class="headerlink" title="3.3.6.1、HashMap原理"></a>3.3.6.1、HashMap原理</h4><h5 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h5><p>（1）JDK7</p><p>JDK7底层基于数组 + 单链表实现。</p><p>JDK7中底层使用HashMap的静态内部类Entry来存储数据：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>    <span class="token class-name">V</span> value<span class="token punctuation">;</span>    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>    <span class="token keyword">int</span> hash<span class="token punctuation">;</span>    <span class="token comment">// method...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）JDK8</p><p>JDK8底层基于数组 + 单链表 + 红黑树实现。</p><p>JDK8中底层使用HashMap的静态内部类Node来存储数据：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>    <span class="token class-name">V</span> value<span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>    <span class="token comment">// method...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>解决哈希冲突的常见方法：开放地址法、链地址法 等。HashMap为了解决哈希冲突，采用了链地址法。</p></blockquote><h5 id="元素特点"><a href="#元素特点" class="headerlink" title="元素特点"></a>元素特点</h5><p><font color='orange'>HashMap支持一个null key 和多个 null value</font>，原因如下：</p><ol><li><p>对于 null key 来说，在求hash值时会直接返回0，故只能有一个 null key。</p></li><li><p>对于 null value 来说，在执行put方法时不会对之进行校验，故可以有多个 null value。</p><p>这里要注意，HashMap 的get方法执行逻辑是：如果没有查询到指定key的键值对时会返回 null 对象。故get(key)方法的返回结果为null有两种可能：</p><ol><li>HashMap中不存在这个 key 对应的键值对；</li><li>HashMap中这个key对应的value为null；</li></ol><p>故，在判断HashMap中是否存在某个key时，应该使用containsKey方法；</p></li></ol><h5 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** 保存Node&lt;K,V>节点的数组，该表在首次使用时初始化，并根据需要调整大小。 分配时，长度始终是2的幂。 */</span><span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token comment">/** 存放具体元素的集合 */</span><span class="token keyword">transient</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span><span class="token punctuation">></span></span> entrySet<span class="token punctuation">;</span><span class="token comment">/** 默认初始容量16 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">/** 最大容量 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token comment">/** 加载因子，用来计算threshold */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span><span class="token comment">/** 触发扩容的阈值，实际大小（容量*加载因子）超过该阈值时会触发扩容  */</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span class="token comment">/** 负载因子：要调整大小的下一个大小值（容量*加载因子）。通过调节负载因子，可使 HashMap 在时间和空间复杂度上有不同表现。调低负载因子时，扩容效率增高，扩容过程中hash碰撞减少、链表长度变短，这是典型的拿空间换时间； 调高负载因子时，容纳键值对数量变多、空间利用率增高，但碰撞也增高了，最终效率下降。故一般使用默认值即可。*/</span><span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token comment">/** 进行resize操作时，若桶中数量少于6则从树转成链表 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">UNTREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment">/** 链表长度大于8时转化为红黑树 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment">/** 链表转为红黑树时，需先判断当前数组容量是否小于64。若小于64且hash冲突太多，则不进行红黑树转化，而要通过resize函数继续扩容。 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MIN_TREEIFY_CAPACITY</span> <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span><span class="token comment">/** 记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。 */</span><span class="token keyword">int</span> modCount<span class="token punctuation">;</span>  <span class="token comment">/** HashMap当前存储的元素数量  */</span><span class="token keyword">int</span> size<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color='orange'>HashMap中哈希桶数组table的长度length大小必须为2的n次方（合数）。</font></p><h5 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h5><ul><li><p>key为空，则hashcode为0，这也是HashMap只允许存在一个key为null的原因。</p></li><li><p>key不为空，则计算公式如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 求hash值</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">;</span> <span class="token comment">// 定位下标</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h5 id="put-操作"><a href="#put-操作" class="headerlink" title="put()操作"></a>put()操作</h5><p><font color='orange'>JDK1.7采用头插法，JDK1.8采用尾插法。</font></p><p>JDK8执行流程如下：</p><ol><li>计算待新增数据key的hash值；</li><li>判断Node[]是否为空，若为空需要进行初始化；</li><li>通过运算(hash &amp;(len-e))得出待插入元素要存储在数组中的下标位置idx，如果该位置idx没有数据，那么该元素数据添加成功。如果该位置idx有数据，则继续判断：<ol><li>如果该位置idx处Node节点的key与待插入数据的key相等，则直接覆盖已存在的值，然后返回旧值；</li><li>如果该结构是树形，则按照树的方式插入数据；</li><li>如果该结构是链表，则从上到下遍历该链表。如果当前节点的下一节点为null，则将待插入数据放在这个null位置，然后判断链表长度是否大于阈值8，如果 &gt;&#x3D; 8 且数组长度 &gt;&#x3D; 64 才转为红黑树，如果 &gt;&#x3D; 8 且数组长度 &lt; 64 则仅仅进行链表的扩容；如果当前节点的下一个节点不为null，且该节点hash、key与待插入元素数据的hash和key都相同，则将待插入数据替换该节点，然后返回旧值。如果该节点hash、key与待插入数据的hash和key不一样，那就继续遍历该链表。</li></ol></li><li>判断数组长度是否大于阈值，如果是则进入扩容阶段；</li></ol><h5 id="resize-操作"><a href="#resize-操作" class="headerlink" title="resize()操作"></a>resize()操作</h5><p><font color='orange'>当数组元素数量 &#x3D; 数组长度*0.75时触发扩容，扩容后数组长度是旧的2倍。</font></p><p>Java8与Java7的迁移算法不一样，Java8不需要每一个元素都重新计算hash值；JDK1.8只需根据原hash值新增的那个bit是1还是0来判断，是0的话索引没变，是1的话索引变成：(原索引+oldCap)。</p><p><font color='red'>注意：JDK1.7中旧链表迁移至新链表时，如果与新表数组索引位置相同，则链表元素会倒置；而JDK1.8不会倒置。</font></p><h5 id="get-key-操作"><a href="#get-key-操作" class="headerlink" title="get(key)操作"></a>get(key)操作</h5><ol><li>根据put()方法中计算hash的方式得到一个数组下标index；</li><li>遍历数组下标为index所对应的链表，若找到key和hash值同时相等的就返回该值，否则返回null；</li></ol><h5 id="remove-操作"><a href="#remove-操作" class="headerlink" title="remove()操作"></a>remove()操作</h5><ol><li>根据get()方法中的方式计算出要删除的key对应的Node节点；</li><li>如果待删除节点是头节点，则将它的next节点作为头节点；</li><li>如果待删除节点是红黑树，则直接调用红黑树的删除算法进行删除；</li><li>如果待删除节点是链表中的一个节点，则将待删除节点的前一个节点的next属性指向待删除节点的下一个节点即可；</li><li>如果删除成功则返回被删除节点的value，否则返回null；</li></ol><p><font color='red'>注意：删除单个key时，返回的是键值对中的value；</font></p><h5 id="iterator迭代器"><a href="#iterator迭代器" class="headerlink" title="iterator迭代器"></a>iterator迭代器</h5><p><code>Hashtable</code> 和 <code>HashMap</code> 有相同的迭代器 Iterator，<code>HashMap</code> 的 Iterator 是 快速失败 fail-fast 的，那自然 <code>Hashtable</code> 的 Iterator 也是 fail-fast 的。但是<code>Hashtable</code> 还有另外一个迭代器 Enumeration，这个迭代器是 安全失败 fail-safe 的，<code>HashTable</code> 中有一个 keys 方法可以返回 Enumeration 迭代器。</p><blockquote><p><font color='orange'>fail-safe 和 fail-fast 是一种思想，一种机制，属于系统设计范畴，并非 Java 集合所特有。</font></p><ul><li><p><font color='orange'>快速失败 fail-fast</font></p><p>一种快速发现系统故障的机制。一旦发生异常，立即停止当前操作，并上报给上层的系统来处理这些故障。</p><p>当 Iterator 这个迭代器被创建后，除了迭代器本身的方法 remove 可以改变集合的结构外，其他的因素若改变了集合的结构（改变只包含插入和删除），都将会抛出 <code>ConcurrentModificationException</code> 异常。</p><p><font color='orange'>java.util 包下的集合类都是 fail-fast 的。</font></p></li><li><p><font color='orange'>安全失败 fail-safe</font></p><p>在故障发生之后会维持系统继续运行。 fail-safe 不会抛出异常的原因如下：</p><ol><li>当集合的结构被改变时，fail-safe 机制会复制一份原集合数据，然后在复制的那份数据上进行遍历。</li></ol><p>虽然 fail-safe 不会抛出异常，但存在以下缺点：</p><ol><li>不能保证遍历的是最新内容。也就是说迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的；</li><li>复制时需要额外的空间和时间开销。</li></ol><p>顾名思义，和 fail-fast 恰恰相反，当我们对集合的结构做出改变的时候，fail-safe 机制不会抛出异常。</p><p><font color='orange'>java.util.concurrent 包下的容器都是 fail-safe 的。</font></p></li></ul></blockquote><h5 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h5><p>HashMap非线程安全，而ConcurrentHashMap线程安全。</p><p>ConcurrentHashMap底层结构在JDK1.7和1.8中也不同：</p><ul><li>JDK1.7： 分段锁；</li><li>JDK1.8：CAS + Synchronized；</li></ul><h5 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h5><p>常见问题如下：</p><ol><li><font color='orange'>多线程扩容，引起死循环问题；</font></li><li><font color='orange'>多线程put时可能导致元素丢失；</font></li><li><font color='orange'>put非null元素后get出来的确实null；</font></li></ol><p>应对措施：使用HashTable 或者 ConcurrentHashMap。</p><h5 id="Key取值问题"><a href="#Key取值问题" class="headerlink" title="Key取值问题"></a>Key取值问题</h5><ol><li><p><font color='orange'>key只允许有一个null，value允许有多个null；</font>（key为null的hashcode总是0）</p></li><li><p><font color='orange'>key取值范围有哪些？</font></p><p>一般使用String、Integer，且String最常用。原因如下：</p><ol><li>字符串是不可变的，它在被创建时其hashcode就缓存了，无需计算，且效率要比其它对象高。</li><li>获取对象时需要用到equals方法和hashCode方法，而String已经规范的重写过了。</li></ol></li><li><p><font color='orange'>可变类可以作为key使用吗？</font></p><p>不可以，因为hashcode可能会发生变化，导致put进去的值，无法get出来。</p></li><li><p><font color='orange'>如何自定义一个类，其可以作为HashMap的key？</font></p><p>该问题考察两个知识点：</p><ol><li><p><font color='orange'>如何重写equals方法和hashCode方法？</font></p><p>根据如下4条规则来设计即可：</p><ol><li>两个对象相等，hashcode⼀定相等；</li><li>两个对象不等，hashcode不⼀定不等；</li><li>hashcode相等，两个对象不⼀定相等；</li><li>hashcode不等，两个对象⼀定不等；</li></ol></li><li><p><font color='orange'>如何设计一个不变类？</font></p><ol><li>使用final修饰类，保证类不能被继承。</li><li>将所有成员变量访问权限设为私有，且加上final修饰，保证成员变量不可变；</li><li>不提供修改成员变量的方法；</li><li>通过构造器初始化所有成员，进行深拷贝；</li><li>getter方法中不要直接返回对象本身，而要返回克隆对象，防止逃逸。</li></ol></li></ol></li></ol><h5 id="位运算-VS-取模运算"><a href="#位运算-VS-取模运算" class="headerlink" title="位运算 VS 取模运算"></a>位运算 VS 取模运算</h5><p><font color='orange'>HashMap采用 位运算 的原因如下</font>：</p><ol><li>效率高。位运算直接对内存数据进行操作，不需要转换为十进制，因此处理速度快；</li><li>可以解决取模运算的负数问题。比如：-15 % 10 &#x3D; -5；</li></ol><h5 id="JDK7和JDK8下HashMap的异同"><a href="#JDK7和JDK8下HashMap的异同" class="headerlink" title="JDK7和JDK8下HashMap的异同"></a>JDK7和JDK8下HashMap的异同</h5><ol><li><font color='orange'>存放数据的节点名称不同；</font><ul><li>JDK7：使用 Entry 命名；</li><li>JDK8：使用 Node 命名；</li></ul></li><li><font color='orange'>定位数组下标位置方法不同；</font><ul><li>JDK7：计算key的hash，然后进行四次扰动，再与数组长度取模得出；</li><li>JDK8：计算key的hash，将hash值进行高低16位异或操作，再与数组长度取模得出；</li></ul></li><li><font color='orange'>扩容时机不同；</font><ul><li>JDK7：添加数据 前 先判断是否需要扩容；</li><li>JDK8：添加数据 后 再判断是否需要扩容；</li></ul></li><li><font color='orange'>扩容迁移定位方法不同；</font><ul><li>JDK7：扩容后需要重新计算hash；</li><li>JDK8：扩容后不需要重新计算hash；</li></ul></li><li><font color='orange'>put方法插入链表位置不同：</font><ul><li>JDK7：头插法；</li><li>JDK8：尾插法；</li></ul></li><li><font color='orange'>红黑树升级和退化</font><ul><li>链表升级为红黑树：JDK8引入红黑树，当链表长度 &gt;&#x3D; 8 且 数组长度 &gt;&#x3D; 64 时，链表转为红黑树；</li><li>红黑树退化为链表：有两个地方会判断并退化成链表：<ol><li>remove时退化；</li><li>扩容时会调用<code>split()</code>进行红黑树的扩容移动处理。split方法中，会将当前红黑树左右子树分别放入low，high两个w变量（treeNode类型）中。可理解为两条链表，当low链表中元素&lt;&#x3D;6，会将low转换为真正的链表（Node类型），当low链表中元素&gt;6，则会进行树化处理， 例如对链表中节点的left、right等进行赋值，high链表同理。</li></ol></li></ul></li></ol><h5 id="HashMap-VS-HashTable"><a href="#HashMap-VS-HashTable" class="headerlink" title="HashMap VS HashTable"></a>HashMap VS HashTable</h5><ol><li><font color='orange'>初始容量</font><ul><li>HashMap：16；</li><li>HashTable：11；</li></ul></li><li><font color='orange'>定位数组下标位置</font><ul><li>HashMap：key.hashcode()后 通过 位运算 定位下标；</li><li>HashTable：key.hashcode()后 通过 取模运算 定位下标；</li></ul></li><li><font color='orange'>判断扩容时机</font><ul><li>HashMap：put之后判断；</li><li>HashTable：put之前判断；</li></ul></li><li><font color='orange'>扩容大小</font><ul><li>HashMap：扩大为原容量的2倍；</li><li>HashTable：扩大为原容量的2倍+1；</li></ul></li><li><font color='orange'>null key 和 null value</font><ul><li>HashMap：允许1个null key（多个覆盖）和 多个null value；</li><li>HashTable：不允许null key 和 null value；</li></ul></li><li><font color='orange'>线程安全</font><ul><li>HashMap：线程不安全；</li><li>HashTable：线程安全；</li></ul></li><li><font color='orange'>接口实现</font><ul><li>HashMap：实现Map接口，继承AbstractMap类；</li><li>HashTable：实现Map接口，继承Dictionary类；</li></ul></li></ol><h5 id="HashMap-VS-TreeMap"><a href="#HashMap-VS-TreeMap" class="headerlink" title="HashMap VS TreeMap"></a>HashMap VS TreeMap</h5><ol><li><font color='orange'>数据结构</font><ul><li>HashMap：数组+链表+红黑树；</li><li>TreeMap：红黑树；</li></ul></li><li><font color='orange'>存储方式</font><ul><li>HashMap：随机存储；</li><li>TreeMap：按key的字典升序排序存储；</li></ul></li><li><font color='orange'>null key 和 null value</font><ul><li>HashMap：允许1个null key（多个覆盖），允许多个null value；</li><li>TreeMap：不允许null key，但允许多个null value；</li></ul></li><li><font color='orange'>效率高低</font><ul><li>HashMap：效率高；</li><li>TreeMap：效率低；</li></ul></li></ol><h4 id="3-3-6-2、HashTable原理"><a href="#3-3-6-2、HashTable原理" class="headerlink" title="3.3.6.2、HashTable原理"></a>3.3.6.2、HashTable原理</h4><h5 id="底层数据结构-1"><a href="#底层数据结构-1" class="headerlink" title="底层数据结构"></a>底层数据结构</h5><p>使用哈希表来存储键值对，数据结构创建了一个继承<code>Map.Entry</code>的私有静态内部类<code>Entry</code>，每一个Entry对象表示存储在哈希表中的一个键值对。</p><h5 id="元素特点-1"><a href="#元素特点-1" class="headerlink" title="元素特点"></a>元素特点</h5><p><font color='orange'>HashTable不支持 null key和null value</font>，原因如下：</p><ol><li>对于 null value 来说，在执行put方法时会直接抛出异常NullPointerException。</li><li>对于 null key 来说，在定位元素时会执行key.hashCode方法，会抛出NullPointerException。</li><li>若允许 null key 和 null value，则多线程环境下会出现问题。（ConcurrentHashMap也不允许null key 和 null value。）</li></ol><h5 id="rehash方法（扩容）"><a href="#rehash方法（扩容）" class="headerlink" title="rehash方法（扩容）"></a>rehash方法（扩容）</h5><p><font color='orange'>当前容量 &gt;&#x3D;（总容量 * 负载因子）时，Hashtable 扩大为旧容量的2倍+1；</font></p><h4 id="3-3-6-3、ArrayList原理"><a href="#3-3-6-3、ArrayList原理" class="headerlink" title="3.3.6.3、ArrayList原理"></a>3.3.6.3、ArrayList原理</h4><h5 id="add-element-操作"><a href="#add-element-操作" class="headerlink" title="add(element)操作"></a>add(element)操作</h5><ol><li><p>判断当前数组是否为空，若是则创建长度为10的数组，因为new ArrayList 时没有初始化；</p></li><li><p>判断是否需要扩容，即：当前数组中元素数+1后（size+1）判断其是否大于当前数组长度，是则进行扩容（执行grow()方法）;</p><p>grow()方法流程如下：</p><ol><li>创建新数组，其长度为原数组长度的1.5倍；</li><li>如果扩大1.5倍后依然不够，则根据实际长度来扩容，比如addAll()场景；</li><li>将原数组的数据通过<code>System.arraycopy</code>方法（native方法）复制到新数组中；</li></ol></li><li><p>在数组末尾添加数据，并将size+1；</p></li></ol><h5 id="add-index-element-操作"><a href="#add-index-element-操作" class="headerlink" title="add(index, element)操作"></a>add(index, element)操作</h5><ol><li>检查index是否在数组范围内，假如数组长度是2，则index必须 &gt;&#x3D; 0 且 &lt;&#x3D; 2，否则抛出异常IndexOutOfBoundsException异常；</li><li>扩容检查；</li><li>通过拷贝方式，把数组位置为index至size-1的元素都往后移动一位，腾出位置后放入元素，并将size+1；</li></ol><h5 id="set-index-element-操作"><a href="#set-index-element-操作" class="headerlink" title="set(index, element)操作"></a>set(index, element)操作</h5><ol><li>检查index是否在数组范围内，加入数组长度为2，则index必须 &gt;&#x3D; 0 且 &lt; 2；</li><li>保存被覆盖的值，因为最终需要返回旧值；</li><li>新元素放至index位置，并返回该位置旧值；</li></ol><h5 id="remove-index-操作"><a href="#remove-index-操作" class="headerlink" title="remove(index)操作"></a>remove(index)操作</h5><ol><li>检查index是否在数组范围内，假如数组长度是2，则index必须 &gt;&#x3D; 0 且 &lt;&#x3D; 2；</li><li>保留要删除的值，因为最终要返回该值（旧值）；</li><li>计算需要移动元素的个数，再通过拷贝使数组中位置为 index+1 到 size-1 的元素向前移动一位，然后把数组最后一位元素设为null，返回旧值；</li></ol><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ol><li>new ArrayList创建对象时，如果没有指定容量则初始化为0；如果有指定，则按照指定大小进行初始化；</li><li>扩容时，将容量扩大1.5倍，如果还是不够则根据实际元素数量来扩大，保证能存储所有数据，比如addAll场景；</li><li>若扩容后数组长度大于 (Integer.MAX_VALUE - 8)，则抛出异常OutOfMemoryError。</li></ol><h5 id="ArrayList-VS-Vector"><a href="#ArrayList-VS-Vector" class="headerlink" title="ArrayList VS Vector"></a>ArrayList VS Vector</h5><ol><li><font color='orange'>线程安全</font><ul><li>ArrayList：不安全；</li><li>Vector：安全；</li></ul></li><li><font color='orange'>扩容倍数</font><ul><li>ArrayList：默认1.5倍；</li><li>Vector：默认扩大为原容量的2倍；创建时也可显式设置扩容量；</li></ul></li><li><font color='orange'>支持序列化</font><ul><li>ArrayList：支持序列化；</li><li>Vector：不支持；</li></ul></li><li><font color='orange'>indexOf()接口支持</font><ul><li>ArrayList：提供了indexOf(obj, start)接口；</li><li>Vector：没有提供；</li></ul></li><li><font color='orange'>指定扩容系数</font><ul><li>ArrayList：不可以指定；</li><li>Vector：可以指定；</li></ul></li></ol><h5 id="ArrayList-VS-LinkedList"><a href="#ArrayList-VS-LinkedList" class="headerlink" title="ArrayList VS LinkedList"></a>ArrayList VS LinkedList</h5><ol><li><font color='orange'>底层数据结构</font><ul><li>ArrayList：动态数组；</li><li>LinkedList：双向链表；</li></ul></li><li><font color='orange'>增删改查特点</font><ul><li>ArrayList：查询快，增删慢；</li><li>LinkedList：随机查询慢，顺序查询快，增删快；</li></ul></li><li><font color='orange'>空间浪费</font><ul><li>ArrayList：空间浪费在数组末尾保留的一定空间；</li><li>LinkedList：空间浪费在每一个节点都要消耗空间来存储prev、next信息；</li></ul></li></ol><h4 id="3-3-6-4、LinkedList原理"><a href="#3-3-6-4、LinkedList原理" class="headerlink" title="3.3.6.4、LinkedList原理"></a>3.3.6.4、LinkedList原理</h4><h5 id="add-操作"><a href="#add-操作" class="headerlink" title="add()操作"></a>add()操作</h5><ol><li>创建一个新节点，节点元素为传入的参数，前继节点是 当前节点的last节点，后继节点next为null；</li><li>判断当前链表last节点是否为null，如果是，则把新建的节点作为头节点，否则把新建的节点作为last节点；</li><li>最后返回true；</li></ol><h5 id="get-index-element-操作"><a href="#get-index-element-操作" class="headerlink" title="get(index, element)操作"></a>get(index, element)操作</h5><ol><li>检擦index是否在数组长度范围内，假如数组长度为2，则index必须 &gt;&#x3D; 0 且 &lt; 2；</li><li>如果 index 小于 (双向链表长度的1&#x2F;2)，则从头开始遍历查找，否则从链表末尾向前遍历查找；</li></ol><h5 id="remove-操作-1"><a href="#remove-操作-1" class="headerlink" title="remove()操作"></a>remove()操作</h5><ol><li>判断first节点是否为空，如果是则抛出异常NoSuchElementException；</li><li>如果不为空，则把待删除节点的next节点的prev属性值设为null，达到 删除头节点的效果；</li><li>返回删除值；</li></ol><h4 id="3-3-6-5、ConcurrentHashMap"><a href="#3-3-6-5、ConcurrentHashMap" class="headerlink" title="3.3.6.5、ConcurrentHashMap"></a>3.3.6.5、ConcurrentHashMap</h4><h5 id="put-操作-1"><a href="#put-操作-1" class="headerlink" title="put()操作"></a>put()操作</h5><ol><li>判断待插入数据key和value是否为空，如果是则抛出空指针异常；</li><li>判断Node[] 数组是否为空，若是则需要初始化；</li><li>根据hash值通过位运算计算出Node数组的下标，判断该数组第一个Node节点是否有数据，如果没有数据则通过CAS将新值插入；</li><li>如果有数据则判断头节点的hashcode是否等于MOVED（即-1），即检查是否正在扩容，如果等于-1则帮助扩容；</li><li>若有数据，则对头节点进行加锁，如果头节点的hashcode &gt;&#x3D; 0，则说明是链表，遍历链表。如果找到key和hahs同时相等，则进行覆盖；若没有找到，则将新值插入到链表的最后面；如果hashCode &lt; 0，说明红黑树，调用红黑树的 插值方法 插入新节点；</li><li>插值完成后，判断链表元素是否 &gt;&#x3D; 8，如果 &gt;&#x3D;8 且 数组长度 &gt;- 64才转为红黑树。如果 &gt;&#x3D; 8 且数组长度 &lt; 64 则仅仅进行扩容；</li></ol><h5 id="resize-操作-1"><a href="#resize-操作-1" class="headerlink" title="resize()操作"></a>resize()操作</h5><p>创建新数组，其长度为原数组长度的2倍；多线程环境下旧数组迁移至新数组时会发生线程安全问题；</p><h5 id="get-操作"><a href="#get-操作" class="headerlink" title="get()操作"></a>get()操作</h5><ol><li>计算获取数据key的hash值；</li><li>根据hashCode并通过位运算得到Node数组的下标，即得到头节点；</li><li>如果头节点为空，则返回null；</li><li>如果头节点的key与参数key可以相等，则返回头节点的值；</li><li>如果头节点的hashcode小于0，说明是红黑树，则调用find方法按照树的方式获取值；</li><li>如果不满足3、4、5条件，说明是链表，则按照链表的方式遍历获取值，整个过程不需要加锁；</li></ol><p>注意：整个过程无需加锁，因为读物的数据被volatile修饰，实现线程可见性；</p><h5 id="remove-操作-2"><a href="#remove-操作-2" class="headerlink" title="remove()操作"></a>remove()操作</h5><ol><li>计算待插入数据key的hash值；</li><li>判断Node[]数组是否为空，如果是则返回null；如果不是，则根据hashCode通过位运算定位到数组下标，即得到头节点；</li><li>判断头节点hashCode是否等于MOVED（即-1），检查是否正在扩容，如果是则帮助扩容；</li><li>如果2、3条件都不满足，则加锁进行删除操作；</li><li>首先判断头节点有无发生变化，如果有改变则返回null；</li><li>如果头节点hashCode大于0，说明是链表，则按照链表方式遍历删除值；</li><li>如果头节点是TreeBin类型，说明是红黑树，则按照红黑树方式删除值；</li></ol><p><font color='red'>注意：remove()底层是调用replaceNode()函数实现节点删除；</font></p><h5 id="JDK7与JDK8-下ConcurrentHashMap的不同"><a href="#JDK7与JDK8-下ConcurrentHashMap的不同" class="headerlink" title="JDK7与JDK8 下ConcurrentHashMap的不同"></a>JDK7与JDK8 下ConcurrentHashMap的不同</h5><ol><li><font color='orange'>底层结构</font><ul><li>JDK7：以 segment 作为每组数据的容器，对segment加锁只能锁住当前segment，segment数量等于并发度。 segment数组 + entry数组 + 链表。</li><li>JDK8：没有segment数组。 直接 entry数组 + 链表，锁粒度为entry数组中每个索引。</li></ul></li><li><font color='orange'>初始化</font><ul><li>JDK7：直接初始化。</li><li>JDK8：第一次put时才初始化。</li></ul></li><li><font color='orange'>锁实现</font><ul><li>JDK7：使用分段锁Segment；</li><li>JDK8：使用CAS+Synchronized；</li></ul></li><li><font color='orange'>查询遍历</font><ul><li>JDK7：基于链表实现，遍历效率低；</li><li>JDK8：基于红黑树实现，遍历效率高；</li></ul></li><li><font color='orange'>数据存放命名</font><ul><li>JDK7：使用名为HashEntry的容器来存储数据；</li><li>JDK8：改名为Node的容器来存储数据；</li></ul></li><li><font color='orange'>数据插入</font><ul><li>JDK7：头插法；<ol><li>segment下标位置：并发度为16，因 2^4 &#x3D; 16，故 下标位置 就是 二次hash值的二进制位的 高4位 对应的 十进制数值。</li><li>数组索引位置：数组长度为8，因2^3 &#x3D; 8，故 索引位置 就是 二次hash值的二进制位的 低3位的十进制数值。</li></ol></li><li>JDK8：尾插法；<ol><li>1.8 中的capacity代表的含义不再是全部容量，而是一定会放如的数据数量。因次如果capacity为16，那么第一次会初始化一个容量为32的数组，因为容量为16，加载因子为0.75，超过12（16*0.75）才扩容，而你直接放入16个元素，那更应该扩容了。</li></ol></li></ul></li><li><font color='orange'>扩容</font><ul><li>JDK7：容量超过3&#x2F;4时才扩容，先扩容再插入值；在其它segment中创建数组时 会以segment[0] 中的数组大小为原型 来创建。segment[0]位置初始容量：总容量 &#x2F; 并发度。</li><li>JDK8：容量等于3&#x2F;4时就扩容，先插入值再扩容；迁移数据时，从旧数组中拿数据的顺序是从右到左。</li></ul></li><li><font color='orange'>锁的粒度</font><ul><li>JDK7：最大并发数是Segment的个数，默认16，锁住整个段，不影响其它段；</li><li>JDK8：去掉分段锁，更细粒度，只锁住一个Node节点，不影响其它Node节点；</li></ul></li><li><font color='orange'>读写限制及扩容</font><ul><li>JDK7：扩容时锁住一个段，当前段可读不可写，其它段可读写，只开启1个线程进行扩容；</li><li>JDK8：锁住一个Node节点，当前节点可读不可写，其它节点可读写，1个线程+可能多个put&#x2F;remove线程帮助扩容；</li></ul></li></ol><h4 id="3-3-6-6、TreeMap"><a href="#3-3-6-6、TreeMap" class="headerlink" title="3.3.6.6、TreeMap"></a>3.3.6.6、TreeMap</h4><h5 id="put-操作-2"><a href="#put-操作-2" class="headerlink" title="put()操作"></a>put()操作</h5><p>主要分为两个步骤：</p><ol><li>构建排序二叉树<ol><li>从根节点root开始查找；</li><li>如果root节点比待插入节点值小，则在root节点左子树查找，如果大于，则在右子树查找；</li><li>递归循步骤2，找到合适节点为止；</li><li>把待插入节点与步骤3中查找到的节点进行对比，如果待插入节点小于找到节点，则把待插入节点作为找到节点的左子树，否则作为右子树；</li></ol></li><li>构建平衡二叉树</li></ol><h5 id="remove-操作-3"><a href="#remove-操作-3" class="headerlink" title="remove()操作"></a>remove()操作</h5><p>比put操作复杂，同样分为两个步骤：</p><ol><li>删除节点<ol><li>待删除节点，如果没有左和右子树时，则直接删除；</li><li>待删除节点，如果有一个字节点时，则把它的子节点指向它的上级节点（父节点）；</li><li>待删除节点，如果有两个非空的子节点时，流程复杂，暂不解释；</li></ol></li><li>着色旋转<ol><li>进行颜色对调和旋转，达到红黑树的特征；</li></ol></li></ol><h2 id="3-4、JAVA引用"><a href="#3-4、JAVA引用" class="headerlink" title="3.4、JAVA引用"></a>3.4、JAVA引用</h2><h3 id="3-4-1、引用类型"><a href="#3-4-1、引用类型" class="headerlink" title="3.4.1、引用类型"></a>3.4.1、引用类型</h3><h4 id="3-4-1-1、强引用"><a href="#3-4-1-1、强引用" class="headerlink" title="3.4.1.1、强引用"></a>3.4.1.1、强引用</h4><ul><li><p>定义：new一个对象就是强引用。</p></li><li><p>回收时机：引用为null时，就可以回收它。</p></li><li><p>代码实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><blockquote><p>new一个对象，这个引用就是强引用。代码中的<code>p</code>就是一个强引用。当p &#x3D; null时，GC就可以回收它了。</p></blockquote><h4 id="3-4-1-2、软引用"><a href="#3-4-1-2、软引用" class="headerlink" title="3.4.1.2、软引用"></a>3.4.1.2、软引用</h4><ul><li><p>定义：被SoftReference类对象指向的引用。</p></li><li><p>回收时机：内存不够时，才回收。</p></li><li><p>代码实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> softReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只有在内存不够时，才会回收 byte字节数组。</p></li><li><p>应用场景：做缓存使用。</p></li></ul><h4 id="3-4-1-3、弱引用"><a href="#3-4-1-3、弱引用" class="headerlink" title="3.4.1.3、弱引用"></a>3.4.1.3、弱引用</h4><ul><li><p>定义：被WeakReference类对象指向的引用。</p></li><li><p>回收时机：GC看到就回收（下一次gc时就回收）。</p></li><li><p>代码实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">></span></span> weakReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>应用场景：用在容器中。</p></li></ul><h4 id="3-4-1-4、虚引用"><a href="#3-4-1-4、虚引用" class="headerlink" title="3.4.1.4、虚引用"></a>3.4.1.4、虚引用</h4><ul><li><p>定义：被PhantomReference类对象指向的应用。相当于不存在，get操作不能获取到值。</p></li><li><p>回收时机：GC看到就回收。（队列不为null，说明已经被回收了）</p></li><li><p>代码实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">></span></span> rq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">></span></span> phantomReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rq<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>PhantomReference的构造函数有两个参数，第二个参数必须是一个队列。虚引用就是给你一个通知，通知时放在队列中，你只需判断队列中是否为null，如果队列不为 null 说明虚引用已被回收。</p></li><li><p>应用场景：处理堆外内存。（参考NIO中的DirectByteBuffer，意为直接内存，直接内存不受JVM管理，而是被系统管理，故又叫堆外内存。堆外内存的回收可以使用虚引用来实现。）</p></li></ul><h1 id="4、Java内存模型"><a href="#4、Java内存模型" class="headerlink" title="4、Java内存模型"></a>4、Java内存模型</h1><h2 id="4-1、简介"><a href="#4-1、简介" class="headerlink" title="4.1、简介"></a>4.1、简介</h2><h3 id="4-1-1、前言"><a href="#4-1-1、前言" class="headerlink" title="4.1.1、前言"></a>4.1.1、前言</h3><p>并发编程中，需要处理两个关键问题：线程之间【如何通信】及线程之间【如何同步】。</p><ul><li><p>通信</p><p>通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：</p><ul><li><p>共享内存</p><p>在共享内存的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状态 进行隐式通信。</p></li><li><p>消息传递。</p><p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发送消 息来显式进行通信。</p></li></ul></li><li><p>同步</p><p>同步是指程序中用于控制不同线程间操作发生相对顺序的机制。</p><p>在共享内存并发模型 里，同步显式进行。在消息传递的并发模型里，由于消息发送必须在消息接收前，因此同步是隐式进行的。</p></li></ul><p><font color='orange'>Java并发采用的是【共享内存模型】，Java线程间的通信是隐式进行，整个通信过程对程序员完全透明。</font></p><h3 id="4-1-2、认识JMM"><a href="#4-1-2、认识JMM" class="headerlink" title="4.1.2、认识JMM"></a>4.1.2、认识JMM</h3><p><font color='orange'>Java内存模型 是根据英文Java Memory Model（JMM）翻译过来。其实JMM并不像JVM内存结构一样真实存在。他只是一个抽象概念。</font></p><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了主内存变量的副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间无法直接访问对方工作内存中的变量，线程间的通信需要通过主内存来实现。</p><p><font color='orange'>JMM就作用于工作内存和主存之间的数据同步过程。它规定了如何做数据同步以及什么时候做数据同步。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210424211138529.png" alt="image-20210424211138529"></p><p>Java内存模型的相关知识在<code>JSR-133: Java Memory Model and Thread Specification</code>中有描述。JMM是和多线程相关，它描述了一组规则或规范，这个规范规定了一个线程对共享变量的写入对另一个线程是可见的。</p><p><font color="orange">Java内存模型（Java Memory Model，JMM）就是一种符合内存模型规范，屏蔽了各种硬件和操作系统访问差异，保证了Java程序在各种平台下对内存的访问都能得到一致效果的机制及规范。目的是解决多线程环境中基于共享内存进行通信时，存在的原子性、可见性（缓存一致性）以及有序性问题。</font></p><h2 id="4-2、重要概念"><a href="#4-2、重要概念" class="headerlink" title="4.2、重要概念"></a>4.2、重要概念</h2><h3 id="4-2-1、原子性问题"><a href="#4-2-1、原子性问题" class="headerlink" title="4.2.1、原子性问题"></a>4.2.1、原子性问题</h3><p>线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。所以在多线程场景下，就会发生<strong>原子性问题</strong>。</p><p>例如：线程要完成一个读、改、写操作，但在执行完读、改之后，时间片耗完了，此时就要放弃CPU，并等待重新调度。这种情况下，读改写就不是一个原子操作。即存在原子性问题。</p><h3 id="4-2-2、一致性问题"><a href="#4-2-2、一致性问题" class="headerlink" title="4.2.2、一致性问题"></a>4.2.2、一致性问题</h3><p>多核CPU 和 多线程场景中，每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且多个线程分别在不同的核心上执行，则每个核心都会在各自的cache中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自缓存的情况，而各自cache之间的数据就有可能不同。</p><p>在CPU和主存之间增加缓存可能导致在多线程场景下出现缓存一致性问题，多核CPU的每个核的缓存中，对于同一数据可能有不同的副本。</p><h3 id="4-2-3、有序性问题"><a href="#4-2-3、有序性问题" class="headerlink" title="4.2.3、有序性问题"></a>4.2.3、有序性问题</h3><p>现代的处理器使用【写缓冲区】临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。它可以通过【批处理】刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写来减少对内存总线的占用。</p><p>但要注意，每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要影响：处理器对内存读&#x2F;写操作的执行顺序，不一定与内存实际发生的读&#x2F;写操作顺序一致。</p><p>由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的 顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此 现代的处理器都会允许对写-读操作进行重排序。</p><p>为提高性能，编译器和处理器会对指令做重排序。重排序分3种类型：</p><ol><li><font color='orange'>编译器优化重排序。（编译器重排序）</font></li><li><font color='orange'>指令级并行重排序。（处理器重排序）</font></li><li><font color='orange'>内存系统重排序。（处理器重排序）</font></li></ol><p>从Java源代码到最终执行的指令序列，会经历下面3种重排序：</p><p><img src="/%5Cimgs%5Cjavadev%5CJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-1.1-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F-%E6%BA%90%E7%A0%81%E5%88%B0%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4%E9%97%B4%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B.png"></p><p>重排序 可能会导致 多线程程序出现 内存可见性问题。</p><h3 id="4-2-4、内存模型"><a href="#4-2-4、内存模型" class="headerlink" title="4.2.4、内存模型"></a>4.2.4、内存模型</h3><p><font color='orange'>CPU多级缓存导致的一致性问题、CPU时间片机制导致的原子性问题、以及处理器优化和指令重排导致的有序性问题等，都是由硬件不断升级导致。</font></p><p>为了保证并发编程中可以满足原子性、可见性及有序性，内存模型 就出现了。</p><p>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器、缓存、并发、编译器有关。它解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p><p><font color='orange'>Java语言为了屏蔽掉底层差异，定义了一套属于Java语言的内存模型规范，即Java内存模型。</font></p><h2 id="4-3、底层实现"><a href="#4-3、底层实现" class="headerlink" title="4.3、底层实现"></a>4.3、底层实现</h2><h3 id="4-3-1、happens-before"><a href="#4-3-1、happens-before" class="headerlink" title="4.3.1、happens-before"></a>4.3.1、happens-before</h3><p>happens-before的概念最初由Leslie Lamport在其一篇影响深远的论文（《Time，Clocks and the Ordering of Events in a Distributed System》）中提出。</p><p>从JDK 5开始，Java使用新的JSR-133内存模型。JSR-133使用happens-before的概念来指定两个操作之间的执行顺序。</p><p>在JMM中，如果一 个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p><p><strong>happens-before规则有8个</strong>，详情如下：</p><ul><li><strong>程序次序规则</strong>：一个线程中的每个操作，happens-before于该线程中的任意后续操作。（线程中的代码顺序执行）</li><li><strong>管程锁定规则</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。（先解锁后加锁）</li><li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的 读。（先volatile写后volatile读）</li><li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</li><li><strong>对象终结规则</strong>：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize()方法的开始。</li><li><strong>线程启动规则</strong>：Thread对象的start()方法先行发生于此线程的每一个动作。</li><li><strong>线程中断规则</strong>：对线程interrupt()方法的调用先行发生于被中断线程 的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。</li><li><strong>线程终止规则</strong>：线程中的所有操作都先行发生于对此线程的终止检 测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。</li></ul><p>JMM把happens-before 要求禁止的重排序分为下面两种：</p><ul><li><p><strong>会改变程序执行结果的重排序</strong>。</p><p>对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。</p></li><li><p><strong>不会改变程序执行结果的重排序</strong>。</p><p>对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种 重排序）。</p></li></ul><blockquote><p>两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个 操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一 个操作按顺序排在第二个操作之前。</p><p>如果前一个操作的结果不需要对后一个操作可见，且前后两个操作按happens-before关系来执行 与 不按照happens-before关系来执行的结果如果完全一致，那么JMM允许这种重排序。</p></blockquote><h3 id="4-3-2、as-if-serial"><a href="#4-3-2、as-if-serial" class="headerlink" title="4.3.2、as-if-serial"></a>4.3.2、as-if-serial</h3><p>as-if-serial语义是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程） 程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p><p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。</p><p>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证了正确同步的多线程程序执行结果的正确性。</p><h3 id="4-3-3、volatile内存语义"><a href="#4-3-3、volatile内存语义" class="headerlink" title="4.3.3、volatile内存语义"></a>4.3.3、volatile内存语义</h3><h4 id="volatile写内存语义"><a href="#volatile写内存语义" class="headerlink" title="volatile写内存语义"></a>volatile写内存语义</h4><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</p><h4 id="volatile读内存语义"><a href="#volatile读内存语义" class="headerlink" title="volatile读内存语义"></a>volatile读内存语义</h4><p>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</p><h4 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h4><p>为了实现volatile内存语义，JMM会限制【编译器重排序】和【处理器重排序】。</p><p>JMM禁止 编译器重排序 的规则如下：</p><p><img src="/%5Cimgs%5Cjavadev%5CJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-1.3-volatile-volatile%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99.png"></p><blockquote><p>在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量重排序。</p></blockquote><h3 id="4-3-4、锁内存语义"><a href="#4-3-4、锁内存语义" class="headerlink" title="4.3.4、锁内存语义"></a>4.3.4、锁内存语义</h3><h4 id="锁获取内存语义"><a href="#锁获取内存语义" class="headerlink" title="锁获取内存语义"></a>锁获取内存语义</h4><p>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的 临界区代码必须从主内存中读取共享变量。</p><h4 id="锁释放内存语义"><a href="#锁释放内存语义" class="headerlink" title="锁释放内存语义"></a>锁释放内存语义</h4><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。</p><blockquote><p>对比锁释放-获取的内存语义与volatile写-读的内存语义可以看出：锁释放与volatile写有 相同的内存语义；锁获取与volatile读有相同的内存语义。</p></blockquote><h4 id="公平锁和非公平锁内存语义"><a href="#公平锁和非公平锁内存语义" class="headerlink" title="公平锁和非公平锁内存语义"></a>公平锁和非公平锁内存语义</h4><ul><li>公平锁和非公平锁释放时，最后都要写一个volatile变量state。</li><li>公平锁获取时，首先会去读volatile变量。 </li><li>非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile 写的内存语义。</li></ul><h3 id="4-3-4、final域内存语义"><a href="#4-3-4、final域内存语义" class="headerlink" title="4.3.4、final域内存语义"></a>4.3.4、final域内存语义</h3><p>对于final域，编译器和处理器要遵守两个重排序规则：</p><ol><li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两者不能重排序。</li><li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能 重排序。</li></ol><h3 id="4-4-1、原子性"><a href="#4-4-1、原子性" class="headerlink" title="4.4.1、原子性"></a>4.4.1、原子性</h3><p><font color='orange'>Java为了保证原子性，提供了两个高级字节码指令<code>monitorenter</code>和<code>monitorexit</code>。在Java中对应的关键字就是synchronized。</font></p><p>Java中可以使用synchronized来保证方法和代码块内操作的原子性。</p><h3 id="4-4-2、可见性"><a href="#4-4-2、可见性" class="headerlink" title="4.4.2、可见性"></a>4.4.2、可见性</h3><p><font color='orange'>Java中的关键字volatile有一个功能：</font>被其修饰的变量在被修改后必须立即同步到主内存，被其修饰的变量在每次使用时都必须从主内存获取。因此，可以使用volatile来保证多线程操作时变量的可见性。</p><p>除了volatile，Java中的synchronized和final关键字也可以实现可见性。只不过实现方式不同。 </p><h3 id="4-4-3、有序性"><a href="#4-4-3、有序性" class="headerlink" title="4.4.3、有序性"></a>4.4.3、有序性</h3><p>Java在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为4类：</p><p><img src="/%5Cimgs%5Cjavadev%5CJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-1.2-%E5%8F%AF%E8%A7%81%E6%80%A7-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E7%B1%BB%E5%9E%8B.png"></p><p><strong>StoreLoad Barriers是一个全能型屏障</strong>，它同时具有其他3个屏障的效果。目前 处理器大多支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为 处理器 要把 写缓冲区数据 全部刷新到内存中（Buffer Fully Flush）。</p><p><font color='orange'>Java中的 synchronized 和 volatile 都可以保证多线程之间操作的有序性。</font>区别：</p><ul><li>volatile关键字 能 禁止指令重排。</li><li>synchronized关键字 能 保证同一时刻只有一条线程运行。</li></ul><h1 id="5、JAVA并发"><a href="#5、JAVA并发" class="headerlink" title="5、JAVA并发"></a>5、JAVA并发</h1><h2 id="5-1、Synchronized"><a href="#5-1、Synchronized" class="headerlink" title="5.1、Synchronized"></a>5.1、Synchronized</h2><h3 id="5-1-1、简介"><a href="#5-1-1、简介" class="headerlink" title="5.1.1、简介"></a>5.1.1、简介</h3><p>synchronized一直被认为是重量级锁。随着Java SE 1.6对<code>synchronized</code>进行了各种优化之后，它就并不那么重了。</p><p>Java SE 1.6中，<strong>锁共有4种状态</strong>，级别从低到高依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</strong>，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。<strong>这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率</strong>。</p><h3 id="5-1-2、底层实现"><a href="#5-1-2、底层实现" class="headerlink" title="5.1.2、底层实现"></a>5.1.2、底层实现</h3><ul><li><p>Java源码层级：synchronized(o)。</p></li><li><p>字节码层级：</p><ul><li>synchronized修饰方法（包括实例方法和静态方法）：添加访问标志<code>ACC_SYNCHRONIZED</code>。</li><li>synchronized修饰同步块：一般情况下都是添加 1个monitor enter 和 2个monitor exit，如果在同步方法中显式抛出异常，那么只会有1个monitor enter 和 1个monitor exit。</li></ul></li><li><p>JVM层级：基于操作系统提供的同步机制。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jol<span class="token punctuation">.</span>info<span class="token punctuation">.</span></span><span class="token class-name">ClassLayout</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">T01_Sync1</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span></span>T01_Sync1</span>$<span class="token class-name">Lock</span> object internals<span class="token operator">:</span> <span class="token constant">OFFSET</span>  <span class="token constant">SIZE</span>   <span class="token constant">TYPE</span> <span class="token constant">DESCRIPTION</span>                               <span class="token constant">VALUE</span>      <span class="token number">0</span>     <span class="token number">4</span>   <span class="token punctuation">(</span>object header<span class="token punctuation">)</span>  <span class="token number">05</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token punctuation">(</span><span class="token number">00000101</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>      <span class="token number">4</span>     <span class="token number">4</span>   <span class="token punctuation">(</span>object header<span class="token punctuation">)</span>  <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token punctuation">(</span><span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>      <span class="token number">8</span>     <span class="token number">4</span>   <span class="token punctuation">(</span>object header<span class="token punctuation">)</span>  <span class="token number">49</span> ce <span class="token number">00</span> <span class="token number">20</span> <span class="token punctuation">(</span><span class="token number">01001001</span> <span class="token number">11001110</span> <span class="token number">00000000</span> <span class="token number">00100000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">536923721</span><span class="token punctuation">)</span>     <span class="token number">12</span>     <span class="token number">4</span>        <span class="token punctuation">(</span>loss due <span class="token keyword">to</span> <span class="token namespace">the</span> next object alignment<span class="token punctuation">)</span><span class="token class-name">Instance</span> size<span class="token operator">:</span> <span class="token number">16</span> bytes<span class="token class-name">Space</span> losses<span class="token operator">:</span> <span class="token number">0</span> bytes internal <span class="token operator">+</span> <span class="token number">4</span> bytes external <span class="token operator">=</span> <span class="token number">4</span> bytes total<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span></span>T02_Sync2</span>$<span class="token class-name">Lock</span> object internals<span class="token operator">:</span> <span class="token constant">OFFSET</span>  <span class="token constant">SIZE</span>   <span class="token constant">TYPE</span> <span class="token constant">DESCRIPTION</span>                               <span class="token constant">VALUE</span>      <span class="token number">0</span>     <span class="token number">4</span>   <span class="token punctuation">(</span>object header<span class="token punctuation">)</span>  <span class="token number">05</span> <span class="token number">90</span> <span class="token number">2</span>e <span class="token number">1</span>e <span class="token punctuation">(</span><span class="token number">00000101</span> <span class="token number">10010000</span> <span class="token number">00101110</span> <span class="token number">00011110</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">506368005</span><span class="token punctuation">)</span>      <span class="token number">4</span>     <span class="token number">4</span>   <span class="token punctuation">(</span>object header<span class="token punctuation">)</span>  <span class="token number">1</span>b <span class="token number">02</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token punctuation">(</span><span class="token number">00011011</span> <span class="token number">00000010</span> <span class="token number">00000000</span> <span class="token number">00000000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">539</span><span class="token punctuation">)</span>      <span class="token number">8</span>     <span class="token number">4</span>   <span class="token punctuation">(</span>object header<span class="token punctuation">)</span>  <span class="token number">49</span> ce <span class="token number">00</span> <span class="token number">20</span> <span class="token punctuation">(</span><span class="token number">01001001</span> <span class="token number">11001110</span> <span class="token number">00000000</span> <span class="token number">00100000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">536923721</span><span class="token punctuation">)</span>     <span class="token number">12</span>     <span class="token number">4</span>        <span class="token punctuation">(</span>loss due <span class="token keyword">to</span> <span class="token namespace">the</span> next object alignment<span class="token punctuation">)</span><span class="token class-name">Instance</span> size<span class="token operator">:</span> <span class="token number">16</span> bytes<span class="token class-name">Space</span> losses<span class="token operator">:</span> <span class="token number">0</span> bytes internal <span class="token operator">+</span> <span class="token number">4</span> bytes external <span class="token operator">=</span> <span class="token number">4</span> bytes tota<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>OS&#x2F;硬件层面</p><ul><li>X86：使用指令 lock cmpxchg xxx 来实现。</li></ul></li></ul><h3 id="5-1-3、锁优化"><a href="#5-1-3、锁优化" class="headerlink" title="5.1.3、锁优化"></a>5.1.3、锁优化</h3><h4 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h4><p><font color='orange'>自旋锁在JDK 1.4.2中就已经引入，默认关闭，可以使用<code>-XX:+UseSpinning</code>参数来开启，在JDK 6中改为默认开启了。</font></p><p>自旋等待不能代替阻塞，自旋等待虽然避免了线程切换的开销，但它要占用处理器时间，如果锁被占用的时间很短，自旋等待效果就会非常好，反之如果锁被占用时间很长，那么自旋线程只会白白消耗处理器资源，这会带来性能的浪费。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍没有获得锁，就应当使用传统方式挂起线程。<font color='orange'>自旋次数 默认是十次，也可以使用参数<code>-XX:PreBlockSpin</code>来修改。</font></p><p><font color='orange'>在 JDK 6中对自旋锁做了优化，引入了自适应自旋。</font>自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待更长时间。另一方面，如果对于某个锁，自旋很少成功获得锁，那么后期再获取这个锁时可能直接省略自旋过程，以避免浪费处理器资源。</p><p><font color='orange'>JDK7之后就不能控制是否开启自旋功能了。</font></p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但对不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span> str1<span class="token punctuation">,</span><span class="token class-name">String</span> str2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><font color='orange'>StringBuffer是线程安全的，因为它的关键方法被<code>synchronized</code>修饰。引用sb只会在<code>add</code>方法中使用，不会发生方法逃逸和线程逃逸，故JVM会自动消除掉StringBuffer对象内部的锁。</font></p><blockquote><p>在JDK 5之前，字符串加法会转化为StringBuffer 对象的连续append()操作，在JDK 5及以后的版本中，会转化为StringBuilder对象的连续append()操作。</p></blockquote><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>原则上，在编写代码时，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了尽可能减少需要同步的操作数量，即使存在锁竞争，等待锁的线程也能尽快地拿到锁。</p><p>大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作出现在循环体之中，那即使没有线程竞争，频繁进行互斥同步操作也会导致不必要的性能损耗。</p><p>比如以下代码，没有锁粗化时需要执行100次加锁&#x2F;解锁操作，执行 锁粗化 优化后只需要加一次锁即可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p><font color='orange'>JDK 6引入偏向锁，目的是消除数据在无竞争情况下的同步原语， 进一步提高程序的运行性能。</font>如果说轻量级锁是在无竞争情况下 使用CAS 来替换 使用互斥量，那偏向锁就是在无竞争情况下去掉 同步 和 CAS。</p><p>偏向锁中的“偏”，就是偏心的“偏”、偏袒的“偏”。它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，没有其它线程来获取这个锁，则持有偏向锁的线程将永远不需要再进行同步。</p><h5 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h5><p>当锁对象第一次被线程获取时，虚拟机会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后再次进入同步块时，就不需要再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作 等）。</p><p>若有其它线程尝试获取锁，偏向模式会马上结束。根据锁对象目前是否处于被锁定的状态来决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位 为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照轻量级锁工作流程来执行。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>当对象进入偏向状态的时候，Mark Word大部分的空间（23个比特）都用于存储持有锁的线程ID了，这部分空间占用了原有存储对象哈希码的位置，那原来对象的哈希码怎么办呢？</p><p>一个对象如果计算过哈希码，就应该一直保持该值不变（推荐但不强制，因为用户可以重载hashCode()方法），否则很多依赖对象哈希码的API都可能存在出错风险。而作为绝大多数对象哈希码来源的Object::hashCode()方法，返回的是对象的一致性哈希码（Identity Hash Code），这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一 次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。因此，当一个对象已经计算过一 致性哈希码后，它就再也无法进入偏向锁状态了；而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。 </p><blockquote><p><font color='red'>注意：如果请求获取的hashcode值来源于对Object::hashCode()或者System::identityHashCode(Object)方法的调用，那么才会撤销偏向锁并升级为重量级锁；反之，如果重写了对象的hashCode()方法，计算哈希码时并不会触发偏向锁的撤销和重量级锁的升级。</font></p></blockquote><p>偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个带有效益权衡（Trade Off）性质的优化，也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数<code>-XX:-UseBiasedLocking</code>来禁止偏向锁优化反而可以提升性能。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h5 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h5><p><font color='orange'>JDK 6中引入了轻量级锁。</font>“轻量级”是相对于使用操作系统互斥量来实现锁而言，因此传统的锁机制被称为“重量级”锁。轻量级锁并不能代替重量级锁，它设计的初衷是在没有多线程竞争的前提下，减少重量级锁使用操作系统互斥量产生的性能消耗。</p><h5 id="工作过程-1"><a href="#工作过程-1" class="headerlink" title="工作过程"></a>工作过程</h5><p>在代码即将进入同步块时，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方为 这份拷贝加了一个Displaced前缀，即Displaced Mark Word）。</p><p>然后，虚拟机将使用CAS操作尝试把锁对象的Mark Word更新为指向Lock Record的指针。</p><ul><li>如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且锁对象Mark Word的锁标志位（Mark Word的 最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。</li><li>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志状态值变为“10”，此时锁对象Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。</li></ul><p>上面描述的是轻量级锁的加锁过程，它的解锁过程也同样是通过CAS操作来进行，如果对象的 Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，那么就要在释放锁的同时，唤醒被挂起的线程。</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>轻量级锁能提升程序同步性能的依据是”对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下， 轻量级锁反而会比传统的重量级锁更慢。</p><p>偏向锁、轻量级锁的状态转化及对象Mark Word的关系如下图所示：</p><p><img src="/%5Cimgs%5Cjavadev%5C%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E4%B8%8EMarkWord%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p><h3 id="5-1-4、锁升级"><a href="#5-1-4、锁升级" class="headerlink" title="5.1.4、锁升级"></a>5.1.4、锁升级</h3><h4 id="5-1-4-1、无锁状态"><a href="#5-1-4-1、无锁状态" class="headerlink" title="5.1.4.1、无锁状态"></a>5.1.4.1、无锁状态</h4><p><font color='orange'>new一个对象，默认就是无锁状态。</font></p><h4 id="5-1-4-2、偏向锁"><a href="#5-1-4-2、偏向锁" class="headerlink" title="5.1.4.2、偏向锁"></a>5.1.4.2、偏向锁</h4><h5 id="偏向锁来历"><a href="#偏向锁来历" class="headerlink" title="偏向锁来历"></a>偏向锁来历</h5><p>HotSpot作者研究发现，通常不存在锁竞争，而是一个线程经常多次获得同一个锁。所以每次都要竞争锁会消耗很多资源，为了降低获取锁的代价就引入了偏向锁。</p><h5 id="偏向锁获取"><a href="#偏向锁获取" class="headerlink" title="偏向锁获取"></a>偏向锁获取</h5><p><font color='orange'>首次访问锁的线程，偏向锁会默认偏向于该线程。有其它线程争夺锁时会撤销偏向锁，然后升级为轻量级锁。</font></p><p>偏向锁 获取和撤销 过程描述如下：</p><p>当锁对象首次被线程获取时，会将获取到该锁的线程ID记录在锁对象的Mark Word中，以后该线程在进入和退出 同步块时不需要执行CAS操作来加锁和解锁：</p><ul><li>如果一致（依然是线程1获取锁对象），则无需通过CAS进行加锁、解锁；</li><li>如果不一致（其他线程（线程2）要竞争锁对象），则需要检查Java对象头中记录的线程1是否存活：<ul><li>如果没有存活，那么锁状态将被重置为无锁状态，其它线程（线程2）可以将其设为偏向锁；</li><li>如果存活，那么检查该线程（线程1）的栈帧信息，如果线程1依然需要这个锁，则暂停当前线程1并撤销偏向锁，然后升级为轻量级锁。如果线程1 不再使用该锁对象，那么锁状态将被设为无锁状态，然后重新偏向新的线程。</li></ul></li></ul><p>获取偏向锁 详细步骤 参考如下：</p><ol><li>验证对象的bias位。如果是0，则表示该对象不可偏向，应该使用轻量级锁算法。</li><li>验证对象所属InstanceKlass的prototype的bias位是否被设置。如果没有设置，则该类所有对象全部不允许被偏向锁定，且所有对象的bias位都需要被重置，使用轻量级锁来替换。</li><li>校验epoch位。校验对象头中MarkWord的epoch位是否与该对象所属InstanceKlass的prototype的MarkWord的epoch匹配。如果不匹配，则表明偏向已过期，需要重新偏向。偏向线程可以通过CAS指令重新偏向于这个锁对象。</li><li>校验owner线程。比较偏向线程ID与当前线程ID。如果匹配，则表明当前线程已经获得了偏向，可以安全返回。如果不匹配，对象锁被假定为匿名偏向状态，当前线程应该尝试使用CAS指令获得偏向。如果失败的话，就尝试撤销(很可能引入安全点)，然后回退到轻量级锁；如果成功，当前线程成功获得偏向，可直接返回。</li></ol><h5 id="偏向锁关闭"><a href="#偏向锁关闭" class="headerlink" title="偏向锁关闭"></a>偏向锁关闭</h5><p><font color='orange'>偏向锁在Java 6和Java 7中默认启用，但是它仅在程序启动几秒后才激活，可以通过JVM参数<code>-XX:BiasedLockingStartupDelay=0</code>来关闭该延迟。</font></p><p><font color='orange'>如果程序线程通常处于竞争状态，可以通过JVM参数<code>-XX:-UseBiasedLocking</code>关闭偏向锁，那么程序默认会直接进入轻量级锁状态。</font></p><p>HotSpot支持 存储&#x2F;释放 偏向锁，以及偏向锁的批量重偏向和撤销。这个特性可以通过JVM参数进行切换，且默认支持。Unlock状态下MarkWord的一个比特位用于标识该对象偏向锁是否被使用或者是否被禁止。如果该bit位为0，则该对象未被锁定，并且禁止偏向；如果该bit位为1，则意味着该对象处于以下三种状态：</p><ol><li><font color='orange'>匿名偏向(Anonymously Biased)</font></li><li><font color='orange'>可重偏向(Rebiasable)</font></li><li><font color='orange'>已偏向(Biased)</font></li></ol><h4 id="5-1-4-3、轻量级锁"><a href="#5-1-4-3、轻量级锁" class="headerlink" title="5.1.4.3、轻量级锁"></a>5.1.4.3、轻量级锁</h4><h5 id="轻量级锁来历"><a href="#轻量级锁来历" class="headerlink" title="轻量级锁来历"></a>轻量级锁来历</h5><p><font color='orange'>轻量级锁适用于 并发高但执行时间短的场景。</font>线程阻塞将导致用户态与内核态的切换，若阻塞时间很短后锁就被释放了，那么代价会更大。为解决该问题，轻量级锁就出现了。</p><h5 id="轻量级锁加锁"><a href="#轻量级锁加锁" class="headerlink" title="轻量级锁加锁"></a>轻量级锁加锁</h5><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用 CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p><h5 id="轻量级锁解锁"><a href="#轻量级锁解锁" class="headerlink" title="轻量级锁解锁"></a>轻量级锁解锁</h5><p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p><h5 id="轻量级锁升级"><a href="#轻量级锁升级" class="headerlink" title="轻量级锁升级"></a>轻量级锁升级</h5><p>轻量级锁的升级过程描述如下：</p><ol><li>线程1获取轻量级锁时会先把锁对象对象头的MarkWord拷贝一份放到线程1栈帧中（称为DisplacedMarkWord），然后通过CAS方式把对象头中的内容替换为指向线程1中锁记录（DisplacedMarkWord）的指针。</li><li>线程1在修改替换对象头时，线程2进来也需要执行相关操作，但线程2在执行CAS时发现线程1已经把对象头换了，此时线程2的CAS会失败，然后线程2会尝试使用自旋锁来等待线程1释放锁。</li><li>线程2自旋次数达到上限时还没有获取锁，那么线程2就会将轻量级锁升级为重量级锁，然后线程2会进入到重量级锁的等待队列中进行等待，后续来的线程也会进入该队列进行等待，直到线程1执行完毕释放了锁，然后唤醒等待队列中的线程。</li></ol><blockquote><p>自旋达到上限时会升级到重量级锁，这里的上限分两种情况：</p><ul><li><p>Java6之前</p><ol><li>默认启用，自旋次数的默认值是10次，也可以使用参数<code>-XX：PreBlockSpin</code>来修改。</li><li>或者，自旋线程数量超过CPU核数一半时升级为重量级锁。</li></ol></li><li><p>Java6之后，引入自适应自旋，自旋次数不再固定，而是根据：同一把锁上次的自旋时间 和 拥有锁的线程的状态来决定。</p><ol><li>如果线程自旋成功，那么下次自旋的最大次数就会增加，因为JVM会认为上次都已经成功了，那么这次一定也会成功。</li><li>如果自旋很少成功，那么下次会减少自旋次数甚至是不再自旋，避免CPU空转，消费资源。</li></ol></li></ul></blockquote><p><font color='red'>注意：</font></p><p>使用CAS自旋去争夺锁，会导致无意义的CPU占用。所以，轻量级锁适用于【线程少且执行时间短】的场景。</p><h4 id="5-1-4-4、重量级锁"><a href="#5-1-4-4、重量级锁" class="headerlink" title="5.1.4.4、重量级锁"></a>5.1.4.4、重量级锁</h4><p>重量级锁竞争时，可以使用自旋来优化。如果当前线程自旋成功（其它线程释放了锁，当前线程获取了锁），那么就可以避免当前线程被阻塞。如果自旋次数达到上限时还没有获取锁，那么就会将轻量级锁升级为重量级锁，然后当前线程会进入到重量级锁的等待队列中进行等待，后续来的线程也会进入该队列进行等待，直到拿到锁的线程执行完毕释放了锁，然后才会唤醒等待队列中的线程。</p><p>重量级锁底层实现是一个Monitor对象，俗称Monitor锁，该对象有WaitSet、EntryList、Owner等重要成员。</p><p>获取轻量级锁失败的线程会将轻量级锁升级为重量级锁，此时会创建Monitor锁对象，然后会在synchronized修饰的锁对象头的markword中存入Monitor对象的地址并设置锁标识位为10，并设置Monitor锁对象的Owner指向获取锁的线程，获取锁失败的线程会进入到Monitor锁对象的EntryList中进行等待，直到获取锁的线程释放了锁，并将Owner设置为null，然后会唤醒EntryList中等待的线程来重新竞争锁。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>锁升级注意事项：</p><ol><li>为了避免无用自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁；</li><li>偏向锁升级为轻量级锁也不能再降级为偏向锁；</li><li>偏向锁状态可以被重置为无锁状态；</li></ol><p>锁优缺点对比：</p><p><img src="/%5Cimgs%5Cjavadev%5CSynachonized-1.1-%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png"></p><h3 id="5-1-5、锁降级"><a href="#5-1-5、锁降级" class="headerlink" title="5.1.5、锁降级"></a>5.1.5、锁降级</h3><p><a href="https://zhuanlan.zhihu.com/p/28505703">https://zhuanlan.zhihu.com/p/28505703</a></p><p><font color='orange'>只被<code>VM Thread</code>访问，降级也就没啥意义了。所以可以认为锁降级不存在！</font></p><h4 id="降级目的和过程"><a href="#降级目的和过程" class="headerlink" title="降级目的和过程"></a>降级目的和过程</h4><p>因为BasicLocking的实现优先于重量级锁的使用，JVM会尝试在STW的停顿中对处于“空闲(idle)”状态的重量级锁进行降级(deflate)。我们知道在STW时，所有的Java线程都会暂停在“安全点(SafePoint)”，此时VM Thread通过对所有Monitor进行遍历，或者通过对所有依赖于<code>MonitorInUseLists</code>值的当前正在“使用”中的<code>Monitor</code>子序列进行遍历，从而得到那些未被使用的“Monitor”并将之作为降级对象。</p><h4 id="降级对象"><a href="#降级对象" class="headerlink" title="降级对象"></a>降级对象</h4><p>重量级锁的降级发生于STW阶段，降级对象就是那些仅仅能被 VM Thread 访问而没有被其它 Java Thread 访问的Monitor对象。</p><h4 id="HotSpot-VM实现"><a href="#HotSpot-VM实现" class="headerlink" title="HotSpot VM实现"></a>HotSpot VM实现</h4><p>HotSpot VM锁降级底层实现，可以参考：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token class-name">ObjectSynchronizer</span><span class="token operator">::</span><span class="token function">deflate_idle_monitors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">assert</span><span class="token punctuation">(</span><span class="token class-name">SafepointSynchronize</span><span class="token operator">::</span><span class="token function">is_at_safepoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"must be at safepoint"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> nInuse <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>              <span class="token comment">// currently associated with objects</span>  <span class="token keyword">int</span> nInCirculation <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>      <span class="token comment">// extant</span>  <span class="token keyword">int</span> nScavenged <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>          <span class="token comment">// reclaimed</span>  bool deflated <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token class-name">ObjectMonitor</span> <span class="token operator">*</span> <span class="token class-name">FreeHead</span> <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>  <span class="token comment">// Local SLL of scavenged monitors</span>  <span class="token class-name">ObjectMonitor</span> <span class="token operator">*</span> <span class="token class-name">FreeTail</span> <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>  <span class="token constant">TEVENT</span> <span class="token punctuation">(</span>deflate_idle_monitors<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">// Prevent omFlush from changing mids in Thread dtor's during deflation</span><span class="token comment">// And in case the vm thread is acquiring a lock during a safepoint</span><span class="token comment">// See e.g. 6320749</span>  <span class="token class-name">Thread</span><span class="token operator">::</span><span class="token function">muxAcquire</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token class-name">ListLock</span><span class="token punctuation">,</span> <span class="token string">"scavenge - return"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">MonitorInUseLists</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> inUse <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">JavaThread</span><span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token class-name">Threads</span><span class="token operator">::</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cur <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> cur <span class="token operator">=</span> cur<span class="token operator">-></span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      nInCirculation<span class="token operator">+=</span> cur<span class="token operator">-></span>omInUseCount<span class="token punctuation">;</span>      <span class="token keyword">int</span> deflatedcount <span class="token operator">=</span> <span class="token function">walk_monitor_list</span><span class="token punctuation">(</span>cur<span class="token operator">-></span><span class="token function">omInUseList_addr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token class-name">FreeHead</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token class-name">FreeTail</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      cur<span class="token operator">-></span>omInUseCount<span class="token operator">-=</span> deflatedcount<span class="token punctuation">;</span><span class="token comment">// verifyInUse(cur);</span>      nScavenged <span class="token operator">+=</span> deflatedcount<span class="token punctuation">;</span>      nInuse <span class="token operator">+=</span> cur<span class="token operator">-></span>omInUseCount<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token comment">// For moribund threads, scan gOmInUseList</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>gOmInUseList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     nInCirculation <span class="token operator">+=</span> gOmInUseCount<span class="token punctuation">;</span>     <span class="token keyword">int</span> deflatedcount <span class="token operator">=</span> <span class="token function">walk_monitor_list</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ObjectMonitor</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>gOmInUseList<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token class-name">FreeHead</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token class-name">FreeTail</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     gOmInUseCount<span class="token operator">-=</span> deflatedcount<span class="token punctuation">;</span>     nScavenged <span class="token operator">+=</span> deflatedcount<span class="token punctuation">;</span>     nInuse <span class="token operator">+=</span> gOmInUseCount<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ObjectMonitor</span><span class="token operator">*</span> block <span class="token operator">=</span> gBlockList<span class="token punctuation">;</span> block <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> block <span class="token operator">=</span> <span class="token function">next</span><span class="token punctuation">(</span>block<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Iterate over all extant monitors - Scavenge all idle monitors.</span>    <span class="token keyword">assert</span><span class="token punctuation">(</span>block<span class="token operator">-></span><span class="token function">object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">CHAINMARKER</span><span class="token punctuation">,</span> <span class="token string">"must be a block header"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    nInCirculation <span class="token operator">+=</span> _BLOCKSIZE <span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _BLOCKSIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">ObjectMonitor</span><span class="token operator">*</span> mid <span class="token operator">=</span> <span class="token operator">&amp;</span>block<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      oop obj <span class="token operator">=</span> <span class="token punctuation">(</span>oop<span class="token punctuation">)</span> mid<span class="token operator">-></span><span class="token function">object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// The monitor is not associated with an object.</span>          <span class="token comment">// The monitor should either be a thread-specific private</span>          <span class="token comment">// free list or the global free list.</span>          <span class="token comment">// obj == NULL IMPLIES mid->is_busy() == 0</span>        guarantee <span class="token punctuation">(</span><span class="token operator">!</span>mid<span class="token operator">-></span><span class="token function">is_busy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"invariant"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>        <span class="token keyword">continue</span> <span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      deflated <span class="token operator">=</span> <span class="token function">deflate_monitor</span><span class="token punctuation">(</span>mid<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token class-name">FreeHead</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token class-name">FreeTail</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>deflated<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        mid<span class="token operator">-></span><span class="token class-name">FreeNext</span> <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>        nScavenged <span class="token operator">++</span> <span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        nInuse <span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token class-name">MonitorFreeCount</span> <span class="token operator">+=</span> nScavenged<span class="token punctuation">;</span><span class="token comment">// Consider: audit gFreeList to ensure that MonitorFreeCount and list agree.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ObjectMonitor</span><span class="token operator">::</span><span class="token class-name">Knob_Verbose</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">::</span><span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"Deflate: InCirc=%d InUse=%d Scavenged=%d ForceMonitorScavenge=%d : pop=%d free=%d\n"</span><span class="token punctuation">,</span>        nInCirculation<span class="token punctuation">,</span> nInuse<span class="token punctuation">,</span> nScavenged<span class="token punctuation">,</span> <span class="token class-name">ForceMonitorScavenge</span><span class="token punctuation">,</span>        <span class="token class-name">MonitorPopulation</span><span class="token punctuation">,</span> <span class="token class-name">MonitorFreeCount</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token operator">::</span><span class="token function">fflush</span><span class="token punctuation">(</span>stdout<span class="token punctuation">)</span> <span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token class-name">ForceMonitorScavenge</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// Reset</span><span class="token comment">// Move the scavenged monitors back to the global free list.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">FreeHead</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     guarantee <span class="token punctuation">(</span><span class="token class-name">FreeTail</span> <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> nScavenged <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"invariant"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>     <span class="token keyword">assert</span> <span class="token punctuation">(</span><span class="token class-name">FreeTail</span><span class="token operator">-></span><span class="token class-name">FreeNext</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"invariant"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">// constant-time list splice - prepend scavenged segment to gFreeList</span>     <span class="token class-name">FreeTail</span><span class="token operator">-></span><span class="token class-name">FreeNext</span> <span class="token operator">=</span> gFreeList <span class="token punctuation">;</span>     gFreeList <span class="token operator">=</span> <span class="token class-name">FreeHead</span> <span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token class-name">Thread</span><span class="token operator">::</span><span class="token function">muxRelease</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token class-name">ListLock</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ObjectMonitor</span><span class="token operator">::</span><span class="token function">_sync_Deflations</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token class-name">ObjectMonitor</span><span class="token operator">::</span><span class="token function">_sync_Deflations</span><span class="token operator">-></span><span class="token function">inc</span><span class="token punctuation">(</span>nScavenged<span class="token punctuation">)</span> <span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ObjectMonitor</span><span class="token operator">::</span><span class="token function">_sync_MonExtant</span>  <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token class-name">ObjectMonitor</span><span class="token operator">::</span><span class="token function">_sync_MonExtant</span> <span class="token operator">-></span><span class="token function">set_value</span><span class="token punctuation">(</span>nInCirculation<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// TODO: Add objectMonitor leak detection.</span><span class="token comment">// Audit/inventory the objectMonitors -- make sure they're all accounted for.</span>  <span class="token class-name">GVars</span><span class="token punctuation">.</span>stwRandom <span class="token operator">=</span> os<span class="token operator">::</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>  <span class="token class-name">GVars</span><span class="token punctuation">.</span>stwCycle <span class="token operator">++</span> <span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1-6、注意事项"><a href="#5-1-6、注意事项" class="headerlink" title="5.1.6、注意事项"></a>5.1.6、注意事项</h3><ol><li>synchronized(Object)模式下，不能用String常量、Integer、Long等类型来作为锁角色。</li><li>锁定方法与非锁定方法可同时执行。</li><li>多个线程必须锁定同一个锁（对象）。（需用final修饰锁对象，防止修改）</li><li>自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。JDK 6 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</li><li>自适应自旋锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</li><li>偏向锁由于有锁撤销的过程，会消耗系统资源，所以，在锁争用特别激烈的时候，用偏向锁未必效率高。还不如直接使用轻量级锁。</li></ol><h2 id="5-2、CAS"><a href="#5-2、CAS" class="headerlink" title="5.2、CAS"></a>5.2、CAS</h2><h3 id="5-2-1、简介"><a href="#5-2-1、简介" class="headerlink" title="5.2.1、简介"></a>5.2.1、简介</h3><p><font color='orange'>CAS是 Compare And Set&#x2F;Swap&#x2F;exchange 的简写，意为比较并交换。</font></p><p><font color='orange'>cas(V, Expected, NewValue)</font>：V为原值，Expected为期望值。NewValue为新值。在修改原值为新值时，判断原值是否与期望值相同，相同则修改，否则拿到和期望值不同的原值再次进行相同逻辑的修改，一直到修改成功为止，这个过程就称为“自旋”。自旋会无意义消耗CPU，故是否选择使用CAS自旋技术，要根据实际场景来选择：</p><ul><li>线程数量多且执行时间长，就要避免使用CAS自旋，而要选用重量级锁来代替，因为重量级锁使用的是等待队列，不会消耗CPU。</li><li>线程数量少且执行时间短，选用CAS自旋会较好。</li></ul><h3 id="5-2-2、底层实现"><a href="#5-2-2、底层实现" class="headerlink" title="5.2.2、底层实现"></a>5.2.2、底层实现</h3><ol><li><font color='orange'>底层指令实现</font>：<ul><li>IA64、X86下：通过<code>lock、cmpxchg</code>指令实现。单纯的<code>cmpxchg</code>不能保证原子性。</li><li>sparc-TSO下：通过<code>case</code>指令实现。</li><li>ARM和PowerPC下：通过一对<code>Idrex/strex</code>指令实现。</li></ul></li><li><font color='orange'>硬件情况下</font>：lock指令在执行后面指令的时候锁定一个北桥信号。</li><li><font color='orange'>拓展知识</font>：处理器 使用【总线锁和缓存锁】来实现原子操作。</li></ol><h3 id="5-2-3、CAS缺点"><a href="#5-2-3、CAS缺点" class="headerlink" title="5.2.3、CAS缺点"></a>5.2.3、CAS缺点</h3><ol><li><p><font color='orange'>ABA问题。</font>解决方法：加版本号。</p></li><li><p><font color='orange'>自旋时间长。</font>解决方法：如果JVM支持处理器提供的pause指令，那么效率会有一点提升。</p><ul><li><p>PAUSE指令作用：</p><ol><li>提升<code>spin-wait loops(自旋锁循环等待)</code>的性能。在执行一个<code>spin-wait loop</code>时，Pentium4 处理器会遇到严重的性能损失，PAUSE 指令会向处理器发起提醒：告诉处理器所执行的代码序列是一个 spin-wait loop。处理器会根据这个提醒而避开内存序列冲突(memory order violation)，也就是说对 spin-wait loop 不做缓存，不做指令重新排序等动作。这样就可以大大的提高了处理器的性能。正是基于此，才建议在 spin-wait loops 中使用 pasuse 指令。</li><li>减少 Pentium4 处理器在执行 spin-wait loop 时的电源消耗。在等待资源而执行自旋锁等待时，Pentium4 处理器会极速执行从而导致消耗很多电能，而<code>pause</code>指令则可以极大的减少处理器的电能消耗。</li></ol></li><li><p>PAUSE指令拓展：</p><p>PAUSE 指令在 Pentium4 处理器中引入，但它也是向前兼容的。在早先的 IA-32 处理器中，PAUSE 指令实际上就相当于 NOP 指令。</p><p>Pentium4 处理器以一种 预延迟(pre-defined delay)的技术来实现 PAUSE 指令。这种延迟是有限度的，且在一些处理器上是零延迟。该指令不会改变处理器的处理器状态。</p></li></ul></li><li><p><font color='orange'>只能保证一个共享变量的原子操作。</font>解决方法：加锁；AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象中执行CAS操作。</p></li></ol><h3 id="5-2-4、自增操作"><a href="#5-2-4、自增操作" class="headerlink" title="5.2.4、自增操作"></a>5.2.4、自增操作</h3><ul><li><p>Synchronized操作。</p><p>执行时间长，因为需要用户态与内核态的切换，从而降低了执行效率。</p></li><li><p>AtomicXXX操作。</p><p>执行时间较Synch要少，因为使用了CAS自旋&#x2F;无锁操作。</p></li><li><p>LongAdder操作。</p><p>执行时间长，因为使用了分段锁。 适用于并发量大的情况。</p></li></ul><h2 id="5-3、Volatile"><a href="#5-3、Volatile" class="headerlink" title="5.3、Volatile"></a>5.3、Volatile</h2><h3 id="5-3-1、简介"><a href="#5-3-1、简介" class="headerlink" title="5.3.1、简介"></a>5.3.1、简介</h3><p>volatile是轻量级的 synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性指的是 当一个线程修改了一个共享变量后，另外一个线程能读到这个共享变量被修改后的值。</p><p>volatile比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p><p>几个重要的CPU术语如下：</p><p><img src="/%5Cimgs%5Cjavadev%5CCPU%E6%9C%AF%E8%AF%AD001.png"></p><p>volatile变量自身具有如下特性。</p><ul><li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li><li>原子性：对任意单个volatile变量的读&#x2F;写具有原子性，但类似于volatile++这种复合操作不具有原子性。</li></ul><h3 id="5-3-2、底层实现"><a href="#5-3-2、底层实现" class="headerlink" title="5.3.2、底层实现"></a>5.3.2、底层实现</h3><h4 id="字节码层面"><a href="#字节码层面" class="headerlink" title="字节码层面"></a>字节码层面</h4><p>在volatile修饰的元素前加了一个访问标志：ACC_VOLATILE。</p><h4 id="JVM层面（规范）"><a href="#JVM层面（规范）" class="headerlink" title="JVM层面（规范）"></a>JVM层面（规范）</h4><ol><li><p>StoreStore Barriers - volatile写 - StoreLoad Barriers。</p></li><li><p>volatile读 - LoadLoad Barriers - LoadStore Barriers。</p></li></ol><h4 id="hotspot"><a href="#hotspot" class="headerlink" title="hotspot"></a>hotspot</h4><p>底层基于大多数CPU都支持的 lock addl 汇编代码指令来实现。</p><p>Lock前缀的指令在多核处理器下的作用：</p><ul><li>将当前处理器缓存行的数据写回到系统内存。</li><li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li></ul><blockquote><p>对volatile修饰的变量执行写操作时会向处理器发送一条Lock前缀指令，将该变量所在缓存行的数据【写回到系统内存】。但要注意，虽然已经写回内存但其它处理器中关于该变量的缓存依然是旧的，对旧的数据执行操作就会有问题。所以，多处理器下，为了保证各个处理器缓存的一致性，就会实现【缓存一 致性协议】，每个处理器通过嗅探总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作时会重新从系统内存中把数据读到处理器缓存里。</p><p>volatile有两个实现原则：</p><ol><li>Lock前缀指令会引起处理器缓存回写到内存。</li><li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</li></ol></blockquote><h4 id="CPU层面"><a href="#CPU层面" class="headerlink" title="CPU层面"></a>CPU层面</h4><ul><li><p>X86 CPU内存屏障（有序性保证）</p><ol><li><font color='orange'>sfence指令</font>：sfence指令前写 优先于 sfence指令后写。</li><li><font color='orange'>lfence指令</font>：lfence指令前读 优先于 lfence指令后读。</li><li><font color='orange'>mfence指令</font>：mfence指令前读写 优先于 sfence指令后读写。</li></ol><p>可惜大多数CPU并不支持这种指令，故hotspor并没有选择这种方案来实现有序性，而是采用大多数CPU都支持的其它指令：lock addl 来实现。</p></li></ul><h3 id="5-3-3、实现一致性-可见性"><a href="#5-3-3、实现一致性-可见性" class="headerlink" title="5.3.3、实现一致性&#x2F;可见性"></a>5.3.3、实现一致性&#x2F;可见性</h3><ol><li><font color='orange'>MESI能解决就用MESI。</font></li><li><font color='orange'>锁总线。</font></li></ol><p>为了保证内存可见性，Java编译器会在生成指令序列的适当位置插入 内存屏障指令 来禁止特定类型的处理器重排序。</p><p><font color='orange'>JMM把内存屏障指令分为4类：LoadLoad屏障、StoreStore屏障、LoadStore屏障、StoreLoad屏障。（详情参考本教程2.4.2节）</font></p><h3 id="5-3-4、实现有序性"><a href="#5-3-4、实现有序性" class="headerlink" title="5.3.4、实现有序性"></a>5.3.4、实现有序性</h3><ol><li>内存屏障、sfence mfence lfence等系统原语&#x2F;指令。sfence mfence lfence为什么不用？因为可移植性差。</li><li>锁总线。</li></ol><h3 id="5-3-5、解决指令重排序"><a href="#5-3-5、解决指令重排序" class="headerlink" title="5.3.5、解决指令重排序"></a>5.3.5、解决指令重排序</h3><ol><li><p><font color='orange'>代码级别</font>：volatile修饰变量。</p></li><li><p><font color='orange'>字节码级别</font>：加访问修饰符 ACC_VOLATILE。</p></li><li><p><font color='orange'>JVM级别</font>：JVM内存屏障。（屏障两边的指令禁止重排）</p></li><li><p><font color='orange'>Hotspot实现</font>：lock addl指令。</p><p>为何lock指令可以解决重排序和可见性问题？因为：lock用于在多处理器中执行指令时会对共享内存进行独占使用，其能够将当前处理器对应的缓存的内容刷新到内存中，并使其它处理器相同缓存中的内容失效。此外还提供有序指令无法越过内存屏障的作用。</p></li><li><p><font color='orange'>系统级别</font>：load fence、store fence原语指令。</p></li></ol><blockquote><p>编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。 </p><p>这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作， 不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p><p>处理器对读&#x2F;写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守as-if-serial语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。 </p><p>as-if-serial语义：不管怎么重排序（编译器和处理器为了提高并行度），（单线程） 程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p><p><font color='red'>注意：在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但允许volatile变量与普通变量重排序。</font></p></blockquote><p>bytecodeinterpreter.cpp</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int field_offset &#x3D; cache-&gt;f2_as_index();if (cache-&gt;is_volatile()) &#123;    if (support_IRIW_for_not_multiple_copy_atomic_cpu) &#123;        OrderAccess::fence();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>orderaccess_linux_x86.inline.hpp</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">inline void OrderAccess::fence() &#123;  if (os::is_MP()) &#123;    &#x2F;&#x2F; always use locked addl since mfence is sometimes expensive#ifdef AMD64    __asm__ volatile (&quot;lock; addl $0,0(%%rsp)&quot; : : : &quot;cc&quot;, &quot;memory&quot;);#else    __asm__ volatile (&quot;lock; addl $0,0(%%esp)&quot; : : : &quot;cc&quot;, &quot;memory&quot;);#endif  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-6、volatile优化"><a href="#5-3-6、volatile优化" class="headerlink" title="5.3.6、volatile优化"></a>5.3.6、volatile优化</h3><h4 id="追加到64字节"><a href="#追加到64字节" class="headerlink" title="追加到64字节"></a>追加到64字节</h4><p><font color='orange'>著名的Java并发编程大师Doug lea在JDK 7的并发包里新增一个队列集合类LinkedTransferQueue，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。</font></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** 队列中的头部节点 */</span> <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">final</span> <span class="token class-name">PaddedAtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">QNode</span><span class="token punctuation">></span></span> head<span class="token punctuation">;</span> <span class="token comment">/** 队列中的尾部节点 */</span> <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">final</span> <span class="token class-name">PaddedAtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">QNode</span><span class="token punctuation">></span></span> tail<span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">V</span> value<span class="token punctuation">;</span>     <span class="token comment">// 省略其他代码 </span>｝<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">PaddedAtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 使用很多4个字节的引用追加到64个字节 </span>    <span class="token class-name">Object</span> p0<span class="token punctuation">,</span> p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">,</span> p4<span class="token punctuation">,</span> p5<span class="token punctuation">,</span> p6<span class="token punctuation">,</span> p7<span class="token punctuation">,</span> p8<span class="token punctuation">,</span> p9<span class="token punctuation">,</span> pa<span class="token punctuation">,</span> pb<span class="token punctuation">,</span> pc<span class="token punctuation">,</span> pd<span class="token punctuation">,</span> pe<span class="token punctuation">;</span>     <span class="token class-name">PaddedAtomicReference</span><span class="token punctuation">(</span><span class="token class-name">T</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="为何追加到64字节？"><a href="#为何追加到64字节？" class="headerlink" title="为何追加到64字节？"></a>为何追加到64字节？</h4><p>因为对于英特尔酷睿i7、酷睿、Atom和 NetBurst，以及Core Solo和Pentium M处理器的L1、L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行。这意味着，如果队列的头节点和尾节点都不足64字节，则处理器会将它们都读到同一个高速缓存行中，多处理器环境下的每个处理器都会缓存同样的头、尾节点，当一 个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致 其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作则需要不断修改头节点，这样一来效率就会大大降低。</p><p>为解决这种问题，就可以把不足64字节的数据后面追加到64字节，也就是说让队列的头节点和尾节点各占一个缓存行，这样就避免了阻塞节点操作，大大提高效率。</p><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><p><font color='orange'>使用volatile变量时一定要追加至64字节的说法并非一定成立。在以下两种场景中不适合：</font></p><ol><li><font color='orange'>缓存行非64字节宽的处理器。</font>如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个 字节宽。 </li><li><font color='orange'>共享变量不会被频繁地写。</font>因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。</li></ol><blockquote><p><font color='red'>注意：追加字节的方式在Java 7下可能不生效，因为Java 7更加智慧，它会淘汰或重新排列无用字段，所以，需要使用其它追加字节的方式。除了volatile，Java并发编程中应用较多的是synchronized。</font></p></blockquote><h2 id="5-4、Lock（锁）"><a href="#5-4、Lock（锁）" class="headerlink" title="5.4、Lock（锁）"></a>5.4、Lock（锁）</h2><h3 id="5-4-1、简介"><a href="#5-4-1、简介" class="headerlink" title="5.4.1、简介"></a>5.4.1、简介</h3><h4 id="锁类架构图"><a href="#锁类架构图" class="headerlink" title="锁类架构图"></a>锁类架构图</h4><img src="\imgs\javadev\Java中的锁和AQS类结构图01.png"/><h4 id="Lock接口特性"><a href="#Lock接口特性" class="headerlink" title="Lock接口特性"></a>Lock接口特性</h4><p>Lock接口提供了synchronized不具备的特性：</p><p><img src="/%5Cimgs%5Cjavadev%5C%E9%94%81-1.1-Lock%E6%8E%A5%E5%8F%A3%E6%8F%90%E4%BE%9B%E4%BA%86synchronized%E4%B8%8D%E5%85%B7%E5%A4%87%E7%9A%84%E7%89%B9%E6%80%A7.png"></p><h3 id="5-4-2、乐观锁"><a href="#5-4-2、乐观锁" class="headerlink" title="5.4.2、乐观锁"></a>5.4.2、乐观锁</h3><h4 id="5-4-2-1、简介"><a href="#5-4-2-1、简介" class="headerlink" title="5.4.2.1、简介"></a>5.4.2.1、简介</h4><p>乐观锁 代表是 AtomicInteger，使用 CAS 保证原子性。</p><p>乐观锁 核心思想：无需加锁，每次只有一个线程能 成功修改 共享变量，其它线程会不断重试直到成功。</p><blockquote><p>乐观锁常见实现就是CAS算法，java java.util.concurrent包下原子类(例如<code>AtomicBoolean</code>，<code>AtomicInteger</code>，<code>AtomicLong</code>)中的递增操作就是通过CAS自旋来实现。</p></blockquote><h4 id="5-4-2-2、特点"><a href="#5-4-2-2、特点" class="headerlink" title="5.4.2.2、特点"></a>5.4.2.2、特点</h4><ul><li>线程一直运行，不会阻塞，故 不存在 线程上下文切换。</li><li>需要多核CPU支持，线程数 不应该 超过 CPU核心数量。</li></ul><h4 id="5-4-2-3、适用场景"><a href="#5-4-2-3、适用场景" class="headerlink" title="5.4.2.3、适用场景"></a>5.4.2.3、适用场景</h4><p><font color='orange'>乐观锁适用于 多读 场景，不加锁可以 提高 读操作性能。</font></p><h3 id="5-4-3、悲观锁"><a href="#5-4-3、悲观锁" class="headerlink" title="5.4.3、悲观锁"></a>5.4.3、悲观锁</h3><h4 id="5-4-3-1、简介"><a href="#5-4-3-1、简介" class="headerlink" title="5.4.3.1、简介"></a>5.4.3.1、简介</h4><p>悲观锁 代表是 synchronized 和 Lock 锁。</p><p>悲观锁 核心思想：线程占有了锁，才能操作共享变量，每次只能有一个线程占有锁，其它获线程都要等待。</p><h4 id="5-4-3-2、特点"><a href="#5-4-3-2、特点" class="headerlink" title="5.4.3.2、特点"></a>5.4.3.2、特点</h4><ul><li>线程从运行到阻塞，再从阻塞到唤醒，期间经历 线程上下文切换，若频繁发生，则会严重影响性能。</li><li>获取 synchronized 和 Lock 锁时，若锁已被占用，那么会默认重试几次，减少阻塞机会。</li></ul><h4 id="5-4-3-3、适用场景"><a href="#5-4-3-3、适用场景" class="headerlink" title="5.4.3.3、适用场景"></a>5.4.3.3、适用场景</h4><p><font color='orange'>悲观锁适用于 多写 场景，先加锁可以保证写操作时数据的正确性。</font></p><h3 id="5-4-4、重入锁"><a href="#5-4-4、重入锁" class="headerlink" title="5.4.4、重入锁"></a>5.4.4、重入锁</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对 资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。</p><p>ReentrantLock虽然没能像synchronized关键字一样支持隐式的重进入，但是在调用lock()方 法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。</p><h4 id="重入锁特点"><a href="#重入锁特点" class="headerlink" title="重入锁特点"></a>重入锁特点</h4><ol><li>线程A获取锁L后，可以在不释放锁L的同时再次获取锁L，且不会出现死锁现象；</li><li>线程A释放掉锁L后，其它线程才能获取锁L；</li></ol><p><font color='orange'>可重入锁的使命就是防止自己锁自己，进而提高程序执行性能。</font></p><p>Java中可重入锁的常见实现如下：</p><ol><li>Synchronized</li><li>ReentrantLock</li></ol><h3 id="5-4-5、ReentrantLock"><a href="#5-4-5、ReentrantLock" class="headerlink" title="5.4.5、ReentrantLock"></a>5.4.5、ReentrantLock</h3><h4 id="5-4-5-1、简介"><a href="#5-4-5-1、简介" class="headerlink" title="5.4.5.1、简介"></a>5.4.5.1、简介</h4><p><font color='orange'>ReentrantLock是一个可重入锁、独占式锁，与synchronized关键字相比，它更灵活、更强大，增加了轮询、超时、中断等高级功能。除此外，还提供了对公平锁与非公平锁的选择。</font></p><p>ReentrantLock的内部类Sync继承了AQS，分为公平锁FairSync和非公平锁NonfairSync。ReentrantLock使用公平锁还是非公平锁，可以通过它的构造函数来决定。</p><blockquote><ul><li>公平锁：按照请求的顺序来获取锁；</li><li>非公平锁：不管请求顺序的先后，谁抢到锁，这把锁就是谁的。</li></ul></blockquote><p>事实上，公平锁往往没有非公平锁的效率高，但是，并不是任何场景都是以TPS作为唯一指标，公平锁能够减少“饥饿”发生的概率，等待越久的请求越能够得到优先满足。</p><h4 id="5-4-5-2、原理"><a href="#5-4-5-2、原理" class="headerlink" title="5.4.5.2、原理"></a>5.4.5.2、原理</h4><p><font color='orange'>ReentrantLock 主要通过 unsafe的CAS和park两个功能实现锁（CAS + park ）机制。</font></p><p>Sync类是ReentrantLock自定义同步组件，它是ReentrantLock的一个内部类，其继承自AQS，它有两个子类：公平锁FairSync和非公平锁NonfairSync。ReentrantLock的获取与释放锁操作都是委托给该同步组件来实现。</p><h3 id="5-4-6、读写锁"><a href="#5-4-6、读写锁" class="headerlink" title="5.4.6、读写锁"></a>5.4.6、读写锁</h3><h4 id="5-4-6-1、简介"><a href="#5-4-6-1、简介" class="headerlink" title="5.4.6.1、简介"></a>5.4.6.1、简介</h4><p>读多写少情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。读写锁的实现是 ReentrantReadWriteLock。</p><p>ReadWriteLock仅定义了获取读锁和写锁的两个方法，其实现ReentrantReadWriteLock，除了接口方法之外，还提供了一些便于外界监控内部工作状态的方法。</p><h4 id="5-4-6-2、特点"><a href="#5-4-6-2、特点" class="headerlink" title="5.4.6.2、特点"></a>5.4.6.2、特点</h4><p><img src="/%5Cimgs%5Cjavadev%5C%E9%94%81-1.2-%E8%AF%BB%E5%86%99%E9%94%81%E7%89%B9%E6%80%A7.png"></p><h4 id="5-4-6-3、底层实现"><a href="#5-4-6-3、底层实现" class="headerlink" title="5.4.6.3、底层实现"></a>5.4.6.3、底层实现</h4><h5 id="读写状态"><a href="#读写状态" class="headerlink" title="读写状态"></a>读写状态</h5><p>读写锁 同样依赖 自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。ReentrantLock中自定义同步器的同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状 态，使得该状态的设计成为读写锁实现的关键。</p><p>如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将 变量切分成了两个部分，高16位表示读，低16位表示写，划分方式如下图：</p><p><img src="/%5Cimgs%5Cjavadev%5C%E9%94%81-1.3-%E8%AF%BB%E5%86%99%E9%94%81%E7%8A%B6%E6%80%81%E5%88%92%E5%88%86%E8%AE%BE%E8%AE%A1%E5%9B%BE.png"></p><p>读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。假设当前同步状态 值为S，写状态等于S&amp;0x0000FFFF（将高16位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号补0右移 16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是 S+0x00010000。</p><h5 id="写锁获取与释放"><a href="#写锁获取与释放" class="headerlink" title="写锁获取与释放"></a>写锁获取与释放</h5><p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程， 则当前线程进入等待状态。</p><blockquote><p>如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果 允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当 前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写 锁一旦被获取，则其他读写线程的后续访问均被阻塞。</p></blockquote><p>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0 时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对 后续读写线程可见。</p><h5 id="读锁获取与释放"><a href="#读锁获取与释放" class="headerlink" title="读锁获取与释放"></a>读锁获取与释放</h5><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问 （或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程 获取，则进入等待状态。</p><p>读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少值是（1&lt;&lt;16）。</p><h4 id="5-4-6-4、锁升级-降级"><a href="#5-4-6-4、锁升级-降级" class="headerlink" title="5.4.6.4、锁升级&#x2F;降级"></a>5.4.6.4、锁升级&#x2F;降级</h4><h5 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h5><p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到 读锁，随后释放（先前拥有的）写锁的过程。</p><h5 id="锁升级（不存在）"><a href="#锁升级（不存在）" class="headerlink" title="锁升级（不存在）"></a>锁升级（不存在）</h5><p>RentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。</p><h3 id="5-4-10、小总结"><a href="#5-4-10、小总结" class="headerlink" title="5.4.10、小总结"></a>5.4.10、小总结</h3><h4 id="5-4-10-1、Synchronized和ReentrantLock区别"><a href="#5-4-10-1、Synchronized和ReentrantLock区别" class="headerlink" title="5.4.10.1、Synchronized和ReentrantLock区别"></a>5.4.10.1、Synchronized和ReentrantLock区别</h4><h5 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h5><ol><li>都是用来协调多线程对共享对象、变量的访问。</li><li>都是可重入锁，即同一线程可以多次获得同一个锁。</li><li>都保证了可见性和互斥性。</li></ol><h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h5><ol><li><p>API方面</p><ul><li>Synchronized：可修饰方法、代码块。隐式获取&#x2F;释放锁。</li><li>ReentrantLock：显式获取&#x2F;释放锁。（获取锁：ReentrantLock.lock；释放锁：ReentrantLock.unlock）</li></ul></li><li><p>等待可中断</p><p>有两个线程：T1、T2，假设T1获取了对象object的锁，T2将等待T1释放object的锁。则：</p><ul><li>Synchronized：T2会一直等待下去，不可被中断。</li><li>ReentrantLock：T2等待一定时间后，会中断操作，转而去做其它事。</li></ul></li><li><p>公平锁</p><ul><li>Synchronized：是非公平锁。</li><li>ReenTrantLock：默认是非公平锁，可通过布尔值来控制使用公平锁。</li></ul></li><li><p>绑定多个条件</p><ul><li>Synchronized：锁对象的wait和notify() 或notifyAll()方法可以实现一个隐含的条件。</li><li>ReenTrantLock：可以同时绑定多个Condition对象，只需多次调用newCondition方法即可。</li></ul></li><li><p>性能</p><p>JDK1.5中的Synchronized有很大优化余地。JDK 1.6 中加入了很多针对锁的优化措施，故synchronized与ReentrantLock在性能方面基本持平。</p></li><li><p>其它</p><ul><li>Synchronized是关键字，是内置语言的实现。Lock是一个接口。</li><li>Synchronized在发生异常时，会自动释放线程占有的锁，不会导致死锁发生。Lock必须通过unlock方法释放锁，否则会造成死锁。</li><li>Synchronized无法判断是否获取到锁；Lock可以。</li><li>Synchronized不管读写，都会阻塞线程，读效率低；Lock可以提供读写锁，可提高并发读的效率。</li></ul></li></ol><table><thead><tr><th align="center">比较方面</th><th align="center">synchronized</th><th align="center">ReenTrantLock</th></tr></thead><tbody><tr><td align="center">原始构成</td><td align="center">Java关键字，原生语法层面的互斥，需要JVM支持。</td><td align="center">JDK1.5之后提供的互斥锁</td></tr><tr><td align="center">实现</td><td align="center">通过JVM自动加锁&#x2F;解锁</td><td align="center">显式加锁&#x2F;解锁</td></tr><tr><td align="center">代码实现</td><td align="center">隐式自动获取锁&#x2F;释放锁</td><td align="center">显式获取锁&#x2F;释放锁</td></tr><tr><td align="center">灵活性</td><td align="center">锁的范围可以随意控制</td><td align="center">Lock是方法调用，可跨方法，灵活性更大</td></tr><tr><td align="center">等待可中断</td><td align="center">不可中断，除非抛出异常。</td><td align="center">可中断</td></tr><tr><td align="center">公平</td><td align="center">非公平锁</td><td align="center">默认非公平锁，但可通过布尔值控制使用公平锁</td></tr><tr><td align="center">条件Condition</td><td align="center"></td><td align="center">通过多次newCondition可以获得多个Condition对象，可以简单的实现比较复杂的线程同步功能。</td></tr><tr><td align="center">高级功能</td><td align="center"></td><td align="center">getHoldCount()、getQueueLength()、isFair()、isHeldByCurrentThread()、isLocked()</td></tr><tr><td align="center">便利性</td><td align="center">会自动释放获取锁，便利性好。</td><td align="center">需要手动获取释放锁，便利性差。</td></tr><tr><td align="center">适用情况</td><td align="center">适用于并发度低的情况。</td><td align="center">适用于并发度高的情况。</td></tr></tbody></table><h4 id="5-4-10-2、Lock-VS-Synchronized"><a href="#5-4-10-2、Lock-VS-Synchronized" class="headerlink" title="5.4.10.2、Lock VS Synchronized"></a>5.4.10.2、Lock VS Synchronized</h4><p>Lock可以非阻塞获取锁；被中断地获取锁；超时获取锁。</p><h2 id="5-5、原子操作"><a href="#5-5、原子操作" class="headerlink" title="5.5、原子操作"></a>5.5、原子操作</h2><h3 id="5-5-1、简介"><a href="#5-5-1、简介" class="headerlink" title="5.5.1、简介"></a>5.5.1、简介</h3><p>原子操作（atomic operation）意 为“不可被中断的一个或一系列操作”。</p><p>原子操作相关术语如下：</p><p><img src="/%5Cimgs%5Cjavadev%5C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-1.1-%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD.png"></p><h3 id="5-5-2、处理器原子操作"><a href="#5-5-2、处理器原子操作" class="headerlink" title="5.5.2、处理器原子操作"></a>5.5.2、处理器原子操作</h3><p>首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写 入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节 的内存地址。</p><p>为保证复杂内存操作的原子性，处理器提供了两种机制：</p><ul><li><p><font color='orange'>总线锁</font></p><p>所谓总线锁就是使用处理器提供的一个 LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该 处理器可以独占共享内存。</p></li><li><p><font color='orange'>缓存锁</font></p><p>总线锁定把CPU和内存之间的通信锁住了，开销较大，所以使用缓存锁定代替总线锁定来进行优化。</p><p>有两种情况下处理器不会使用缓存锁定：</p><ol><li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，处理器会调用总线锁定。</li><li>有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的 内存区域在处理器的缓存行中也会调用总线锁定。</li></ol></li></ul><h3 id="5-5-3、Java原子操作"><a href="#5-5-3、Java原子操作" class="headerlink" title="5.5.3、Java原子操作"></a>5.5.3、Java原子操作</h3><p><font color='orange'>Java中可以通过【锁和循环CAS】的方式来实现原子操作。</font></p><h4 id="CAS实现原子操作"><a href="#CAS实现原子操作" class="headerlink" title="CAS实现原子操作"></a>CAS实现原子操作</h4><p>JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。从Java 1.5开始，JDK的并发包里提供了一些原子操作类来支持原子操作。</p><p>CAS实现原子操作的三大问题：</p><ol><li>ABA问题。</li><li>循环时间长开销大。</li><li>只能保证一个共享变量的原子操作。</li></ol><h4 id="锁实现原子操作"><a href="#锁实现原子操作" class="headerlink" title="锁实现原子操作"></a>锁实现原子操作</h4><p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁 机制，有偏向锁、轻量级锁和互斥锁。除了偏向锁，JVM实现锁的方式都用了循环 CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时 候使用循环CAS释放锁。</p><h4 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h4><p>从JDK 1.5开始提供了java.util.concurrent.atomic包，Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。Atomic包里的类基本都是使用Unsafe实现的包装类。</p><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><ul><li>AtomicBoolean：原子更新布尔类型。 </li><li>AtomicInteger：原子更新整型。 </li><li>AtomicLong：原子更新长整型。</li></ul><p>Java的基本类型里还有char、float和double等，对其这些基本类型，可以将它们转换成整型后，再使用compareAndSwapInt进行CAS更新。</p><h5 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h5><ul><li>AtomicIntegerArray：原子更新整型数组里的元素。 </li><li>AtomicLongArray：原子更新长整型数组里的元素。 </li><li>AtomicReferenceArray：原子更新引用类型数组里的元素。</li></ul><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><ul><li>AtomicReference：原子更新引用类型。 </li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。 </li><li>AtomicMarkableReference：原子更新带有标记位的引用类型。</li></ul><h5 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h5><ul><li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。 </li><li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。 </li><li>AtomicStampedReference：原子更新带有版本号的引用类型。</li></ul><h2 id="5-6、并发工具类"><a href="#5-6、并发工具类" class="headerlink" title="5.6、并发工具类"></a>5.6、并发工具类</h2><h3 id="5-6-1、CountDownLatch"><a href="#5-6-1、CountDownLatch" class="headerlink" title="5.6.1、CountDownLatch"></a>5.6.1、CountDownLatch</h3><p><font color='orange'>CountDownLatch允许一个或多个线程等待其他线程完成操作。</font></p><p><font color='orange'>调用CountDownLatch的countDown方法时，N会减1，CountDownLatch的await方法会阻塞当前线程，直到N变成零。</font>由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程中时，只需要把这个 CountDownLatch的引用传递到线程里即可。 </p><p><font color='red'>注意：计数器必须大于等于0，如果等于0，则调用await方法时不会阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值。一个线程调用countDown方法happen-before另外一个线程调用await方法。</font></p><h3 id="5-6-2、CyclicBarrier"><a href="#5-6-2、CyclicBarrier" class="headerlink" title="5.6.2、CyclicBarrier"></a>5.6.2、CyclicBarrier</h3><p>CyclicBarrier是可循环使用（Cyclic）的屏障（Barrier）。它的目的：让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p><p>CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p><p>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier（int parties，Runnable barrierAction），用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景。</p><ul><li>CyclicBarrier VS CountDownLatch</li></ul><p>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。</p><h3 id="5-6-3、Semaphore"><a href="#5-6-3、Semaphore" class="headerlink" title="5.6.3、Semaphore"></a>5.6.3、Semaphore</h3><p><font color='orange'>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。 </font></p><p>Semaphore的构造方法Semaphore(int permits) 接受一个整型的数字，表示可用的许可证数量。Semaphore(10) 表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用 Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。</p><h3 id="5-6-4、Exchanger"><a href="#5-6-4、Exchanger" class="headerlink" title="5.6.4、Exchanger"></a>5.6.4、Exchanger</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>Exchanger（交换者）是一个用于线程间协作的工具类</font>。Exchanger用于线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。<font color='orange'>两个线程通过 exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</font> </p><p><font color='red'>注意：如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange(V x, longtimeout, TimeUnit unit)设置最大等待时长。</font></p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>Exchanger可以用于遗传算法，遗传算法中需要选出两个人作为交换对象，这时候会交换两人的数据，并使用交叉规则得出2个结果。</li><li>Exchanger也可以用于校对工作。</li></ol><h2 id="5-7、并发容器及框架"><a href="#5-7、并发容器及框架" class="headerlink" title="5.7、并发容器及框架"></a>5.7、并发容器及框架</h2><h3 id="5-7-1、阻塞队列"><a href="#5-7-1、阻塞队列" class="headerlink" title="5.7.1、阻塞队列"></a>5.7.1、阻塞队列</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><p>JDK 7提供了7个阻塞队列，如下。 </p><ul><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。 </li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。 </li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。 </li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。 </li><li>SynchronousQueue：一个不存储元素的阻塞队列。 </li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 </li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ul><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><p>此队列按照先进先出（FIFO）的原 则对元素进行排序，默认情况下不保证线程访问队列的公平性。</p><p>为了保证公平性，通常会降低吞吐量。可以使用以下代码创建一个公平的阻塞队列：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ArrayBlockingQueue</span> fairQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><p>此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p><h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h5><p>默认情况下元素采取自然顺序 升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化 PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证 同优先级元素的顺序。</p><h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h5><p>DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队 列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。 只有在延迟期满时才能从队列中提取元素。</p><p>应用场景：</p><ul><li>缓存系统的设计</li><li>定时任务调度</li></ul><h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h5><p>每一个put操作必须等待一个take操作， 否则不能继续添加元素。</p><p>它支持公平访问队列，默认情况下线程采用非公平性策略访问队列。</p><p>SynchronousQueue的吞吐量高于 LinkedBlockingQueue和ArrayBlockingQueue。</p><h5 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h5><p>相对于其它 阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</p><ul><li><p>transfer方法</p><p>如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法 时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等 待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。</p></li><li><p>tryTransfer方法</p><p>tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等 待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法 立即返回，而transfer方法是必须等到消费者消费了才返回。</p></li></ul><h5 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h5><p>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以 从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队 时，也就减少了一半的竞争。</p><p>初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以 运用在“工作窃取”模式中</p><h4 id="底层实现-2"><a href="#底层实现-2" class="headerlink" title="底层实现"></a>底层实现</h4><p><font color='orange'>阻塞队列 底层主要使用【通知模式】来实现生产者与消费者间的通信。</font></p><p>ArrayBlockingQueue使用了Condition来实现，当往队列里插入一个元素时，如果队列不可用，那么阻塞生产者主要通过 LockSupport.park（this）来实现。</p><p>park这个方法会阻塞当前线程，只有以下4种情况中的一种发生时，该方法才会返回：</p><ul><li>与park对应的unpark执行或已经执行过时。</li><li>线程被中断时。</li><li>等待完time参数指定的毫秒数时。</li><li>异常现象发生时，这个异常现象没有任何原因。</li></ul><h3 id="5-7-2、ForkJoin框架"><a href="#5-7-2、ForkJoin框架" class="headerlink" title="5.7.2、ForkJoin框架"></a>5.7.2、ForkJoin框架</h3><h4 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>Fork&#x2F;Join框架是Java 7提供的一个用于【并行执行任务】的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</font></p><h4 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h4><p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。</p><p>工作窃取算法的优缺点如下：</p><ul><li><p>优点</p><p>充分利用线程进行并行计算，减少了线程间的竞争</p></li><li><p>缺点</p><p>某些情况下还是存在竞争，比如双端队列里只有一个任务时。并 且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p></li></ul><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经 被取消，且可以通过ForkJoinTask的getException方法获取异常。</p><p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或没有抛出异常则返回null。</p><h4 id="底层设计"><a href="#底层设计" class="headerlink" title="底层设计"></a>底层设计</h4><ul><li>步骤1，分割任务。</li><li>步骤2，执行任务并合并结果。</li></ul><p>Fork&#x2F;Join使用两个类来完成以上两件事情：</p><ul><li><p>ForkJoinTask：使用ForkJoin框架，必须首先创建一个ForkJoin任务。</p><p>通常情况下，我们不需要直接继承ForkJoinTask类，只需要继 承它的子类：</p><ul><li>RecursiveAction：用于没有返回结果的任务。 </li><li>RecursiveTask：用于有返回结果的任务。</li></ul></li><li><p>ForkJoinPool：ForkJoinTask需要通过ForkJoinPool来执行。</p></li></ul><p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责将存放程序提交给ForkJoinPool的任务，而ForkJoinWorkerThread数组负责执行这些任务。</p><ul><li><p>ForkJoinTask的fork方法</p><p>调用ForkJoinTask的fork方法时，会异步调用ForkJoinWorkerThread的pushTask方法将任务放到ForkJoinTask数组中，然后调用ForkJoinPool的signalWork方法唤醒或创建一个线程去执行该任务。</p></li><li><p>ForkJoinTask的join方法</p><p>调用Join方法会调用doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有4种：已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常 （EXCEPTIONAL）。</p></li></ul><h2 id="5-8、并发底层原理"><a href="#5-8、并发底层原理" class="headerlink" title="5.8、并发底层原理"></a>5.8、并发底层原理</h2><h3 id="5-8-1、LockSupport工具"><a href="#5-8-1、LockSupport工具" class="headerlink" title="5.8.1、LockSupport工具"></a>5.8.1、LockSupport工具</h3><p>LockSupport是构建同步组件的基础工具。LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread) 方法来唤醒一个被阻塞的线程。</p><p>Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos) 和parkUntil(Object blocker,long deadline)3个方法，用于实现阻塞当前线程的功能，其中参数 blocker是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和 系统监控。</p><h3 id="5-8-2、Condition接口"><a href="#5-8-2、Condition接口" class="headerlink" title="5.8.2、Condition接口"></a>5.8.2、Condition接口</h3><h4 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h4><p>Java对象（wait&#x2F;notify）配合Synchronized可以实现等待&#x2F;通知模式。Condition接口配合Lock同样可以实现等待&#x2F;通知模式，但是两者的使用方式和功能特性是有差别的。</p><p>Object监视器 VS Condition接口：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200620151112096.png" alt="image-20200620151112096"></p><p>Condition对象由Lock对象（调用Lock对象的newCondition()方法）创建出来，即 通过Lock的newCondition()方法可以获取一个Condition。</p><p>Condition使用方式比较简单。当前线程调用await()方法后会释放锁并在此等待，其它线程调用Condition对象的signal()方法会导致当前线程获取锁并从await()方法返回。</p><h4 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h4><p>ConditionObject是同步器AbstractQueuedSynchronizer的内部类，每个Condition对象都包含一个等待队列，该队列是Condition对象实现等待&#x2F;通知功能的关键。</p><p><font color='orange'>Condition的实现主要包括：等待队列、等待和通知，下面提到的Condition，如果不加说明均指的是ConditionObject。</font></p><ul><li><p><font color='orange'>等待队列</font></p><p>等待队列是一个FIFO单向队列，队列中的每个节点都包含一个线程引用，该线程就是 在Condition对象上等待的线程，<font color='orange'>一个线程调用Condition.await()方法后会释放锁并被构造成节点放入到等待队列，然后进入等待状态。</font>事实上，节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中的节点类型都是同步器的静态内部类 AbstractQueuedSynchronizer.Node。</p><p>一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点 （lastWaiter）。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210221163426067.png" alt="image-20210221163426067"></p><p><font color='orange'>Object监视器模型中，一个对象拥有一个同步队列和等待队列，而并发包中的 Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列。</font></p><p>Condition是同步器的内部类，因此每个Condition实例都能够访问 同步器提供的方法，相当于每个Condition都拥有所属同步器的引用。</p></li><li><p><font color='orange'>等待</font></p><p>调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</p><p>如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同 步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。</p></li><li><p><font color='orange'>通知</font></p><p>调用Condition的signal()方法会导致：将等待队列的首节点移至同步队列中，然后唤醒该节点中的线程，被唤醒的线程会通过调用同步器的acquireQueued()方法来尝试获取同步状态。成功获取同步状态（锁）后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功获取了锁。</p><blockquote><p><font color='red'>注意事项：</font></p><ol><li>当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</li><li>调用signal()方法的前提是当前线程必须获取了锁；</li><li>如果节点不是通过Condition.signal()方法被唤醒，而是通过中断被唤醒的话，会抛出异常 InterruptedException。</li></ol></blockquote></li></ul><p>Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点中的线程。</p><h4 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h4><p><font color='orange'>为什么wait()、notyfy()、notifyAll()要放在同步块中？</font></p><ol><li>调用wait()就是释放锁，释放锁的前提必须要先获得锁，先获得锁才能释放锁。</li><li>notify()、notifyAll()是将锁交给调用wait()方法的线程，让其继续执行下去，如果自身没有锁，怎么叫把锁交给其他线程呢；（本质是让处于入口队列的线程竞争锁）。</li></ol><h3 id="5-8-3、AQS（CLH）"><a href="#5-8-3、AQS（CLH）" class="headerlink" title="5.8.3、AQS（CLH）"></a>5.8.3、AQS（CLH）</h3><h4 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>AQS（Abstract Queued Synchronizer）：简称抽象队列同步器。</font></p><p>CLH（Craig Landin and Hagersten locks）：是一种基于链表的可扩展、高性能、公平的自旋锁，能确保无饥饿性、公平性。申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。</p><h4 id="底层实现-3"><a href="#底层实现-3" class="headerlink" title="底层实现"></a>底层实现</h4><p><font color='orange'>基于volatile + CAS + 队列来实现。</font></p><h5 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h5><p><font color='orange'>同步器 依赖内部的 同步队列（FIFO双向队列）来完成同步状态管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node），然后基于CAS的方式放入到同步队列尾部，同时会阻塞当前线程，当同步队列首节点释放同步状态时，会唤醒后继节点来获取同步状态，后继节点获取同步状态成功后会将自己设置为首节点。 </font></p><p><font color='orange'>同步队列中的节点（Node）保存的内容：获取同步状态失败的线程引用、等待状态以及前驱和后继节点。</font></p><p>同步队列的基本结构如下图所示：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200721002028762.png" alt="image-20200721002028762"></p><p>同步器拥有首节点（head） 和尾节点（tail）。 当一个线程无法获取到同步状态时，会被构造成节点并放入到同步队列末尾。放入队列末尾的操作将通过调用CAS方法：<code>compareAndSetTail(Node expect,Node update)</code>来实现，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。 插入过程如图所示：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200721002419902.png" alt="image-20200721002419902"></p><p>同步队列遵循FIFO规则，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点来获取同步状态，而后继节点在获取同步状态成功时会将自己设置为首节点。</p><p><font color='orange'>注意：由于只有一个线程能够成功获取到同步状态，因此设置头节点的操作并不需要通过CAS来保证。 </font></p><h5 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h5><p><font color='orange'>等待队列是一个FIFO单向队列。线程A调用Condition.await()方法将会导致线程A释放锁并被构造成节点放入到等待队列末尾，同时线程A进入等待状态。</font></p><p>等待队列基本结构如下图所示：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200721004540435.png" alt="image-20200721004540435"></p><p><font color='orange'>Object监视器模型中，一个对象拥有一个同步队列和等待队列，而并发包中的 Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列，</font>其对应关系如图所示：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200721004716947.png" alt="image-20200721004716947"></p><h5 id="独占式获取与释放"><a href="#独占式获取与释放" class="headerlink" title="独占式获取与释放"></a>独占式获取与释放</h5><p>调用同步器的acquire(int arg)方法可以获取同步状态，该方法对中断不敏感。</p><p><font color='orange'>当前线程调用<code>acquireQueued(final Node node,int arg)</code>方法会在“死循环”中尝试获取同步状态，而只有前驱节点是头节点才能够尝试获取同步状态，</font>这是为什么？原因有两个：</p><ol><li>头节点是成功获取到同步状态的节点，头节点中的线程释放同步状态后会唤醒后继节点来获取同步状态，后继节点中的线程被唤醒后还需要检查自己的前驱节点是否是头节点。 </li><li>维护同步队列的FIFO原则。</li></ol><p><font color='orange'>调用同步器的<code>release(int arg)</code>方法会释放同步状态，释放同步状态后会唤醒后继节点来尝试获取同步状态。</font></p><h5 id="共享式获取与释放"><a href="#共享式获取与释放" class="headerlink" title="共享式获取与释放"></a>共享式获取与释放</h5><p>共享式获取与独占式获取最主要的区别在于：同一时刻能否有多个线程同时获取到同步状态。</p><p>通过调用同步器的acquireShared(int arg)方法可以共享式获取同步状态。共享式成功获取到同步状态并退出自旋的条件是<code>tryAcquireShared(int arg)</code>方法返回值大于等于0。其具体过程：如果当前节点的前驱节点是头节点，则尝试获取同步状态，返回值大于等于0时标志着获取同步状态成功并从自旋过程中退出。</p><p>与独占式一样，共享式获取也需要释放同步状态，通过调用releaseShared(int arg)方法可以释放同步状态。</p><h3 id="5-8-4、Unsafe"><a href="#5-8-4、Unsafe" class="headerlink" title="5.8.4、Unsafe"></a>5.8.4、Unsafe</h3><h4 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h4><ol><li>主要用来操作JVM中的内存。</li><li>直接操作内存：allocateMemory、putXX、freeMemory、pageSize</li><li>直接生成实例：allocateInstance。</li><li>直接操作类或实例变量：objectFieldOffset、getInt、getObject。</li><li>CAS相关：weakCompareAndSetObject &#x2F; int &#x2F; Long。</li><li>Unsafe相当于C&#x2F;C++中的指针。</li></ol><blockquote><p><strong>注意</strong>：C分配&#x2F;释放内存使用malloc&#x2F;free，C++分配&#x2F;释放内存使用new&#x2F;delete。</p></blockquote><h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><p>Atomicinteger：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> next <span class="token operator">=</span> current <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Unsafe:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">,</span> <span class="token keyword">int</span> var5<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span><span class="token class-name">Unsafe</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Field</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">T02_TestUnsafe</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">T02_TestUnsafe</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T02_TestUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//Unsafe unsafe = Unsafe.getUnsafe();</span>        <span class="token class-name">Field</span> unsafeField <span class="token operator">=</span> <span class="token class-name">Unsafe</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        unsafeField<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Unsafe</span> unsafe <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Unsafe</span><span class="token punctuation">)</span> unsafeField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Field</span> f <span class="token operator">=</span> <span class="token class-name">T02_TestUnsafe</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"i"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> offset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> success <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//unsafe.compareAndSwapInt()</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>jdk8u: unsafe.cpp:</p><p>cmpxchg &#x3D; compare and exchange</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))  UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;);  oop p &#x3D; JNIHandles::resolve(obj);  jint* addr &#x3D; (jint *) index_oop_from_field_offset_long(p, offset);  return (jint)(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e;UNSAFE_END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>jdk8u: atomic_linux_x86.inline.hpp</p><p>is_MP &#x3D; Multi Processor  </p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">inline jint Atomic::cmpxchg(jint exchange_value, volatile jint*dest, jint compare_value) &#123;  int mp &#x3D; os::is_MP();  __asm__ volatile (LOCK_IF_MP(%4) &quot;cmpxchgl %1,(%3)&quot;                    : &quot;&#x3D;a&quot; (exchange_value)                    : &quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp)                    : &quot;cc&quot;, &quot;memory&quot;);  return exchange_value;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>jdk8u: os.hpp is_MP()</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static inline bool is_MP() &#123;  &#x2F;&#x2F; During bootstrap if _processor_count is not yet initialized  &#x2F;&#x2F; we claim to be MP as that is safest. If any platform has a  &#x2F;&#x2F; stub generator that might be triggered in this phase and for  &#x2F;&#x2F; which being declared MP when in fact not, is a problem - then  &#x2F;&#x2F; the bootstrap routine for the stub generator needs to check  &#x2F;&#x2F; the processor count directly and leave the bootstrap routine  &#x2F;&#x2F; in place until called after initialization has ocurred.  return (_processor_count !&#x3D; 1) || AssumeMP;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>jdk8u: atomic_linux_x86.inline.hpp</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define LOCK_IF_MP(mp) &quot;cmp $0, &quot; #mp &quot;; je 1f; lock; 1: &quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最终实现：cmpxchg &#x3D; cas修改变量值</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lock cmpxchg 指令<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>硬件：lock指令在执行后面指令的时候锁定一个北桥信号（不采用锁总线的方式）。</p><h1 id="6、Java线程池"><a href="#6、Java线程池" class="headerlink" title="6、Java线程池"></a>6、Java线程池</h1><h2 id="6-1、认识线程池"><a href="#6-1、认识线程池" class="headerlink" title="6.1、认识线程池"></a>6.1、认识线程池</h2><h3 id="6-1-1、线程池优点"><a href="#6-1-1、线程池优点" class="headerlink" title="6.1.1、线程池优点"></a>6.1.1、线程池优点</h3><p>合理地使用线程池能够带来3个好处：</p><ol><li>降低资源消耗。</li><li>提高响应速度。</li><li>提高线程的可管理性。</li></ol><h3 id="6-1-2、提交任务"><a href="#6-1-2、提交任务" class="headerlink" title="6.1.2、提交任务"></a>6.1.2、提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。</p><p>两者区别如下：</p><ol><li>execute方法没有返回值，submit方法有返回值；</li><li>execute方法会抛出异常，submit方法不会抛出异常，但可通过Future.get方法打印异常；</li><li>execute方法入参为Runnable，submit方法入参可以是Runnable，也可以是Callable；</li></ol><h3 id="6-1-3、执行任务"><a href="#6-1-3、执行任务" class="headerlink" title="6.1.3、执行任务"></a>6.1.3、执行任务</h3><p>当提交一个新任务到线程池时，线程池的处理流程如下。</p><ol><li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作 线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li><li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这 个工作队列里。如果工作队列满了，则进入下个流程。</li><li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程 来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li></ol><h3 id="6-1-4、关闭线程池"><a href="#6-1-4、关闭线程池" class="headerlink" title="6.1.4、关闭线程池"></a>6.1.4、关闭线程池</h3><p>调用线程池的shutdown或shutdownNow方法可以关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务 可能 永远无法终止。</p><p>shutdown和shutdownNow两者有区别：</p><ul><li><p><strong>shutdown</strong></p><p>shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有空闲线程。</p></li><li><p><strong>shutdownNow</strong></p><p>shutdownNow首先将线程池的状态设置成 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。</p></li></ul><p>只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务 都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。</p><h2 id="6-2、线程池实现"><a href="#6-2、线程池实现" class="headerlink" title="6.2、线程池实现"></a>6.2、线程池实现</h2><h3 id="6-2-1、WorkStealingPool"><a href="#6-2-1、WorkStealingPool" class="headerlink" title="6.2.1、WorkStealingPool"></a>6.2.1、WorkStealingPool</h3><h4 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>WorkStealingPool是一种特殊线程池，核心很简单，和其它线程池的区别是：每一个线程都有自己单独的队列，任务会不断的插入到每一个线程对应的队列中，某个线程执行完自己队列中的任务后，会尝试从其它线程的队列中取出任务来执行，这个就是WorkStealingPool。</font></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>本质上是一个ForkJoinPool。</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>针对通常意义上的线程池来说，如果某一个线程任务量非常庞大，一直占据着CPU，与此同时其它线程就算是闲着也不能去帮忙——无能为力；而WorkStealingPool就灵活了许多，遇到任务量庞大的线程，其它线程如果执行完了自己的任务后，可以帮忙执行这个任务量庞大的线程，提高了执行效率。</p><h3 id="6-2-2、ForkJoinPool"><a href="#6-2-2、ForkJoinPool" class="headerlink" title="6.2.2、ForkJoinPool"></a>6.2.2、ForkJoinPool</h3><h4 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>ForkJoinPool适合把大任务切分成一个个小任务去执行，如果觉得小任务还是太大，那就再切，切到满意为止。每一个小任务执行完成后需要进行汇总——小任务汇总到父任务，父任务最终汇总到根任务，最后得到最终期望的结果，这个汇总合并的过程叫join，故该线程池称为ForkJoinPool。</font></p><p>Fork&#x2F;Join默认会创建与CPU核数数量相同的线程池。</p><h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><p>一般实现ForkJoinPool的时候需要定义为特定的类型——能进行切分的任务，故出现了该种类型的任务——ForkJoinTask。但ForkJoinTask太过于原始，我们可以使用RecursiveAction，其有两种形式：</p><ol><li><font color='orange'>RecursiveAction递归</font>：大任务可以切分成小任务，小任务还可以再切分成更小的任务，其隐含了一个递归的过程，因此叫RecursiveAction递归，是不带返回值的。</li><li><font color='orange'>从RecursiveTask继承，有返回值。</font></li></ol><h2 id="6-3、默认线程池"><a href="#6-3、默认线程池" class="headerlink" title="6.3、默认线程池"></a>6.3、默认线程池</h2><p>Class Executors中提供了默认线程池创建API，不过最终还是会通过ThreadPoolExecutor去实现。</p><p>Executors常用线程池实现有：</p><ol><li><font color='orange'>SingleThreadExecutor</font></li><li><font color='orange'>CachedThreadPool</font></li><li><font color='orange'>FixedThreadPool</font></li><li><font color='orange'>ScheduledThreadPool</font></li></ol><h3 id="6-3-1、SingleThreadExecutor"><a href="#6-3-1、SingleThreadExecutor" class="headerlink" title="6.3.1、SingleThreadExecutor"></a>6.3.1、SingleThreadExecutor</h3><ul><li><p>简介：线程池中只有一个线程，一个线程的线程池可以保证扔进去的任务是顺序执行的。</p></li><li><p>特点（默认）：核心1，最大1，空闲0L，单位毫秒，队列LinkedBlockingQueue，工厂DefaultThreadFactory，拒绝策略AbortPolicy；</p></li><li><p>实例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="6-3-2、CachedThreadPool"><a href="#6-3-2、CachedThreadPool" class="headerlink" title="6.3.2、CachedThreadPool"></a>6.3.2、CachedThreadPool</h3><ul><li><p>简介：提交一个任务时，若线程池中没有线程则创建一个线程来执行该任务，若有则不创建。</p></li><li><p>特点（默认）：核心0，最大Integer.MAX_VALUE，空闲60，单位秒，队列SynchronousQueue(默认false非公平；fair ? new TransferQueue<E>() : new TransferStack<E>();)，工厂DefaultThreadFactory，拒绝策略AbortPolicy；</p></li><li><p>实例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1 service: "</span> <span class="token operator">+</span> service<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token function">shhSleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2 service: "</span> <span class="token operator">+</span> service<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">shhSleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3 service: "</span> <span class="token operator">+</span> service<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">-</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shhSleep</span><span class="token punctuation">(</span><span class="token keyword">long</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="6-3-3、FixedThreadPool"><a href="#6-3-3、FixedThreadPool" class="headerlink" title="6.3.3、FixedThreadPool"></a>6.3.3、FixedThreadPool</h3><ul><li><p>简介：固定的线程数，核心线程数和最大线程数都一样，因此没有回收之说，故就指定为0。</p></li><li><p>特点（默认）：核心、最大显式指定且一样，空闲0，单位毫秒，队列LinkedBlockingQueue，工厂DefaultThreadFactory，拒绝策略AbortPolicy；</p></li><li><p>实例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">FixedThreadPoolTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> start<span class="token punctuation">,</span> end<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> cpuCoreNum <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span>cpuCoreNum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Task</span> task1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">80000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Task</span> task2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token number">80001</span><span class="token punctuation">,</span> <span class="token number">130000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Task</span> task3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token number">130001</span><span class="token punctuation">,</span> <span class="token number">170000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Task</span> task4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token number">170001</span><span class="token punctuation">,</span> <span class="token number">200000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> f1 <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> f2 <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> f3 <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> f4 <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span><span class="token punctuation">&#123;</span>        start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f3<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f4<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">--</span><span class="token operator">-</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Task</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> startPos<span class="token punctuation">,</span> endPos<span class="token punctuation">;</span>    <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>startPos <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>endPos <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> r <span class="token operator">=</span> <span class="token function">getPrime</span><span class="token punctuation">(</span>startPos<span class="token punctuation">,</span> endPos<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">getPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> results <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPrime</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>                results<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> results<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="6-3-4、ScheduledThreadPool"><a href="#6-3-4、ScheduledThreadPool" class="headerlink" title="6.3.4、ScheduledThreadPool"></a>6.3.4、ScheduledThreadPool</h3><ul><li><p>简介：定时任务池，本质上还是ThreadPoolExecutor。</p></li><li><p>特点（默认）：核心指定，最大Integer.MAX_VALUE，空闲0，单位纳秒，队列DelayedWorkQueue，工厂DefaultThreadFactory，拒绝策略AbortPolicy；</p></li><li><p>实例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">ScheduledThreadPoolTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">ScheduledExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    service<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="6-4、自定义线程池"><a href="#6-4、自定义线程池" class="headerlink" title="6.4、自定义线程池"></a>6.4、自定义线程池</h2><h3 id="6-4-1、简介"><a href="#6-4-1、简介" class="headerlink" title="6.4.1、简介"></a>6.4.1、简介</h3><p>自定义线程池可通过ThreadPoolExecutor来实现，其相关参数如下：</p><ol><li><p>corePoolSize（核心线程数）</p></li><li><p>maximumPoolSize（最大线程数）</p></li><li><p>keepAliveTime（空闲时间）</p></li><li><p>TimeUnit unit（空闲时间单位）</p></li><li><p>BlockingQueue workQueue（阻塞队列）</p></li><li><p>ThreadFactory threadFactory（线程工厂）</p></li><li><p>RejectedExecutionHandler handler（拒绝策略）：拒绝策略有四种</p><ol><li>AbortPolicy（默认）：抛异常RejectedExecutionException</li><li>DiscardPolicy：扔掉，不抛异常。</li><li>DiscardOldestPolicy：扔掉排队时间最久的。但是线程池如果关闭了，任务就会被丢弃。</li><li>CallerRunsPolicy：调用者来处理被拒绝的任务，比如主线程调用submit方法任务，但任务被拒绝，则主线程直接执行。但是线程池如果关闭了，任务就会被丢弃。</li></ol><p>除此之外还可以自定义拒绝策略，方式为：实现接口<code>RejectedExecutionHandler</code>，并重写其<code>rejectedExecution(Runnable r, ThreadPoolExecutor executor)</code>方法。</p></li><li><p>boolean allowCoreThreadTimeOut：是否允许核心线程超时销毁，该参数不在构造函数中，但也极其重要。</p><p><font color="orange">取值定义</font>：如果为false（默认），则表示即使处于空闲状态，核心线程也保持活动状态（不销毁）。如果为true，则核心线程使用keepAliveTime来超时等待工作（时间过后就销毁）。</p></li></ol><h3 id="6-4-2、使用示例"><a href="#6-4-2、使用示例" class="headerlink" title="6.4.2、使用示例"></a>6.4.2、使用示例</h3><p>拒绝策略使用示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ThreadPoolExecutor</span> executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-4-3、最合适的线程数量"><a href="#6-4-3、最合适的线程数量" class="headerlink" title="6.4.3、最合适的线程数量"></a>6.4.3、最合适的线程数量</h3><h4 id="6-4-3-1、CPU密集型运算"><a href="#6-4-3-1、CPU密集型运算" class="headerlink" title="6.4.3.1、CPU密集型运算"></a>6.4.3.1、CPU密集型运算</h4><p>通常采用 cpu核数+1 的数量值作为合适的线程数量。这样可以实现最优的CPU利用率，加1是保证当线程由于页缺失或其它问题导致暂停时，额外的线程就能顶上去，保证CPU时钟周期不浪费。</p><h4 id="6-4-3-2、IO密集型运算"><a href="#6-4-3-2、IO密集型运算" class="headerlink" title="6.4.3.2、IO密集型运算"></a>6.4.3.2、IO密集型运算</h4><p>CPU不总是处于繁忙状态，例如，当执行业务计算时会使用CPU资源，但当执行IO操作、RPC远程调用、数据库操作时，CPU不会工作会空闲下来，此时可以利用多线程来提高CPU利用率。</p><p>经验公式如下：<br>$$<br>线程数量 &#x3D; 核数 * CPU期望利用率 * 总时间(CPU计算时间+等待时间) &#x2F; CPU计算时间。<br>$$<br>例如：4核CPU计算时间50%，其它等待时间是50%，期望CPU被100%利用，则</p><p>4 * 100% * 100% &#x2F; 50% &#x3D; 8</p><p>例如：4核CPU计算时间10%，其它等待时间是90%，期望CPU被100%利用，则</p><p>4 * 100% * 100% &#x2F; 10% &#x3D; 40</p><h2 id="6-5、线程池监控"><a href="#6-5、线程池监控" class="headerlink" title="6.5、线程池监控"></a>6.5、线程池监控</h2><h3 id="6-5-1、简介"><a href="#6-5-1、简介" class="headerlink" title="6.5.1、简介"></a>6.5.1、简介</h3><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。</p><h3 id="6-5-2、监控方式"><a href="#6-5-2、监控方式" class="headerlink" title="6.5.2、监控方式"></a>6.5.2、监控方式</h3><h4 id="参数监控"><a href="#参数监控" class="headerlink" title="参数监控"></a>参数监控</h4><p>可以通过线程池提供的参数进行监控，监控线程池时可以使用以下属性。</p><ul><li>taskCount：线程池需要执行的任务数量。 </li><li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。 </li><li>largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是 否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。 </li><li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。 </li><li>getActiveCount：获取活动的线程数。</li></ul><h4 id="扩展监控"><a href="#扩展监控" class="headerlink" title="扩展监控"></a>扩展监控</h4><p>通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的 beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执 行一些代码来进行监控。</p><p>例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。 这几个方法在线程池里是空方法。</p><h2 id="6-6、Executor框架"><a href="#6-6、Executor框架" class="headerlink" title="6.6、Executor框架"></a>6.6、Executor框架</h2><h3 id="6-6-1、Executor类结构图"><a href="#6-6-1、Executor类结构图" class="headerlink" title="6.6.1、Executor类结构图"></a>6.6.1、Executor类结构图</h3><p><img src="/%5Cimgs%5Cjavadev%5CExecutor%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE01.png" alt="image-20210313181639361"></p><h3 id="6-6-2、ThreadPoolExecutor源码解析（JDK8）"><a href="#6-6-2、ThreadPoolExecutor源码解析（JDK8）" class="headerlink" title="6.6.2、ThreadPoolExecutor源码解析（JDK8）"></a>6.6.2、ThreadPoolExecutor源码解析（JDK8）</h3><h4 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h4><p>addWorker的源码分两部分：</p><ol><li><font color='orange'>上面的嵌套for死循环，目的就是把worker数量加1。</font><ol><li>外层for循环：遍历检测状态值是否符合条件，如果状态值 &gt;&#x3D; shutdown，说明不符合条件，执行return false退出。</li><li>内层for循环：添加线程。先判断当前WC线程数量是否超过上限（数量 &gt; 536870911或者 &gt;&#x3D; (corePoolSize &#x2F;maximumPoolSize)），如果超过就不再添加，否则通过CAS方式进行添加。如果添加成功了，则执行break retr跳出双层循环，这说明第一步算是完成了；如果没有添加成功就继续AtomicInteger的get方法，然后跳到最外层循环处进行重新处理；</li></ol></li><li><font color='orange'>创建一个Worker，并执行这个Worker。</font></li></ol><h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><ol><li><p>如果任务为null，则抛出异常。</p></li><li><p>工作线程数 是否小于 核心线程数，若小于则直接创建核心线程。否则将任务放入队列中。</p></li><li><p>如果线程池不是运行状态，或者任务进入队列失败了，则创建非核心线程执行任务。</p></li></ol><p><font color='red'>注意事项：</font></p><ol><li>线程非运行状态时，addWorker内部会判断线程池状态。</li><li>addWorker的第二个参数表示是否创建核心线程。</li><li>addWorker返回false，说明任务执行失败，需要进行reject操作。</li></ol><h4 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h4><p>启动线程后会通过该方法去执行任务，期间需要加锁。</p><ol><li><p>先执行Worker.unlock()方法来允许中断操作；变量boolean completedAbruptly 用于表示是否自旋。</p></li><li><p>自旋过程。如果firstTask不为null 或者 任务队列不为空，则从队列拿任务来执行，否则将 completedAbruptly设为false; 且最终执行processWorkerExit(w, completedAbruptly);</p><p>从队列拿到任务后，执行任务的过程如下：</p><ol><li>w.lock()加锁，任务执行的原子性。</li><li>如果线程池正在停止，则对当前线程进行中断操作。</li><li>执行任务的前后通过beforeExecute()、afterExecute()来扩展功能。但要注意这两个方法在该类中默认是空实现。</li><li>执行 completedAbruptly &#x3D; false;  和  processWorkerExit(w, completedAbruptly);</li></ol></li></ol><h3 id="6-6-3、ScheduledThreadPoolExecutor"><a href="#6-6-3、ScheduledThreadPoolExecutor" class="headerlink" title="6.6.3、ScheduledThreadPoolExecutor"></a>6.6.3、ScheduledThreadPoolExecutor</h3><h4 id="简介-12"><a href="#简介-12" class="headerlink" title="简介"></a>简介</h4><p>继承自ThreadPoolExecutor，可在指定延迟之后运行任务，或者定期执行任务。其功能与Timer类似，但 ScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而 ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。</p><h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><p>ScheduledThreadPoolExecutor的执行主要分为两大部分：</p><ol><li>当调用ScheduledThreadPoolExecutor的scheduleAtFixedRate()方法或者scheduleWithFixedDelay()方法时，会向ScheduledThreadPoolExecutor的DelayQueue添加一个实现了 RunnableScheduledFutur接口的ScheduledFutureTask。</li><li>线程池中的线程从DelayQueue中获取ScheduledFutureTask，然后执行任务。</li></ol><h4 id="底层实现-4"><a href="#底层实现-4" class="headerlink" title="底层实现"></a>底层实现</h4><p>ScheduledThreadPoolExecutor会把待调度的任务（ScheduledFutureTask） 放到一个DelayQueue中。</p><p>ScheduledFutureTask主要包含3个成员变量：</p><ul><li>long型成员变量time，表示这个任务将要被执行的具体时间。 </li><li>long型成员变量sequenceNumber，表示这个任务被添加到ScheduledThreadPoolExecutor中 的序号。 </li><li>long型成员变量period，表示任务执行的间隔周期。</li></ul><h3 id="6-6-4、FutureTask"><a href="#6-6-4、FutureTask" class="headerlink" title="6.6.4、FutureTask"></a>6.6.4、FutureTask</h3><p>Future接口和实现Future接口的FutureTask类，代表异步计算的结果。</p><h4 id="简介-13"><a href="#简介-13" class="headerlink" title="简介"></a>简介</h4><p>FutureTask除了实现Future接口外，还实现了Runnable接口。因此，FutureTask可以交给 Executor执行，也可以由调用线程直接执行（FutureTask.run()）。</p><p>根据FutureTask.run()方法被执行 的时机，FutureTask可以处于下面3种状态：</p><ul><li>未启动<ol><li>FutureTask.get()方法将导致调用线程阻塞；</li><li>FutureTask.cancel()方法将导致此任务永远不会被执行；</li></ol></li><li>已启动<ol><li>FutureTask.get()方法将导致调用线程阻塞；</li><li>FutureTask.cancel（true）方法将以中断执行此任务线程 的方式来试图停止任务；</li><li>FutureTask.cancel（false）方法将 不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）；</li></ol></li><li>已完成<ol><li>FutureTask.get()方法将导致调用线程立即返回结果或抛出异常；</li><li>FutureTask.cancel（…）方法将返回false。</li></ol></li></ul><h4 id="底层实现-5"><a href="#底层实现-5" class="headerlink" title="底层实现"></a>底层实现</h4><p>FutureTask的实现基于AbstractQueuedSynchronizer。</p><p>AQS被作为“模板方法模式”的基础类提供给FutureTask的内部子类Sync，这个内部子类只 需要实现状态检查和状态更新的方法即可，这些方法将控制FutureTask的获取和释放操作。具 体来说，Sync实现了AQS的tryAcquireShared（int）方法和tryReleaseShared（int）方法，Sync通过这 两个方法来检查和更新同步状态。</p><h2 id="6-7、总结"><a href="#6-7、总结" class="headerlink" title="6.7、总结"></a>6.7、总结</h2><h3 id="6-7-1、建议使用ThreadPoolExecutor创建线程池？"><a href="#6-7-1、建议使用ThreadPoolExecutor创建线程池？" class="headerlink" title="6.7.1、建议使用ThreadPoolExecutor创建线程池？"></a>6.7.1、建议使用ThreadPoolExecutor创建线程池？</h3><ol><li><p>Executors提供的线程池 【使用场景有限】。</p></li><li><p>Executors底层还是调用ThreadPoolExecutor创建线程池。</p></li><li><p>OOM问题（阿里手册）</p><ol><li><p>FixedThreadPool 和 SingleThreadPool</p><p>两者允许请求的队列长度为Integer.MAX_VALUE，可能堆积大量请求，进而导致OOM。</p></li><li><p>CachedThreadPool</p><p>允许创建的线程数量为Integer.MAX_VALUE，可能创建大量的线程，进而导致OOM。</p></li></ol></li></ol><h3 id="6-7-2、生产中如何选择使用正确的队列？"><a href="#6-7-2、生产中如何选择使用正确的队列？" class="headerlink" title="6.7.2、生产中如何选择使用正确的队列？"></a>6.7.2、生产中如何选择使用正确的队列？</h3><p>这个要看实际情况：</p><ol><li>高峰期的任务，建议使用LinkedBlockingQueue，这个是无界队列，不限制任务数量。</li><li>重要性较低的任务，建议使用ArrayBlockingQueue，这个队列需要指定大小，如果任务超出，会创建非核心线程执行任务。</li></ol><h3 id="6-7-3、生产中如何保证线程池队列的可用性？"><a href="#6-7-3、生产中如何保证线程池队列的可用性？" class="headerlink" title="6.7.3、生产中如何保证线程池队列的可用性？"></a>6.7.3、生产中如何保证线程池队列的可用性？</h3><ol><li>设计一个线程管理器，通过一个定时任务 定时检测 Map中线程池当前任务队列的状态，会设置一个报警阈值（waterThreshold - 水位线），超过该阈值就会报警，然后根据实际情况去应对。</li><li>线程池压测，如果发生超水位现象，就对线程按线程名做降级，动态调整核心线程数和队列，当然还有限流等保障。</li></ol><h3 id="6-7-4、如何拆分线程池、核心任务数、队列大小呢？"><a href="#6-7-4、如何拆分线程池、核心任务数、队列大小呢？" class="headerlink" title="6.7.4、如何拆分线程池、核心任务数、队列大小呢？"></a>6.7.4、如何拆分线程池、核心任务数、队列大小呢？</h3><ol><li><p>按照 任务类型 【拆分任务】，使用不同的线程池，分别命名。</p></li><li><p>【区分 任务类型】。其是 CPU密集型 还是 IO密集型，CPU密集型 可以设置 核心线程数为CPU核心数，上下文切换少；IO密集型则可以设置核心线程数大一点。</p></li><li><p>【压测并估算】，可以参考线程池变量largestPoolSize，它表示线程池达到过的最大线程任务。</p></li><li><p>设置核心线程数参考公式如下：</p><p><font color="orange">最佳线程数 &#x3D; ((线程等待时间 + 线程CPU时间) &#x2F; 线程CPU时间) * CPU数量;</font></p></li></ol><h1 id="7、高效存储工具"><a href="#7、高效存储工具" class="headerlink" title="7、高效存储工具"></a>7、高效存储工具</h1><h2 id="7-1、Disruptor"><a href="#7-1、Disruptor" class="headerlink" title="7.1、Disruptor"></a>7.1、Disruptor</h2><h3 id="7-1-1、简介"><a href="#7-1-1、简介" class="headerlink" title="7.1.1、简介"></a>7.1.1、简介</h3><p>Disruptor是分裂、瓦解的意思。Disruptor是一个做金融、做股票的公司开发的，开源后受到广泛认可，2011年获得Duke奖。如果将之用作MQ的话，其是单机最快的MQ。该工具性能非常高，因为内部用了大量的CAS，另外把各种各样的性能开发到了极致，所以单机支持高并发。</p><p>Disruptor存储在内存中，简单理解就是内存中用于存储元素的一个高效队列。</p><p>Disruptor称为无锁的、高并发的、环形Buffer，直接覆盖旧数据，降低GC频率，用于生产者消费者模式。</p><h3 id="7-1-2、核心及特点"><a href="#7-1-2、核心及特点" class="headerlink" title="7.1.2、核心及特点"></a>7.1.2、核心及特点</h3><p>Disruptor也是一个队列，和其它队列不同的是——Disruptor是一个环形队列、环形Buffer。</p><p>Disruptor是用数组实现的一个队列，你也可以认为Disruptor就是用数组实现的ConcurrentArrayQueue，另外这个Queue是首尾相连。</p><h3 id="7-1-3、实现原理"><a href="#7-1-3、实现原理" class="headerlink" title="7.1.3、实现原理"></a>7.1.3、实现原理</h3><h4 id="Disruptor为啥快？"><a href="#Disruptor为啥快？" class="headerlink" title="Disruptor为啥快？"></a>Disruptor为啥快？</h4><p>环形结构 只需维护 一个位置，就是sequence序列，该序列表示下一个元素在哪里，相当于只有一个指针在移动定位。位置可以通过数值与环形队列容量取模获得。</p><p>由于采用覆盖方式，所以没有必要记录头指针和尾指针。我只需要一个指针就够用了，就这一点来说依然比ConcurrentLinkedQueue要快。</p><h4 id="生产者装满数据后继续装会覆盖吗？"><a href="#生产者装满数据后继续装会覆盖吗？" class="headerlink" title="生产者装满数据后继续装会覆盖吗？"></a>生产者装满数据后继续装会覆盖吗？</h4><p>不会覆盖的，因为有等待策略——生产者生产满了就要停止生产并进入等待状态。等待策略共有8种，详情见总结部分。</p><h3 id="7-1-4、开发步骤"><a href="#7-1-4、开发步骤" class="headerlink" title="7.1.4、开发步骤"></a>7.1.4、开发步骤</h3><p>开发步骤是比较固定的。</p><ol><li>定义Event：队列中需要处理的元素。</li><li>定义Event工厂：用于填充队列。</li><li>定义EventHandle（消费者）：处理容器中的元素。</li></ol><h3 id="7-1-5、入门案例"><a href="#7-1-5、入门案例" class="headerlink" title="7.1.5、入门案例"></a>7.1.5、入门案例</h3><h4 id="OrderEvent-java"><a href="#OrderEvent-java" class="headerlink" title="OrderEvent.java"></a>OrderEvent.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderEvent</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> value<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token keyword">long</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="OrderEventFactory-java"><a href="#OrderEventFactory-java" class="headerlink" title="OrderEventFactory.java"></a>OrderEventFactory.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderEventFactory</span> <span class="token keyword">implements</span> <span class="token class-name">EventFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OrderEvent</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">OrderEvent</span> <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">OrderEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="OrderEventHandler-java"><a href="#OrderEventHandler-java" class="headerlink" title="OrderEventHandler.java"></a>OrderEventHandler.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderEventHandler</span> <span class="token keyword">implements</span> <span class="token class-name">EventHandler</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OrderEvent</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onEvent</span><span class="token punctuation">(</span><span class="token class-name">OrderEvent</span> event<span class="token punctuation">,</span> <span class="token keyword">long</span> sequence<span class="token punctuation">,</span> <span class="token keyword">boolean</span> endOfBatch<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者："</span> <span class="token operator">+</span> event<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="OrderEventProducer-java"><a href="#OrderEventProducer-java" class="headerlink" title="OrderEventProducer.java"></a>OrderEventProducer.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderEventProducer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">RingBuffer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OrderEvent</span><span class="token punctuation">></span></span> ringBuffer<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">OrderEventProducer</span><span class="token punctuation">(</span><span class="token class-name">RingBuffer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OrderEvent</span><span class="token punctuation">></span></span> ringBuffer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>ringBuffer <span class="token operator">=</span> ringBuffer<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendData</span><span class="token punctuation">(</span><span class="token class-name">ByteBuffer</span> data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> sequence <span class="token operator">=</span> ringBuffer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>            <span class="token comment">//1. 在生产者发送消息的时候，首先需要从ringBuffer里面获取一个可用的序号</span>            <span class="token comment">//2. 根据这个序号 找到具体的“orderEvent”元素 此时获取的OrderEvent是一个空的对象</span>            <span class="token class-name">OrderEvent</span> event <span class="token operator">=</span> ringBuffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>sequence<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//3 进行实际的赋值操作</span>            event<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">getLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 4 提交操作</span>            ringBuffer<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span>sequence<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="App-java"><a href="#App-java" class="headerlink" title="App.java"></a>App.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">OrderEventFactory</span> orderEventFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderEventFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ringBufferSize <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>        <span class="token comment">/**         *  1 eventFacotry 消息工厂对象         *  2 ringBufferSize 容器的长度         *  3 executor 线程池         *  4 ProducerType 生产者类型         *  5 waitStartegy 等待策略         */</span>        <span class="token comment">// 1 实例化一个disruptor的对象</span>        <span class="token class-name">Disruptor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OrderEvent</span><span class="token punctuation">></span></span> disruptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Disruptor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>orderEventFactory<span class="token punctuation">,</span> ringBufferSize<span class="token punctuation">,</span> executor<span class="token punctuation">,</span> <span class="token class-name">ProducerType</span><span class="token punctuation">.</span><span class="token constant">SINGLE</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">BlockingWaitStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2 添加消费者的监听(Disruptor 与消费者的一个关联关系)</span>        disruptor<span class="token punctuation">.</span><span class="token function">handleEventsWith</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OrderEventHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3 启动disruptor</span>        disruptor<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4 获取实际存储数据的容器 RingBuffer</span>        <span class="token class-name">RingBuffer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OrderEvent</span><span class="token punctuation">></span></span> ringBuffer <span class="token operator">=</span> disruptor<span class="token punctuation">.</span><span class="token function">getRingBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">OrderEventProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderEventProducer</span><span class="token punctuation">(</span>ringBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 生成一百个数 然后丢给producer</span>        <span class="token class-name">ByteBuffer</span> bb <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            bb<span class="token punctuation">.</span><span class="token function">putLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            producer<span class="token punctuation">.</span><span class="token function">sendData</span><span class="token punctuation">(</span>bb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 关闭disruptor和线程池</span>        disruptor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-1-6、总结"><a href="#7-1-6、总结" class="headerlink" title="7.1.6、总结"></a>7.1.6、总结</h3><h4 id="ProducerType（生产者线程模式）"><a href="#ProducerType（生产者线程模式）" class="headerlink" title="ProducerType（生产者线程模式）"></a>ProducerType（生产者线程模式）</h4><p><font color='orange'>ProducerType有两种模式：Producer.MULTI 和 Producer.SINGLE。默认为MULTI，表示在多线程模式下产生sequence。如果确定是单线程生产者，可以指定SINGLE，效率会有提升。</font></p><h4 id="等待策略（8种）"><a href="#等待策略（8种）" class="headerlink" title="等待策略（8种）"></a>等待策略（8种）</h4><ol><li><font color='orange'>BlockingWaitStrategy（常用）</font>：通过线程阻塞的方式，等待生产者被唤醒，唤醒后再次检查依赖的sequence是否已经消费。</li><li><font color='orange'>BusySpinWaitStrategy</font>：线程一直自旋等待，可能比较消耗CPU。</li><li><font color='orange'>LiteBlockingWaitStrategy</font>：线程阻塞等待生产者被唤醒。与第1个的区别是——如果两个线程同时访问一个waitfor，一个访问signalAll时，可以减少lock加锁次数。</li><li><font color='orange'>LiteTimeoutBlockingWaitStrategy</font>：与第3个相比，该策略设置了阻塞时间，超过时间后抛出异常。</li><li><font color='orange'>PhasedBackoffWaitStrategy</font>：根据时间参数和等待的策略来决定使用哪种等待策略。</li><li><font color='orange'>TimeoutBlockingWaitStrategy</font>：相对于第1个来说，该策略设置了等待时间，超过后抛出异常。</li><li><font color='orange'>YieldingWatitStrategy（常用）</font>：尝试100次，然后Thread.yield()让出CPU。</li><li><font color='orange'>SleepingWaitStrategy（常用）</font>：sleep。</li></ol><h4 id="消费者异常处理"><a href="#消费者异常处理" class="headerlink" title="消费者异常处理"></a>消费者异常处理</h4><ol><li>默认：disruptor.setDefaultExceptionHandler()；</li><li>覆盖：disruptor.handleExceptionFor().wait()；</li></ol><h1 id="8、高效测试工具"><a href="#8、高效测试工具" class="headerlink" title="8、高效测试工具"></a>8、高效测试工具</h1><h2 id="8-1、JMH"><a href="#8-1、JMH" class="headerlink" title="8.1、JMH"></a>8.1、JMH</h2><h4 id="8-1-1、简介"><a href="#8-1-1、简介" class="headerlink" title="8.1.1、简介"></a>8.1.1、简介</h4><p><font color='orange'><code>JMH</code>全程为<code>java Microbenchmark Harness</code>，意为Java微基准测试。它测试的是一个方法的性能到底是否好，换了一种实现后再次观察其性能好坏。</font></p><p><font color='red'>注意：该测试框架于2013年由JLT人员开发而成，后来归到了OpenJDK下面。</font></p><h4 id="8-1-2、JMH相关概念"><a href="#8-1-2、JMH相关概念" class="headerlink" title="8.1.2、JMH相关概念"></a>8.1.2、JMH相关概念</h4><ol><li><font color='orange'>Benchmark mode</font>：基准测试的模式。</li><li><font color='orange'>Warmup</font>：预热，由于JVM会对特定代码进行优化，预热对于测试很重要。</li><li><font color='orange'>Measurement</font>：共执行多少次测试。</li><li><font color='orange'>Timeout</font>：超时时间。</li><li><font color='orange'>Threads</font>：线程数，由fork指定。</li><li><font color='orange'>Benchmark</font>：测试哪一段代码。</li></ol><h3 id="8-1-3、使用示例"><a href="#8-1-3、使用示例" class="headerlink" title="8.1.3、使用示例"></a>8.1.3、使用示例</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token class-name">Benchmark</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token class-name">BenchmarkMode</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token class-name">Mode</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token class-name">OutputTimeUnit</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token class-name">State</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token class-name">Scope</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token class-name">Setup</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token class-name">TearDown</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>runner<span class="token punctuation">.</span></span><span class="token class-name">Runner</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>runner<span class="token punctuation">.</span></span><span class="token class-name">RunnerException</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>runner<span class="token punctuation">.</span>options<span class="token punctuation">.</span></span><span class="token class-name">Options</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>runner<span class="token punctuation">.</span>options<span class="token punctuation">.</span></span><span class="token class-name">OptionsBuilder</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span></span><span class="token punctuation">;</span><span class="token comment">/** * JMH工具测试 */</span><span class="token annotation punctuation">@State</span><span class="token punctuation">(</span><span class="token class-name">Scope<span class="token punctuation">.</span>Thread</span><span class="token punctuation">)</span><span class="token annotation punctuation">@BenchmarkMode</span><span class="token punctuation">(</span><span class="token class-name">Mode<span class="token punctuation">.</span>AverageTime</span><span class="token punctuation">)</span>    <span class="token comment">// 测试模式</span><span class="token annotation punctuation">@OutputTimeUnit</span><span class="token punctuation">(</span><span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span>  <span class="token comment">// 时间单位</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JMHUseTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Random</span> random<span class="token punctuation">;</span>    <span class="token comment">/**     * 测试前的初始化     *     * 初始化了一个由1000个随机整数组成的List     */</span>    <span class="token annotation punctuation">@Setup</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 测试后的清理动作     */</span>    <span class="token annotation punctuation">@TearDown</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">teardown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        list <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        random <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 排序     */</span>    <span class="token annotation punctuation">@Benchmark</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        list<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">compare</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 并行排序     */</span>    <span class="token annotation punctuation">@Benchmark</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testParallelSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        list<span class="token punctuation">.</span><span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">compare</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 常用方法解析：     * - `include(String classNameRegex)`：指定要测试的类，可以使用正则表达式来匹配多个类。     * - `forks(int count)`：指定测试时进行的fork数量，即测试时重复运行基准测试的次数。     * - `warmupIterations(int count)`：指定预热迭代次数，即在测量迭代次数前进行的预热迭代次数。     * - `measurementIterations(int count)`：指定测量迭代次数，即每个基准测试运行的迭代次数。     * - `mode(Mode mode)`：指定测试模式，包括平均时间（AverageTime）、平均吞吐量（Througput）、平均延迟（SampleTime）等。     * - `timeUnit(TimeUnit unit)`：指定测试结果的时间单位，包括纳秒（NANOSECONDS）、微秒（MICROSECONDS）、毫秒（MILLISECONDS）等。     * - `threads(int count)`：指定测试时使用的线程数。     * - `verbosity(VerboseMode mode)`：指定测试结果的详细程度，包括默认（NORMAL）、详细（EXTRA）、极度详细（DEBUG）等。     * - `jvmArgs(String... args)`：指定测试时使用的Java虚拟机参数。     * - `addProfiler(Class&lt;? extends Profiler> profilerClass)`：指定测试时使用的分析器.     * - `resultFormat(ResultFormatType type)`：指定测试结果的输出格式，包括文本（TEXT）、CSV、JSON等。     *     * 创建`Options`对象后，可以使用`Runner`类来运行基准测试。`Runner`类提供了多个方法来运行基准测试，如：     * - `run()`：运行基准测试并输出测试结果。     * - `runAsync()`：异步运行基准测试。     * - `runTo(TimeValue time)`：运行基准测试并在指定时间后停止。     * - `runTo(TimeValue time, TimeUnit timeUnit)`：运行基准测试并在指定时间后停止。     *     * @param args     * @throws RunnerException     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RunnerException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Options</span> options <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OptionsBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">include</span><span class="token punctuation">(</span><span class="token class-name">JMHUseTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">forks</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment">// 运行基准测试的次数</span>                <span class="token punctuation">.</span><span class="token function">warmupIterations</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment">// 预热次数</span>                <span class="token punctuation">.</span><span class="token function">measurementIterations</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>   <span class="token comment">// 基准测试执行的次数</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Runner</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java系列-ASM</title>
      <link href="/2023/07/30/asm-zhi-shi-dian-zong-jie/"/>
      <url>/2023/07/30/asm-zhi-shi-dian-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h1><p>本文档基于ASM4.0来分析。</p><h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h1><h2 id="1-1、简析"><a href="#1-1、简析" class="headerlink" title="1.1、简析"></a>1.1、简析</h2><p>ASM不是生成和转换已编译Java的唯一工具类，但它是最新且有效的类之一。其主要优点如下：</p><ol><li>它具有易使用、简单、精心设计的模块化API。</li><li>并且具有关联的Eclipse插件。</li><li>它支持最新的Java版本Java 7</li><li>它体积小，速度快且非常稳定。</li><li>庞大的社区支持。</li><li>完全开源。</li></ol><h2 id="1-2、总述"><a href="#1-2、总述" class="headerlink" title="1.2、总述"></a>1.2、总述</h2><h3 id="1-2-1、作用域"><a href="#1-2-1、作用域" class="headerlink" title="1.2.1、作用域"></a>1.2.1、作用域</h3><p>ASM库的目标是生成、转换和分析以字节数组表示的已编译Java类（因为它们存储在磁盘上并已加载到Java虚拟机中）。为此，ASM提供了使用比字节更高的概念来读取，写入和转换此类字节数组的工具，例如数字常量，字符串，Java标识符，Java类型，Java类结构元素等。请注意，ASM的范围图书馆严格限于阅读，写作，转换和分析类。特别是类加载过程超出了范围。</p><h3 id="1-2-2、模块"><a href="#1-2-2、模块" class="headerlink" title="1.2.2、模块"></a>1.2.2、模块</h3><p>ASM库提供了两个用于生成和转换已编译类的API：核心API提供基于事件的类表示，而树API提供基于对象的表示。</p><p>这两个API可以与XML文档的简单API（SAX）和XML文档的文档对象模型（DOM）API进行比较：基于事件的API与SAX类似，而基于对象的API与DOM类似。基于对象的API建立在基于事件的API之上，就像可以在SAX之上提供DOM一样。</p><p>优缺点：</p><ul><li>与基于对象的API相比，基于事件的API更快，并且所需的内存更少，因为不需要创建并在内存中存储代表该类的对象树（SAX和DOM之间也存在相同的区别）。</li><li>但是，使用基于事件的API来实现类转换可能会更加困难，因为在任何给定时间只有该类的一个元素（与当前事件相对应的元素）才可用，而整个类可以在基于对象的内存中使用API。</li></ul><h3 id="1-2-3、结构"><a href="#1-2-3、结构" class="headerlink" title="1.2.3、结构"></a>1.2.3、结构</h3><p>ASM应用程序具有强大的体系结构方面。实际上，基于事件的API是围绕事件生成器（类解析器），事件使用者（类编写器）和各种预定义的事件过滤器组织的，可以向其中添加用户定义的生产者，使用者和过滤器。因此，使用此API分为两个步骤：</p><ol><li>将事件产生器，过滤器和使用者组件组装成可能复杂的架构。</li><li>然后启动事件生产者以运行生成或转换过程。</li></ol><h2 id="1-3、组织"><a href="#1-3、组织" class="headerlink" title="1.3、组织"></a>1.3、组织</h2><p>ASM库组织在几个包中，这些包分布在几个jar文件中：</p><ol><li>asm.jar</li><li>asm-util.jar</li><li>asm-commons.jar</li><li>asm-tree.jar</li><li>asm-analysis.jar</li></ol><h1 id="2、类"><a href="#2、类" class="headerlink" title="2、类"></a>2、类</h1><h2 id="2-1、结构"><a href="#2-1、结构" class="headerlink" title="2.1、结构"></a>2.1、结构</h2><h3 id="2-1-3、类型描述符"><a href="#2-1-3、类型描述符" class="headerlink" title="2.1.3、类型描述符"></a>2.1.3、类型描述符</h3><p>内部名称仅用于约束为类或接口类型的类型。在所有其他情况下，例如字段类型，Java类型都在带有类型描述符的已编译类中表示：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200905140752294.png" alt="image-20200905140752294"></p><h3 id="2-1-4、方法描述符"><a href="#2-1-4、方法描述符" class="headerlink" title="2.1.4、方法描述符"></a>2.1.4、方法描述符</h3><p>方法描述符是类型描述符的列表，这些类型描述符在单个字符串中描述方法的参数类型和返回类型。方法描述符以左括号开头，然后是每个形式参数的类型描述符，然后是右括号，然后是返回类型的类型描述符，如果该方法返回void，则返回V（方法描述符不包含方法名称或参数名称）。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200905141030231.png" alt="image-20200905141030231"></p><h2 id="2-2、接口与组件"><a href="#2-2、接口与组件" class="headerlink" title="2.2、接口与组件"></a>2.2、接口与组件</h2><h3 id="2-2-1、简介"><a href="#2-2-1、简介" class="headerlink" title="2.2.1、简介"></a>2.2.1、简介</h3><p>用于生成和转换已编译类的 ASM API 基于 ClassVisitor 抽象类。此类中的每个方法都对应于同名的类文件结构部分。通过单个方法调用可以访问简单部分，该方法的参数描述其内容，并返回void。使用初始方法调用（其返回辅助访问者类）访问其内容可以具有任意长度和复杂度的节。 visitAnnotation，visitField和visitMethod方法就是这种情况，它们分别返回AnnotationVisitor，FieldVisitor和MethodVisitor。</p><p>这些辅助类递归使用相同的原理。例如，FieldVisitor抽象类中的每个方法（请参见图2.5）对应于具有相同名称的类文件子结构，并且与ClassVisitor中一样，返回一个辅助AnnotationVisitor。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ClassVisitor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ClassVisitor</span><span class="token punctuation">(</span><span class="token keyword">int</span> api<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ClassVisitor</span><span class="token punctuation">(</span><span class="token keyword">int</span> api<span class="token punctuation">,</span> <span class="token class-name">ClassVisitor</span> cv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">int</span> version<span class="token punctuation">,</span> <span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token class-name">String</span> signature<span class="token punctuation">,</span> <span class="token class-name">String</span> superName<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitSource</span><span class="token punctuation">(</span><span class="token class-name">String</span> source<span class="token punctuation">,</span> <span class="token class-name">String</span> debug<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitOuterClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> owner<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">AnnotationVisitor</span> <span class="token function">visitAnnotation</span><span class="token punctuation">(</span><span class="token class-name">String</span> desc<span class="token punctuation">,</span> <span class="token keyword">boolean</span> visible<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitAttribute</span><span class="token punctuation">(</span><span class="token class-name">Attribute</span> attr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitInnerClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> outerName<span class="token punctuation">,</span><span class="token class-name">String</span> innerName<span class="token punctuation">,</span> <span class="token keyword">int</span> access<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">FieldVisitor</span> <span class="token function">visitField</span><span class="token punctuation">(</span><span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">,</span><span class="token class-name">String</span> signature<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">MethodVisitor</span> <span class="token function">visitMethod</span><span class="token punctuation">(</span><span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">,</span><span class="token class-name">String</span> signature<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> exceptions<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">FieldVisitor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">FieldVisitor</span><span class="token punctuation">(</span><span class="token keyword">int</span> api<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">FieldVisitor</span><span class="token punctuation">(</span><span class="token keyword">int</span> api<span class="token punctuation">,</span> <span class="token class-name">FieldVisitor</span> fv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AnnotationVisitor</span> <span class="token function">visitAnnotation</span><span class="token punctuation">(</span><span class="token class-name">String</span> desc<span class="token punctuation">,</span> <span class="token keyword">boolean</span> visible<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitAttribute</span><span class="token punctuation">(</span><span class="token class-name">Attribute</span> attr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ASM提供了三个基于ClassVisitor API的核心组件，用于生成和转换类：</p><ol><li>ClassReader类解析以字节数组形式给出的已编译类，并在作为参数传递给其accept方法的ClassVisitor实例上调用相应的visitXxx方法。可以将其视为事件产生器。</li><li>ClassWriter类是ClassVisitor抽象类的子类，该类直接以二进制形式构建编译的类。它产生包含已编译类的字节数组作为输出，可以使用toByteArray方法进行检索。可以将其视为事件消费者。</li><li>ClassVisitor类将它收到的所有方法调用委托给另一个ClassVisitor实例。可以将其视为事件过滤器。</li></ol><h3 id="2-2-2、解析类"><a href="#2-2-2、解析类" class="headerlink" title="2.2.2、解析类"></a>2.2.2、解析类</h3><p>解析现有类的唯一必需组件是ClassReader组件。让我们以一个例子来说明这一点。假设我们希望以类似于javap工具的方式打印类的内容。第一步是编写ClassVisitor类的子类，该子类打印有关其访问的类的信息。这是一个可能的，过于简化的实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassPrinter</span> <span class="token keyword">extends</span> <span class="token class-name">ClassVisitor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ClassPrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">ASM4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">int</span> version<span class="token punctuation">,</span> <span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token class-name">String</span> signature<span class="token punctuation">,</span> <span class="token class-name">String</span> superName<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">" extends "</span> <span class="token operator">+</span> superName <span class="token operator">+</span> <span class="token string">" &#123;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitSource</span><span class="token punctuation">(</span><span class="token class-name">String</span> source<span class="token punctuation">,</span> <span class="token class-name">String</span> debug<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitOuterClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> owner<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">AnnotationVisitor</span> <span class="token function">visitAnnotation</span><span class="token punctuation">(</span><span class="token class-name">String</span> desc<span class="token punctuation">,</span><span class="token keyword">boolean</span> visible<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitAttribute</span><span class="token punctuation">(</span><span class="token class-name">Attribute</span> attr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitInnerClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> outerName<span class="token punctuation">,</span> <span class="token class-name">String</span> innerName<span class="token punctuation">,</span> <span class="token keyword">int</span> access<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">FieldVisitor</span> <span class="token function">visitField</span><span class="token punctuation">(</span><span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">,</span><span class="token class-name">String</span> signature<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" "</span> <span class="token operator">+</span> desc <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">MethodVisitor</span> <span class="token function">visitMethod</span><span class="token punctuation">(</span><span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token class-name">String</span> desc<span class="token punctuation">,</span> <span class="token class-name">String</span> signature<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> exceptions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" "</span> <span class="token operator">+</span> name <span class="token operator">+</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&#125;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二步是将该ClassPrinter与ClassReader组件结合起来，以便ClassReader产生的事件由我们的ClassPrinter消耗：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ClassPrinter</span> cp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ClassReader</span> cr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassReader</span><span class="token punctuation">(</span><span class="token string">"java.lang.Runnable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cr<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>cp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>请注意，有几种方法可以构造ClassReader实例。可以通过名称（如上所述）或通过值（字节数组或InputStream）指定必须读取的类。可以使用ClassLoader的getResourceAsStream方法通过以下方式获取用于读取类内容的输入流：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">cl<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>classname<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>’<span class="token punctuation">.</span>’<span class="token punctuation">,</span> ’<span class="token operator">/</span>’<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".class"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-3、生成类"><a href="#2-2-3、生成类" class="headerlink" title="2.2.3、生成类"></a>2.2.3、生成类</h3><p>生成类的唯一必需组件是ClassWriter组件。让我们以一个例子来说明这一点。考虑以下接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparable</span> <span class="token keyword">extends</span> <span class="token class-name">Mesurable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token constant">LESS</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">EQUAL</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">GREATER</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它可以通过对ClassVisitor的六个方法调用来生成：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ClassWriter</span> cw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassWriter</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cw<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token constant">V1_5</span><span class="token punctuation">,</span> <span class="token constant">ACC_PUBLIC</span> <span class="token operator">+</span> <span class="token constant">ACC_ABSTRACT</span> <span class="token operator">+</span> <span class="token constant">ACC_INTERFACE</span><span class="token punctuation">,</span> <span class="token string">"pkg/Comparable"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"java/lang/Object"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> <span class="token string">"pkg/Mesurable"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cw<span class="token punctuation">.</span><span class="token function">visitField</span><span class="token punctuation">(</span><span class="token constant">ACC_PUBLIC</span> <span class="token operator">+</span> <span class="token constant">ACC_FINAL</span> <span class="token operator">+</span> <span class="token constant">ACC_STATIC</span><span class="token punctuation">,</span> <span class="token string">"LESS"</span><span class="token punctuation">,</span> <span class="token string">"I"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cw<span class="token punctuation">.</span><span class="token function">visitField</span><span class="token punctuation">(</span><span class="token constant">ACC_PUBLIC</span> <span class="token operator">+</span> <span class="token constant">ACC_FINAL</span> <span class="token operator">+</span> <span class="token constant">ACC_STATIC</span><span class="token punctuation">,</span> <span class="token string">"EQUAL"</span><span class="token punctuation">,</span> <span class="token string">"I"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cw<span class="token punctuation">.</span><span class="token function">visitField</span><span class="token punctuation">(</span><span class="token constant">ACC_PUBLIC</span> <span class="token operator">+</span> <span class="token constant">ACC_FINAL</span> <span class="token operator">+</span> <span class="token constant">ACC_STATIC</span><span class="token punctuation">,</span> <span class="token string">"GREATER"</span><span class="token punctuation">,</span> <span class="token string">"I"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cw<span class="token punctuation">.</span><span class="token function">visitMethod</span><span class="token punctuation">(</span><span class="token constant">ACC_PUBLIC</span> <span class="token operator">+</span> <span class="token constant">ACC_ABSTRACT</span><span class="token punctuation">,</span> <span class="token string">"compareTo"</span><span class="token punctuation">,</span> <span class="token string">"(Ljava/lang/Object;)I"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cw<span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> cw<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-3-1、使用生成的类："><a href="#2-2-3-1、使用生成的类：" class="headerlink" title="2.2.3.1、使用生成的类："></a>2.2.3.1、使用生成的类：</h4><p>先前的字节数组可以存储在Comparable.class文件中，以备将来使用。另外，也可以使用ClassLoader动态加载它。一种方法是定义ClassLoader子类，其defineClass方法是公共的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Class</span> <span class="token function">defineClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，可以使用以下命令直接加载生成的类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span> c <span class="token operator">=</span> myClassLoader<span class="token punctuation">.</span><span class="token function">defineClass</span><span class="token punctuation">(</span><span class="token string">"pkg.Comparable"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>加载生成的类的另一种方法（可能更干净）是定义ClassLoader子类，该类的findClass方法被重写，以便动态生成请求的类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">StubClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token class-name">Class</span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">"_Stub"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">ClassWriter</span> cw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassWriter</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//...</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> cw<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，使用生成的类的方式取决于上下文，并且超出了ASM API的范围。如果正在编写编译器，则类生成过程将由表示要编译的程序的抽象语法树驱动，并且生成的类将存储在磁盘上。如果要编写动态代理类生成器或Aspect Weaver，则将以一种或另一种方式使用ClassLoader。</p><h3 id="2-2-4、转换类"><a href="#2-2-4、转换类" class="headerlink" title="2.2.4、转换类"></a>2.2.4、转换类</h3><p>到目前为止，仅单独使用了ClassReader和ClassWriter组件。这些事件是“手动”产生的，并由ClassWriter直接消耗，或者对称地，它们是由ClassReader产生并“手动”消耗的，即由自定义的ClassVisitor实现。当这些组件一起使用时，事情开始变得非常有趣。第一步是将ClassReader产生的事件定向到ClassWriter。结果是由类编写器重构了由类读取器解析的类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b1 <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token class-name">ClassWriter</span> cw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassWriter</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ClassReader</span> cr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassReader</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span><span class="token punctuation">;</span>cr<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>cw<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b2 <span class="token operator">=</span> cw<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// b2 represents the same class as b1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下一步是在类读取器和类写入器之间引入ClassVisitor：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b1 <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token class-name">ClassWriter</span> cw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassWriter</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// cv forwards all events to cw</span><span class="token class-name">ClassVisitor</span> cv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassVisitor</span><span class="token punctuation">(</span><span class="token constant">ASM4</span><span class="token punctuation">,</span> cw<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">ClassReader</span> cr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassReader</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span><span class="token punctuation">;</span>cr<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>cv<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b2 <span class="token operator">=</span> cw<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// b2 represents the same class as b1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，结果不会改变，因为ClassVisitor事件过滤器不过滤任何内容。但是，现在可以通过重写某些方法来过滤某些事件，以便能够转换类。例如，考虑以下ClassVisitor子类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChangeVersionAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">ClassVisitor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ChangeVersionAdapter</span><span class="token punctuation">(</span><span class="token class-name">ClassVisitor</span> cv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">ASM4</span><span class="token punctuation">,</span> cv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">int</span> version<span class="token punctuation">,</span> <span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> signature<span class="token punctuation">,</span> <span class="token class-name">String</span> superName<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    cv<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token constant">V1_5</span><span class="token punctuation">,</span> access<span class="token punctuation">,</span> name<span class="token punctuation">,</span> signature<span class="token punctuation">,</span> superName<span class="token punctuation">,</span> interfaces<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此类仅覆盖ClassVisitor类的一个方法。结果，除了对visit方法的调用之外，所有调用均以不变的方式转发给传递给构造函数的类visitor cv，后者以修改后的类版本号转发。</p><h4 id="2-2-4-1、优化"><a href="#2-2-4-1、优化" class="headerlink" title="2.2.4.1、优化"></a>2.2.4.1、优化</h4><p>上一个转换仅更改原始类中的四个字节。但是，使用上面的代码，b1被完全解析，并且相应的事件用于从头开始构造b2，这不是很有效。复制不直接转换为b2的b1部分，而无需解析这些部分并且不生成相应的事件，将更加有效。 ASM自动为方法执行此优化：</p><ol><li>如果ClassReader组件检测到作为参数传递给其accept方法的ClassVisitor返回的MethodVisitor来自ClassWriter，则这意味着该方法的内容将不会被转换，并且实际上甚至不会被应用程序看到。</li><li>在这种情况下，ClassReader组件不会解析此方法的内容，不会生成相应的事件，而只是复制ClassWriter中此方法的字节数组表示形式</li></ol><p>如果ClassReader和ClassWriter组件具有相互引用，则可以通过以下方式进行此优化：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b1 <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token class-name">ClassReader</span> cr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassReader</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ClassWriter</span> cw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassWriter</span><span class="token punctuation">(</span>cr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ChangeVersionAdapter</span> ca <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChangeVersionAdapter</span><span class="token punctuation">(</span>cw<span class="token punctuation">)</span><span class="token punctuation">;</span>cr<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>ca<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b2 <span class="token operator">=</span> cw<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-4-2、使用转换类"><a href="#2-2-4-2、使用转换类" class="headerlink" title="2.2.4.2、使用转换类"></a>2.2.4.2、使用转换类</h4><p>可以将转换后的类b2存储在磁盘上或用ClassLoader加载。但是在ClassLoader内部完成的类转换只能转换由此类加载器加载的类。如果要转换所有类，则必须将转换放入ClassFileTransformer内，如java.lang.instrument包中所定义（有关更多详细信息，请参见此包的文档）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">premain</span><span class="token punctuation">(</span><span class="token class-name">String</span> agentArgs<span class="token punctuation">,</span> <span class="token class-name">Instrumentation</span> inst<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    inst<span class="token punctuation">.</span><span class="token function">addTransformer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ClassFileTransformer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">transform</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> l<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Class</span> c<span class="token punctuation">,</span> <span class="token class-name">ProtectionDomain</span> d<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IllegalClassFormatException</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">ClassReader</span> cr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassReader</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">ClassWriter</span> cw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassWriter</span><span class="token punctuation">(</span>cr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">ClassVisitor</span> cv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChangeVersionAdapter</span><span class="token punctuation">(</span>cw<span class="token punctuation">)</span><span class="token punctuation">;</span>            cr<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>cv<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> cw<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-5、删除类成员"><a href="#2-2-5、删除类成员" class="headerlink" title="2.2.5、删除类成员"></a>2.2.5、删除类成员</h3><p>例如，以下类适配器删除有关外部类和内部类的信息，以及从中编译该类的源文件的名称（生成的类保持完整的功能，因为这些元素仅用于调试目的）。这是通过不以适当的访问方法转发任何内容来完成的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RemoveDebugAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">ClassVisitor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">RemoveDebugAdapter</span><span class="token punctuation">(</span><span class="token class-name">ClassVisitor</span> cv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">ASM4</span><span class="token punctuation">,</span> cv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitSource</span><span class="token punctuation">(</span><span class="token class-name">String</span> source<span class="token punctuation">,</span> <span class="token class-name">String</span> debug<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitOuterClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> owner<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitInnerClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> outerName<span class="token punctuation">,</span> <span class="token class-name">String</span> innerName<span class="token punctuation">,</span> <span class="token keyword">int</span> access<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该策略不适用于字段和方法，因为visitField和visitMethod方法必须返回结果。为了删除字段或方法，您必须不要转发方法调用，并且必须将null返回给调用方。例如，以下类适配器删除由其名称和其描述符指定的单个方法（该名称不足以标识一个方法，因为一个类可以包含多个同名但参数不同的方法）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RemoveMethodAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">ClassVisitor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> mName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> mDesc<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">RemoveMethodAdapter</span><span class="token punctuation">(</span><span class="token class-name">ClassVisitor</span> cv<span class="token punctuation">,</span> <span class="token class-name">String</span> mName<span class="token punctuation">,</span> <span class="token class-name">String</span> mDesc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">ASM4</span><span class="token punctuation">,</span> cv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mName <span class="token operator">=</span> mName<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mDesc <span class="token operator">=</span> mDesc<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">MethodVisitor</span> <span class="token function">visitMethod</span><span class="token punctuation">(</span><span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">,</span> <span class="token class-name">String</span> signature<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> exceptions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>mName<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> desc<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>mDesc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// do not delegate to next visitor -> this removes the method</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> cv<span class="token punctuation">.</span><span class="token function">visitMethod</span><span class="token punctuation">(</span>access<span class="token punctuation">,</span> name<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> signature<span class="token punctuation">,</span> exceptions<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-6、添加类成员"><a href="#2-2-6、添加类成员" class="headerlink" title="2.2.6、添加类成员"></a>2.2.6、添加类成员</h3><p>这里是一个类适配器，它将一个字段添加到类中，除非该字段已经存在：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AddFieldAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">ClassVisitor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> fAcc<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> fName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> fDesc<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> isFieldPresent<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AddFieldAdapter</span><span class="token punctuation">(</span><span class="token class-name">ClassVisitor</span> cv<span class="token punctuation">,</span> <span class="token keyword">int</span> fAcc<span class="token punctuation">,</span> <span class="token class-name">String</span> fName<span class="token punctuation">,</span> <span class="token class-name">String</span> fDesc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">ASM4</span><span class="token punctuation">,</span> cv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>fAcc <span class="token operator">=</span> fAcc<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>fName <span class="token operator">=</span> fName<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>fDesc <span class="token operator">=</span> fDesc<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">FieldVisitor</span> <span class="token function">visitField</span><span class="token punctuation">(</span><span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">,</span> <span class="token class-name">String</span> signature<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>fName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            isFieldPresent <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> cv<span class="token punctuation">.</span><span class="token function">visitField</span><span class="token punctuation">(</span>access<span class="token punctuation">,</span> name<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> signature<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isFieldPresent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">FieldVisitor</span> fv <span class="token operator">=</span> cv<span class="token punctuation">.</span><span class="token function">visitField</span><span class="token punctuation">(</span>fAcc<span class="token punctuation">,</span> fName<span class="token punctuation">,</span> fDesc<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fv <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            fv<span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        cv<span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-7、转型链"><a href="#2-2-7、转型链" class="headerlink" title="2.2.7、转型链"></a>2.2.7、转型链</h3><p>到目前为止，我们已经看到了由ClassReader，类适配器和ClassWriter组成的简单转换链。当然，可以使用更复杂的链，将多个类适配器链在一起。链接多个适配器可让您组成多个独立的类转换，以执行复杂的转换。还要注意，转换链不一定是线性的。您可以编写一个ClassVisitor，将它同时收到的所有方法调用转发到多个ClassVisitor：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MultiClassAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">ClassVisitor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token class-name">ClassVisitor</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cvs<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">MultiClassAdapter</span><span class="token punctuation">(</span><span class="token class-name">ClassVisitor</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cvs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">ASM4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cvs <span class="token operator">=</span> cvs<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">int</span> version<span class="token punctuation">,</span> <span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> signature<span class="token punctuation">,</span> <span class="token class-name">String</span> superName<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ClassVisitor</span> cv <span class="token operator">:</span> cvs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cv<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span>version<span class="token punctuation">,</span> access<span class="token punctuation">,</span> name<span class="token punctuation">,</span> signature<span class="token punctuation">,</span> superName<span class="token punctuation">,</span> interfaces<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3、工具"><a href="#2-3、工具" class="headerlink" title="2.3、工具"></a>2.3、工具</h2><h3 id="2-3-1、Type"><a href="#2-3-1、Type" class="headerlink" title="2.3.1、Type"></a>2.3.1、Type</h3><p>如前几节所述，ASM API公开了Java类型，因为它们存储在编译的类中，即作为内部名称或类型描述符。可以将它们公开显示在源代码中，以使代码更具可读性。但这需要在ClassReader和ClassWriter中的两种表示形式之间进行系统的转换，这会降低性能。这就是ASM不会将内部名称和类型描述符透明转换为等效的源代码形式的原因。但是，它提供了Type类，以便在必要时手动执行此操作。</p><p>Type对象表示Java类型，可以从类型描述符或从Class对象构造。 Type类还包含表示原始类型的静态变量。例如，Type.INT_TYPE是表示int类型的Type对象。</p><h3 id="2-3-2、TraceClassVisitor"><a href="#2-3-2、TraceClassVisitor" class="headerlink" title="2.3.2、TraceClassVisitor"></a>2.3.2、TraceClassVisitor</h3><p>为了检查生成的或转换的类是否符合您的期望，ClassWriter返回的字节数组并没有真正的帮助，因为它是人类无法读取的。文本表示将更易于使用。这是TraceClassVisitor类提供的。顾名思义，该类扩展了ClassVisitor类，并构造了所访问类的文本表示形式。因此，可以使用TraceClassVisitor而不是使用ClassWriter来生成类，以便获得对实际生成内容的可读记录。或者，甚至更好的是，您可以同时使用两者。实际上，TraceClassVisitor除了其默认行为外，还可以将对其方法的所有调用委派给另一个访问者，例如ClassWriter：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ClassWriter</span> cw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassWriter</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">TraceClassVisitor</span> cv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TraceClassVisitor</span><span class="token punctuation">(</span>cw<span class="token punctuation">,</span> printWriter<span class="token punctuation">)</span><span class="token punctuation">;</span>cv<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>cv<span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">byte</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> cw<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码创建了一个TraceClassVisitor，它将接收到的所有调用委托给cw，并将这些调用的文本表示输出到printWriter。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// class version 49.0 (49)</span><span class="token comment">// access flags 1537</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">interface</span> pkg<span class="token operator">/</span><span class="token class-name">Comparable</span> <span class="token keyword">implements</span> pkg<span class="token operator">/</span><span class="token class-name">Mesurable</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// access flags 25</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">I</span> <span class="token constant">LESS</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token comment">// access flags 25</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">I</span> <span class="token constant">EQUAL</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment">// access flags 25</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">I</span> <span class="token constant">GREATER</span> <span class="token operator">=</span> <span class="token number">1</span>    <span class="token comment">// access flags 1025</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Ljava</span><span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">Object</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token class-name">I</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-3、CheckClassAdapter"><a href="#2-3-3、CheckClassAdapter" class="headerlink" title="2.3.3、CheckClassAdapter"></a>2.3.3、CheckClassAdapter</h3><p>为了检查一个类，打印该类的文本表示形式，最后创建一个字节数组表示形式，您应该使用类似以下内容的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ClassWriter</span> cw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassWriter</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">TraceClassVisitor</span> tcv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TraceClassVisitor</span><span class="token punctuation">(</span>cw<span class="token punctuation">,</span> printWriter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">CheckClassAdapter</span> cv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CheckClassAdapter</span><span class="token punctuation">(</span>tcv<span class="token punctuation">)</span><span class="token punctuation">;</span>cv<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>cv<span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">byte</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> cw<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请注意，如果以不同的顺序链接这些类访问者，则它们执行的操作也将以不同的顺序进行。例如，使用以下代码，检查将在跟踪之后进行：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ClassWriter</span> cw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassWriter</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">CheckClassAdapter</span> cca <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CheckClassAdapter</span><span class="token punctuation">(</span>cw<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">TraceClassVisitor</span> cv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TraceClassVisitor</span><span class="token punctuation">(</span>cca<span class="token punctuation">,</span> printWriter<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>与TraceClassVisitor一样，您可以在生成或转换链中的任何点使用CheckClassAdapter，不仅可以在ClassWriter之前使用，还可以在链中此点检查类。</p><h3 id="2-3-4、ASMifier"><a href="#2-3-4、ASMifier" class="headerlink" title="2.3.4、ASMifier"></a>2.3.4、ASMifier</h3><p>可以从命令行使用ASMifier类。例如使用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> <span class="token parameter variable">-classpath</span> asm.jar:asm-util.jar <span class="token punctuation">\</span>org.objectweb.asm.util.ASMifier <span class="token punctuation">\</span>java.lang.Runnable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>产生缩进后的代码为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">asm<span class="token punctuation">.</span>java<span class="token punctuation">.</span>lang</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>objectweb<span class="token punctuation">.</span>asm<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RunnableDump</span> <span class="token keyword">implements</span> <span class="token class-name">Opcodes</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">dump</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ClassWriter</span> cw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassWriter</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">FieldVisitor</span> fv<span class="token punctuation">;</span>        <span class="token class-name">MethodVisitor</span> mv<span class="token punctuation">;</span>        <span class="token class-name">AnnotationVisitor</span> av0<span class="token punctuation">;</span>        cw<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token constant">V1_5</span><span class="token punctuation">,</span> <span class="token constant">ACC_PUBLIC</span> <span class="token operator">+</span> <span class="token constant">ACC_ABSTRACT</span> <span class="token operator">+</span> <span class="token constant">ACC_INTERFACE</span><span class="token punctuation">,</span> <span class="token string">"java/lang/Runnable"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"java/lang/Object"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#123;</span>        mv <span class="token operator">=</span> cw<span class="token punctuation">.</span><span class="token function">visitMethod</span><span class="token punctuation">(</span><span class="token constant">ACC_PUBLIC</span> <span class="token operator">+</span> <span class="token constant">ACC_ABSTRACT</span><span class="token punctuation">,</span> <span class="token string">"run"</span><span class="token punctuation">,</span> <span class="token string">"()V"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mv<span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cw<span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> cw<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3、方法"><a href="#3、方法" class="headerlink" title="3、方法"></a>3、方法</h1><p>本章介绍如何使用核心ASM API生成和转换编译方法。它首先介绍了已编译的方法，然后提供了许多说明性示例，介绍了相应的ASM接口，组件以及生成和转换它们的工具。</p><h2 id="3-1、结构"><a href="#3-1、结构" class="headerlink" title="3.1、结构"></a>3.1、结构</h2><p>在已编译的类中，方法的代码存储为一系列字节码指令。为了生成和转换类，了解这些指令并理解它们的工作原理至关重要。</p><h3 id="3-1-1、执行模式"><a href="#3-1-1、执行模式" class="headerlink" title="3.1.1、执行模式"></a>3.1.1、执行模式</h3><p>在呈现字节码指令之前，必须呈现Java虚拟机执行模型。如您所知，Java代码是在线程内部执行的。每个线程都有其自己的执行堆栈，该堆栈由框架组成。每个框架代表一个方法调用：每次调用一个方法时，都会在当前线程的执行堆栈上推送一个新框架。当方法返回时，无论是正常情况还是由于异常而返回，都会从执行堆栈弹出该框架，并在调用方法中继续执行（其框架现在位于堆栈的顶部）。</p><p>局部变量和操作数堆栈部分的大小取决于方法的代码。它是在编译时计算的，并与字节码指令一起存储在已编译的类中。结果，与给定方法的调用相对应的所有框架都具有相同的大小，但是与不同方法相对应的框架的局部变量和操作数堆栈部分可以具有不同的大小。</p><h3 id="3-1-2、字节码指令"><a href="#3-1-2、字节码指令" class="headerlink" title="3.1.2、字节码指令"></a>3.1.2、字节码指令</h3><p>字节码指令由标识该指令的操作码和固定数量的参数组成：</p><ul><li>操作码是一个无符号的字节值（因此为字节码名称），并由助记符标识。例如，操作码值0由助记符NOP设计，并且对应于不执行任何操作的指令。</li><li>参数是定义精确指令行为的静态值。它们在操作码之后给出。例如，操作码值为167的GOTO标签指令将自变量标签指定为要执行的下一条指令。指令参数不能与指令操作数混淆：参数值是静态已知的，并存储在编译后的代码中，而操作数值来自操作数堆栈，并且仅在运行时才知道。</li></ul><p>字节码指令可分为两类：一小组指令旨在将值从局部变量传输到操作数堆栈，反之亦然；其他指令仅作用于操作数堆栈：它们从堆栈中弹出一些值，根据这些值计算结果，然后将其推回堆栈。</p><p>所有其他字节码指令仅在操作数堆栈上工作。它们可以分为以下类别：</p><ul><li>Stack</li><li>Constants</li><li>Arithmetic and logic</li><li>Casts</li><li>Objects</li><li>Fields</li><li>Methods</li><li>Arrays</li><li>Jumps</li><li>Return</li></ul><h3 id="3-1-3、实例"><a href="#3-1-3、实例" class="headerlink" title="3.1.3、实例"></a>3.1.3、实例</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">pkg</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bean</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> f<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getF</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>f<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setF</span><span class="token punctuation">(</span><span class="token keyword">int</span> f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>f <span class="token operator">=</span> f<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>getter方法的字节码为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token constant">ALOAD</span> <span class="token number">0</span><span class="token constant">GETFIELD</span> pkg<span class="token operator">/</span><span class="token class-name">Bean</span> f <span class="token class-name">I</span><span class="token constant">IRETURN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第一条指令读取局部变量0，该局部变量在创建此方法调用的帧期间已初始化为0，并将此值压入操作数堆栈。第二条指令从堆栈中弹出此值，即this，并压入此对象的f字段，即this.f.最后一条指令从堆栈中弹出该值，并将其返回给调用方。此方法的执行帧的连续状态如下图所示：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200906150115558.png" alt="image-20200906150115558"></p><p>setter方法的字节码为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token constant">ALOAD</span> <span class="token number">0</span><span class="token constant">ILOAD</span> <span class="token number">1</span><span class="token constant">PUTFIELD</span> pkg<span class="token operator">/</span><span class="token class-name">Bean</span> f <span class="token class-name">I</span><span class="token constant">RETURN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第一条指令将其压入操作数堆栈。第二条指令压入局部变量1，该局部变量在创建用于此方法调用的框架期间使用f参数值初始化。第三条指令弹出这两个值，并将int值存储在所引用对象的f字段中，即在this.f中。最后一条指令在源代码中是隐式的，而在编译后的代码中是强制性的，它会破坏当前执行框架并返回给调用者。此方法的执行帧的连续状态如图3.3所示。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200906150426003.png" alt="image-20200906150426003"></p><p>现在让我们考虑一个稍微复杂一些的setter方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">checkAndSetF</span><span class="token punctuation">(</span><span class="token keyword">int</span> f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>f <span class="token operator">=</span> f<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应字节码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">    <span class="token constant">ILOAD</span> <span class="token number">1</span>    <span class="token constant">IFLT</span> label    <span class="token constant">ALOAD</span> <span class="token number">0</span>    <span class="token constant">ILOAD</span> <span class="token number">1</span>    <span class="token constant">PUTFIELD</span> pkg<span class="token operator">/</span><span class="token class-name">Bean</span> f <span class="token class-name">I</span>    <span class="token constant">GOTO</span> endlabel<span class="token operator">:</span>    <span class="token constant">NEW</span> java<span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">IllegalArgumentException</span>    <span class="token constant">DUP</span>    <span class="token constant">INVOKESPECIAL</span> java<span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">IllegalArgumentException</span> <span class="token generics"><span class="token punctuation">&lt;</span>init<span class="token punctuation">></span></span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token class-name">V</span>    <span class="token constant">ATHROW</span>end<span class="token operator">:</span><span class="token constant">RETURN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-4、异常处理"><a href="#3-1-4、异常处理" class="headerlink" title="3.1.4、异常处理"></a>3.1.4、异常处理</h3><p>例如下面的源代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">long</span> d<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其可以编译成：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token constant">TRYCATCHBLOCK</span> <span class="token keyword">try</span> <span class="token keyword">catch</span> <span class="token keyword">catch</span> java<span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">InterruptedException</span><span class="token keyword">try</span><span class="token operator">:</span><span class="token constant">LLOAD</span> <span class="token number">0</span><span class="token constant">INVOKESTATIC</span> java<span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">Thread</span> sleep <span class="token punctuation">(</span><span class="token class-name">J</span><span class="token punctuation">)</span><span class="token class-name">V</span><span class="token constant">RETURN</span><span class="token keyword">catch</span><span class="token operator">:</span><span class="token constant">INVOKEVIRTUAL</span> java<span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">InterruptedException</span> printStackTrace <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token class-name">V</span><span class="token constant">RETURN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-5、Frames"><a href="#3-1-5、Frames" class="headerlink" title="3.1.5、Frames"></a>3.1.5、Frames</h3><p>例如，如果考虑上一节的getF方法，则可以定义三个堆栈映射框架，这些框架映射框架给出了执行框架的状态，这些状态仅在ALOAD之前，在GETFIELD之前和在IRETURN之前。这三个堆栈映射框架对应于图3.2中所示的三种情况，可以描述如下，其中第一个方括号之间的类型对应于局部变量，其他类型对应于操作数堆栈：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">State</span> of the execution frame before <span class="token class-name">Instruction</span><span class="token punctuation">[</span>pkg<span class="token operator">/</span><span class="token class-name">Bean</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>   <span class="token constant">ALOAD</span> <span class="token number">0</span><span class="token punctuation">[</span>pkg<span class="token operator">/</span><span class="token class-name">Bean</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>pkg<span class="token operator">/</span><span class="token class-name">Bean</span><span class="token punctuation">]</span>    <span class="token constant">GETFIELD</span><span class="token punctuation">[</span>pkg<span class="token operator">/</span><span class="token class-name">Bean</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token class-name">I</span><span class="token punctuation">]</span>   <span class="token constant">IRETURN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以对checkAndSetF方法做同样的事情：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200906151656565.png" alt="image-20200906151656565"></p><p>为了节省更多空间，通过仅存储与前一帧的差异来压缩每个帧，并且不存储初始帧，因为它可以很容易地从方法参数类型推导出来。在使用checkAndSetF方法的情况下，必须存储的两个帧相等并且等于初始帧，因此将它们存储为F_SAME助记符指定的单字节值。这些帧可以在它们关联的字节码指令之前被表示。这给出了checkAndSetF方法的最终字节码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token constant">ILOAD</span> <span class="token number">1</span><span class="token constant">IFLT</span> label<span class="token constant">ALOAD</span> <span class="token number">0</span><span class="token constant">ILOAD</span> <span class="token number">1</span><span class="token constant">PUTFIELD</span> pkg<span class="token operator">/</span><span class="token class-name">Bean</span> f <span class="token class-name">I</span><span class="token constant">GOTO</span> endlabel<span class="token operator">:</span><span class="token constant">F_SAME</span><span class="token constant">NEW</span> java<span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">IllegalArgumentException</span><span class="token constant">DUP</span><span class="token constant">INVOKESPECIAL</span> java<span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">IllegalArgumentException</span> <span class="token generics"><span class="token punctuation">&lt;</span>init<span class="token punctuation">></span></span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token class-name">V</span><span class="token constant">ATHROW</span>end<span class="token operator">:</span><span class="token constant">F_SAME</span><span class="token constant">RETURN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2、接口与组件"><a href="#3-2、接口与组件" class="headerlink" title="3.2、接口与组件"></a>3.2、接口与组件</h2><h3 id="3-2-2、生成方法"><a href="#3-2-2、生成方法" class="headerlink" title="3.2.2、生成方法"></a>3.2.2、生成方法</h3><p>如果mv是MethodVisitor，则可以使用以下方法调用生成3.1.3节中定义的getF方法的字节码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">mv<span class="token punctuation">.</span><span class="token function">visitCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitVarInsn</span><span class="token punctuation">(</span><span class="token constant">ALOAD</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitFieldInsn</span><span class="token punctuation">(</span><span class="token constant">GETFIELD</span><span class="token punctuation">,</span> <span class="token string">"pkg/Bean"</span><span class="token punctuation">,</span> <span class="token string">"f"</span><span class="token punctuation">,</span> <span class="token string">"I"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token constant">IRETURN</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitMaxs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>setF方法和构造函数的字节码可以类似的方式生成。一个更有趣的示例是checkAndSetF方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">mv<span class="token punctuation">.</span><span class="token function">visitCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitVarInsn</span><span class="token punctuation">(</span><span class="token constant">ILOAD</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Label</span> label <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Label</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitJumpInsn</span><span class="token punctuation">(</span><span class="token constant">IFLT</span><span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitVarInsn</span><span class="token punctuation">(</span><span class="token constant">ALOAD</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitVarInsn</span><span class="token punctuation">(</span><span class="token constant">ILOAD</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitFieldInsn</span><span class="token punctuation">(</span><span class="token constant">PUTFIELD</span><span class="token punctuation">,</span> <span class="token string">"pkg/Bean"</span><span class="token punctuation">,</span> <span class="token string">"f"</span><span class="token punctuation">,</span> <span class="token string">"I"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Label</span> end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Label</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitJumpInsn</span><span class="token punctuation">(</span><span class="token constant">GOTO</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitLabel</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitFrame</span><span class="token punctuation">(</span><span class="token constant">F_SAME</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitTypeInsn</span><span class="token punctuation">(</span><span class="token constant">NEW</span><span class="token punctuation">,</span> <span class="token string">"java/lang/IllegalArgumentException"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token constant">DUP</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitMethodInsn</span><span class="token punctuation">(</span><span class="token constant">INVOKESPECIAL</span><span class="token punctuation">,</span><span class="token string">"java/lang/IllegalArgumentException"</span><span class="token punctuation">,</span> <span class="token string">"&lt;init>"</span><span class="token punctuation">,</span> <span class="token string">"()V"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token constant">ATHROW</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitLabel</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitFrame</span><span class="token punctuation">(</span><span class="token constant">F_SAME</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token constant">RETURN</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitMaxs</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mv<span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：Label对象指定该标签的visitLabel调用之后的指令。例如，end指定RETURN指令，而不是紧随其后访问的帧，因为这不是指令。拥有多个指定同一条指令的标签是完全合法的，但是标签必须精确地指定一条指令。换句话说，可以使用不同的标签连续调用visitLabel，但是指令中使用的标签必须使用visitLabel进行一次精确的访问。最后一个约束是不能共享标签：每个方法必须具有自己的标签。</p></blockquote><h3 id="3-2-3、转换方法"><a href="#3-2-3、转换方法" class="headerlink" title="3.2.3、转换方法"></a>3.2.3、转换方法</h3><p>为了了解如何使用方法适配器，让我们考虑一个非常简单的适配器，它删除了方法内部的NOP指令（可以删除它们，因为它们什么都不做，因此不会出现问题）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RemoveNopAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">MethodVisitor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">RemoveNopAdapter</span><span class="token punctuation">(</span><span class="token class-name">MethodVisitor</span> mv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">ASM4</span><span class="token punctuation">,</span> mv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token keyword">int</span> opcode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>opcode <span class="token operator">!=</span> <span class="token constant">NOP</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        mv<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span>opcode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以在类适配器内部使用此适配器，如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RemoveNopClassAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">ClassVisitor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">RemoveNopClassAdapter</span><span class="token punctuation">(</span><span class="token class-name">ClassVisitor</span> cv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">ASM4</span><span class="token punctuation">,</span> cv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">MethodVisitor</span> <span class="token function">visitMethod</span><span class="token punctuation">(</span><span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span>        <span class="token class-name">String</span> desc<span class="token punctuation">,</span> <span class="token class-name">String</span> signature<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> exceptions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">MethodVisitor</span> mv<span class="token punctuation">;</span>        mv <span class="token operator">=</span> cv<span class="token punctuation">.</span><span class="token function">visitMethod</span><span class="token punctuation">(</span>access<span class="token punctuation">,</span> name<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> signature<span class="token punctuation">,</span> exceptions<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mv <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        mv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RemoveNopAdapter</span><span class="token punctuation">(</span>mv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> mv<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是请注意，这不是强制性的：完全有可能构建与类适配器链不同的方法适配器链。每个方法甚至可以具有不同的方法适配器链。例如，类适配器可以选择仅在方法中而不在构造函数中删除NOP。可以按照以下步骤进行：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>mv <span class="token operator">=</span> cv<span class="token punctuation">.</span><span class="token function">visitMethod</span><span class="token punctuation">(</span>access<span class="token punctuation">,</span> name<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> signature<span class="token punctuation">,</span> exceptions<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>mv <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"&lt;init>"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>mv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RemoveNopAdapter</span><span class="token punctuation">(</span>mv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法适配器链甚至可以具有与类适配器链不同的拓扑。例如，类适配器链可以是线性的，而方法适配器链具有分支：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">MethodVisitor</span> <span class="token function">visitMethod</span><span class="token punctuation">(</span><span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">,</span> <span class="token class-name">String</span> signature<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> exceptions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">MethodVisitor</span> mv1<span class="token punctuation">,</span> mv2<span class="token punctuation">;</span>    mv1 <span class="token operator">=</span> cv<span class="token punctuation">.</span><span class="token function">visitMethod</span><span class="token punctuation">(</span>access<span class="token punctuation">,</span> name<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> signature<span class="token punctuation">,</span> exceptions<span class="token punctuation">)</span><span class="token punctuation">;</span>    mv2 <span class="token operator">=</span> cv<span class="token punctuation">.</span><span class="token function">visitMethod</span><span class="token punctuation">(</span>access<span class="token punctuation">,</span> <span class="token string">"_"</span> <span class="token operator">+</span> name<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> signature<span class="token punctuation">,</span> exceptions<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MultiMethodAdapter</span><span class="token punctuation">(</span>mv1<span class="token punctuation">,</span> mv2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-4、无状态转换"><a href="#3-2-4、无状态转换" class="headerlink" title="3.2.4、无状态转换"></a>3.2.4、无状态转换</h3><p>假设我们要衡量一个程序的每个类所花费的时间。我们需要在每个类中添加一个静态计时器字段，并且需要将该类的每个方法的执行时间添加到此计时器字段中。换句话说，我们要转换一个诸如C的类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>转为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> timer<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        timer <span class="token operator">-=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        timer <span class="token operator">+=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了了解如何在ASM中实现这一点，我们可以编译这两个类，并比较这两个版本上的TraceClassVisitor的输出（使用默认的Textifier后端或使用ASMifier后端）。使用默认后端，我们得到以下差异（粗体）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token constant">GETSTATIC</span> <span class="token class-name">C</span><span class="token punctuation">.</span>timer <span class="token operator">:</span> <span class="token class-name">J</span><span class="token constant">INVOKESTATIC</span> java<span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token class-name">J</span><span class="token constant">LSUB</span><span class="token constant">PUTSTATIC</span> <span class="token class-name">C</span><span class="token punctuation">.</span>timer <span class="token operator">:</span> <span class="token class-name">J</span><span class="token constant">LDC</span> <span class="token number">100</span><span class="token constant">INVOKESTATIC</span> java<span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">J</span><span class="token punctuation">)</span><span class="token class-name">V</span><span class="token constant">GETSTATIC</span> <span class="token class-name">C</span><span class="token punctuation">.</span>timer <span class="token operator">:</span> <span class="token class-name">J</span><span class="token constant">INVOKESTATIC</span> java<span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token class-name">J</span><span class="token constant">LADD</span><span class="token constant">PUTSTATIC</span> <span class="token class-name">C</span><span class="token punctuation">.</span>timer <span class="token operator">:</span> <span class="token class-name">J</span><span class="token class-name">RETURN</span><span class="token constant">MAXSTACK</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token constant">MAXLOCALS</span> <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到必须在方法的开头添加四个指令，在返回指令之前添加四个其他指令。我们还需要更新最大操作数堆栈大小。该方法代码的开头是通过visitCode方法访问的。因此，我们可以通过在方法适配器中重写此方法来添加前四个指令：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    mv<span class="token punctuation">.</span><span class="token function">visitCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mv<span class="token punctuation">.</span><span class="token function">visitFieldInsn</span><span class="token punctuation">(</span><span class="token constant">GETSTATIC</span><span class="token punctuation">,</span> owner<span class="token punctuation">,</span> <span class="token string">"timer"</span><span class="token punctuation">,</span> <span class="token string">"J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mv<span class="token punctuation">.</span><span class="token function">visitMethodInsn</span><span class="token punctuation">(</span><span class="token constant">INVOKESTATIC</span><span class="token punctuation">,</span> <span class="token string">"java/lang/System"</span><span class="token punctuation">,</span> <span class="token string">"currentTimeMillis"</span><span class="token punctuation">,</span> <span class="token string">"()J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mv<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token constant">LSUB</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mv<span class="token punctuation">.</span><span class="token function">visitFieldInsn</span><span class="token punctuation">(</span><span class="token constant">PUTSTATIC</span><span class="token punctuation">,</span> owner<span class="token punctuation">,</span> <span class="token string">"timer"</span><span class="token punctuation">,</span> <span class="token string">"J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>必须将owner设置为要转换的类的名称。现在，我们必须在任何RETURN之前，任何xRETURN或ATHROW之前添加其他四条指令，它们都是终止该方法执行的所有指令。这些指令没有任何参数，因此可以在visitInsn方法中进行访问。然后，我们可以覆盖此方法以添加我们的说明：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token keyword">int</span> opcode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>opcode <span class="token operator">>=</span> <span class="token constant">IRETURN</span> <span class="token operator">&amp;&amp;</span> opcode <span class="token operator">&lt;=</span> <span class="token constant">RETURN</span><span class="token punctuation">)</span> <span class="token operator">||</span> opcode <span class="token operator">==</span> <span class="token constant">ATHROW</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        mv<span class="token punctuation">.</span><span class="token function">visitFieldInsn</span><span class="token punctuation">(</span><span class="token constant">GETSTATIC</span><span class="token punctuation">,</span> owner<span class="token punctuation">,</span> <span class="token string">"timer"</span><span class="token punctuation">,</span> <span class="token string">"J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mv<span class="token punctuation">.</span><span class="token function">visitMethodInsn</span><span class="token punctuation">(</span><span class="token constant">INVOKESTATIC</span><span class="token punctuation">,</span> <span class="token string">"java/lang/System"</span><span class="token punctuation">,</span> <span class="token string">"currentTimeMillis"</span><span class="token punctuation">,</span> <span class="token string">"()J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mv<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token constant">LADD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mv<span class="token punctuation">.</span><span class="token function">visitFieldInsn</span><span class="token punctuation">(</span><span class="token constant">PUTSTATIC</span><span class="token punctuation">,</span> owner<span class="token punctuation">,</span> <span class="token string">"timer"</span><span class="token punctuation">,</span> <span class="token string">"J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    mv<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span>opcode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-5、有状态转换"><a href="#3-2-5、有状态转换" class="headerlink" title="3.2.5、有状态转换"></a>3.2.5、有状态转换</h3><p>为了实现删除或替换某些指令序列的转换，可以方便地引入MethodVisitor子类，该子类的visitXxx Insn方法调用通用的visitInsn（）方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">PatternMethodAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">MethodVisitor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token constant">SEEN_NOTHING</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">PatternMethodAdapter</span><span class="token punctuation">(</span><span class="token keyword">int</span> api<span class="token punctuation">,</span> <span class="token class-name">MethodVisitor</span> mv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>api<span class="token punctuation">,</span> mv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Overrid</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token keyword">int</span> opcode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mv<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span>opcode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitIntInsn</span><span class="token punctuation">(</span><span class="token keyword">int</span> opcode<span class="token punctuation">,</span> <span class="token keyword">int</span> operand<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mv<span class="token punctuation">.</span><span class="token function">visitIntInsn</span><span class="token punctuation">(</span>opcode<span class="token punctuation">,</span> operand<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后可以像这样实现上面的转换：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RemoveAddZeroAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">PatternMethodAdapter</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token constant">SEEN_ICONST_0</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">RemoveAddZeroAdapter</span><span class="token punctuation">(</span><span class="token class-name">MethodVisitor</span> mv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">ASM4</span><span class="token punctuation">,</span> mv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token keyword">int</span> opcode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> <span class="token constant">SEEN_ICONST_0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>opcode <span class="token operator">==</span> <span class="token constant">IADD</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            state <span class="token operator">=</span> <span class="token constant">SEEN_NOTHING</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>opcode <span class="token operator">==</span> <span class="token constant">ICONST_0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            state <span class="token operator">=</span> <span class="token constant">SEEN_ICONST_0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        mv<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span>opcode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span> <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> <span class="token constant">SEEN_ICONST_0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        mv<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token constant">ICONST_0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        state <span class="token operator">=</span> <span class="token constant">SEEN_NOTHING</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3、工具"><a href="#3-3、工具" class="headerlink" title="3.3、工具"></a>3.3、工具</h2><h3 id="3-3-1、基础工具"><a href="#3-3-1、基础工具" class="headerlink" title="3.3.1、基础工具"></a>3.3.1、基础工具</h3><ul><li>Type</li><li>TraceClassVisitor</li><li>CheckClassAdapter</li><li>ASMifier</li></ul><h3 id="3-3-2、分析适配器"><a href="#3-3-2、分析适配器" class="headerlink" title="3.3.2、分析适配器"></a>3.3.2、分析适配器</h3><p>在我们的AddTimerAdapter示例中，可以使用此适配器来获取RETURN指令之前的操作数堆栈的大小，从而允许为visitMaxs中的maxStack计算最佳转换值（实际上，不建议使用此方法，因为它比使用COMPUTE_MAXS效率低得多）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">AddTimerMethodAdapter2</span> <span class="token keyword">extends</span> <span class="token class-name">AnalyzerAdapter</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> maxStack<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AddTimerMethodAdapter2</span><span class="token punctuation">(</span><span class="token class-name">String</span> owner<span class="token punctuation">,</span> <span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">,</span> <span class="token class-name">MethodVisitor</span> mv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">ASM4</span><span class="token punctuation">,</span> owner<span class="token punctuation">,</span> access<span class="token punctuation">,</span> name<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> mv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mv<span class="token punctuation">.</span><span class="token function">visitFieldInsn</span><span class="token punctuation">(</span><span class="token constant">GETSTATIC</span><span class="token punctuation">,</span> owner<span class="token punctuation">,</span> <span class="token string">"timer"</span><span class="token punctuation">,</span> <span class="token string">"J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mv<span class="token punctuation">.</span><span class="token function">visitMethodInsn</span><span class="token punctuation">(</span><span class="token constant">INVOKESTATIC</span><span class="token punctuation">,</span> <span class="token string">"java/lang/System"</span><span class="token punctuation">,</span> <span class="token string">"currentTimeMillis"</span><span class="token punctuation">,</span> <span class="token string">"()J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mv<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token constant">LSUB</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mv<span class="token punctuation">.</span><span class="token function">visitFieldInsn</span><span class="token punctuation">(</span><span class="token constant">PUTSTATIC</span><span class="token punctuation">,</span> owner<span class="token punctuation">,</span> <span class="token string">"timer"</span><span class="token punctuation">,</span> <span class="token string">"J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        maxStack <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token keyword">int</span> opcode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>opcode <span class="token operator">>=</span> <span class="token constant">IRETURN</span> <span class="token operator">&amp;&amp;</span> opcode <span class="token operator">&lt;=</span> <span class="token constant">RETURN</span><span class="token punctuation">)</span> <span class="token operator">||</span> opcode <span class="token operator">==</span> <span class="token constant">ATHROW</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            mv<span class="token punctuation">.</span><span class="token function">visitFieldInsn</span><span class="token punctuation">(</span><span class="token constant">GETSTATIC</span><span class="token punctuation">,</span> owner<span class="token punctuation">,</span> <span class="token string">"timer"</span><span class="token punctuation">,</span> <span class="token string">"J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mv<span class="token punctuation">.</span><span class="token function">visitMethodInsn</span><span class="token punctuation">(</span><span class="token constant">INVOKESTATIC</span><span class="token punctuation">,</span> <span class="token string">"java/lang/System"</span><span class="token punctuation">,</span> <span class="token string">"currentTimeMillis"</span><span class="token punctuation">,</span> <span class="token string">"()J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mv<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token constant">LADD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mv<span class="token punctuation">.</span><span class="token function">visitFieldInsn</span><span class="token punctuation">(</span><span class="token constant">PUTSTATIC</span><span class="token punctuation">,</span> owner<span class="token punctuation">,</span> <span class="token string">"timer"</span><span class="token punctuation">,</span> <span class="token string">"J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            maxStack <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxStack<span class="token punctuation">,</span> stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span>opcode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitMaxs</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxStack<span class="token punctuation">,</span> <span class="token keyword">int</span> maxLocals<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitMaxs</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>maxStack<span class="token punctuation">,</span> maxStack<span class="token punctuation">)</span><span class="token punctuation">,</span> maxLocals<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者，可以通过调用超类的方法来插入新指令：结果是这些指令的帧将由AnalyzerAdapter计算。此外，由于此适配器基于其计算的帧来更新visitMaxs的参数，因此我们不需要自己更新它们：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">AddTimerMethodAdapter3</span> <span class="token keyword">extends</span> <span class="token class-name">AnalyzerAdapter</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">AddTimerMethodAdapter3</span><span class="token punctuation">(</span><span class="token class-name">String</span> owner<span class="token punctuation">,</span> <span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">,</span> <span class="token class-name">MethodVisitor</span> mv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">ASM4</span><span class="token punctuation">,</span> owner<span class="token punctuation">,</span> access<span class="token punctuation">,</span> name<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> mv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitFieldInsn</span><span class="token punctuation">(</span><span class="token constant">GETSTATIC</span><span class="token punctuation">,</span> owner<span class="token punctuation">,</span> <span class="token string">"timer"</span><span class="token punctuation">,</span> <span class="token string">"J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitMethodInsn</span><span class="token punctuation">(</span><span class="token constant">INVOKESTATIC</span><span class="token punctuation">,</span> <span class="token string">"java/lang/System"</span><span class="token punctuation">,</span> <span class="token string">"currentTimeMillis"</span><span class="token punctuation">,</span> <span class="token string">"()J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token constant">LSUB</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitFieldInsn</span><span class="token punctuation">(</span><span class="token constant">PUTSTATIC</span><span class="token punctuation">,</span> owner<span class="token punctuation">,</span> <span class="token string">"timer"</span><span class="token punctuation">,</span> <span class="token string">"J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token keyword">int</span> opcode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>opcode <span class="token operator">>=</span> <span class="token constant">IRETURN</span> <span class="token operator">&amp;&amp;</span> opcode <span class="token operator">&lt;=</span> <span class="token constant">RETURN</span><span class="token punctuation">)</span> <span class="token operator">||</span> opcode <span class="token operator">==</span> <span class="token constant">ATHROW</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitFieldInsn</span><span class="token punctuation">(</span><span class="token constant">GETSTATIC</span><span class="token punctuation">,</span> owner<span class="token punctuation">,</span> <span class="token string">"timer"</span><span class="token punctuation">,</span> <span class="token string">"J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitMethodInsn</span><span class="token punctuation">(</span><span class="token constant">INVOKESTATIC</span><span class="token punctuation">,</span> <span class="token string">"java/lang/System"</span><span class="token punctuation">,</span> <span class="token string">"currentTimeMillis"</span><span class="token punctuation">,</span> <span class="token string">"()J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token constant">LADD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitFieldInsn</span><span class="token punctuation">(</span><span class="token constant">PUTSTATIC</span><span class="token punctuation">,</span> owner<span class="token punctuation">,</span> <span class="token string">"timer"</span><span class="token punctuation">,</span> <span class="token string">"J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span>opcode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-3、LocalVariablesSorter"><a href="#3-3-3、LocalVariablesSorter" class="headerlink" title="3.3.3、LocalVariablesSorter"></a>3.3.3、LocalVariablesSorter</h3><p>为了展示如何使用此适配器，假设我们要使用局部变量来实现AddTimerAdapter：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> timer<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> t <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        timer <span class="token operator">+=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过扩展LocalVariablesSorter并使用此类中定义的newLocal方法，可以轻松完成此操作：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">AddTimerMethodAdapter4</span> <span class="token keyword">extends</span> <span class="token class-name">LocalVariablesSorter</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> time<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AddTimerMethodAdapter4</span><span class="token punctuation">(</span><span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">,</span> <span class="token class-name">MethodVisitor</span> mv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">ASM4</span><span class="token punctuation">,</span> access<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> mv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mv<span class="token punctuation">.</span><span class="token function">visitMethodInsn</span><span class="token punctuation">(</span><span class="token constant">INVOKESTATIC</span><span class="token punctuation">,</span> <span class="token string">"java/lang/System"</span><span class="token punctuation">,</span> <span class="token string">"currentTimeMillis"</span><span class="token punctuation">,</span> <span class="token string">"()J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        time <span class="token operator">=</span> <span class="token function">newLocal</span><span class="token punctuation">(</span><span class="token class-name">Type</span><span class="token punctuation">.</span><span class="token constant">LONG_TYPE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mv<span class="token punctuation">.</span><span class="token function">visitVarInsn</span><span class="token punctuation">(</span><span class="token constant">LSTORE</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token keyword">int</span> opcode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>opcode <span class="token operator">>=</span> <span class="token constant">IRETURN</span> <span class="token operator">&amp;&amp;</span> opcode <span class="token operator">&lt;=</span> <span class="token constant">RETURN</span><span class="token punctuation">)</span> <span class="token operator">||</span> opcode <span class="token operator">==</span> <span class="token constant">ATHROW</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            mv<span class="token punctuation">.</span><span class="token function">visitMethodInsn</span><span class="token punctuation">(</span><span class="token constant">INVOKESTATIC</span><span class="token punctuation">,</span> <span class="token string">"java/lang/System"</span><span class="token punctuation">,</span> <span class="token string">"currentTimeMillis"</span><span class="token punctuation">,</span> <span class="token string">"()J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mv<span class="token punctuation">.</span><span class="token function">visitVarInsn</span><span class="token punctuation">(</span><span class="token constant">LLOAD</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>            mv<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token constant">LSUB</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mv<span class="token punctuation">.</span><span class="token function">visitFieldInsn</span><span class="token punctuation">(</span><span class="token constant">GETSTATIC</span><span class="token punctuation">,</span> owner<span class="token punctuation">,</span> <span class="token string">"timer"</span><span class="token punctuation">,</span> <span class="token string">"J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mv<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token constant">LADD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mv<span class="token punctuation">.</span><span class="token function">visitFieldInsn</span><span class="token punctuation">(</span><span class="token constant">PUTSTATIC</span><span class="token punctuation">,</span> owner<span class="token punctuation">,</span> <span class="token string">"timer"</span><span class="token punctuation">,</span> <span class="token string">"J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span>opcode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitMaxs</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxStack<span class="token punctuation">,</span> <span class="token keyword">int</span> maxLocals<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitMaxs</span><span class="token punctuation">(</span>maxStack <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">,</span> maxLocals<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用局部变量不能解决我们在此类的原始版本中遇到的问题，该问题涉及maxStack的最坏情况。如果要使用AnalyzerAdapter来解决此问题，除了LocalVariablesSorter之外，还必须通过委派而不是通过继承使用这些适配器（因为无法进行多重继承）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">AddTimerMethodAdapter5</span> <span class="token keyword">extends</span> <span class="token class-name">MethodVisitor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">LocalVariablesSorter</span> lvs<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AnalyzerAdapter</span> aa<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> time<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> maxStack<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AddTimerMethodAdapter5</span><span class="token punctuation">(</span><span class="token class-name">MethodVisitor</span> mv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">ASM4</span><span class="token punctuation">,</span> mv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        mv<span class="token punctuation">.</span><span class="token function">visitCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mv<span class="token punctuation">.</span><span class="token function">visitMethodInsn</span><span class="token punctuation">(</span><span class="token constant">INVOKESTATIC</span><span class="token punctuation">,</span> <span class="token string">"java/lang/System"</span><span class="token punctuation">,</span> <span class="token string">"currentTimeMillis"</span><span class="token punctuation">,</span> <span class="token string">"()J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        time <span class="token operator">=</span> lvs<span class="token punctuation">.</span><span class="token function">newLocal</span><span class="token punctuation">(</span><span class="token class-name">Type</span><span class="token punctuation">.</span><span class="token constant">LONG_TYPE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mv<span class="token punctuation">.</span><span class="token function">visitVarInsn</span><span class="token punctuation">(</span><span class="token constant">LSTORE</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>        maxStack <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token keyword">int</span> opcode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>opcode <span class="token operator">>=</span> <span class="token constant">IRETURN</span> <span class="token operator">&amp;&amp;</span> opcode <span class="token operator">&lt;=</span> <span class="token constant">RETURN</span><span class="token punctuation">)</span> <span class="token operator">||</span> opcode <span class="token operator">==</span> <span class="token constant">ATHROW</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            mv<span class="token punctuation">.</span><span class="token function">visitMethodInsn</span><span class="token punctuation">(</span><span class="token constant">INVOKESTATIC</span><span class="token punctuation">,</span> <span class="token string">"java/lang/System"</span><span class="token punctuation">,</span> <span class="token string">"currentTimeMillis"</span><span class="token punctuation">,</span> <span class="token string">"()J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mv<span class="token punctuation">.</span><span class="token function">visitVarInsn</span><span class="token punctuation">(</span><span class="token constant">LLOAD</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>            mv<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token constant">LSUB</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mv<span class="token punctuation">.</span><span class="token function">visitFieldInsn</span><span class="token punctuation">(</span><span class="token constant">GETSTATIC</span><span class="token punctuation">,</span> owner<span class="token punctuation">,</span> <span class="token string">"timer"</span><span class="token punctuation">,</span> <span class="token string">"J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mv<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token constant">LADD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mv<span class="token punctuation">.</span><span class="token function">visitFieldInsn</span><span class="token punctuation">(</span><span class="token constant">PUTSTATIC</span><span class="token punctuation">,</span> owner<span class="token punctuation">,</span> <span class="token string">"timer"</span><span class="token punctuation">,</span> <span class="token string">"J"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            maxStack <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>aa<span class="token punctuation">.</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">,</span> maxStack<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        mv<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span>opcode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitMaxs</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxStack<span class="token punctuation">,</span> <span class="token keyword">int</span> maxLocals<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    mv<span class="token punctuation">.</span><span class="token function">visitMaxs</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>maxStack<span class="token punctuation">,</span> maxStack<span class="token punctuation">)</span><span class="token punctuation">,</span> maxLocals<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了使用此适配器，您必须将LocalVariablesSorter链接到AnalyzerAdapter，后者本身也链接到您的适配器：第一个适配器将对局部变量进行排序并相应地更新帧，分析器适配器将计算中间帧，并考虑到前一个适配器中完成的重新编号，您的适配器将可以访问这些重新编号的中间框架。该链可以在visitMethod中构造如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">mv <span class="token operator">=</span> cv<span class="token punctuation">.</span><span class="token function">visitMethod</span><span class="token punctuation">(</span>access<span class="token punctuation">,</span> name<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> signature<span class="token punctuation">,</span> exceptions<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isInterface <span class="token operator">&amp;&amp;</span> mv <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"&lt;init>"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">AddTimerMethodAdapter5</span> at <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AddTimerMethodAdapter5</span><span class="token punctuation">(</span>mv<span class="token punctuation">)</span><span class="token punctuation">;</span>    at<span class="token punctuation">.</span>aa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnalyzerAdapter</span><span class="token punctuation">(</span>owner<span class="token punctuation">,</span> access<span class="token punctuation">,</span> name<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> at<span class="token punctuation">)</span><span class="token punctuation">;</span>    at<span class="token punctuation">.</span>lvs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LocalVariablesSorter</span><span class="token punctuation">(</span>access<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> at<span class="token punctuation">.</span>aa<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> at<span class="token punctuation">.</span>lvs<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-4、AdviceAdapter"><a href="#3-3-4、AdviceAdapter" class="headerlink" title="3.3.4、AdviceAdapter"></a>3.3.4、AdviceAdapter</h3><h1 id="4、元数据"><a href="#4、元数据" class="headerlink" title="4、元数据"></a>4、元数据</h1><p>本章说明如何使用核心API生成和转换已编译的Java类元数据，例如注释。每个部分都以一种类型的元数据开始呈现，然后以一些说明性示例呈现相应的ASM接口，组件和工具以生成和转换这些元数据。</p><h2 id="4-1、泛型"><a href="#4-1、泛型" class="headerlink" title="4.1、泛型"></a>4.1、泛型</h2><p>诸如List之类的通用类以及使用它们的类包含有关它们声明或使用的通用类型的信息。字节码指令在运行时不使用此信息，但是可以通过反射API进行访问。编译器还使用它进行单独的编译。</p><h3 id="4-1-2、接口与组件"><a href="#4-1-2、接口与组件" class="headerlink" title="4.1.2、接口与组件"></a>4.1.2、接口与组件</h3><p>与描述符一样，出于相同的效率原因（请参阅第2.3.1节），ASM API公开存储在已编译类中的签名（签名的主要出现位置是ClassVisitor类的visit，visitField和visitMethod方法，作为可选的类，类型或方法签名参数）。希望它还在org.objectweb.asm.signature包中基于SignatureVisitor抽象类提供了一些生成和转换签名的工具。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">SignatureVisitor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token constant">EXTENDS</span> <span class="token operator">=</span> ’<span class="token operator">+</span>’<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token constant">SUPER</span> <span class="token operator">=</span> ’<span class="token operator">-</span>’<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token constant">INSTANCEOF</span> <span class="token operator">=</span> ’<span class="token operator">=</span>’<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">SignatureVisitor</span><span class="token punctuation">(</span><span class="token keyword">int</span> api<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitFormalTypeParameter</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">SignatureVisitor</span> <span class="token function">visitClassBound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">SignatureVisitor</span> <span class="token function">visitInterfaceBound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">SignatureVisitor</span> <span class="token function">visitSuperclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">SignatureVisitor</span> <span class="token function">visitInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">SignatureVisitor</span> <span class="token function">visitParameterType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">SignatureVisitor</span> <span class="token function">visitReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">SignatureVisitor</span> <span class="token function">visitExceptionType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitBaseType</span><span class="token punctuation">(</span><span class="token keyword">char</span> descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitTypeVariable</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">SignatureVisitor</span> <span class="token function">visitArrayType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitClassType</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitInnerClassType</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitTypeArgument</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">SignatureVisitor</span> <span class="token function">visitTypeArgument</span><span class="token punctuation">(</span><span class="token keyword">char</span> wildcard<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下代码的结果为“ LA.B;”：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"Ljava/util/HashMap&lt;TK;TV;>.HashIterator&lt;TK;>;"</span><span class="token punctuation">;</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> renaming <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>renaming<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"java/util/HashMap"</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>renaming<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"java/util/HashMap.HashIterator"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SignatureWriter</span> sw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SignatureWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SignatureVisitor</span> sa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RenameSignatureAdapter</span><span class="token punctuation">(</span>sw<span class="token punctuation">,</span> renaming<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SignatureReader</span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SignatureReader</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>sr<span class="token punctuation">.</span><span class="token function">acceptType</span><span class="token punctuation">(</span>sa<span class="token punctuation">)</span><span class="token punctuation">;</span>sw<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-1-3、工具"><a href="#4-1-3、工具" class="headerlink" title="4.1.3、工具"></a>4.1.3、工具</h3><p>2.3节中介绍的TraceClassVisitor和ASMifier类以内部形式打印类文件中包含的签名。它们可以通过以下方式用于查找与给定泛型类型相对应的签名：编写具有某些泛型类型的Java类，对其进行编译，然后使用这些命令行工具来找到相应的签名。</p><h2 id="4-2、注解"><a href="#4-2、注解" class="headerlink" title="4.2、注解"></a>4.2、注解</h2><p>如果类，字段，方法和方法参数的注释（例如@Deprecated或@Override）存储在已编译的类中，则其保留策略不是RetentionPolicy.SOURCE。该信息在运行时不会由字节码指令使用，但是如果保留策略为RetentionPolicy.RUNTIME，则可以通过反射API进行访问。编译器也可以使用它。</p><h3 id="4-2-1、结构"><a href="#4-2-1、结构" class="headerlink" title="4.2.1、结构"></a>4.2.1、结构</h3><p>源代码中的注释可以采用各种形式，例如@ Deprecated，@ Retention（RetentionPolicy.CLASS）或@Task（desc &#x3D;“ refactor”，id &#x3D; 1）。但是，在内部，所有注释都具有相同的形式，并由注释类型和一组名称值对指定，其中值限于：</p><ol><li>基本值，字符串或类值。</li><li>枚举值。</li><li>注释值。</li><li>以上值的数组。</li></ol><p>请注意，注释可以包含其他注释，甚至可以包含注释数组。因此，注释可能非常复杂。</p><h3 id="4-2-2、接口与组件"><a href="#4-2-2、接口与组件" class="headerlink" title="4.2.2、接口与组件"></a>4.2.2、接口与组件</h3><p>用于生成和转换注释的ASM API基于AnnotationVisitor抽象类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationVisitor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">AnnotationVisitor</span><span class="token punctuation">(</span><span class="token keyword">int</span> api<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AnnotationVisitor</span><span class="token punctuation">(</span><span class="token keyword">int</span> api<span class="token punctuation">,</span> <span class="token class-name">AnnotationVisitor</span> av<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitEnum</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">,</span> <span class="token class-name">String</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AnnotationVisitor</span> <span class="token function">visitAnnotation</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AnnotationVisitor</span> <span class="token function">visitArray</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>添加，删除和检测注释：</strong></p><p>像字段和方法一样，可以通过在visitAnnotation方法中返回null来删除注释：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RemoveAnnotationAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">ClassVisitor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> annDesc<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">RemoveAnnotationAdapter</span><span class="token punctuation">(</span><span class="token class-name">ClassVisitor</span> cv<span class="token punctuation">,</span> <span class="token class-name">String</span> annDesc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">ASM4</span><span class="token punctuation">,</span> cv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>annDesc <span class="token operator">=</span> annDesc<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">AnnotationVisitor</span> <span class="token function">visitAnnotation</span><span class="token punctuation">(</span><span class="token class-name">String</span> desc<span class="token punctuation">,</span> <span class="token keyword">boolean</span> vis<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>desc<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>annDesc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> cv<span class="token punctuation">.</span><span class="token function">visitAnnotation</span><span class="token punctuation">(</span>desc<span class="token punctuation">,</span> vis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于必须调用ClassVisitor类的方法的限制，添加类注释会更加困难。实际上，必须重写所有在visitAnnotation之后的方法，以检测何时访问了所有注释（由于使用了visitCode方法，方法注释更易于添加）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AddAnnotationAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">ClassVisitor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> annotationDesc<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> isAnnotationPresent<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AddAnnotationAdapter</span><span class="token punctuation">(</span><span class="token class-name">ClassVisitor</span> cv<span class="token punctuation">,</span> <span class="token class-name">String</span> annotationDesc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">ASM4</span><span class="token punctuation">,</span> cv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>annotationDesc <span class="token operator">=</span> annotationDesc<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">int</span> version<span class="token punctuation">,</span> <span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> signature<span class="token punctuation">,</span> <span class="token class-name">String</span> superName<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token punctuation">(</span>version <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">V1_5</span> <span class="token operator">?</span> <span class="token constant">V1_5</span> <span class="token operator">:</span> version<span class="token punctuation">;</span>        cv<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> access<span class="token punctuation">,</span> name<span class="token punctuation">,</span> signature<span class="token punctuation">,</span> superName<span class="token punctuation">,</span> interfaces<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token class-name">AnnotationVisitor</span> <span class="token function">visitAnnotation</span><span class="token punctuation">(</span><span class="token class-name">String</span> desc<span class="token punctuation">,</span> <span class="token keyword">boolean</span> visible<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visible <span class="token operator">&amp;&amp;</span> desc<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>annotationDesc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            isAnnotationPresent <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> cv<span class="token punctuation">.</span><span class="token function">visitAnnotation</span><span class="token punctuation">(</span>desc<span class="token punctuation">,</span> visible<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitInnerClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> outerName<span class="token punctuation">,</span> <span class="token class-name">String</span> innerName<span class="token punctuation">,</span> <span class="token keyword">int</span> access<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addAnnotation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cv<span class="token punctuation">.</span><span class="token function">visitInnerClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> outerName<span class="token punctuation">,</span> innerName<span class="token punctuation">,</span> access<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">FieldVisitor</span> <span class="token function">visitField</span><span class="token punctuation">(</span><span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">,</span> <span class="token class-name">String</span> signature<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addAnnotation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> cv<span class="token punctuation">.</span><span class="token function">visitField</span><span class="token punctuation">(</span>access<span class="token punctuation">,</span> name<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> signature<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">MethodVisitor</span> <span class="token function">visitMethod</span><span class="token punctuation">(</span><span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">,</span> <span class="token class-name">String</span> signature<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> exceptions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addAnnotation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> cv<span class="token punctuation">.</span><span class="token function">visitMethod</span><span class="token punctuation">(</span>access<span class="token punctuation">,</span> name<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> signature<span class="token punctuation">,</span> exceptions<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addAnnotation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cv<span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addAnnotation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isAnnotationPresent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">AnnotationVisitor</span> av <span class="token operator">=</span> cv<span class="token punctuation">.</span><span class="token function">visitAnnotation</span><span class="token punctuation">(</span>annotationDesc<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>av <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            av<span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            isAnnotationPresent <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-3、工具"><a href="#4-2-3、工具" class="headerlink" title="4.2.3、工具"></a>4.2.3、工具</h3><p>2.3节中介绍的TraceClassVisitor，CheckClassAdapter和ASMifier类也支持注释（与方法一样，也可以使用TraceAnnotationVisitor或CheckAnnotationAdapter在单个注释级别而不是在类级别使用）。它们可以用来查看如何生成一些特定的注释。例如使用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> <span class="token parameter variable">-classpath</span> asm.jar:asm-util.jar <span class="token punctuation">\</span>org.objectweb.asm.util.ASMifier <span class="token punctuation">\</span>java.lang.Deprecated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>打印经过少量重构后的代码，其内容为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">asm<span class="token punctuation">.</span>java<span class="token punctuation">.</span>lang</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>objectweb<span class="token punctuation">.</span>asm<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeprecatedDump</span> <span class="token keyword">implements</span> <span class="token class-name">Opcodes</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">dump</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ClassWriter</span> cw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassWriter</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">AnnotationVisitor</span> av<span class="token punctuation">;</span>        cw<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token constant">V1_5</span><span class="token punctuation">,</span> <span class="token constant">ACC_PUBLIC</span> <span class="token operator">+</span> <span class="token constant">ACC_ANNOTATION</span> <span class="token operator">+</span> <span class="token constant">ACC_ABSTRACT</span> <span class="token operator">+</span> <span class="token constant">ACC_INTERFACE</span><span class="token punctuation">,</span> <span class="token string">"java/lang/Deprecated"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"java/lang/Object"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token string">"java/lang/annotation/Annotation"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#123;</span>            av <span class="token operator">=</span> cw<span class="token punctuation">.</span><span class="token function">visitAnnotation</span><span class="token punctuation">(</span><span class="token string">"Ljava/lang/annotation/Documented;"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            av<span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#123;</span>            av <span class="token operator">=</span> cw<span class="token punctuation">.</span><span class="token function">visitAnnotation</span><span class="token punctuation">(</span><span class="token string">"Ljava/lang/annotation/Retention;"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            av<span class="token punctuation">.</span><span class="token function">visitEnum</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">,</span> <span class="token string">"Ljava/lang/annotation/RetentionPolicy;"</span><span class="token punctuation">,</span>            <span class="token string">"RUNTIME"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            av<span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cw<span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> cw<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3、Debug"><a href="#4-3、Debug" class="headerlink" title="4.3、Debug"></a>4.3、Debug</h2><p>用javac -g编译的类包含其源文件的名称，源行号和字节码指令之间的映射以及源代码中的本地变量名称和字节码中的本地变量槽之间的映射。此可选信息在调试器中使用，并且在可用时在异常堆栈跟踪中使用。</p><h3 id="4-3-2、接口与组件"><a href="#4-3-2、接口与组件" class="headerlink" title="4.3.2、接口与组件"></a>4.3.2、接口与组件</h3><p>使用ClassVisitor和MethodVisitor类的三种方法访问调试信息：</p><ul><li>使用ClassVisitor类的visitSource方法访问源文件名；</li><li>使用MethodVisitor类的visitLineNumber方法访问源行号和字节码指令之间的映射，一次一对。</li><li>使用MethodVisitor类的visitLocalVariable方法访问源代码中的局部变量名称和字节码中的局部变量槽之间的映射，一次访问一个元组。</li></ul><p>在访问作为参数传递的标签之后，必须调用visitLineNumber方法。实际上，在该标签之后调用它，这使得在方法访问者中很容易知道当前指令的源代码行：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">MethodVisitor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> currentLine<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">MyAdapter</span><span class="token punctuation">(</span><span class="token class-name">MethodVisitor</span> mv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">ASM4</span><span class="token punctuation">,</span> mv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitLineNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> line<span class="token punctuation">,</span> <span class="token class-name">Label</span> start<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        mv<span class="token punctuation">.</span><span class="token function">visitLineNumber</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>        currentLine <span class="token operator">=</span> line<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样，在访问作为参数传递的标签之后，必须调用visitLocalVariable方法。这是与上一节中介绍的对和元组相对应的示例方法调用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">visitLineNumber</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> l1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">visitLineNumber</span><span class="token punctuation">(</span>n2<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">visitLineNumber</span><span class="token punctuation">(</span>n3<span class="token punctuation">,</span> l3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">visitLocalVariable</span><span class="token punctuation">(</span><span class="token string">"i"</span><span class="token punctuation">,</span> <span class="token string">"I"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> l1<span class="token punctuation">,</span> l2<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">visitLocalVariable</span><span class="token punctuation">(</span><span class="token string">"j"</span><span class="token punctuation">,</span> <span class="token string">"I"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> l2<span class="token punctuation">,</span> l3<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">visitLocalVariable</span><span class="token punctuation">(</span><span class="token string">"i"</span><span class="token punctuation">,</span> <span class="token string">"I"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> l3<span class="token punctuation">,</span> end<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>忽略调试信息</strong></p><p>注意：ClassReader类提供其他选项，例如SKIP_CODE跳过对已编译代码的访问（如果您只需要类结构，这将很有用），SKIP_FRAMES跳过堆栈映射框架，以及EXPAND_FRAMES取消压缩这些框架。</p><h3 id="4-3-3、工具"><a href="#4-3-3、工具" class="headerlink" title="4.3.3、工具"></a>4.3.3、工具</h3><p>与通用类型和注释一样，您可以使用TraceClassVisitor，CheckClassAdapter和ASMifier类来查找如何使用调试信息。</p><h1 id="5、向后兼容（Backward-compatibility）"><a href="#5、向后兼容（Backward-compatibility）" class="headerlink" title="5、向后兼容（Backward compatibility）"></a>5、向后兼容（Backward compatibility）</h1><h2 id="5-1、简介"><a href="#5-1、简介" class="headerlink" title="5.1、简介"></a>5.1、简介</h2><p>ASM 4.0中引入的向后兼容机制，需要将ClassVisitor，FieldVisitor，MethodVisitor等从接口更改为抽象类，并使用构造函数以ASM版本作为参数。如果您的代码是针对ASM 3.x实施的，则可以通过在代码分析器和适配器中将扩展替换为工具，并在其构造函数中指定ASM版本，将其升级到ASM 4.0。此外，ClassAdapter和MethodAdapter已合并为ClassVisitor和MethodVisitor。要转换代码，只需要将ClassAdapter替换为ClassVisitor，并将MethodAdapter替换为MethodVisitor。另外，如果定义了自定义FieldAdapter或AnnotationAdapter类，则现在可以将它们替换为FieldVisitor和AnnotationVisitor。</p><h3 id="5-1-1、Backward-compatibility-contract"><a href="#5-1-1、Backward-compatibility-contract" class="headerlink" title="5.1.1、Backward compatibility contract"></a>5.1.1、Backward compatibility contract</h3><p>实际上，对于类生成器，分析器和适配器，影响是不同的：</p><ul><li>类生成器不受影响：它们生成具有某些固定类版本的代码，并且这些生成的类将在将来的JVM版本中保持有效，因为JVM确保了向后二进制兼容性。</li><li>•类分析器可能会受到影响，也可能不会受到影响。例如，尽管引入了注释，但是分析针对Java 4编写的字节码指令的代码可能仍将适用于Java 5类。但是，这些相同的代码可能不再适用于Java 7类，因为它不能忽略新的invokedynamic指令。</li><li>类适配器可能会受到影响，也可能不会受到影响。无效代码删除工具不受注释的引入甚至新的invokedynamic指令的影响。另一方面，类重命名工具受这两者的影响。类适配器可能会受到影响，也可能不会受到影响。无效代码删除工具不受注释的引入甚至新的invokedynamic指令的影响。另一方面，类重命名工具受这两者的影响。</li></ul><p>所有这些导致了以下向后兼容协议的定义：</p><ul><li>ASM版本X是为版本小于或等于x的Java类编写的。它不能生成版本y&gt; x的类，并且在ClassReader.accept中输入大于x的类作为输入时必须失败。</li><li>为ASM X编写的代码并遵循下面介绍的准则，必须继续使用未经修改的输入类，并且输入类的版本必须为x，且ASM的将来版本为Y&gt; X。</li><li>为ASM X编写并遵循下面介绍的准则的代码必须继续使用未经声明的输入类，它们的声明版本为y，但仅使用具有ASM Y或更高版本的旧版本或等于x的版本中定义的功能。</li><li>如果将使用ASM X或任何其他将来版本的，使用类版本y&gt; x中引入的功能的输入作为输入，则为ASM X编写并遵循下面介绍的准则的代码必须失败。</li></ul><p>请注意，最后三点与类别生成器无关，后者没有类别输入。</p><h3 id="5-1-2、例子"><a href="#5-1-2、例子" class="headerlink" title="5.1.2、例子"></a>5.1.2、例子</h3><p>为了说明用户指南和确保向后兼容性的内部ASM机制，我们在本章中假设将向Java 8类添加两个新的虚构属性，一个用于存储类作者，另一个用于存储其许可证。 。我们还假设这些新属性将通过ASM 5.0中的ClassVisitor中的两个新方法公开：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">visitLicense</span><span class="token punctuation">(</span><span class="token class-name">String</span> license<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来访问许可证，并使用新版本的visitSource来与源文件名和调试信息1一起访问作者：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">visitSource</span><span class="token punctuation">(</span><span class="token class-name">String</span> author<span class="token punctuation">,</span> <span class="token class-name">String</span> source<span class="token punctuation">,</span> <span class="token class-name">String</span> debug<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>旧的visitSource方法仍然有效，但是在ASM 5.0中声明为已弃用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Deprecated</span> <span class="token keyword">void</span> <span class="token function">visitSource</span><span class="token punctuation">(</span><span class="token class-name">String</span> source<span class="token punctuation">,</span> <span class="token class-name">String</span> debug<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>author和license属性是可选的，即，调用visitLicense不是必需的，在visitSource调用中author可以为null。</p><h2 id="5-2、指导"><a href="#5-2、指导" class="headerlink" title="5.2、指导"></a>5.2、指导</h2><h3 id="5-2-1、基本规则"><a href="#5-2-1、基本规则" class="headerlink" title="5.2.1、基本规则"></a>5.2.1、基本规则</h3><p>准则1：为ASM版本X编写ClassVisitor子类，以该确切版本作为参数调用ClassVisitor构造函数，并且永远不要覆盖或调用在此版本的ClassVisitor类中不推荐使用的方法（或在更高版本中引入的方法）。</p><h3 id="5-2-2、继承规则"><a href="#5-2-2、继承规则" class="headerlink" title="5.2.2、继承规则"></a>5.2.2、继承规则</h3><p>准则2：不要使用访问者的继承，而应使用委派（即访问者链）。一种好的做法是，默认情况下将您的访问者班级定为最终班，以确保做到这一点。</p><p>实际上，该规则有两个例外：</p><ol><li>如果您自己完全控制继承链，并同时释放层次结构的所有类，则可以使用访问者的继承。然后，您必须确保为同一ASM版本编写层次结构中的所有类。尽管如此，将层次结构的叶类定为最终类。</li><li>如果除叶子类之外没有其他类重写任何访问方法，则可以使用“访问者”的继承（例如，如果您在ClassVisitor和具体访问者类之间使用中间类只是为了引入便捷方法）。仍然，使层次结构的叶类成为最终类（除非它们也不覆盖任何访问方法；在这种情况下，请提供一个构造器，以ASM版本作为参数，以便子类可以指定为其编写的版本）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> ASM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据与算法系列-数据结构与算法</title>
      <link href="/2023/07/30/shu-ju-jie-gou-yu-suan-fa-zhi-shi-dian-zong-jie/"/>
      <url>/2023/07/30/shu-ju-jie-gou-yu-suan-fa-zhi-shi-dian-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="1、算法"><a href="#1、算法" class="headerlink" title="1、算法"></a>1、算法</h1><p>算法 指 同一问题的不同解决方法。算法 通常针对 特定数据结构。</p><h2 id="1-1、排序算法"><a href="#1-1、排序算法" class="headerlink" title="1.1、排序算法"></a>1.1、排序算法</h2><h3 id="1-1-1、内部排序（使用内存）"><a href="#1-1-1、内部排序（使用内存）" class="headerlink" title="1.1.1、内部排序（使用内存）"></a>1.1.1、内部排序（使用内存）</h3><h4 id="1-1-1-1、插入排序"><a href="#1-1-1-1、插入排序" class="headerlink" title="1.1.1.1、插入排序"></a>1.1.1.1、插入排序</h4><ol><li><p><font color='orange'>直接插入排序</font></p><p>将n个待排序元素看成一个有序表和一个无序表，第一次排序时，有序表中只有一个元素，无序表中有n-1个元素，接下来每次从无序表中拿出第一个元素，将它放入有序表的适当位置，使之依然序表。然后继续，直到排序完毕；</p></li><li><p><font color='orange'>折半插入排序</font></p><p>折半插入排序（binary insertion sort）是对直接插入排序算法的一种改进。与直接插入排序的区别是：在有序表中寻找待排序数据的正确位置时，使用了折半查找&#x2F;二分查找。</p></li><li><p><font color='orange'>希尔排序</font></p><p>希尔排序是将记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p></li></ol><h4 id="1-1-1-2、选择排序"><a href="#1-1-1-2、选择排序" class="headerlink" title="1.1.1.2、选择排序"></a>1.1.1.2、选择排序</h4><ol><li><p><font color='orange'>简单选择排序</font></p><p>每一轮只找最小值且放在最前面，下一轮在剩下的元素中再次寻找最小值并放于上一次找到的最小值右边，以此类推，直到全部比较完毕。</p></li><li><p><font color='orange'>堆排序</font></p><p>堆排序是一种选择排序，最坏，最好的平均时间复杂度均为O(nlogn)，它是不稳定排序。</p><p>堆是一个完全二叉树，有如下特点：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><p>推排序逻辑如下：</p><ol><li>将无序序列构建成一个堆，根据 升序&#x2F;降序 需求 选择 小顶堆或大顶堆；</li><li>将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端；</li><li>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序；</li></ol><p>堆排序时间复杂度：</p><ul><li>平均时间复杂度：O(nlogn)</li><li>最好情况：O(nlogn)</li><li>最坏情况：O(nlogn)</li><li>空间复杂度：O(1)</li><li>稳定性：不稳定</li></ul></li></ol><h4 id="1-1-1-3、交换排序"><a href="#1-1-1-3、交换排序" class="headerlink" title="1.1.1.3、交换排序"></a>1.1.1.3、交换排序</h4><ol><li><p><font color='orange'>冒泡排序</font></p><p>其逻辑是 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p></li><li><p><font color='orange'>快速排序</font></p><p>快速排序是一种 排序执行效率很高的 排序算法，它利用 分治法 来对 待排序序列 进行分治排序。</p><p>它的思想是：以最后一位数字为关键字，拿待排序数组中的每个元素对比关键字进行一趟排序将待排记录分隔成独立的两部分，其中的一部分比关键字小，后面一部分比关键字大，然后再对这前后的两部分分别采用这种方式进行排序，通过递归的运算最终达到整个序列有序。</p><blockquote><p>快排之所以被称为“快”排，是因为它的平均时间是最短的，主要原因是硬件方面的，每趟快排需要指定一个“支点”（也就是作为分界点的值），一趟中涉及的所有比较都是与这个“支点”来进行比较的，那么我们可以把这个“支点”放在寄存器里，如此这般，效率自然大大提高。除此之外，快排的高效率与分治思想也是分不开的。</p></blockquote></li></ol><h4 id="1-1-1-4、归并排序"><a href="#1-1-1-4、归并排序" class="headerlink" title="1.1.1.4、归并排序"></a>1.1.1.4、归并排序</h4><p>归并排序 基于 分治法，其思想是将待排序的元素序列分成两个相等的子序列，然后再对子序列再次分割两个子序列，一直分割到一个序列只有一个元素为止。然后比较相邻两个子序列中数据大小，将小的放左边，大的放右边，并将之合并为一个序列，以此类推，直到合并完成为止。</p><img src="\imgs\javadev\image-20200921145201640.png" alt="image-20200921145201640" style="zoom:50%;" /><h4 id="1-1-1-5、基数排序"><a href="#1-1-1-5、基数排序" class="headerlink" title="1.1.1.5、基数排序"></a>1.1.1.5、基数排序</h4><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，从而达到排序的作用，基数排序法是属于稳定性的排序。</p><h3 id="1-1-2、外部排序"><a href="#1-1-2、外部排序" class="headerlink" title="1.1.2、外部排序"></a>1.1.2、外部排序</h3><h2 id="1-2、查找算法"><a href="#1-2、查找算法" class="headerlink" title="1.2、查找算法"></a>1.2、查找算法</h2><p>Java中常用的查找算法有四种。</p><h3 id="1-2-1、顺序（线性）查找"><a href="#1-2-1、顺序（线性）查找" class="headerlink" title="1.2.1、顺序（线性）查找"></a>1.2.1、顺序（线性）查找</h3><h3 id="1-2-2、二分查找"><a href="#1-2-2、二分查找" class="headerlink" title="1.2.2、二分查找"></a>1.2.2、二分查找</h3><p>每次拿到 待查找元素数组 中间元素值 且将数组分成两半（左半和右半），然后拿查找值与中间元素值比较，大了就以右半数组为基础做相同操作，小了就以左半数组为基础做相同操作，以此类推，直到找到为止。</p><h3 id="1-2-3、插值查找"><a href="#1-2-3、插值查找" class="headerlink" title="1.2.3、插值查找"></a>1.2.3、插值查找</h3><p>二分查找的升级版，升级地方为求中间元素值的公式。</p><ul><li><p>二分查找 获取中间元素值的公式为：int mid &#x3D; (left + right) &#x2F; 2;</p></li><li><p>插值查找 获取中间元素值的公式为：int mid &#x3D; left + (right - left)*(findVal - arr[left]) &#x2F; (arr[right] - arr[left]);</p></li></ul><h3 id="1-2-4、斐波那契查找（黄金分割点查找）"><a href="#1-2-4、斐波那契查找（黄金分割点查找）" class="headerlink" title="1.2.4、斐波那契查找（黄金分割点查找）"></a>1.2.4、斐波那契查找（黄金分割点查找）</h3><p>其原理与前两种类似，仅仅改变了中间元素（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即：mid &#x3D; low + F(k - 1) - 1; F代表斐波那契数列。</p><blockquote><p>斐波那契数列：{1,1,2,3,5,8,13,21,34,55}，发现数列的两个相邻数的比例无限接近0.618。</p></blockquote><h2 id="1-3、常用算法"><a href="#1-3、常用算法" class="headerlink" title="1.3、常用算法"></a>1.3、常用算法</h2><h3 id="1-3-1、二分查找算法（非递归，关键字匹配）"><a href="#1-3-1、二分查找算法（非递归，关键字匹配）" class="headerlink" title="1.3.1、二分查找算法（非递归，关键字匹配）"></a>1.3.1、二分查找算法（非递归，关键字匹配）</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>二分查找也称 折半查找（Binary Search），它是一种效率较高的查找方法。折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。该算法时间复杂度可以表示O(h)&#x3D;O(log2n)。</p><p>首先，假设表中元素是按升序排列，将表中间位置记录的<a href="https://baike.baidu.com/item/%E5%85%B3%E9%94%AE%E5%AD%97">关键字</a>与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的<a href="https://baike.baidu.com/item/%E8%AE%B0%E5%BD%95/1837758">记录</a>，使查找成功，或直到子表不存在为止，此时查找不成功。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> srcArray<span class="token punctuation">,</span> <span class="token keyword">int</span> des<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//定义初始最小、最大索引</span>    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> end <span class="token operator">=</span> srcArray<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//确保不会出现重复查找，越界</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//计算出中间索引值</span>        <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span>end <span class="token operator">+</span> start<span class="token punctuation">)</span><span class="token operator">>>></span><span class="token number">1</span> <span class="token punctuation">;</span><span class="token comment">//防止溢出</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>des <span class="token operator">==</span> srcArray<span class="token punctuation">[</span>middle<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> middle<span class="token punctuation">;</span>        <span class="token comment">//判断下限</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>des <span class="token operator">&lt;</span> srcArray<span class="token punctuation">[</span>middle<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            end <span class="token operator">=</span> middle <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">//判断上限</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            start <span class="token operator">=</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//若没有，则返回-1</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-2、分治算法"><a href="#1-3-2、分治算法" class="headerlink" title="1.3.2、分治算法"></a>1.3.2、分治算法</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解就可得到原问题的解。即一种分割目标完成计算的算法，简单问题可用二分法完成。</p><h4 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h4><p>分治法解题的一般步骤：</p><ol><li>分解，将要解决的问题划分成若干规模较小的同类问题；</li><li>求解，当子问题划分得足够小时，用较简单的方法解决；</li><li>合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。</li></ol><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>运用分治策略解决的问题一般来说具有以下特点：</p><ol><li><p>原问题可以分解为多个子问题：</p><p>这些子问题与原问题相比，只是问题的规模有所降低，其结构和求解方法与原问题相同或相似。</p></li><li><p>原问题在分解过程中，递归地求解子问题：</p><p>由于递归都必须有一个终止条件，因此，当分解后的子问题规模足够小时，应能够直接求解。</p></li><li><p>在求解并得到各个子问题的解后：</p><p>应能够采用某种方式、方法合并或构造出原问题的解。</p></li></ol><p>不难发现，在分治策略中，由于子问题与原问题在结构和解法上的相似性，用分治方法解决的问题，大都采用了递归的形式。在各种排序方法中，如归并排序、堆排序、快速排序等，都存在有分治的思想。</p><h3 id="1-3-3、动态规划算法（求最优决策）"><a href="#1-3-3、动态规划算法（求最优决策）" class="headerlink" title="1.3.3、动态规划算法（求最优决策）"></a>1.3.3、动态规划算法（求最优决策）</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>动态规划（Dynamic Programming，DP）是<a href="https://baike.baidu.com/item/%E8%BF%90%E7%AD%B9%E5%AD%A6/1559">运筹学</a>的一个分支，是求解<a href="https://baike.baidu.com/item/%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B/6714639">决策过程</a>最优化的过程。20世纪50年代初，美国数学家<a href="https://baike.baidu.com/item/%E8%B4%9D%E5%B0%94%E6%9B%BC/9239579">贝尔曼</a>（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的 最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等中取得了显著的效果。</p><p><font color='orange'>动态规划算法通常用于求解具有某种最优性质的问题。</font>动态规划算法与<a href="https://baike.baidu.com/item/%E5%88%86%E6%B2%BB%E6%B3%95">分治法</a>类似，基本思想是 将待求解问题分解成若干个子问题，先求解子问题，然后根据 子问题的解 得到 原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。</p><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>动态规划对于解决多阶段决策问题的效果很明显，但是动态规划也有一定的局限性。首先，它没有统一的处理方法，必须根据问题的各种性质并结合一定的技巧来处理；另外当变量的维数增大时，总的计算量及存贮量急剧增大。因而，受计算机的存贮量及计算速度的限制，当今的计算机仍不能用动态规划方法来解决较大规模的问题，这就是“维数障碍”。</p><h3 id="1-3-4、暴力匹配算法（字符串匹配）"><a href="#1-3-4、暴力匹配算法（字符串匹配）" class="headerlink" title="1.3.4、暴力匹配算法（字符串匹配）"></a>1.3.4、暴力匹配算法（字符串匹配）</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>暴力匹配的思想：假设下标<code>i</code>指向字符串<code>str1</code>，下标<code>j</code>指向字符串<code>str2</code>，则有如下规律：</p><ol><li>如果str1[i] &#x3D; str2[j]，则i++，j++。</li><li>如果str1[i] !&#x3D; str2[j]，则令i &#x3D; i - (j - 1)，j &#x3D; 0。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p><strong>暴力破解会有大量的回溯</strong>，每次只移动一位，若不匹配，则移动到下一位接着判断，浪费了大量时间。</p><p>为了优化之，就诞生了KMP算法。</p><h3 id="1-3-5、KMP算法（字符串匹配）"><a href="#1-3-5、KMP算法（字符串匹配）" class="headerlink" title="1.3.5、KMP算法（字符串匹配）"></a>1.3.5、KMP算法（字符串匹配）</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p><strong>KMP算法是一种改进的字符串匹配算法</strong>，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的 时间复杂度为 <code>O(m+n) [1]</code> 。</p><h4 id="模式匹配类型"><a href="#模式匹配类型" class="headerlink" title="模式匹配类型"></a>模式匹配类型</h4><ol><li>精确匹配</li><li>近似匹配</li></ol><h4 id="部分匹配表"><a href="#部分匹配表" class="headerlink" title="部分匹配表"></a>部分匹配表</h4><img src="C:\Users\shihao\AppData\Roaming\Typora\typora-user-images\image-20200919141327620.png" alt="image-20200919141327620" style="zoom:100%;float:left;" /><p>由表可得：移动位数 &#x3D; 已匹配的字符数 + 对应的部分匹配值。</p><h3 id="1-3-6、贪心算法（局部最优解）"><a href="#1-3-6、贪心算法（局部最优解）" class="headerlink" title="1.3.6、贪心算法（局部最优解）"></a>1.3.6、贪心算法（局部最优解）</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><p><strong>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解</strong>。</p><p>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择。也就是说，不从整体最优上加以考虑，做出的只是在某种意义上的局部最优解。</p><h3 id="1-3-7、普利姆算法（Prim，稠密图最小生成树）"><a href="#1-3-7、普利姆算法（Prim，稠密图最小生成树）" class="headerlink" title="1.3.7、普利姆算法（Prim，稠密图最小生成树）"></a>1.3.7、普利姆算法（Prim，稠密图最小生成树）</h3><h4 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h4><p>普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图。</p><p>例如，通过普里姆算法查找下图的最小生成树的步骤为：</p><ol><li><p>假如从顶点A出发，顶点 B、C、D 到顶点 A 的权值分别为 2、4、2，所以，对于顶点 A 来说，顶点 B 和顶点 D 到 A 的权值最小，假设先找到的顶点 B：</p><p><img src="C:\Users\shihao\AppData\Roaming\Typora\typora-user-images\image-20200920084320304.png" alt="image-20200920084320304"></p></li><li><p>继续分析顶点 C 和 D，顶点 C 到 B 的权值为 3，到 A 的权值为 4；顶点 D 到 A 的权值为 2，到 B 的权值为无穷大（如果之间没有直接通路，设定权值为无穷大）。所以顶点 D 到 A 的权值最小：</p><p><img src="C:\Users\shihao\AppData\Roaming\Typora\typora-user-images\image-20200920084352501.png" alt="image-20200920084352501"></p></li><li><p>最后，只剩下顶点 C，到 A 的权值为 4，到 B 的权值和到 D 的权值一样大，为 3。所以该连通图有两个最小生成树：</p><p><img src="C:\Users\shihao\AppData\Roaming\Typora\typora-user-images\image-20200920084435924.png" alt="image-20200920084435924"></p></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>普利姆算法求最小生成树，是从顶点方面考虑，存在两重遍历(已访问顶点集和未访问顶点集)，对应的还有一个克鲁斯卡尔算法求最小生成树，是从边的角度出发考虑的。根据各自算法特性，可以粗略的判断出，把稠密图看作边集相对于点集数量级比较大，稀疏图看作点集相对于边集较大，则普利姆算法适合于计算稠密图，克鲁斯卡尔算法适合于计算稀疏图。</p><h3 id="1-3-8、克鲁斯卡尔算法（Kruskal，稀疏图最小生成树）"><a href="#1-3-8、克鲁斯卡尔算法（Kruskal，稀疏图最小生成树）" class="headerlink" title="1.3.8、克鲁斯卡尔算法（Kruskal，稀疏图最小生成树）"></a>1.3.8、克鲁斯卡尔算法（Kruskal，稀疏图最小生成树）</h3><h4 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h4><p>克鲁斯卡尔算法是求连通网的最小生成树的另一种方法。与普里姆算法不同，它的时间复杂度为O（e loge）（e为网中的边数），所以，适合于求边稀疏的网的最小生成树 [1] 。</p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>克鲁斯卡尔（Kruskal）算法从另一途径求网的最小生成树。其基本思想是：假设连通网G&#x3D;（V，E），令最小生成树的初始状态为只有n个顶点而无边的非连通图T&#x3D;（V，{}），图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点分别在T中不同的连通分量上，则将此边加入到T中；否则，舍去此边而选择下一条代价最小的边。依此类推，直至T中所有顶点构成一个连通分量为止 [2] 。</p><h3 id="1-3-9、迪杰斯特拉算法（Dijkstra，最短路径）"><a href="#1-3-9、迪杰斯特拉算法（Dijkstra，最短路径）" class="headerlink" title="1.3.9、迪杰斯特拉算法（Dijkstra，最短路径）"></a>1.3.9、迪杰斯特拉算法（Dijkstra，最短路径）</h3><h4 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h4><p>迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家<a href="https://baike.baidu.com/item/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89/2828872">狄克斯特拉</a>于1959 年提出，因此又叫<a href="https://baike.baidu.com/item/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/6764865">狄克斯特拉算法</a>。是从一个顶点到其余各顶点的<a href="https://baike.baidu.com/item/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">最短路径</a>算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是从起始点开始，采用<a href="https://baike.baidu.com/item/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/5411800">贪心算法</a>的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。</p><p>Dijkstra算法一般的表述通常有两种方式，一种用永久和临时标号方式，一种是用OPEN、CLOSE表的方式，这里均采用永久和临时标号的方式。注意该算法要求图中不存在负权边。</p><h3 id="1-3-10、弗洛伊德算法（Floyd，最短路径）"><a href="#1-3-10、弗洛伊德算法（Floyd，最短路径）" class="headerlink" title="1.3.10、弗洛伊德算法（Floyd，最短路径）"></a>1.3.10、弗洛伊德算法（Floyd，最短路径）</h3><h4 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h4><p>Floyd算法又称为插点法，是一种利用<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408">动态规划</a>思想寻找给定<a href="https://baike.baidu.com/item/%E5%8A%A0%E6%9D%83%E5%9B%BE/10579361">加权图</a>中多源点之间<a href="https://baike.baidu.com/item/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/6334920">最短路径</a>的算法，与Dijkstra算法类似。该算法名称以创始人之一、1978年<a href="https://baike.baidu.com/item/%E5%9B%BE%E7%81%B5%E5%A5%96/324645">图灵奖</a>获得者、斯坦福大学计算机科学系教授<a href="https://baike.baidu.com/item/%E7%BD%97%E4%BC%AF%E7%89%B9%C2%B7%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7/4903135">罗伯特·弗洛伊德</a>命名。</p><p>该算法也称为Floyd算法，Roy-Warshall算法，Roy-Floyd算法或WFI算法。</p><h4 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h4><ol><li>从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。</li><li>对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比已知的路径更短。如果是更新它。</li></ol><h4 id="时间-空间复杂度"><a href="#时间-空间复杂度" class="headerlink" title="时间&#x2F;空间复杂度"></a>时间&#x2F;空间复杂度</h4><ul><li>时间复杂度：O(n^3)；</li><li>空间复杂度：O(n^2)；</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>Floyd算法适用于APSP(All Pairs Shortest Paths，多源最短路径)，是一种动态规划算法，稠密图效果最佳，边权可正可负。此算法简单有效，由于三重循环结构紧凑，对于稠密图，效率要高于执行|V|次<a href="https://baike.baidu.com/item/Dijkstra%E7%AE%97%E6%B3%95">Dijkstra算法</a>，也要高于执行|V|次<a href="https://baike.baidu.com/item/SPFA%E7%AE%97%E6%B3%95">SPFA算法</a>。</p><ul><li>优点：容易理解，可以算出任意两个节点之间的最短距离，代码编写简单。</li><li>缺点：时间复杂度比较高，不适合计算大量数据。</li></ul><h3 id="1-3-11、骑士周游回溯算法"><a href="#1-3-11、骑士周游回溯算法" class="headerlink" title="1.3.11、骑士周游回溯算法"></a>1.3.11、骑士周游回溯算法</h3><h4 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h4><p>深度优先遍历+回溯+贪心。从初始位置startPoint开始，获取下一步能到达的所有位置，将它们添加到集合ArrayList&lt; Point &gt;中，根据它们下一步所能到达的位置的个数k对ArrayList&lt; Point &gt;中所有位置进行非递减排序，优先对k较小的位置进行遍历，若此路不通，则回溯。</p><h2 id="1-4、算法复杂度"><a href="#1-4、算法复杂度" class="headerlink" title="1.4、算法复杂度"></a>1.4、算法复杂度</h2><h3 id="1-4-1、时间复杂度"><a href="#1-4-1、时间复杂度" class="headerlink" title="1.4.1、时间复杂度"></a>1.4.1、时间复杂度</h3><p>度量一个程序执行时间的方法有两种：</p><ol><li>事前估算法</li><li>事后统计法</li></ol><h4 id="时间频度"><a href="#时间频度" class="headerlink" title="时间频度"></a>时间频度</h4><p>一个算法中语句执行次数称为 语句频度 或 时间频度，记为T(n)。</p><h4 id="时间复杂度表示"><a href="#时间复杂度表示" class="headerlink" title="时间复杂度表示"></a>时间复杂度表示</h4><ol><li>常数阶O(1)</li><li>对数阶O(log n)</li><li>线性阶O(n)</li><li>线性对数阶O(n*log n)</li><li>平方阶O(n^2)</li><li>立方阶O(n^3)</li><li>k次方阶O(n^k)</li><li>指数阶O(2^n)</li></ol><p><img src="C:\Users\shihao\Desktop\图片\工作\算法数据结构\算法时间复杂度01.jpg" alt="算法时间复杂度01"></p><h3 id="1-4-2、空间复杂度"><a href="#1-4-2、空间复杂度" class="headerlink" title="1.4.2、空间复杂度"></a>1.4.2、空间复杂度</h3><h4 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h4><p>类似于时间复杂度，一个算法的空间复杂度 定义为 该算法所消耗的存储空间。</p><h4 id="Big-O"><a href="#Big-O" class="headerlink" title="Big O"></a>Big O</h4><ul><li>时间问题（数据）规模<ol><li>不考虑 必要操作。</li><li>不考虑 常数项。</li><li>不考虑 低次项。</li></ol></li><li>O(1) 和 O(n)的使用<ol><li>O(1)：称为常数时间。随着规模扩大，时间消耗没有变化或者变化不大，则用(O1)来表示。</li><li>O(n)：称为线性时间。随着规模扩大，时间也相应的扩大，则用O(n)来表示。</li></ol></li></ul><h3 id="1-4-3、总结"><a href="#1-4-3、总结" class="headerlink" title="1.4.3、总结"></a>1.4.3、总结</h3><h4 id="排序算法-时间-空间复杂度-对比"><a href="#排序算法-时间-空间复杂度-对比" class="headerlink" title="排序算法 时间&#x2F;空间复杂度 对比"></a>排序算法 时间&#x2F;空间复杂度 对比</h4><p><img src="C:\Users\shihao\Desktop\图片\工作\算法数据结构\排序算法时间空间复杂度01.jpg" alt="排序算法时间空间复杂度01"></p><h1 id="2、数据结构"><a href="#2、数据结构" class="headerlink" title="2、数据结构"></a>2、数据结构</h1><h2 id="2-1、简介"><a href="#2-1、简介" class="headerlink" title="2.1、简介"></a>2.1、简介</h2><p>其英文称为：Data Structure，其表示存储数据的不同方式。 </p><h2 id="2-2、分类"><a href="#2-2、分类" class="headerlink" title="2.2、分类"></a>2.2、分类</h2><p>数据结构分为 <strong>线性结构 和 非线性结构</strong> 两大类。</p><h3 id="2-2-1、线性结构"><a href="#2-2-1、线性结构" class="headerlink" title="2.2.1、线性结构"></a>2.2.1、线性结构</h3><p>线性结构是常用的数据结构，其特点是数据元素之间存在一对一的线性关系。</p><p>线性结构有两种存储结构：</p><ol><li><p><font color='orange'>顺序存储结构</font></p><p>顺序存储的线性表称为顺序表，其中的元素是连续的：</p></li><li><p><font color='orange'>链式存储结构</font></p><p>链式存储的线性表称为链表，其中的元素不一定是连续的，元素节点存放数据及相邻节点的地址信息：</p></li></ol><p>线性结构常见实现有：</p><ol><li><p><font color='orange'>数组</font></p></li><li><p><font color='orange'>队列</font></p><p>队列是一个有序列表，遵循FIFO规则，可以用数组或链表来实现。</p><ul><li>队列是一种特殊操作受限的线性表，它只允许在表的前端（front，队头）执行删除操作，而在表的后端（rear，队尾）执行插入操作。</li><li>队列中没有元素时，称为空队列。</li><li>创建顺序队列结构必须为其静态分配或动态申请一片连续的存储空间，并设置两个指针进行管理。一个是队头指针front，它指向队头元素；另一个是队尾指针rear，它指向下一个入队元素的存储位置。</li><li>队列采用FIFO(first in first out——先进先出)，数据插入到链表尾部，从头部开始读取数据。每次读取一个元素，释放一个元素。所谓的动态创建，动态释放。因而也不存在溢出等问题。由于链表由结构体间接而成，遍历也方便。（先进先出）。</li></ul></li><li><p><font color='orange'>链表</font></p></li><li><p><font color='orange'>栈</font></p></li></ol><h3 id="2-2-2、非线性结构"><a href="#2-2-2、非线性结构" class="headerlink" title="2.2.2、非线性结构"></a>2.2.2、非线性结构</h3><p>非线性结构常见实现有：</p><ol><li><p><font color='orange'>二维数组</font></p></li><li><p><font color='orange'>多维数组</font></p></li><li><p><font color='orange'>广义表</font></p></li><li><p><font color='orange'>树结构</font></p><ol><li><p>二叉树</p><ol><li><p>满二叉树</p><p>所有叶子节点都在同一层的二叉树称为：满二叉树。</p></li><li><p>完全二叉树</p><p>所有叶子节点在最后一层或者倒数第二层，且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，则我们称这样的二叉树为：完全二叉树。</p></li></ol></li><li><p>AVL树</p></li></ol></li><li><p><font color='orange'>图结构</font></p></li></ol><h1 id="3、常见问题及应对"><a href="#3、常见问题及应对" class="headerlink" title="3、常见问题及应对"></a>3、常见问题及应对</h1><h2 id="3-1、修路问题"><a href="#3-1、修路问题" class="headerlink" title="3.1、修路问题"></a>3.1、修路问题</h2><p>最小生成树 + 普利姆算法</p><h2 id="3-2、最短路径问题"><a href="#3-2、最短路径问题" class="headerlink" title="3.2、最短路径问题"></a>3.2、最短路径问题</h2><p>图 + 弗洛伊德算法</p><h2 id="3-3、汉诺塔问题"><a href="#3-3、汉诺塔问题" class="headerlink" title="3.3、汉诺塔问题"></a>3.3、汉诺塔问题</h2><p>分支算法</p><h2 id="3-4、八皇后问题"><a href="#3-4、八皇后问题" class="headerlink" title="3.4、八皇后问题"></a>3.4、八皇后问题</h2><p>回溯法</p>]]></content>
      
      
      <categories>
          
          <category> 数据与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据与算法系列-树结构</title>
      <link href="/2023/07/30/shu-xing-jie-gou-zhi-shi-dian-zong-jie/"/>
      <url>/2023/07/30/shu-xing-jie-gou-zhi-shi-dian-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="1、二叉排序树"><a href="#1、二叉排序树" class="headerlink" title="1、二叉排序树"></a>1、二叉排序树</h1><h2 id="1-1、简介"><a href="#1-1、简介" class="headerlink" title="1.1、简介"></a>1.1、简介</h2><p><font color='orange'>二叉排序树 又称 二叉查找树、二叉搜索树。其是数据结构的一种。</font></p><p>通常情况下，查询效率比链表要高。</p><h2 id="1-2、定义"><a href="#1-2、定义" class="headerlink" title="1.2、定义"></a>1.2、定义</h2><p>空树，或拥有如下特点的二叉树：</p><ol><li>左子树上所有结点的值 均小于 根结点的值；</li><li>右子树上所有结点的值 均大于 根结点的值；</li><li>左、右子树也分别为二叉排序树；</li><li>没有键值相等的结点。</li></ol><h2 id="1-3、插入删除"><a href="#1-3、插入删除" class="headerlink" title="1.3、插入删除"></a>1.3、插入删除</h2><p>与次优二叉树相对，二叉排序树 是一种 动态树表。特点是：<font color='orange'>树结构 通常 并非是一次生成，而是在查找过程中，当树中不存在关键字等于给定值的结点时再进行插入。新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。</font></p><h2 id="1-4、性能分析"><a href="#1-4、性能分析" class="headerlink" title="1.4、性能分析"></a>1.4、性能分析</h2><p>每个结点的C(i) 就是 该结点的层次数。最坏情况下，当插入的关键字有序时，会形成单支树，树深为平均查找长度(n+1)&#x2F;2（和顺序查找相同），最好情况就是 与折半查找相同，平均查找长度和log2(n)成正比。</p><blockquote><p><font color='orange'>最好情况下时间复杂度为O(1)，最坏情况下时间复杂度为O(n)。</font></p></blockquote><h2 id="1-5、优化"><a href="#1-5、优化" class="headerlink" title="1.5、优化"></a>1.5、优化</h2><p>使用其它数据结构代替，且其查找树的高度均为O(log(n))。</p><ol><li>Size Balanced Tree(SBT)</li><li>AVL树</li><li>红黑树</li><li>Treap</li></ol><h1 id="2、AVL树"><a href="#2、AVL树" class="headerlink" title="2、AVL树"></a>2、AVL树</h1><h2 id="2-1、简介"><a href="#2-1、简介" class="headerlink" title="2.1、简介"></a>2.1、简介</h2><p>AVL树是一种高效的自平衡二叉搜索树，它的特点在于它可以自动保持平衡。</p><blockquote><p><font color='orange'>windows对 进程地址空间 的管理用到了 AVL树。</font></p></blockquote><h2 id="2-2、特点"><a href="#2-2、特点" class="headerlink" title="2.2、特点"></a>2.2、特点</h2><p>AVL树 本质上是 二叉搜索树，其特点如下：</p><ol><li>是二叉搜索树。</li><li>带有平衡条件：<font color='orange'>每个结点的左右子树的高度差的绝对值（平衡因子）最大为1。</font></li></ol><h2 id="2-3、优缺点"><a href="#2-3、优缺点" class="headerlink" title="2.3、优缺点"></a>2.3、优缺点</h2><h3 id="2-3-1、优点（严格平衡）"><a href="#2-3-1、优点（严格平衡）" class="headerlink" title="2.3.1、优点（严格平衡）"></a>2.3.1、优点（严格平衡）</h3><p><font color='orange'>AVL树 是严格的 平衡二叉树，所有节点的左右子树高度差不能超过1；</font></p><h3 id="2-3-2、缺点（旋转耗时）"><a href="#2-3-2、缺点（旋转耗时）" class="headerlink" title="2.3.2、缺点（旋转耗时）"></a>2.3.2、缺点（旋转耗时）</h3><p>AVL的平衡 得益于 旋转操作：插入和删除 可能会破坏 二叉树的平衡，此时需要 旋转 。</p><p>插入操作 最多需要 1次旋转（单旋转或双旋转）；删除节点 需要维护从 被删节点 到 根节点 路径上所有节点的平衡，旋转复杂度为O(log n)。</p><p>因 旋转耗时，故删除数据时效率很低；删除操作较多时，维护平衡所需的代价可能高于其带来的好处，因此AVL实际使用并不广泛。</p><h1 id="3、红黑树"><a href="#3、红黑树" class="headerlink" title="3、红黑树"></a>3、红黑树</h1><h2 id="3-1、简介"><a href="#3-1、简介" class="headerlink" title="3.1、简介"></a>3.1、简介</h2><p><font color='orange'>红黑树（Red Black Tree） 是一种 自平衡 二叉查找树，是常用的一种数据结构，主要用于实现【关联数组】。 </font></p><p>红黑树 是一种 【特化版AVL树】，在插入、删除时 可通过 变换节点颜色 来保持 树平衡，进而 获得 较高性能。</p><p>红黑树虽复杂，但最坏情况下其表现也很好。可在O(log n，n是树中元素的数量)时间内 实现 查找、插入和删除。 </p><h2 id="3-2、特征"><a href="#3-2、特征" class="headerlink" title="3.2、特征"></a>3.2、特征</h2><ol><li>节点不是红色就是黑色。</li><li>根节点是黑色；所有NUll节点都是黑色；</li><li>红色节点 的两个子节点 是 黑色；红色节点不能相邻。</li><li>从根节点到任意一个叶子节点，路径中的黑色节点数量都一样。</li></ol><h2 id="3-3、使用场景"><a href="#3-3、使用场景" class="headerlink" title="3.3、使用场景"></a>3.3、使用场景</h2><p><font color='orange'>红黑树 多用于【内部排序】，即全放在内存中，STL的 map 和 set 的内部实现就是红黑树。</font></p><h2 id="3-4、应用"><a href="#3-4、应用" class="headerlink" title="3.4、应用"></a>3.4、应用</h2><ol><li><p><font color='orange'>红黑树 在 【Linux非实时任务调度中】的应用</font></p><p>Linux 的稳定内核版本在 2.6.24 之后，使用了新的调度程序 CFS，所有非实时可运行进程都以虚拟运行时间为 key 值挂在一棵红黑树上，以完成更公平高效地调度所有任务。CFS 弃用 active &#x2F;expired 数组和动态计算优先级，不再跟踪任务的睡眠时间和区别是否交互任务，并且在调度中采用基于时间计算键值的红黑树来选取下一个任务，根据所有任务占用 CPU 时间的状态来确定调度任务优先级。</p></li><li><p><font color='orange'>红黑树 在 【Linux虚拟内存中】的应用</font></p><p>32 位 Linux 内核虚拟地址空间划分 0 － 3G 为用户空间，3 － 4G 为内核空间，因此每个进程可以使用 4GB的虚拟空间。同时，Linux 定义了虚拟存储区域( VMA) 以便于更好表示进程所使用的虚拟空间，每个 VMA是某个进程的一段连续虚拟空间，其中的单元具有相同的特征，所有的虚拟区域按照地址排序由指针链接为一个链表。当发生缺页中断时搜索 VMA 到指定区域时，则需要频繁操作，因此选用了红黑树以减少查找时间。</p></li><li><p><font color='orange'>红黑树 在 【检测树平衡性】上的应用</font></p><p>红黑树是一种自平衡二叉搜索树，它的每个节点都被“着色”为红色或者黑色，这些节点的颜色被用来检测树的平衡性。红黑树作为嵌入式数据库中的索引机制，可以获得更好的性能，对于SQLite数据库，可以采用红黑树实现索引机制的优化。</p></li></ol><h2 id="3-5、数据结构"><a href="#3-5、数据结构" class="headerlink" title="3.5、数据结构"></a>3.5、数据结构</h2><p>红黑树 【统计性能】 要优于 平衡二叉树。目前，红黑树已广泛应用于Linux 进程管理、内存管理，设备驱动、虚拟内存跟踪 等场景中。</p><h2 id="3-6、优缺点"><a href="#3-6、优缺点" class="headerlink" title="3.6、优缺点"></a>3.6、优缺点</h2><h3 id="3-6-1、优点"><a href="#3-6-1、优点" class="headerlink" title="3.6.1、优点"></a>3.6.1、优点</h3><ol><li><font color='orange'>红黑树 不追求 严格平衡：只需保证 【根到叶子的最长路径长度不超过最短路径的2倍】。</font></li><li><font color='orange'>红黑树删除效率较高，因O(1)次数的 【旋转及变色】 就能保证 基本平衡，无需像AVL树一样进行 O(lgn)次的旋转。</font></li><li><font color='orange'>红黑树 适用于【内存操作】场景。其 统计性能 高于 AVL树。</font></li></ol><h3 id="3-6-2、缺点（树太高）"><a href="#3-6-2、缺点（树太高）" class="headerlink" title="3.6.2、缺点（树太高）"></a>3.6.2、缺点（树太高）</h3><ol><li><p>较AVL数来说，红黑树 【查询效率差】，因为 树平衡性较差，高度更高。</p></li><li><p>对于磁盘等辅助存储设备中数据的操作来说（如 MySQL），红黑树并不擅长，因为【 红黑树高度太高】。</p><blockquote><p>当数据在磁盘中时，磁盘IO会成为最大性能瓶颈；树高度越高，IO次数也会越多，性能影响也会越严重。</p></blockquote></li></ol><h1 id="4、B树"><a href="#4、B树" class="headerlink" title="4、B树"></a>4、B树</h1><h2 id="4-1、简介"><a href="#4-1、简介" class="headerlink" title="4.1、简介"></a>4.1、简介</h2><p>B-树 查找关键字 方法是：先拿到 根结点 ，在根结点 所包含的关键字K1,…,Kn中 查找给定关键字（可用顺序查找或二分查找法）。若找到关键字就表示查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，拿到 指针Pi 指向的结点 继续查找，直至找到，指针Pi为空时查找失败。（Pi为指向子树根节点的指针）</p><h2 id="4-2、定义"><a href="#4-2、定义" class="headerlink" title="4.2、定义"></a>4.2、定义</h2><p><font color='orange'>1970年，R.Bayer和E.mccreight提出了一种 【平衡多叉树，称为B树（或B-树、B_树）】。</font></p><p>一棵 m 阶 B树 是一棵平衡的m路搜索树。它可能是空树，也可能是如下特点的树：</p><ol><li><font color='orange'>根结点至少有两个子女；</font></li><li>每个 非根节点 所包含的关键字个数 j 满足：┌m&#x2F;2┐ - 1 &lt;&#x3D; j &lt;&#x3D; m - 1；</li><li>除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：┌m&#x2F;2┐ &lt;&#x3D; k &lt;&#x3D; m ；</li><li><font color='orange'>所有的叶子结点都位于同一层。</font></li></ol><p>B-树每个结点中的关键字从小到大排列，且当该结点的孩子是非叶子结点时，该k-1个关键字正好是k个孩子包含的关键字的值域的分划。</p><p>因为叶子结点不包含关键字，所以可以把叶子结点看成在树里实际上并不存在外部结点，指向这些外部结点的指针为空，叶子结点的数目正好等于树中所包含的关键字总个数加1。</p><p>B-树中的一个包含n个关键字，n+1个指针的结点的一般形式为：（n、P0、K1、P1、K2、P2,…,Kn、Pn）。</p><p>其中，Ki为关键字，K1&lt;K2&lt;…&lt;Kn, Pi 是指向包括Ki到Ki+1之间的关键字的子树的指针。</p><h2 id="4-3、性能分析"><a href="#4-3、性能分析" class="headerlink" title="4.3、性能分析"></a>4.3、性能分析</h2><p>设B-树包含N个关键字，因此有N+1个叶子结点，叶子都在第I层。因为根至少有两个孩子，因此第二层至少有两个结点。除根和叶子外，其它结点至少有┌m&#x2F;2┐个孩子，因此在第三层至少有2<em>┌m&#x2F;2┐个结点，在第四层至少有2</em>(┌m&#x2F;2┐^2)个结点，．．．，在第I层至少有2*(┌m&#x2F;2┐^(l-2) )个结点，于是有：</p><p>N+1 ≥ 2*┌m&#x2F;2┐I-2</p><p>考虑第L层的结点个数为N+1，那么2*(┌m&#x2F;2┐^(l-2)）≤N+1，也就是L层的最少结点数刚好达到N+1个。</p><p>即： I≤ log┌m&#x2F;2┐((N+1)&#x2F;2 )+2</p><p>所以，当B-树包含N个关键字时，B-树最大高度为l-1（因为计算B-树高度时，叶结点所在层不计算在内）。</p><p>即：log┌m&#x2F;2┐((N+1)&#x2F;2 )+1。</p><p>这个公式保证了B-树 较高 的查询率。</p><h2 id="4-4、优缺点"><a href="#4-4、优缺点" class="headerlink" title="4.4、优缺点"></a>4.4、优缺点</h2><h3 id="4-4-1、优点"><a href="#4-4-1、优点" class="headerlink" title="4.4.1、优点"></a>4.4.1、优点</h3><ol><li><font color='orange'>B树 适用于 磁盘等辅存设备，B树每个非叶节点可以有多个子树，进而【降低了树的高度】。</font></li><li><font color='orange'>B树 提供了 局部性访问。</font>换句话说，B树缓存命中率更高。（局部性原理是指：一个数据被使用时，其附近数据有较大概率在短时间内被使用。B树会将相邻数据存储在同一节点，当访问其中某个数据时会将整个节点读到缓存中；当相邻数据被访问时，可直接从缓存中读取，无需执行磁盘IO；）</li></ol><h3 id="4-4-2、缺点"><a href="#4-4-2、缺点" class="headerlink" title="4.4.2、缺点"></a>4.4.2、缺点</h3><ol><li>仅适用于 磁盘存储操作 场景。</li><li>B树 叶子和非叶子节点 都存储数据，所以树高度还是会太高。</li><li>B树 叶子节点 没有指针连接，且叶子节点中的元素是无序排列。</li><li>不适合范围查询。</li></ol><h1 id="5、B-树"><a href="#5、B-树" class="headerlink" title="5、B+树"></a>5、B+树</h1><h2 id="5-1、简介"><a href="#5-1、简介" class="headerlink" title="5.1、简介"></a>5.1、简介</h2><p><font color='orange'>B+树 通常用于 数据库和操作系统的 【文件系统】。</font></p><p>B+树 能够保持 数据稳定有序，插入、修改 拥有 稳定的 时间复杂度。B+树元素自底向上插入，这与二叉树恰好相反。</p><blockquote><p>B+ 树创造者 Rudolf Bayer 没有解释 B 代表什么。通常 B 代表平衡（balanced），因为所有叶子节点都在树的统一级别上。<em>B</em>也可能代表<em>Bayer</em>，或者是波音（Boeing），因为他曾经工作于波音科学研究实验室。</p></blockquote><p><font color='orange'>B+树 适用于 磁盘文件组织、数据索引 和 数据库索引。</font></p><h2 id="5-2、定义"><a href="#5-2、定义" class="headerlink" title="5.2、定义"></a>5.2、定义</h2><p><font color='orange'>B+树 的 叶子结点 存储关键字 和 记录地址，非叶子节点作为索引使用。</font>一棵m阶的B+树定义如下: </p><ol><li>每个结点至多有m个子女；</li><li>除根结点外，每个结点至少有[m&#x2F;2]个子女，根结点至少有两个子女； </li><li>有k个子女的结点必有k个关键字。</li></ol><p>与B树的查找操作不同，B+树在 索引关键字与待找关键字匹配时并不停止查找，而会 沿着该关键字左边指针向下，一直找到该关键字所在的叶子结点为止。 </p><h2 id="5-3、特征"><a href="#5-3、特征" class="headerlink" title="5.3、特征"></a>5.3、特征</h2><p>B+树是B树的一种变形，比B树具有更广泛的应用，m阶 B+树 有如下特征: </p><ol><li>每个结点的关键字个数与孩子个数相等，所有非最下层的内层结点的关键字是对应子树上的最大关键字，最下层内部结点包含了全部关键字。 [3] </li><li>除根结点以外，每个内部结点有<img src="https://bkimg.cdn.bcebos.com/formula/b6d57d975fb784adc5203ddf01a692ee.svg" alt="img">到m个孩子。 </li><li>所有叶结点在树结构的同一层，并且不含任何信息(可看成是外部结点或查找失败的结点)，因此，树结构总是树高平衡的。</li></ol><h2 id="5-4、算法"><a href="#5-4、算法" class="headerlink" title="5.4、算法"></a>5.4、算法</h2><h3 id="5-4-1、查找"><a href="#5-4-1、查找" class="headerlink" title="5.4.1、查找"></a>5.4.1、查找</h3><p>查找以典型的方式进行，类似于二叉查找树。起始于根节点，自顶向下遍历树，选择其分离值在要查找值的任意一边的子指针。在节点内部典型的使用是二分查找来确定这个位置。</p><h3 id="5-4-2、插入"><a href="#5-4-2、插入" class="headerlink" title="5.4.2、插入"></a>5.4.2、插入</h3><p>节点要处于违规状态，它必须包含在可接受范围之外数目的元素。</p><ol><li>首先，查找要插入其中的节点的位置。接着把值插入这个节点中。</li><li>如果没有节点处于违规状态则处理结束。</li><li>如果某个节点有过多元素，则把它分裂为两个节点，每个都有最小数目的元素。在树上递归向上继续这个处理直到到达根节点，如果根节点被分裂，则创建一个新根节点。为了使它工作，元素的最小和最大数目典型的必须选择为使最小数不小于最大数的一半。</li></ol><h3 id="5-4-3、删除"><a href="#5-4-3、删除" class="headerlink" title="5.4.3、删除"></a>5.4.3、删除</h3><ol><li><p>首先，查找要删除的值。接着从包含它的节点中删除这个值。</p></li><li><p>如果没有节点处于违规状态则处理结束。 </p></li><li><p>如果节点处于违规状态则有两种可能情况：</p><ol><li>它的兄弟节点，就是同一个父节点的子节点，可以把一个或多个它的子节点转移到当前节点，而把它返回为合法状态。如果是这样，在更改父节点和两个兄弟节点的分离值之后处理结束。</li><li>它的兄弟节点由于处在低边界上而没有额外的子节点。在这种情况下把两个兄弟节点合并到一个单一的节点中，而且我们递归到父节点上，因为它被删除了一个子节点。持续这个处理直到当前节点是合法状态或者到达根节点，在其上根节点的子节点被合并而且合并后的节点成为新的根节点。</li></ol></li></ol><h2 id="5-5、优缺点"><a href="#5-5、优缺点" class="headerlink" title="5.5、优缺点"></a>5.5、优缺点</h2><h3 id="5-5-1、优点"><a href="#5-5-1、优点" class="headerlink" title="5.5.1、优点"></a>5.5.1、优点</h3><ol><li><font color='orange'>B+树 只会 在叶子节点存储 键值和数据，非叶子节点只存储键值和指针，而B树叶子和非叶子节点都会存储。</font></li><li><font color='orange'>B+树叶子节点通过指针连接在一起且有序，而B树没有这个特性。</font></li><li><font color='orange'>IO次数更少。</font></li><li><font color='orange'>适合范围查询。</font></li><li><font color='orange'>查询效率稳定。</font></li></ol><h3 id="5-5-2、缺点"><a href="#5-5-2、缺点" class="headerlink" title="5.5.2、缺点"></a>5.5.2、缺点</h3><ol><li><font color='red'>由于键会重复出现，因此会占用更多空间。</font>但是与带来的性能优势相比，空间劣势往往可以接受，因此B+树在数据库中的使用 较B树 更广泛。</li></ol><h2 id="5-6、使用场景"><a href="#5-6、使用场景" class="headerlink" title="5.6、使用场景"></a>5.6、使用场景</h2><p>B+树多用于磁盘存储等场景。</p><h2 id="5-7、B树-VS-B-树"><a href="#5-7、B树-VS-B-树" class="headerlink" title="5.7、B树 VS B+树"></a>5.7、B树 VS B+树</h2><p>B+树是应文件系统所需而产生的一种B树的变形树。m阶B+树 和 m阶B树 的区别是：</p><ol><li>有n棵子树的结点中含有n个关键码；</li><li>所有的叶子结点中包含了全部关键码的信息，及指向含有这些关键码记录的指针，且叶子结点本身依关键码的大小自小而大的顺序链接；</li><li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大(或最小)关键码。</li></ol><h2 id="5-8、知识点扩展"><a href="#5-8、知识点扩展" class="headerlink" title="5.8、知识点扩展"></a>5.8、知识点扩展</h2><h3 id="MySQL中基于B-树的表插入数据时，主键需要递增吗？"><a href="#MySQL中基于B-树的表插入数据时，主键需要递增吗？" class="headerlink" title="MySQL中基于B+树的表插入数据时，主键需要递增吗？"></a>MySQL中基于B+树的表插入数据时，主键需要递增吗？</h3><p>需要，其目的是为了 【减少&#x2F;防止 块分裂】。</p><h1 id="6、Trie树（字典树）"><a href="#6、Trie树（字典树）" class="headerlink" title="6、Trie树（字典树）"></a>6、Trie树（字典树）</h1><h2 id="6-1、简介"><a href="#6-1、简介" class="headerlink" title="6.1、简介"></a>6.1、简介</h2><p>Trie树 又称 单词查找树，Trie树 是一种 树形结构，是一种 变种哈希树。通常用于统计、排序、保存大量字符串（但不仅限于字符串），所以经常被 搜索引擎 用于 文本词频统计。优点是：<font color='orange'>利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</font></p><h2 id="6-2、性质"><a href="#6-2、性质" class="headerlink" title="6.2、性质"></a>6.2、性质</h2><ol><li>根节点 不包含 字符，其它节点 都只包含 一个字符；</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；</li><li>每个节点的所有子节点包含的字符都不相同。</li></ol><h2 id="6-3、基本操作"><a href="#6-3、基本操作" class="headerlink" title="6.3、基本操作"></a>6.3、基本操作</h2><p>基本操作：查找、插入和删除，当然删除操作比较少见。</p><h2 id="6-4、实现方法"><a href="#6-4、实现方法" class="headerlink" title="6.4、实现方法"></a>6.4、实现方法</h2><p>搜索字典项目的方法为：</p><ol><li>从根结点开始一次搜索；</li><li>取得要查找关键词的第一个字母，并根据该字母选择对应的子树并转到该子树继续进行检索；</li><li>在相应的子树上，取得要查找关键词的第二个字母,并进一步选择对应的子树进行检索。</li><li>迭代过程……</li><li>在某个结点处，关键词的所有字母已被取出，则读取附在该结点上的信息，即完成查找。</li></ol><p>其他操作类似处理。</p><h1 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h1><h2 id="7-1、二叉查找树-BST"><a href="#7-1、二叉查找树-BST" class="headerlink" title="7.1、二叉查找树(BST)"></a>7.1、二叉查找树(BST)</h2><p>解决了 排序 基本问题，但可能退化为链表；</p><h2 id="7-2、平衡二叉树-AVL"><a href="#7-2、平衡二叉树-AVL" class="headerlink" title="7.2、平衡二叉树(AVL)"></a>7.2、平衡二叉树(AVL)</h2><p>通过旋转 解决 平衡问题，但旋转效率太低；</p><h2 id="7-3、红黑树"><a href="#7-3、红黑树" class="headerlink" title="7.3、红黑树"></a>7.3、红黑树</h2><p>通过舍弃严格的平衡和引入红黑节点，解决了AVL旋转效率过低的问题，但在 磁盘IO场景 下，树仍然太高，IO次数太多；</p><h2 id="7-4、B树"><a href="#7-4、B树" class="headerlink" title="7.4、B树"></a>7.4、B树</h2><p>通过将二叉树改为多路平衡查找树，解决了树过高问题；</p><h2 id="7-5、B-树"><a href="#7-5、B-树" class="headerlink" title="7.5、B+树"></a>7.5、B+树</h2><p>在B树基础上，将 非叶节点 改造为 索引节点，进一步降低了树高；此外叶子节点 使用指针 连接成链表，范围查询更加高效。</p><h1 id="X、知识拓展"><a href="#X、知识拓展" class="headerlink" title="X、知识拓展"></a>X、知识拓展</h1><h2 id="X-1、为什么MySQL索引使用B-树而不使用红黑树"><a href="#X-1、为什么MySQL索引使用B-树而不使用红黑树" class="headerlink" title="X.1、为什么MySQL索引使用B+树而不使用红黑树?"></a>X.1、为什么MySQL索引使用B+树而不使用红黑树?</h2><p>B+树 适用于 文件存储IO。</p><p>数据库文件 通常位于 磁盘中，定位一行信息需要查找该文件所在柱面号，磁盘号，扇区号，页号等。一次请求要做一次IO，因此减少IO次数是提高性能的关键。</p><p>IO次数是索引树的高度，高度越低查询次数越少。相同结点个数（个数为n）环境下，红黑树高度最高为<code>2log(n+1)</code>，B+树高度最高为<code>(log(n+1)/2)+1</code>，随着 n 增大B+树高度会更小，IO次数会更少。</p>]]></content>
      
      
      <categories>
          
          <category> 数据与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据与算法系列-原码反码补码移码转换</title>
      <link href="/2023/07/30/jin-zhi-shu-ju-zhi-shi-dian-zong-jie/"/>
      <url>/2023/07/30/jin-zhi-shu-ju-zhi-shi-dian-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="原码-反码-补码-移码"><a href="#原码-反码-补码-移码" class="headerlink" title="原码&#x2F;反码&#x2F;补码&#x2F;移码"></a>原码&#x2F;反码&#x2F;补码&#x2F;移码</h1><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>是最简单的机器数表示法。用最高位表示符号位，‘1’表示负号，‘0’表示正号。其它位存放该数的二进制的绝对值。</p><p>注意： </p><ol><li>数0的原码有两种形式： [+0]原&#x3D;00000000B [-0]原&#x3D;10000000B。</li><li>8位二进制原码的表示范围：-127～+127。</li></ol><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>符号位0表示正，1表示负。正数的反码等于原码。负数的反码等于原码按位数取反，（绝对值按位求反）。</p><p>步骤：先将这个负数化为原码，再根据原码取反。比如该负数原码是：00000001，那么它取反就是0 1111110。</p><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>符号位0表示正，1表示负，正数的补码等于原码。负数的补码等于反码末位加1，</p><p>步骤：先将这个负数化为原码再化为反码，末位加1。比如该负数的反码是11111110，那么它末位加1就是11111111。</p><h2 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h2><p>等于补码的符号（第一位数字）位取反。</p><p>步骤：先把这个数化为补码，然后再根据补码的第一位数字取反即可。（移码和补码的关系：同一数值的移码与补码符号位相反，其它各位相同。）</p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ol><li><font color='orange'>正数的原码、反码、补码都相同；</font></li><li><font color='orange'>负数的反码 就是 原码的各个位取反。</font></li><li><font color='orange'>负数的补码 就是 反码末位加1。</font></li><li><font color='orange'>负数的移码 就是 补码的符号位（第一位数字）取反。</font></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原码反码补码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系列-系统总线</title>
      <link href="/2023/07/30/zong-xian-zhi-shi-zong-jie/"/>
      <url>/2023/07/30/zong-xian-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="1、认识总线"><a href="#1、认识总线" class="headerlink" title="1、认识总线"></a>1、认识总线</h1><h2 id="1-1、总线简介"><a href="#1-1、总线简介" class="headerlink" title="1.1、总线简介"></a>1.1、总线简介</h2><p><font color='orange'>随着处理器和存储器速度越来越快，单总线（当然还有IBM PC总线）很难处理总线交通流量，故新一代总线出现了。</font></p><p>Pentium系统结构图如下所示：</p><p><img src="/%5Cimgs%5Cjavadev%5C%E5%A4%A7%E5%9E%8BPentium%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%9B%BE01.png"></p><p><font color='orange'>图中系统有8个总线（高速缓存、局部、内存、PCI、SCSI、USB、IDE和ISA），每个总线传输速度和功能都不同。</font>操作系统必须了解所有总线的配置和管理。有两个主要总线，即早期的IBM PC ISA（Industry Standard Architecture）总线和它的后继者PCI（Peripheral Component Interconnect）总线。</p><h2 id="1-2、ISA-PCI总线"><a href="#1-2、ISA-PCI总线" class="headerlink" title="1.2、ISA&#x2F;PCI总线"></a>1.2、ISA&#x2F;PCI总线</h2><h3 id="1-2-1、ISA总线"><a href="#1-2-1、ISA总线" class="headerlink" title="1.2.1、ISA总线"></a>1.2.1、ISA总线</h3><p><font color='orange'>ISA总线就是原先的IBM PC&#x2F;AT总线，以8.33MHz频率运行，可并行传送2字节，最大速率为16.67MB&#x2F;s。它还可与老式的慢速I&#x2F;O卡向后兼容。</font></p><h3 id="1-2-2、PCI总线"><a href="#1-2-2、PCI总线" class="headerlink" title="1.2.2、PCI总线"></a>1.2.2、PCI总线</h3><p><font color='orange'>PCI总线 作为 ISA总线 的后继者 由Intel公司发布。它可在66MHz频率运行，可并行传送8字节，数据速率为528MB&#x2F;s。</font></p><blockquote><p>目前多数高速I&#x2F;O设备采用PCI总线。由于有大量I&#x2F;O卡采用PCI总线，甚至许多非Intel计算机也使用PCI总线。现在，使用称为PCI Express的PCI总线升级版的新计算机已经出现。</p></blockquote><p>在这种配置中，CPU通过局部总线与PCI桥芯片对话，而PCI桥芯片通过专门的存储总线与存储器对话，一般速率为100MHz。</p><p>Pentium系统在芯片上有1级高速缓存，在芯片外有一个非常大的2级高速缓存，它通过高速缓存总线与CPU连接。</p><h2 id="1-3、IDE-USB-SCSI总线"><a href="#1-3、IDE-USB-SCSI总线" class="headerlink" title="1.3、IDE&#x2F;USB&#x2F;SCSI总线"></a>1.3、IDE&#x2F;USB&#x2F;SCSI总线</h2><p>系统中有三个专门的总线：IDE、USB和SCSI。</p><h3 id="1-3-1、IDE总线"><a href="#1-3-1、IDE总线" class="headerlink" title="1.3.1、IDE总线"></a>1.3.1、IDE总线</h3><p><font color='orange'>IDE总线 将诸如 磁盘 和 CD-ROM 类的外部设备与系统相连接。IDE总线 是PC&#x2F;AT的 磁盘控制器接口的副产品，现在几乎成了所有基于Pentium系统的硬盘标准，对于CD-ROM也经常是这样。</font></p><h3 id="1-3-2、USB总线"><a href="#1-3-2、USB总线" class="headerlink" title="1.3.2、USB总线"></a>1.3.2、USB总线</h3><h4 id="1-3-2-1、USB总线简介"><a href="#1-3-2-1、USB总线简介" class="headerlink" title="1.3.2.1、USB总线简介"></a>1.3.2.1、USB总线简介</h4><p><font color='orange'>通用串行总线（Universal Serial Bus，USB）是用来 将所有慢速I&#x2F;O设备，诸如键盘和鼠标，与计算机连接。</font></p><p>USB总线采用一种小型四针连接器，其中两针为USB设备提供电源。</p><h4 id="1-3-2-2、USB总线特点"><a href="#1-3-2-2、USB总线特点" class="headerlink" title="1.3.2.2、USB总线特点"></a>1.3.2.2、USB总线特点</h4><p><font color='orange'>USB是一种集中式总线，其 根设备 每1ms轮询一次I&#x2F;O设备，看是否有信息收发。</font></p><blockquote><p>USB1.0可以处理总计为1.5MB&#x2F;s的负载，而较新的USB2.0总线可以有60MB&#x2F;s的速率。</p><p>所有USB设备共享一个USB设备驱动器，所以无须重新启动就可以给计算机添加USB设备。</p></blockquote><h3 id="1-3-3、SCSI总线"><a href="#1-3-3、SCSI总线" class="headerlink" title="1.3.3、SCSI总线"></a>1.3.3、SCSI总线</h3><p><font color='orange'>SCSI（Small Computer System Interface）总线是一种高速总线，用在高速硬盘、扫描仪和其他需要较大带宽的设备上。它最高可达320MB&#x2F;s。</font></p><p>自从其发布以来，SCSI总线一直用在Macintosh系统上，在UNIX和一些基于Intel的系统中也很流行。</p><h3 id="1-3-4、IEEE-1394总线"><a href="#1-3-4、IEEE-1394总线" class="headerlink" title="1.3.4、IEEE 1394总线"></a>1.3.4、IEEE 1394总线</h3><p><font color='orange'>EEE 1394 称为 火线（FireWire），严格来说，火线是苹果公司具体实现1394的名称。</font></p><p><font color='orange'>与USB一样，IEEE 1394 是位串行总线，设计用于最快可达100MB&#x2F;s的包传送中，它适合于将数码相机和类似的多媒体设备连接到计算机上。</font></p><p>IEEE 1394与USB不同，不需要集中式控制器。</p><h3 id="1-3-5、总结"><a href="#1-3-5、总结" class="headerlink" title="1.3.5、总结"></a>1.3.5、总结</h3><p><font color='orange'>要想使总线工作起来，则须让 操作系统知道 连接到计算机的外部设备有哪些，并对它们进行配置。</font></p><p>这个特点 导致 Intel 和 微软 设计了一种名为 即插即用 的I&#x2F;O系统。</p><blockquote><p>在即插即用之前，每块I&#x2F;O卡有一个固定的中断请求级别和用于其I&#x2F;O寄存器的固定地址，例如，键盘的中断级别是1，并使用0x60至0x64的I&#x2F;O地址，软盘控制器是中断6级并使用0x3F0至0x3F7的I&#x2F;O地址，而打印机是中断7级并使用0x378至0x37A的I&#x2F;O地址等。</p><p>比如，用户买了一块声卡和调制解调卡，并且它们都是可以使用中断4的，但此时，问题发生了，两块卡互相冲突，结果不能在一起工作。解决方案是在每块I&#x2F;O卡上提供DIP开关或跳接器，并指导用户对其进行设置以选择中断级别和I&#x2F;O地址，使其不会与用户系统的任何其他部件冲突。</p></blockquote><p><font color='orange'>即插即用所做的工作是，系统自动地收集有关I&#x2F;O设备的信息，集中赋予中断级别和I&#x2F;O地址，然后通知每块卡所使用的数值。</font>这项工作与计算机的启动密切相关。</p><h2 id="1-4、启动计算机"><a href="#1-4、启动计算机" class="headerlink" title="1.4、启动计算机"></a>1.4、启动计算机</h2><p><font color='orange'>环境描述如下</font>：</p><p>在每个Pentium上有一块双亲板（在政治上的纠正影响到计算机产业之前，它们曾称为“母板”）。在双亲板上有一个称为基本输入输出系统（Basic Input Output System，BIOS）的程序。在BIOS内有底层I&#x2F;O软件，包括读键盘、写屏幕、进行磁盘I&#x2F;O以及其他过程。现在这个程序存放在一块闪速RAM中，它是非可易失性的，但是在发现BIOS中有错时可以通过操作系统对它进行更新。</p><p><font color='orange'>Pentium启动过程可简单描述如下</font>：</p><ol><li><p>计算机启动，BIOS开始运行。</p><ol><li>首先检查安装的RAM数量，键盘和其他基本设备是否已安装并正常响应。</li><li>扫描ISA和PCI总线并找出连在上面的所有设备。其中有些是遗留设备，且有固定的中断级别和I&#x2F;O地址。即插即用设备也被记录下来。如果现有设备 与 系统上一次启动时的设备不同，则配置新设备。</li></ol></li><li><p>BIOS尝试 在CMOS存储器中的设备清单中 来决定启动设备。</p><p>用户可以在系统刚启动之后进入一个BIOS配置程序，对设备清单进行修改。典型地，如果存在软盘，则系统试图从软盘启动。如果失败则试用CD-ROM，看看是否有可启动CD-ROM存在。如果软盘和CD-ROM都没有，系统从硬盘启动。启动设备上的第一个扇区被读入内存并执行。这个扇面中包含一个对保存在启动扇面末尾的分区表检查的程序，以确定哪个分区是活动的。然后，从该分区读入第二个启动装载模块。来自活动分区的这个装载模块被读入操作系统，并启动之。</p></li><li><p>操作系统询问BIOS，获得配置信息。</p><p>对于每种设备，系统检查对应的设备驱动程序是否存在。如果没有，系统要求用户插入含有该设备驱动程序的CD-ROM（由设备供应商提供）。一旦有了全部的设备驱动程序，操作系统就将它们调入内核。然后初始化有关表格，创建需要的任何背景进程，并在每个终端上启动登录程序或GUI。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统总线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系列-TCP基础知识</title>
      <link href="/2023/07/30/tcp-ji-chu-zhi-shi/"/>
      <url>/2023/07/30/tcp-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="1、必备知识"><a href="#1、必备知识" class="headerlink" title="1、必备知识"></a>1、必备知识</h1><h2 id="1-1、协议分类"><a href="#1-1、协议分类" class="headerlink" title="1.1、协议分类"></a>1.1、协议分类</h2><ul><li><font color='orange'>IP：Internet Protocol－⽹络协议。</font></li><li><font color='orange'>TCP：Transmission Control Protocol－传输控制协议。</font></li></ul><p>四层协议，五层协议和七层协议的关系如下：</p><ul><li><p><font color='orange'>OSI七层协议模型包括</font>：应⽤层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、⽹络层（Network）、数据链路层（Data Link）、物理层（Physical）。</p></li><li><p><font color='orange'>TCP&#x2F;IP四层体系结构包括</font>：应⽤层、运输层、⽹际层和⽹络接⼝层。</p></li></ul><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200908153007750.png" alt="image-20200908153007750"></p><blockquote><p>注：五层协议体系结构只是为了介绍⽹络原理⽽设计，实际应⽤还是 TCP&#x2F;IP 四层体系结构。</p></blockquote><h2 id="1-2、OSI七层协议"><a href="#1-2、OSI七层协议" class="headerlink" title="1.2、OSI七层协议"></a>1.2、OSI七层协议</h2><ol><li><font color='orange'>物理层（Physical）</font>：网线、网卡、集线器、调制解调器；</li><li><font color='orange'>数据链路层（Data Link）</font>：网桥、交换机、基于mac地址的物理寻址；例如以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP。</li><li><font color='orange'>⽹络层（Network）</font>：路由器；例如IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、 X.25。</li><li><font color='orange'>传输层（Transport）</font>：TLS协议、SSL协议；例如TCP、UDP、RTP、SCTP、SPX、ATP、IL。</li><li><font color='orange'>会话层（Session）</font>：例如ASAP、TLS、SSH、ISO 8327 &#x2F; CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets。</li><li><font color='orange'>表示层（Presentation）</font>：例如XDR、ASN.1、SMB、AFP、NCP。</li><li><font color='orange'>应⽤层（Application）</font>：例如HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP。</li></ol><blockquote><p> 传输层安全性协议（英语：Transport Layer Security，缩写TLS）的前身是安全套接层（Secure Sockets Layer，缩写作SSL）协议。该协议主要为互联网通信提供安全及数据完整性保障。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。</font></p><p> TLS协议采用主从式架构模型，用于在两个应用程序间透过网络创建安全连线，防止在交换数据时被窃听及篡改。</p></blockquote><h2 id="1-3、TCP-IP四层协议"><a href="#1-3、TCP-IP四层协议" class="headerlink" title="1.3、TCP&#x2F;IP四层协议"></a>1.3、TCP&#x2F;IP四层协议</h2><p>TCP&#x2F;IP 被分为 4 层，每层的 任务 和 ⼯作⽅式 都不同，每层封装上层数据的⽅式也不同：</p><ol><li><font color='orange'>应⽤层</font>：应⽤程序通过该层访问⽹络，该层协议有HTTP、FTP、TFTP、SMTP、SNMP、DNS 和 TELNET；数据格式为数据报文。</li><li><font color='orange'>传输层</font>：TCP协议、UDP协议；数据格式为 数据段。</li><li><font color='orange'>⽹络层</font>：IP协议、ICMP协议、IGMP协议等；数据格式为 数据包。</li><li><font color='orange'>⽹络接⼝层</font>：ARP协议、RARP协议；该层是TCP&#x2F;IP 协议的基层，负责数据帧的发送和接收。数据格式为 数据帧和bit。</li></ol><h1 id="2、TCP深度剖析"><a href="#2、TCP深度剖析" class="headerlink" title="2、TCP深度剖析"></a>2、TCP深度剖析</h1><h2 id="2-1、TCP与UDP"><a href="#2-1、TCP与UDP" class="headerlink" title="2.1、TCP与UDP"></a>2.1、TCP与UDP</h2><ul><li><font color='orange'>TCP（传输控制协议）</font>：提供⾯向连接的，可靠的数据传输服务。</li><li><font color='orange'>UDP（⽤户数据协议）</font>：提供⽆连接的，尽最⼤努⼒的数据传输服务（不保证数据传输的可靠性）。</li></ul><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200908153446067.png" alt="image-20200908153446067"></p><h2 id="2-2、TCP-IP数据包结构"><a href="#2-2、TCP-IP数据包结构" class="headerlink" title="2.2、TCP&#x2F;IP数据包结构"></a>2.2、TCP&#x2F;IP数据包结构</h2><h3 id="2-2-1、TCP数据包结构"><a href="#2-2-1、TCP数据包结构" class="headerlink" title="2.2.1、TCP数据包结构"></a>2.2.1、TCP数据包结构</h3><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200908153709918.png" alt="image-20200908153709918"></p><ol><li>第一行：源端口2字节，目的端口2字节；</li></ol><p>   表示发送方和接收方的端口号。</p><ol start="2"><li><p>第二、三行：序列号4字节，确认号4字节；</p><ul><li>序列号是指该报文段在发送方数据字节流中的位置，在TCP字节流中，每个数据字节都被编号；</li><li>确认号是指本机希望收到的下一个字节的序号；</li><li>序列号和确认号分别对应报文发送方向和相反方向的数据流；</li><li>报文被分解成多个报文段时，序列号就是首字节在整个报文中的偏移量，确认号指定下一个期待的字节；</li><li>序列号和确认号的最大表示范围均为2^32-1&#x3D;4294967295≈42.9亿；</li></ul></li><li><p>第四行：首部长度4位，保留6位，标志位6位，窗口大小16位；</p><ul><li><p>首部长度：指明首部共有多少行（每行4个字节），则TCP首部的最大长度为（2^4-1)*4&#x3D;60字节；</p></li><li><p>标志位：公有6位，每一项含义分别如下：</p><ol><li><font color='orange'>SYN：建立连接 - 同步序号用来发起一个连接。</font></li><li><font color='orange'>FIN：关闭连接 - 发端完成发送任务。</font></li><li><font color='orange'>ACK：响应 - 确认序号有效。</font></li><li><font color='orange'>PSH：有data数据传输 - 接收方尽快将这个报文段交给应用层。</font></li><li><font color='orange'>RST：重建连接。</font></li><li><font color='orange'>URG：紧急指针有效。</font></li></ol></li><li><p>窗口大小：即发送数据的窗口大小，告诉对方在不等待确认的情况下，可以发来多大的数据；这里表示的最大长度是2^16-1&#x3D;65535，如需要使用更大的窗口大小，需要使用选项中的窗口扩大因子选项；</p></li></ul></li><li><p>第五行：TCP校验和16位，紧急指针16位；</p><ul><li><font color='orange'>TCP校验和</font>：【待补充】</li><li><font color='orange'>紧急指针</font>：当URG标志为1时紧急指针才有效，紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号（即序列号到紧急指针之间的数据为紧急数据，后面的数据才是正常数据）。</li></ul></li><li><p>第六行开始是选项部分：每个选项的开头是1字节的kind字段，表示选项类型。</p></li></ol><h3 id="2-2-2、IP数据包结构"><a href="#2-2-2、IP数据包结构" class="headerlink" title="2.2.2、IP数据包结构"></a>2.2.2、IP数据包结构</h3><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200908154657846.png" alt="image-20200908154657846"></p><h1 id="3、TCP传输"><a href="#3、TCP传输" class="headerlink" title="3、TCP传输"></a>3、TCP传输</h1><h2 id="3-1、三次握手"><a href="#3-1、三次握手" class="headerlink" title="3.1、三次握手"></a>3.1、三次握手</h2><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200908154817025.png" alt="image-20200908154817025"></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200908154934881.png" alt="image-20200908154934881"></p><h2 id="3-2、四次挥手"><a href="#3-2、四次挥手" class="headerlink" title="3.2、四次挥手"></a>3.2、四次挥手</h2><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200908155442522.png" alt="image-20200908155442522"></p><p> <font color='orange'>最⼤分段寿命（MSL, Maximum Segment Lifetime）表示⼀个 TCP 分段可以存在于互联⽹系统中的最⼤时间，由 TCP 实现，超出这个寿命的分⽚都会被丢弃。</font></p><p> <font color='orange'>centOS 上，它被定义为 30s，我们可以通过<code>/proc/sys/net/ipv4/tcp_fin_timeout</code>这个⽂件查看和修改这个值。</font></p><blockquote><p><font color='orange'>Socket：套接字，ip + port : ip + port。</font></p><p><font color='orange'>每台主机可以有65535个连接。</font></p></blockquote><h2 id="3-3、总结"><a href="#3-3、总结" class="headerlink" title="3.3、总结"></a>3.3、总结</h2><h3 id="3-3-1、为何需要三次握手？"><a href="#3-3-1、为何需要三次握手？" class="headerlink" title="3.3.1、为何需要三次握手？"></a>3.3.1、为何需要三次握手？</h3><p> A-&gt;B    —&gt;     B-&gt;A    —&gt;     A-&gt;B</p><p> <font color='orange'>因为需要考虑连接时的丢包问题。</font></p><p>如果只握⼿两次，即 B响应A后就开始收发数据。假如此时B响应A的确认包在传送过程中丢失了，且A因为⼀直无法收到B的确认包可能会关掉⾃⼰的socket，而B认为A一直在就会一直发送资源，最终会⽩⽩浪费掉B的资源。如果存在三次握⼿，就可避免上述问题。因为B在⼀段时间内没有收到A的确认ack报⽂，那么就会重发SYN报⽂段给A，A收到重发报⽂段后会再次发送确认ack报⽂给B。</p><h3 id="3-3-2、为何握手要三次，而挥手要四次？"><a href="#3-3-2、为何握手要三次，而挥手要四次？" class="headerlink" title="3.3.2、为何握手要三次，而挥手要四次？"></a>3.3.2、为何握手要三次，而挥手要四次？</h3><ol><li><p>A -&gt; <em>FIN</em> -&gt; B</p></li><li><p>B -&gt; <em>ACK</em> -&gt; A</p><p>……….数据传输………</p></li><li><p>B -&gt; <em>FIN</em> -&gt; A</p></li><li><p>A -&gt; <em>ACK</em> -&gt; B</p></li><li><p>B收到A的回应后立即关闭，A则等待2MSL，若期间无任何动静再立即关闭。</p></li></ol><p><font color='orange'>因为只有在客户端和服务端都没有数据要发送时才能断开TCP。</font>A发送FIN报⽂时只能证明A没有数据要发了，服务端B是否还有数据发给客户端A是不知道的。⽽服务端B收到客户端A的FIN报⽂后只能先回复客户端A⼀个确认报⽂我已收到，但我服务端B还有⼀些数据没发完，等这些数据发完了服务端B才能给客户端A发FIN报⽂(所以不能⼀次性将确认报⽂和FIN报⽂发给客户端，就是这⾥多出来了⼀次)。</p><h3 id="3-3-3、为何客户端第四次发送确认报文后还要等2MSL后才关闭？"><a href="#3-3-3、为何客户端第四次发送确认报文后还要等2MSL后才关闭？" class="headerlink" title="3.3.3、为何客户端第四次发送确认报文后还要等2MSL后才关闭？"></a>3.3.3、为何客户端第四次发送确认报文后还要等2MSL后才关闭？</h3><p> <font color='orange'>因为同样是考虑到丢包问题。</font></p><p>第4次挥⼿报⽂发过之后，A并不知道B是否接到⾃⼰的ACK。但是A发送ACK后只有两种结果：</p><ol><li><font color='orange'>如果B没有收到A发送的ACK，B会超时重传FIN，那么A再次接到重传FIN，进而会再次发送ACK。</font></li><li><font color='orange'>如果B收到了A发送的ACK，被动关闭的B⽆需任何wait time，直接释放资源。也不会再发任何消息，包括ACK。</font></li></ol><p>所以A要取这两种情况等待时间的最⼤值，以应对最坏情况发⽣，<font color='orange'>最坏情况就是第⼀种情况：去向ACK消息最⼤存活时间（MSL) + 来向FIN消息最⼤存活时间(MSL)，刚好是2MSL( Maximum Segment Life)。等待2MSL时间，A就可以放⼼地释放TCP占⽤的资源、端⼝号，此时可以使⽤该端⼝号连接任何服务器。</font></p><p>还有⼀个重要概念——端⼝重⽤。</p><blockquote><p> <font color='orange'>每个MSL是2分钟，2个MSL就是4分钟。MSL是<code>maximium segment lifetime</code>的缩写，意为最长报文寿命。这个时间由官方RFC协议规定。</font></p></blockquote><h3 id="3-3-4、若已经建立连接，但客户端突然出现故障，那如何解决？"><a href="#3-3-4、若已经建立连接，但客户端突然出现故障，那如何解决？" class="headerlink" title="3.3.4、若已经建立连接，但客户端突然出现故障，那如何解决？"></a>3.3.4、若已经建立连接，但客户端突然出现故障，那如何解决？</h3><p> <font color='orange'>因 TCP 有⼀个保活计时器，故 客户端出现故障时不会导致服务器⼀直等下去。</font></p><p>服务器每次收到客户端请求后都会重新复位计时器，时间通常为2⼩时，若两⼩时后依然没有收到客户端任何数据，则服务器就会发送探测报⽂段来进行判断。以每75秒发送⼀次连续发送10次后依然无响应，则服务器就会认为客户端出了故障，然后关闭连接。</p><h1 id="4、TCP可靠传输"><a href="#4、TCP可靠传输" class="headerlink" title="4、TCP可靠传输"></a>4、TCP可靠传输</h1><p><font color='orange'>TCP 是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</font></p><h2 id="4-1、重传机制"><a href="#4-1、重传机制" class="headerlink" title="4.1、重传机制"></a>4.1、重传机制</h2><p> <font color='orange'>TCP 实现 可靠传输 的⽅式之⼀就是 通过序列号与确认应答。</font></p><p>TCP传输中，主机B在收到主机A的请求后会发送响应给主机A。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417191856726.png" alt="image-20210417191856726"></p><p>在错综复杂的⽹络中，顺利进行数据传输是不一定成立的，所以  <font color='orange'>TCP 针对数据包丢失的情况，会⽤重传机制解决。</font> </p><p>常⻅重传机制有：</p><ol><li><font color='orange'>超时重传</font></li><li><font color='orange'>快速重传</font></li><li><font color='orange'>SACK</font></li><li><font color='orange'>D-SACK</font></li></ol><h3 id="5-1-1、超时重传"><a href="#5-1-1、超时重传" class="headerlink" title="5.1.1、超时重传"></a>5.1.1、超时重传</h3><h4 id="何为超时重传"><a href="#何为超时重传" class="headerlink" title="何为超时重传"></a>何为超时重传</h4><p><font color='orange'>在发送数据时，设定⼀个定时器，当超过指定的时间后，没有收到对⽅ ACK 确认应答报⽂时，就会重发该数据，也就是我们常说的超时重传。</font></p><h4 id="触发超时重传"><a href="#触发超时重传" class="headerlink" title="触发超时重传"></a>触发超时重传</h4><p>TCP 会在以下两种情况中 执行 超时重传操作：</p><ol><li>数据包丢失</li><li>确认应答丢失</li></ol><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417192440953.png" alt="image-20210417192440953"></p><h4 id="设置超时时间"><a href="#设置超时时间" class="headerlink" title="设置超时时间"></a>设置超时时间</h4><p>何为RTT（Round-Trip Time 往返时延），可从下图中找到答案：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417192532442.png" alt="image-20210417192532442"></p><p><font color='orange'>RTT 就是数据从⽹络⼀端传送到另⼀端所需的时间，也就是包的往返时间。</font></p><p><font color='orange'>超时重传时间会以 RTO （Retransmission Timeout 超时重传时间）表示。</font></p><p>重传环境下，超时时间 RTO 「较⻓或较短」时，会发⽣什么？</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417192649183.png" alt="image-20210417192649183"></p><p>上图中有两种超时时间不同的情况：</p><ul><li>当超时时间 RTO 较⼤时，重发就慢，丢了⽼半天才重发，没有效率，性能差；</li><li>当超时时间 RTO 较⼩时，会导致可能并没有丢就重发，于是重发就快，会增加⽹络拥塞，导致 更多超时，更多超时导致更多重发。</li></ul><p>精确的测量超时时间 RTO 的值是⾮常重要的，这可让我们的重传机制更⾼效。 </p><p>根据上述的两种情况，我们可以得知： <font color='orange'>超时重传时间 RTO 的值应该略⼤于报⽂往返 RTT 的值。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417192824629.png" alt="image-20210417192824629"></p><p>⾄此，可能⼤家觉得超时᯿传时间 RTO 的值计算，也不是很复杂嘛。</p><p>好像就是在发送端发包时记下 t0 ，然后接收端再把这个 ack 回来时再记⼀个 t1 ，于是 RTT &#x3D; t1 – t0 。没那么简单，这只是⼀个采样，不能代表普遍情况。</p><p>实际上「报⽂往返 RTT 的值」是经常变化的，因为我们的⽹络也是时常变化的。也就因为「报⽂往返 RTT 的值」 是经常波动变化的，所以「超时᯿传时间 RTO 的值」应该是⼀个动态变化的值。</p><p>我们来看看 Linux 是如何计算 RTO 的呢？</p><p> <font color='orange'>估计往返时间，需要参考如下两项：</font></p><ol><li>TCP 通过采样 RTT 时间，然后进⾏加权平均，算出⼀个平滑 RTT 值，⽽且该值还是要 不断变化的，因为⽹络状况不断地变化。</li><li>除了采样 RTT，还要采样 RTT 的波动范围，这样就避免了 RTT 若有⼀个⼤波动的话，就会很难被发现的情况。</li></ol><p>RFC6289 建议使⽤以下的公式计算 RTO：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417192939108.png" alt="image-20210417192939108"></p><p><font color='orange'>其中，SRTT 是计算平滑RTT ， DevRTR 是计算平滑RTT 与 最新 RTT 的差距。</font></p><p>在 Linux 下，α &#x3D; 0.125，β &#x3D; 0.25， μ &#x3D; 1，∂ &#x3D; 4。别问怎么来的，问就是⼤量实验中调出来的。</p><p> <font color='orange'>如果超时重发的数据，再次超时且⼜需要重传时，TCP 的策略是超时间隔加倍。</font></p><p>也就是每当遇到⼀次超时重传的时候，都会将下⼀次超时时间间隔设为先前值的两倍。两次超时，就说明⽹络环境差，不宜频繁反复发送。</p><p>超时重传存在的问题是，超时周期可能相对较⻓。那是不是有更快的⽅式呢？</p><p> <font color='orange'>于是就可以⽤「快速重传」机制来解决超时重发的时间等待。</font></p><h3 id="5-1-2、快速重传"><a href="#5-1-2、快速重传" class="headerlink" title="5.1.2、快速重传"></a>5.1.2、快速重传</h3><p> <font color='orange'>快速重传（Fast Retransmit）机制不以时间为驱动，⽽是以数据驱动重传。</font></p><p>快速重传机制，是如何⼯作的呢？其实很简单，⼀图胜千⾔。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417232739572.png" alt="image-20210417232739572"></p><p>在上图，发送⽅发出了 1，2，3，4，5 份数据： </p><ol><li>第⼀份 Seq1 先送到了，于是就 Ack 回 2；</li><li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li><li>后⾯的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li><li>发送端收到了三个 Ack &#x3D; 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失 的 Seq2。</li><li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li></ol><p>所以， <font color='orange'>快速重传的⼯作⽅式是当收到三个相同 ACK 报⽂时，会在定时器过期之前，重传丢失的报⽂段。</font></p><p><font color='orange'>快速重传机制只解决了超时时间问题，还有重传一个，还是重传所有的问题。</font></p><p>⽐如对于上⾯的例⼦，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清 楚这连续的三个 Ack 2 是谁传回来的。</p><p><font color='orange'>因为TCP的不同实现，故以上两种情况都有可能发生。这是⼀把双刃剑。</font></p><p><font color='orange'>通过 SACK ⽅法可以解决 到底该重传哪些 TCP 报⽂的问题。</font></p><h3 id="5-1-3、SACK"><a href="#5-1-3、SACK" class="headerlink" title="5.1.3、SACK"></a>5.1.3、SACK</h3><p><font color='orange'>SACK （ Selective Acknowledgment 选择性确认）需要在 TCP 头部「选项」字段中加⼀个 SACK，它可以将缓存的地图 送给 发送⽅， 发送方可根据该地图来判断哪些收到了哪些没有收到，然后只重发那些没有收到的。</font></p><p>如下图，发送⽅收到了三次同样的 ACK 确认报⽂，于是就会触发快速重发机制，通过 SACK 信息发现 只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进⾏重复。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417233420965.png" alt="image-20210417233420965"></p><p><font color='orange'>如果要⽀持 SACK ，必须双⽅都要⽀持。在 Linux 下，可以通过 net.ipv4.tcp_sack 参数打开这个功能（Linux 2.4 后默认打开）。</font></p><h3 id="5-1-4、D-SACK"><a href="#5-1-4、D-SACK" class="headerlink" title="5.1.4、D-SACK"></a>5.1.4、D-SACK</h3><p><font color='orange'>Duplicate SACK ⼜称 D-SACK ，主要通过 SACK 来告诉「发送⽅」哪些数据被重复接收了。</font></p><p>下⾯举两个栗⼦，来说明 D-SACK 的作⽤。</p><p><strong>栗⼦⼀号：ACK 丢包</strong></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417233640884.png" alt="image-20210417233640884"></p><ul><li>「接收⽅」发给「发送⽅」的两个 ACK 确认应答都丢失了，所以发送⽅超时后，᯿传第⼀个数据 包（3000 ~ 3499）</li><li>于是「接收⽅」发现数据是重复收到的，于是回了⼀个 SACK &#x3D; 3000<del>3500，告诉「发送⽅」 3000</del>3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都 已收到，所以这个 SACK 就代表着 D-SACK 。</li><li>这样「发送⽅」就知道了，数据没有丢，是「接收⽅」的 ACK 确认报⽂丢了。</li></ul><p><strong>栗子二号：网络延时</strong></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417233800922.png" alt="image-20210417233800922"></p><ul><li>数据包（1000~1499） 被⽹络延迟了，导致「发送⽅」没有收到 Ack 1500 的确认报⽂。</li><li>⽽后⾯报⽂到达的三个相同的 ACK 确认报⽂，就触发了快速᯿传机制，但是在᯿传后，被延迟的 数据包（1000~1499）⼜到了「接收⽅」；</li><li>所以「接收⽅」回了⼀个 SACK&#x3D;1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 DSACK，表示收到了重复的包。</li><li>这样发送⽅就知道快速᯿传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，⽽ 是因为⽹络延迟了。</li></ul><p>可⻅， D-SACK 有这么⼏个好处： </p><ol><li>可以让「发送⽅」知道，是发出去的包丢了，还是接收⽅回应的 ACK 包丢了；</li><li>可以知道是不是「发送⽅」的数据包被⽹络延迟了；</li><li>可以知道⽹络中是不是把「发送⽅」的数据包给复制了;</li></ol><p><font color='orange'>Linux 下可以通过 net.ipv4.tcp_dsack 参数开启&#x2F;关闭这个功能（Linux 2.4 后默认打开）。</font></p><h2 id="4-2、滑动窗口"><a href="#4-2、滑动窗口" class="headerlink" title="4.2、滑动窗口"></a>4.2、滑动窗口</h2><h3 id="4-2-1、窗口作用"><a href="#4-2-1、窗口作用" class="headerlink" title="4.2.1、窗口作用"></a>4.2.1、窗口作用</h3><p>我们都知道 TCP 每发送⼀个数据，都要进⾏⼀次确认应答。当上⼀个数据包收到了应答， 再发送下⼀个。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417234245342.png" alt="image-20210417234245342"></p><p>所以，这样的传输⽅式有⼀个缺点：数据包的往返时间越⻓，通信的效率就越低。 </p><p>为解决这个问题，TCP 引⼊了窗⼝这个概念。</p><p><font color='orange'>有了窗⼝，就可以指定窗⼝⼤⼩，窗⼝⼤⼩是指：⽆需等待确认应答就可以继续发送数据的最⼤值。</font></p><p><font color='orange'>窗⼝的实现实际上是操作系统开辟的⼀个缓存空间，发送⽅主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</font></p><p>假设窗⼝⼤⼩为 3 个 TCP 段，那么发送⽅就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下⼀个确认应答进⾏确认」。如下图：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417234516493.png" alt="image-20210417234516493"></p><p>图中的 ACK 600 确认应答报⽂丢失，也没关系，因为可以通过下⼀个确认应答进⾏确认，只要发送⽅ 收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收⽅」都收到了。这个模式就叫累计确认或者累计应答。</p><h3 id="4-2-2、窗口大小谁来决定"><a href="#4-2-2、窗口大小谁来决定" class="headerlink" title="4.2.2、窗口大小谁来决定"></a>4.2.2、窗口大小谁来决定</h3><p>TCP 头⾥有⼀个字段叫 Window ，也就是窗⼝⼤⼩。 这个字段是接收端告诉发送端⾃⼰还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能⼒来发送数据，⽽不会导致接收端处理不过来。 所以，<font color='orange'>通常窗⼝的⼤⼩是由接收⽅窗⼝⼤⼩来决定的。</font> 发送⽅发送的数据⼤⼩不能超过接收⽅的窗⼝⼤⼩，否则接收⽅就⽆法正常接收到数据。</p><h3 id="4-2-3、发送方窗口"><a href="#4-2-3、发送方窗口" class="headerlink" title="4.2.3、发送方窗口"></a>4.2.3、发送方窗口</h3><p>我们先来看看发送⽅窗⼝，下图就是发送⽅缓存数据，根据处理的情况分成四个部分，其中 深蓝⾊⽅框 是发送窗⼝，紫⾊⽅框是可⽤窗⼝：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417234958826.png" alt="image-20210417234958826"></p><ul><li>#1 是已发送并收到 ACK确认的数据：1~31 字节。</li><li>#2 是已发送但未收到 ACK确认的数据：32~45 字节。</li><li>#3 是未发送但总⼤⼩在接收⽅处理范围内（接收⽅还有空间）：46~51字节。</li><li>#4 是未发送但总⼤⼩超过接收⽅处理范围（接收⽅没有空间）：52字节以后。</li></ul><p>在下图，当发送⽅把数据「全部」都⼀下发送出去后，可⽤窗⼝的⼤⼩就为 0 了，表明可⽤窗⼝耗尽， 在没收到 ACK 确认之前是⽆法继续发送数据了。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417235253264.png" alt="image-20210417235253264"></p><p>在下图，当收到之前发送的数据 32<del>36 字节的 ACK 确认应答后，如果发送窗⼝的⼤⼩没有变化，则 滑动窗⼝往右边移动 5 个字节，因为有 5 个字节的数据被应答确认，接下来 52</del>56 字节⼜变成了可⽤ 窗⼝，那么后续也就可以发送 52~56 这 5 个字节的数据了。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417235319675.png" alt="image-20210417235319675"></p><p><strong>程序如何表示发送方四个部分呢？</strong></p><p>TCP 滑动窗⼝⽅案使⽤三个指针来跟踪在四个传输类别中的每⼀个类别中的字节。其中两个指针是绝对 指针（指特定的序列号），⼀个是相对指针（需要做偏移）。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417235701045.png" alt="image-20210417235701045"></p><ul><li>SND.WND ：表示发送窗⼝的⼤⼩（⼤⼩是由接收⽅指定的）；</li><li>SND.UNA ：是⼀个绝对指针，它指向的是已发送但未收到确认的第⼀个字节的序列号，也就是 #2 的第⼀个字节。</li><li>SND.NXT ：也是⼀个绝对指针，它指向未发送但可发送范围的第⼀个字节的序列号，也就是 #3 的 第⼀个字节。</li><li>指向 #4 的第⼀个字节是个相对指针，它需要 SND.UNA 指针加上 SND.WND ⼤⼩的偏移量，就可以 指向 #4 的第⼀个字节了。</li></ul><p>那么可⽤窗⼝⼤⼩的计算公式就是： <code>可⽤窗⼝⼤ = SND.WND -（SND.NXT - SND.UNA）</code>。</p><h3 id="4-2-4、接收方窗口"><a href="#4-2-4、接收方窗口" class="headerlink" title="4.2.4、接收方窗口"></a>4.2.4、接收方窗口</h3><p>接下来我们看看接收⽅窗⼝，接收窗⼝相对简单⼀些，根据处理情况分成三个部分：</p><ul><li>#1 + #2 是已成功接收并确认的数据（等待应⽤进程读取）；</li><li>#3 是未收到数据但可以接收的数据；</li><li>#4 未收到数据并不可以接收的数据；</li></ul><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417235921203.png" alt="image-20210417235921203"></p><p>其中三个接收部分，使⽤两个指针进⾏划分：</p><ul><li>RCV.WND 表示接收窗⼝的⼤⼩，它会通告给发送⽅。</li><li>RCV.NXT ：是⼀个指针，它指向期望从发送⽅发送来的下⼀个数据字节的序列号，也就是 #3 的第 ⼀个字节。</li><li>指向 #4 的第⼀个字节是个相对指针，它需要 RCV.NXT 指针加上 RCV.WND ⼤⼩的偏移量，就可以指向 #4 的第⼀个字节了。</li></ul><p><strong>接收窗口和发送窗口大小一样吗？</strong></p><p>并不是完全相等，<strong>接收窗⼝⼤⼩ 约等于 发送窗⼝⼤⼩</strong>。</p><p>因为滑动窗⼝并不是⼀成不变的。⽐如，当接收⽅的应⽤进程读取数据的速度⾮常快的话，接收窗⼝可以很快的腾出空闲空间。那么新的接收窗⼝⼤⼩，是通过 TCP 报⽂中的 Windows 字段来告诉发送⽅。那么这个传输过程是存在时延的，所以接收窗⼝的大小和发送窗⼝是约等于的关系。</p><h2 id="4-3、流量控制"><a href="#4-3、流量控制" class="headerlink" title="4.3、流量控制"></a>4.3、流量控制</h2><h3 id="4-3-1、流量控制来源"><a href="#4-3-1、流量控制来源" class="headerlink" title="4.3.1、流量控制来源"></a>4.3.1、流量控制来源</h3><p>发送⽅不能⽆脑的发数据给接收⽅，要考虑接收⽅处理能⼒。</p><p>如果⼀直⽆脑的发数据给对⽅，但对⽅处理不过来，那么就会导致触发重发机制，从⽽导致⽹络流量的⽆端的浪费。</p><p>为了解决这种现象发⽣，<strong>TCP 提供⼀种机制可以让「发送⽅」根据「接收⽅」的实际接收能⼒ 控制发送的数据量，这就是所谓的流量控制</strong>。</p><p>下⾯举个栗⼦，为了简单起⻅，假设以下场景：</p><ul><li>客户端是接收⽅，服务端是发送⽅。</li><li>假设接收窗⼝和发送窗⼝相同，都为 200。</li><li>假设两个设备在整个传输过程中都保持相同的窗⼝⼤⼩，不受外界影响。</li></ul><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418180447932.png" alt="image-20210418180447932"></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418180514513.png" alt="image-20210418180514513"></p><p>根据上图的流量控制，说明下每个过程：</p><ol><li>客户端向服务端发送请求数据报⽂。这⾥要说明下，本次例⼦是把服务端作为发送⽅，所以没有画 出服务端的接收窗⼝。</li><li>服务端收到请求报⽂后，发送确认报⽂和 80 字节的数据，于是可⽤窗⼝ Usable 减少为 120 字 节，同时 SND.NXT 指针也向右偏移 80 字节后，指向 321，这意味着下次发送数据的时候，序列号 是 321。</li><li>客户端收到 80 字节数据后，于是接收窗⼝往右移动 80 字节， RCV.NXT 也就指向 321，这意味着 客户端期望的下⼀个报⽂的序列号是 321，接着发送确认报⽂给服务端。</li><li>服务端再次发送了 120 字节数据，于是可⽤窗⼝耗尽为 0，服务端⽆法再继续发送数据。</li><li>客户端收到 120 字节的数据后，于是接收窗⼝往右移动 120 字节， RCV.NXT 也就指向 441，接着 发送确认报⽂给服务端。</li><li>服务端收到对 80 字节数据的确认报⽂后， SND.UNA 指针往右偏移后指向 321，于是可⽤窗⼝ Usable 增⼤到 80。</li><li>服务端收到对 120 字节数据的确认报⽂后， SND.UNA 指针往右偏移后指向 441，于是可⽤窗⼝ Usable 增⼤到 200。</li><li>服务端可以继续发送了，于是发送了 160 字节的数据后， SND.NXT 指向 601，于是可⽤窗⼝ Usable 减少到 40。</li><li>客户端收到 160 字节后，接收窗⼝往右移动了 160 字节， RCV.NXT 也就是指向了 601，接着发送 确认报⽂给服务端。</li><li>服务端收到对 160 字节数据的确认报⽂后，发送窗⼝往右移动了 160 字节，于是 SND.UNA 指针偏 移了 160 后指向 601，可⽤窗⼝ Usable 也就增⼤⾄了 200。</li></ol><h3 id="4-3-2、操作系统缓冲区与滑动窗口的关系"><a href="#4-3-2、操作系统缓冲区与滑动窗口的关系" class="headerlink" title="4.3.2、操作系统缓冲区与滑动窗口的关系"></a>4.3.2、操作系统缓冲区与滑动窗口的关系</h3><p>假定了发送窗⼝和接收窗⼝是不变的，但实际上，发送窗⼝和接收窗⼝中所存放的字节数，都是放在操作系统内存缓冲区中，⽽操作系统的缓冲区，会被操作系统调整。</p><p>当应⽤进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。</p><h4 id="4-3-2-1、缓冲区如何响应发送-接收窗口"><a href="#4-3-2-1、缓冲区如何响应发送-接收窗口" class="headerlink" title="4.3.2.1、缓冲区如何响应发送&#x2F;接收窗口"></a>4.3.2.1、缓冲区如何响应发送&#x2F;接收窗口</h4><p><strong>例⼦一</strong></p><p>当应⽤程序没有及时读取缓存时，发送窗⼝和接收窗⼝的变化。</p><p>考虑以下场景：</p><ul><li>客户端作为发送⽅，服务端作为接收⽅，发送窗⼝和接收窗⼝初始⼤⼩为 360 ；</li><li>服务端⾮常的繁忙，当收到客户端的数据时，应⽤层不能及时读取数据。</li></ul><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418181534600.png" alt="image-20210418181534600"></p><p>根据上图的流量控制，说明下每个过程：</p><ol><li>客户端发送 140 字节数据后，可⽤窗⼝变为 220 （360 - 140）。</li><li>服务端收到 140 字节数据，但是服务端⾮常繁忙，应⽤进程只读取了 40 个字节，还有 100 字节占 ⽤着缓冲区，于是接收窗⼝收缩到了 260 （360 - 100），最后发送确认信息时，将窗⼝⼤⼩通告 给客户端。</li><li>客户端收到确认和窗⼝通告报⽂后，发送窗⼝减少为 260。</li><li>客户端发送 180 字节数据，此时可⽤窗⼝减少到 80。</li><li>服务端收到 180 字节数据，但是应⽤程序没有读取任何数据，这 180 字节直接就留在了缓冲区，于 是接收窗⼝收缩到了 80 （260 - 180），并在发送确认信息时，通过窗⼝⼤⼩给客户端。</li><li>客户端收到确认和窗⼝通告报⽂后，发送窗⼝减少为 80。</li><li>客户端发送 80 字节数据后，可⽤窗⼝耗尽。</li><li>服务端收到 80 字节数据，但是应⽤程序依然没有读取任何数据，这 80 字节留在了缓冲区，于是接 收窗⼝收缩到了 0，并在发送确认信息时，通过窗⼝⼤⼩给客户端。</li><li>客户端收到确认和窗⼝通告报⽂后，发送窗⼝减少为 0。</li></ol><p>可⻅最后窗⼝都收缩为 0 了，也就是发⽣了窗⼝关闭。当发送⽅可⽤窗⼝变为 0 时，发送⽅实际上会定 时发送窗⼝探测报⽂，以便知道接收⽅的窗⼝是否发⽣了改变，这个内容后⾯会说，这⾥先简单提⼀ 下。</p><p><strong>例⼦二</strong> </p><p>当服务端系统资源⾮常紧张的时候，操⼼系统可能会直接减少了接收缓冲区⼤⼩，这时应⽤程序⼜⽆法 及时读取缓存数据，那么这时候就有严᯿的事情发⽣了，会出现数据包丢失的现象</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418181843933.png" alt="image-20210418181843933"></p><p>说明下每个过程：</p><ol><li>客户端发送 140 字节的数据，于是可⽤窗⼝减少到了 220。</li><li>服务端因为现在⾮常的繁忙，操作系统于是就把接收缓存减少了 120 字节，当收到 140 字节数据 后，⼜因为应⽤程序没有读取任何数据，所以 140 字节留在了缓冲区中，于是接收窗⼝⼤⼩从 360 收缩成了 100，最后发送确认信息时，通告窗⼝⼤⼩给对⽅。</li><li>此时客户端因为还没有收到服务端的通告窗⼝报⽂，所以不知道此时接收窗⼝收缩成了 100，客户 端只会看⾃⼰的可⽤窗⼝还有 220，所以客户端就发送了 180 字节数据，于是可⽤窗⼝减少到 40。</li><li>服务端收到了 180 字节数据时，发现数据⼤⼩超过了接收窗⼝的⼤⼩，于是就把数据包丢失了。</li><li>客户端收到第 2 步时，服务端发送的确认报⽂和通告窗⼝报⽂，尝试减少发送窗⼝到 100，把窗⼝ 的右端向左收缩了 80，此时可⽤窗⼝的⼤⼩就会出现诡异的负值。</li></ol><p>所以，如果发⽣了先减少缓存，再收缩窗⼝，就会出现丢包的现象。</p><p>为了防⽌这种情况发⽣，TCP 规定是不允许同时减少缓存⼜收缩窗⼝的，⽽是采⽤先收缩窗⼝，过段时 间再减少缓存，这样就可以避免了丢包情况。</p><h3 id="4-3-3、窗口关闭"><a href="#4-3-3、窗口关闭" class="headerlink" title="4.3.3、窗口关闭"></a>4.3.3、窗口关闭</h3><p>在前⾯我们都看到了，TCP 通过让接收⽅指明希望从发送⽅接收的数据⼤⼩（窗⼝⼤⼩）来进⾏流量控 制。</p><p><strong>窗⼝⼤⼩为 0 时，就会阻⽌发送⽅给接收⽅传递数据，直到窗⼝变为⾮ 0 为⽌，这就是窗⼝关闭</strong>。</p><h4 id="5-3-3-1、窗口关闭潜在危险"><a href="#5-3-3-1、窗口关闭潜在危险" class="headerlink" title="5.3.3.1、窗口关闭潜在危险"></a>5.3.3.1、窗口关闭潜在危险</h4><p><strong>接收⽅向发送⽅通告窗⼝⼤⼩时，是通过 ACK 报⽂来通告的</strong>。</p><p><strong>当发⽣窗⼝关闭时，接收⽅处理完数据后，会向发送⽅通告⼀个窗⼝⾮ 0 的 ACK 报⽂，如果这个通告窗⼝的 ACK 报⽂在⽹络中丢失了，那麻烦就⼤了</strong>。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418182234840.png" alt="image-20210418182234840"></p><p>这会导致<strong>发送⽅⼀直等待接收⽅的⾮ 0 窗⼝通知，接收⽅也⼀直等待发送⽅的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象</strong>。</p><h4 id="5-3-3-2、如何解决窗口关闭时的死锁现象"><a href="#5-3-3-2、如何解决窗口关闭时的死锁现象" class="headerlink" title="5.3.3.2、如何解决窗口关闭时的死锁现象"></a>5.3.3.2、如何解决窗口关闭时的死锁现象</h4><p><strong>为了解决这个问题，TCP 为每个连接设有⼀个持续定时器，只要 TCP 连接⼀⽅收到对⽅的零窗⼝通知，就启动持续计时器</strong>。</p><p><strong>如果持续计时器超时，就会发送窗⼝探测 ( Window probe ) 报⽂，⽽对⽅在确认这个探测报⽂时，给出⾃⼰现在的接收窗⼝⼤⼩</strong>。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418182508676.png" alt="image-20210418182508676"></p><ul><li>如果接收窗⼝仍然为 0，那么收到这个报⽂的⼀⽅就会᯿新启动持续计时器；</li><li>如果接收窗⼝不是 0，那么死锁的局⾯就可以被打破了。</li></ul><p><strong>窗⼝探测的次数⼀般为 3 次，每次⼤约 30-60 秒（不同的实现可能会不⼀样）。如果 3 次过后接收窗⼝还是 0 的话，有的 TCP 实现就会发 RST 报⽂来中断连接</strong>。</p><h3 id="5-3-4、糊涂窗口综合症"><a href="#5-3-4、糊涂窗口综合症" class="headerlink" title="5.3.4、糊涂窗口综合症"></a>5.3.4、糊涂窗口综合症</h3><p>如果接收⽅太忙了，来不及取⾛接收窗⼝⾥的数据，那么就会导致发送⽅的发送窗⼝越来越⼩。</p><p>到最后，如果接收⽅腾出⼏个字节并告诉发送⽅现在有⼏个字节的窗⼝，⽽发送⽅会义⽆反顾地发送这⼏个字节，这就是糊涂窗⼝综合症。</p><p>要知道，我们的 TCP + IP 头有 40 个字节，为了传输那⼏个字节的数据，要达上这么⼤的开销，这太不经济了。</p><p>就好像⼀个可以承载 50 ⼈的⼤巴⻋，每次来了⼀两个⼈，就直接发⻋。除⾮家⾥有矿的⼤巴司机，才敢这样玩，不然迟早破产。要解决这个问题也不难，⼤巴司机等乘客数量超过了 25 个，才认定可以发车。</p><p>现举个糊涂窗⼝综合症的栗⼦，考虑以下场景：</p><p>接收⽅的窗⼝⼤⼩是 360 字节，但接收⽅由于某些原因陷⼊困境，假设接收⽅的应⽤层读取的能⼒如下：</p><ul><li>接收⽅每接收 3 个字节，应⽤程序就只能从缓冲区中读取 1 个字节的数据；</li><li>在下⼀个发送⽅的 TCP 段到达之前，应⽤程序还从缓冲区中读取了 40 个额外的字节；</li></ul><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418182907615.png" alt="image-20210418182907615"></p><p>每个过程的窗⼝⼤⼩的变化，在图中都描述的很清楚了，可以发现窗⼝不断减少了，并且发送的数据都 是⽐较⼩的了。</p><p>所以，糊涂窗⼝综合症的现象是可以发⽣在发送⽅和接收⽅：</p><ul><li>接收⽅可以通告⼀个⼩的窗⼝。</li><li>⽽发送⽅可以发送⼩数据。</li></ul><p>于是，要解决糊涂窗⼝综合症，就解决上⾯两个问题就可以了</p><ul><li>让接收⽅不通告⼩窗⼝给发送⽅。</li><li>让发送⽅避免发送⼩数据。</li></ul><h4 id="5-3-4-1、如何让接收方不通告小窗口"><a href="#5-3-4-1、如何让接收方不通告小窗口" class="headerlink" title="5.3.4.1、如何让接收方不通告小窗口"></a>5.3.4.1、如何让接收方不通告小窗口</h4><p>接收⽅通常的策略如下：</p><p><strong>当「窗⼝⼤⼩」⼩于 min( MSS，缓存空间&#x2F;2 ) ，也就是⼩于 MSS 与 1&#x2F;2 缓存⼤⼩中的最⼩值时，就会向发送⽅通告窗⼝为 0 ，也就阻⽌了发送⽅再发数据过来</strong>。</p><p>等到接收⽅处理了⼀些数据后，窗⼝⼤⼩ &gt;&#x3D; MSS，或者接收⽅缓存空间有⼀半可以使⽤，就可以把窗⼝打开让发送⽅发送数据过来。</p><h4 id="5-3-4-2、如何让发送方避免发送小数据"><a href="#5-3-4-2、如何让发送方避免发送小数据" class="headerlink" title="5.3.4.2、如何让发送方避免发送小数据"></a>5.3.4.2、如何让发送方避免发送小数据</h4><p>发送⽅通常的策略：</p><p><strong>使⽤ Nagle 算法，该算法的思路是延时处理，它满⾜以下两个条件中的⼀条才可以发送数据</strong>：</p><ul><li>要等到窗⼝⼤⼩ &gt;&#x3D; MSS 或是数据⼤⼩ &gt;&#x3D; MSS</li><li>收到之前发送数据的 ack 回包</li></ul><p><strong>只要没满⾜上⾯条件中的⼀条，发送⽅⼀直在囤积数据，直到满⾜上⾯的发送条件</strong>。</p><p>另外，<strong>Nagle 算法默认打开</strong>，如果对于⼀些需要⼩数据包交互的场景的程序，⽐如，telnet 或 ssh 这样的交互性⽐较强的程序，则需要关闭 Nagle 算法。</p><p>可以在 Socket 设置 TCP_NODELAY 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每 个应⽤⾃⼰的特点来关闭）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">setsockopt</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">,</span> <span class="token constant">IPPROTO_TCP</span><span class="token punctuation">,</span> <span class="token constant">TCP_NODELAY</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>value<span class="token punctuation">,</span> <span class="token function">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-4、拥塞控制"><a href="#4-4、拥塞控制" class="headerlink" title="4.4、拥塞控制"></a>4.4、拥塞控制</h2><h3 id="4-4-1、简介"><a href="#4-4-1、简介" class="headerlink" title="4.4.1、简介"></a>4.4.1、简介</h3><h4 id="4-4-1-1、为何需要拥塞控制"><a href="#4-4-1-1、为何需要拥塞控制" class="headerlink" title="4.4.1.1、为何需要拥塞控制"></a>4.4.1.1、为何需要拥塞控制</h4><p>前⾯的流量控制是避免「发送⽅」的数据填满「接收⽅」的缓存，但是并不知道⽹络中发⽣了什么。</p><p> ⼀般来说，计算机⽹络都处在⼀个共享的环境。因此也有可能会因为其他主机之间的通信使得⽹络拥堵。</p><p>在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传 数据，但是⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进 ⼊恶性循环被不断地放⼤…. 。</p><p>所以，TCP 不能忽略⽹络中发⽣的事，它被设计成⼀个⽆私的协议，当⽹络发送拥塞时，TCP 会⾃我 牺牲，降低发送的数据量。</p><p>于是，就有了<strong>拥塞控制，控制的⽬的就是避免「发送⽅」的数据填满整个⽹络</strong>。</p><p><strong>为了调节「发送⽅」所要发送数据的量，定义了⼀个叫做「拥塞窗⼝」的概念</strong>。</p><h4 id="4-4-1-2、何为拥塞窗口，与发送窗口有啥关系？"><a href="#4-4-1-2、何为拥塞窗口，与发送窗口有啥关系？" class="headerlink" title="4.4.1.2、何为拥塞窗口，与发送窗口有啥关系？"></a>4.4.1.2、何为拥塞窗口，与发送窗口有啥关系？</h4><p>拥塞窗⼝ cwnd是发送⽅维护的⼀个状态变量，它会根据⽹络的拥塞程度动态变化。</p><p>我们在前⾯提到过发送窗⼝ swnd 和接收窗⼝ rwnd 是约等于的关系，那么加⼊拥塞窗⼝的概念后，此时发送窗⼝的值是swnd &#x3D; min(cwnd, rwnd)，也就是拥塞窗⼝和接收窗⼝中的最⼩值。</p><p>拥塞窗⼝ cwnd 变化规则：</p><ul><li>⽹络中没有出现拥塞， cwnd 就会增⼤；</li><li>⽹络中出现了拥塞， cwnd 就减少；</li></ul><h4 id="4-4-1-3、如何判断网络拥塞了？"><a href="#4-4-1-3、如何判断网络拥塞了？" class="headerlink" title="4.4.1.3、如何判断网络拥塞了？"></a>4.4.1.3、如何判断网络拥塞了？</h4><p><strong>只要「发送⽅」没有在规定时间内接收到 ACK 应答报⽂，也就是发⽣了超时重传，就会认为⽹络出现了拥塞</strong>。</p><h4 id="4-4-1-4、拥塞控制算法"><a href="#4-4-1-4、拥塞控制算法" class="headerlink" title="4.4.1.4、拥塞控制算法"></a>4.4.1.4、拥塞控制算法</h4><p>拥塞控制主要四个算法：</p><ol><li>慢启动</li><li>拥塞避免</li><li>拥塞发⽣</li><li>快速恢复</li></ol><h3 id="4-4-2、慢启动"><a href="#4-4-2、慢启动" class="headerlink" title="4.4.2、慢启动"></a>4.4.2、慢启动</h3><p><strong>TCP 在刚建⽴连接完成后，⾸先有个慢启动过程，这个慢启动意思就是⼀点⼀点提⾼发送数据包的数量</strong>。如果⼀上来就发⼤量的数据，这不是给⽹络添堵吗？</p><p><strong>慢启动算法记住⼀个规则就⾏：当发送⽅每收到⼀个 ACK，拥塞窗⼝ cwnd 的⼤⼩就会加 1</strong>。</p><p>这⾥假定拥塞窗⼝ cwnd 和发送窗⼝ swnd 相等，下⾯举个栗⼦：</p><ul><li>连接建⽴完成后，⼀开始初始化 cwnd &#x3D; 1 ，表示可以传⼀个 MSS ⼤⼩的数据。</li><li>当收到⼀个 ACK 确认应答后，cwnd 增加 1，于是⼀次能够发送 2 个 </li><li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以⽐之前多发2 个，所以这⼀次能够发送 4 个</li><li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以⽐ 之前多发 4 个，所以这⼀次能够发送 8 个。</li></ul><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418184842512.png" alt="image-20210418184842512"></p><p>可以看出慢启动算法，发包的个数是指数性的增⻓。</p><h4 id="4-4-2-1、慢启动涨到什么时候结束"><a href="#4-4-2-1、慢启动涨到什么时候结束" class="headerlink" title="4.4.2.1、慢启动涨到什么时候结束"></a>4.4.2.1、慢启动涨到什么时候结束</h4><p>有⼀个叫慢启动⻔限 ssthresh （slow start threshold）状态变量。</p><ul><li>当 cwnd &lt; ssthresh 时，使⽤慢启动算法。</li><li>当 cwnd &gt;&#x3D; ssthresh 时，就会使⽤「拥塞避免算法」。</li></ul><h3 id="4-4-3、拥塞避免算法"><a href="#4-4-3、拥塞避免算法" class="headerlink" title="4.4.3、拥塞避免算法"></a>4.4.3、拥塞避免算法</h3><p>前⾯说道，当拥塞窗⼝ cwnd 「超过」慢启动⻔限 ssthresh 就会进⼊拥塞避免算法。</p><p>⼀般来说 ssthresh 的⼤⼩是 65535 字节。</p><p>那么进⼊拥塞避免算法后，它的规则是：每当收到⼀个 ACK 时，cwnd 增加 1&#x2F;cwnd。</p><p>接上前⾯的慢启动的栗⼦，现假定 ssthresh 为 8 ：</p><ul><li>当 8 个 ACK 应答确认到来时，每个确认增加 1&#x2F;8，8 个 ACK 确认 cwnd ⼀共增加 1，于是这⼀次 能够发送 9 个 MSS ⼤⼩的数据，变成了线性增⻓。</li></ul><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418190150299.png" alt="image-20210418190150299"></p><p>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增⻓变成了线性增⻓，还是增⻓阶 段，但是增⻓速度缓慢了⼀些。</p><p>就这么⼀直增⻓着后，⽹络就会慢慢进⼊了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失 的数据包进⾏᯿传。</p><p>当触发了重传机制，也就进⼊了「拥塞发⽣算法」</p><h3 id="4-4-4、拥塞发生"><a href="#4-4-4、拥塞发生" class="headerlink" title="4.4.4、拥塞发生"></a>4.4.4、拥塞发生</h3><p>当⽹络出现拥塞，也就是会发⽣数据包᯿传，重传机制主要有两种：</p><ul><li>超时重传</li><li>快速重传</li></ul><h4 id="4-4-4-1、超时重传拥塞发生算法"><a href="#4-4-4-1、超时重传拥塞发生算法" class="headerlink" title="4.4.4.1、超时重传拥塞发生算法"></a>4.4.4.1、超时重传拥塞发生算法</h4><p>当发⽣了「超时重传」，则就会使⽤拥塞发⽣算法。</p><p>这个时候，ssthresh 和 cwnd 的值会发⽣变化：</p><ul><li>ssthresh 设为 cwnd&#x2F;2。</li><li>cwnd ᯿置为 1。</li></ul><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418190500847.png" alt="image-20210418190500847"></p><p>接着，就᯿新开始慢启动，慢启动是会突然减少数据流的。这真是⼀旦「超时᯿传」，⻢上回到解放 前。但是这种⽅式太激进了，反应也很强烈，会造成⽹络卡顿。</p><p>就好像本来在秋名⼭⾼速漂移着，突然来个紧急刹⻋，轮胎受得了吗。</p><h4 id="4-4-4-2、快速重传拥塞发生算法"><a href="#4-4-4-2、快速重传拥塞发生算法" class="headerlink" title="4.4.4.2、快速重传拥塞发生算法"></a>4.4.4.2、快速重传拥塞发生算法</h4><p>还有更好的⽅式，前⾯我们讲过「快速᯿传算法」。当接收⽅发现丢了⼀个中间包的时候，发送三次前⼀个包的 ACK，于是发送端就会快速地᯿传，不必等待超时再᯿传。</p><p>TCP 认为这种情况不严重，因为⼤部分没丢，只丢了⼀⼩部分，则 ssthresh 和 cwnd 变化如下：</p><ul><li>cwnd &#x3D; cwnd&#x2F;2 ，也就是设置为原来的⼀半;</li><li>ssthresh &#x3D; cwnd ;</li><li>进⼊快速恢复算法</li></ul><h3 id="4-4-5、快速恢复"><a href="#4-4-5、快速恢复" class="headerlink" title="4.4.5、快速恢复"></a>4.4.5、快速恢复</h3><p>快速重传和快速恢复算法⼀般同时使⽤，快速恢复算法是认为，你还能收到 3 个᯿复 ACK 说明⽹络也 不那么糟糕，所以没有必要像 RTO 超时那么强烈。</p><p>正如前⾯所说，进⼊快速恢复之前， cwnd 和 ssthresh 已被更新了：</p><ul><li>cwnd &#x3D; cwnd&#x2F;2 ，也就是设置为原来的⼀半;</li><li>ssthresh &#x3D; cwnd ;</li></ul><p>然后，进⼊快速恢复算法如下： </p><ul><li>拥塞窗⼝ cwnd &#x3D; ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到᯿复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第⼀步中的 ssthresh 的值，原因是该 ACK 确认了新 的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的 状态了，也即再次进⼊拥塞避免状态；</li></ul><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418190824253.png" alt="image-20210418190824253"></p><p>也就是没有像「超时᯿传」⼀夜回到解放前，⽽是还在⽐较⾼的值，后续呈线性增⻓。</p><h3 id="4-4-6、拥塞算法示意图"><a href="#4-4-6、拥塞算法示意图" class="headerlink" title="4.4.6、拥塞算法示意图"></a>4.4.6、拥塞算法示意图</h3><p>好了，以上就是拥塞控制的全部内容了，看完后，你再来看下⾯这张图⽚，每个过程我相信你都能明⽩：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418190933705.png" alt="image-20210418190933705"></p><h1 id="5、TCP性能传输"><a href="#5、TCP性能传输" class="headerlink" title="5、TCP性能传输"></a>5、TCP性能传输</h1><h2 id="5-1、提升TCP三次握手性能"><a href="#5-1、提升TCP三次握手性能" class="headerlink" title="5.1、提升TCP三次握手性能"></a>5.1、提升TCP三次握手性能</h2><p><font color='orange'>TCP 是⾯向连接的、可靠的、双向传输的传输层通信协议。在传输数据之前需要经过三次握⼿才能 建⽴连接。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418200853587.png" alt="image-20210418200853587"></p><p>那么，三次握⼿时间消耗在⼀个 HTTP 请求的平均时间中占⽐ 10% 以上，在⽹络状态不佳、⾼并发或者遭遇 SYN 攻击等场景中，如果不能有效正确的调节三次握⼿中的参数，就会对性能产⽣很多的影响。</p><p>如何正确有效的使⽤这些参数，来提⾼ TCP 三次握⼿的性能，这就需要理解「三次握⼿的状态变迁」，<font color='orange'>当出现问题时，先⽤ netstat 命令查看是哪个握⼿阶段出现问题，再来对症下药，⽽不是病急乱投医。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418200928818.png" alt="image-20210418200928818"></p><p><font color='orange'>客户端和服务端都可以通过三次握⼿优化性能。主动发起连接的客户端优化相对简单些，⽽服务端需要 监听端⼝，属于被动连接⽅，其间保持许多的中间状态，优化⽅法相对复杂⼀些。</font></p><p>所以，客户端（主动发起连接⽅）和服务端（被动连接⽅）优化的⽅式是不同的，接下来分别针对客户端和服务端来进行优化。</p><h3 id="5-1-1、客户端优化"><a href="#5-1-1、客户端优化" class="headerlink" title="5.1.1、客户端优化"></a>5.1.1、客户端优化</h3><p><font color='orange'>三次握⼿ 建⽴连接 ⾸要⽬的是 同步序列号</font>。</p><p>SYN 的全称就叫 Synchronize Sequence Numbers（同步序列号）。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418201102398.png" alt="image-20210418201102398"></p><h4 id="5-1-1-1、SYN-SENT-状态优化"><a href="#5-1-1-1、SYN-SENT-状态优化" class="headerlink" title="5.1.1.1、SYN_SENT 状态优化"></a>5.1.1.1、SYN_SENT 状态优化</h4><p>客户端 先发送 SYN 包，然后进入 SYN_SENT 状态。</p><p>如果客户端⻓时间没有收到 SYN+ACK 报⽂，则会重发 SYN 包，重发次数由 tcp_syn_retries 参数控制， 默认是 5 次：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202018005.png" alt="image-20210418202018005"></p><p>通常，第⼀次超时重传是在 1 秒后，第⼆次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。<font color='orange'>每次超时的时间是上⼀次的 2 倍。</font>当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就会终⽌三次握⼿。</p><p><font color='orange'>所以，总耗时是 1+2+4+8+16+32&#x3D;63 秒，⼤约 1 分钟左右。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202153188.png" alt="image-20210418202153188"></p><p>客户端优化参考如下：<font color="orange">根据 ⽹络稳定性 和 服务器繁忙程度 来修改 SYN 重传次数，调整客户端三次握⼿时间上限。</font></p><h3 id="5-1-2、服务端优化"><a href="#5-1-2、服务端优化" class="headerlink" title="5.1.2、服务端优化"></a>5.1.2、服务端优化</h3><p>服务端收到 SYN 包后会⽴⻢回复 SYN+ACK 包，表明收到了客户端序列号，同时也把⾃⼰的序列号发给对⽅。</p><p><font color='orange'>服务端 收到 新连接 就会 进入SYN_RCV状态，同时 Linux 内核就会建⽴⼀个「半连接队列」来维护「未完成」的握⼿信息，当半连接队列溢出后，服务端就⽆法再建⽴新连接。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202233550.png" alt="image-20210418202233550"></p><p>SYN 攻击半连接队列。</p><h4 id="5-1-2-1、如何查看由于-SYN-半连接队列已满⽽被丢弃连接的情况？"><a href="#5-1-2-1、如何查看由于-SYN-半连接队列已满⽽被丢弃连接的情况？" class="headerlink" title="5.1.2.1、如何查看由于 SYN 半连接队列已满⽽被丢弃连接的情况？"></a>5.1.2.1、如何查看由于 SYN 半连接队列已满⽽被丢弃连接的情况？</h4><p><font color='orange'>可以从 <code>netstat -s</code> 命令返回的统计结果中得到由于半连接队列已满而引发的失败次数：</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202341149.png" alt="image-20210418202341149"></p><p>上⾯输出的数值是累计值，表示共有多少个 TCP 连接因半连接队列溢出⽽被丢弃。隔⼏秒执⾏⼏次，如果有上升趋势，说明当前存在半连接队列溢出现象。</p><h4 id="5-1-2-2、如何调整-SYN-半连接队列⼤⼩？"><a href="#5-1-2-2、如何调整-SYN-半连接队列⼤⼩？" class="headerlink" title="5.1.2.2、如何调整 SYN 半连接队列⼤⼩？"></a>5.1.2.2、如何调整 SYN 半连接队列⼤⼩？</h4><p><font color='orange'>要想增⼤ 半连接队列，不仅需要增大 <code>tcp_max_syn_backlog</code> 的值，还需增⼤ accept 队列。两者缺一不可，否则⽆效。</font></p><p>增⼤ <code>tcp_max_syn_backlog</code> 和 <code>somaxconn</code> 的⽅法是修改 Linux 内核参数：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202433581.png" alt="image-20210418202433581"></p><p>增⼤ backlog 的⽅式，每个 Web 服务都不同，⽐如 Nginx 增⼤ backlog 的⽅法如下：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202450402.png" alt="image-20210418202450402"></p><p>最后，改变了如上这些参数后，要᯿启 Nginx 服务，因为 SYN 半连接队列和 accept 队列都是在 listen() 初始化的。</p><h4 id="5-1-2-3、如果-SYN-半连接队列已满，只能丢弃连接吗？"><a href="#5-1-2-3、如果-SYN-半连接队列已满，只能丢弃连接吗？" class="headerlink" title="5.1.2.3、如果 SYN 半连接队列已满，只能丢弃连接吗？"></a>5.1.2.3、如果 SYN 半连接队列已满，只能丢弃连接吗？</h4><p><font color='orange'>事实并非如此，开启 syncookies 功能就可实现不使⽤ SYN 半连接队列的情况下成功建⽴连接。</font></p><p><font color='orange'>syncookies ⼯作原理：服务器根据当前状态计算出⼀个值，放在⼰⽅的 SYN+ACK 报⽂中并发出，当客户端返回 ACK 报⽂时，取出该值验证，如果合法，就认为连接建⽴成功，</font>如下图所示。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202537593.png" alt="image-20210418202537593"></p><p>syncookies 参数主要有以下三个值：</p><ul><li>0：表示关闭该功能；</li><li>1：表示仅当 SYN 半连接队列放不下时，再启⽤它；</li><li>2：表示⽆条件开启功能；</li></ul><p><font color='orange'>在应对 SYN 攻击时，只需设为 1 即可：</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202615907.png" alt="image-20210418202615907"></p><h4 id="5-1-2-4、SYN-RCV-状态优化"><a href="#5-1-2-4、SYN-RCV-状态优化" class="headerlink" title="5.1.2.4、SYN_RCV 状态优化"></a>5.1.2.4、SYN_RCV 状态优化</h4><p>当客户端接收到服务器发来的 SYN+ACK 报⽂后，就会回复 ACK 给服务器，同时客户端连接状态从 SYN_SENT 转换为 ESTABLISHED，表示连接建⽴成功。</p><p>服务器端连接成功建⽴的时间还要再往后，等到服务端收到客户端的 ACK 后，服务端的连接状态才变 为 ESTABLISHED。</p><p>如果服务器没有收到 ACK，就会重发 SYN+ACK 报⽂，同时⼀直处于 SYN_RCV 状态。</p><p>当⽹络繁忙、不稳定时，报⽂丢失就会变严重，此时应该调⼤᯿发次数。反之则可以调⼩重发次数。修改重发次数的⽅法是，调整 tcp_synack_retries 参数：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202715040.png" alt="image-20210418202715040"></p><p>tcp_synack_retries 的默认重试次数是 5 次，与客户端重传 SYN 类似，它的重传会经历 1、2、4、8、 16 秒，最后⼀次重传后会继续等待 32 秒，如果服务端仍然没有收到 ACK，才会关闭连接，故共需要等待 63 秒。</p><p>服务器收到 ACK 后连接建⽴成功，此时，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调⽤ accept 函数时把连接取出来。</p><p>如果进程不能及时地调⽤ accept 函数，就会造成 accept 队列（也称全连接队列）溢出，最终导致建⽴ 好的 TCP 连接被丢弃。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202743734.png" alt="image-20210418202743734"></p><h4 id="5-1-2-5、accept-队列已满，只能丢弃连接吗？"><a href="#5-1-2-5、accept-队列已满，只能丢弃连接吗？" class="headerlink" title="5.1.2.5、accept 队列已满，只能丢弃连接吗？"></a>5.1.2.5、accept 队列已满，只能丢弃连接吗？</h4><p>丢弃连接只是 Linux 的默认⾏为，我们还可以选择向客户端发送 RST 复位报⽂，告诉客户端连接已经 建⽴失败。打开这⼀功能需要将 tcp_abort_on_overflow 参数设置为 1。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202819569.png" alt="image-20210418202819569"></p><p>tcp_abort_on_overflow 共有两个值分别是 0 和 1，其分别表示：</p><ul><li>0 ：如果 accept 队列满了，那么 server 扔掉 client 发过来的 ack ；</li><li>1 ：如果 accept 队列满了，server 发送⼀个 RST 包给 client，表示废掉这个握⼿过程和这个连接；</li></ul><p>如果要想知道客户端连接不上服务端，是不是服务端 TCP 全连接队列满的原因，那么可以把 tcp_abort_on_overflow 设置为 1，这时如果在客户端异常中可以看到很多 connection reset by peer 的错误，那么就可以证明是由于服务端 TCP 全连接队列溢出的问题。</p><p>通常情况下，应当把 tcp_abort_on_overflow 设置为 0，因为这样更有利于应对突发流量。</p><p>举个例⼦，当 accept 队列满导致服务器丢掉了 ACK，与此同时，客户端的连接状态却是 ESTABLISHED，客户端进程就在建⽴好的连接上发送请求。只要服务器没有为请求回复 ACK，客户端 的请求就会被多次「᯿发」。如果服务器上的进程只是短暂的繁忙造成 accept 队列满，那么当 accept 队列有空位时，再次接收到的请求报⽂由于含有 ACK，仍然会触发服务器端成功建⽴连接。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202908422.png" alt="image-20210418202908422"></p><p>所以，tcp_abort_on_overflow 设为 0 可以提⾼连接建⽴的成功率，只有你⾮常肯定 TCP 全连接队列会 ⻓期溢出时，才能设置为 1 以尽快通知客户端。</p><h4 id="5-1-2-6、如何调整-accept-队列的⻓度？"><a href="#5-1-2-6、如何调整-accept-队列的⻓度？" class="headerlink" title="5.1.2.6、如何调整 accept 队列的⻓度？"></a>5.1.2.6、如何调整 accept 队列的⻓度？</h4><p>可以通过 ss -lnt 命令查看：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202957783.png" alt="image-20210418202957783"></p><ul><li>Recv-Q：当前 accept 队列的⼤⼩，也就是当前已完成三次握⼿并等待服务端 accept() 的 TCP 连接；</li><li>Send-Q：accept 队列最⼤⻓度，上⾯的输出结果说明监听 8088 端⼝的 TCP 服务，accept 队列的 最⼤⻓度为 128；</li></ul><h4 id="5-1-2-7、如何查看由于-accept-连接队列已满，⽽被丢弃的连接？"><a href="#5-1-2-7、如何查看由于-accept-连接队列已满，⽽被丢弃的连接？" class="headerlink" title="5.1.2.7、如何查看由于 accept 连接队列已满，⽽被丢弃的连接？"></a>5.1.2.7、如何查看由于 accept 连接队列已满，⽽被丢弃的连接？</h4><p><font color='orange'>当超过了 accept 连接队列，服务端则会丢掉后续进来的 TCP 连接，丢掉的 TCP 连接的个数会被统计 起来，我们可以使⽤ netstat -s 命令来查看：</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418203046836.png" alt="image-20210418203046836"></p><p>上⾯看到的 41150 times ，表示 accept 队列溢出的次数，注意这个是累计值。可以隔⼏秒钟执⾏下， 如果这个数字⼀直在增加的话，说明 accept 连接队列偶尔满了。</p><p>如果持续不断地有连接因为 accept 队列溢出被丢弃，就应该调⼤ backlog 以及 somaxconn 参数。</p><h3 id="5-1-3、如何绕过三次握手"><a href="#5-1-3、如何绕过三次握手" class="headerlink" title="5.1.3、如何绕过三次握手"></a>5.1.3、如何绕过三次握手</h3><p>下面我们看看如何绕过三次握⼿发送数据。</p><p>三次握⼿建⽴连接造成的后果就是，HTTP 请求必须在⼀个 RTT（客户端到服务器⼀个往返时间） 后才能发送。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418203159568.png" alt="image-20210418203159568"></p><p><font color='orange'>在 Linux 3.7 内核版本之后，提供了 TCP Fast Open 功能，这个功能可以减少 TCP 连接建⽴的时延。</font></p><h4 id="5-1-3-1、TCP-Fast-Open-⼯作⽅式。"><a href="#5-1-3-1、TCP-Fast-Open-⼯作⽅式。" class="headerlink" title="5.1.3.1、TCP Fast Open ⼯作⽅式。"></a>5.1.3.1、TCP Fast Open ⼯作⽅式。</h4><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418203407354.png" alt="image-20210418203407354"></p><p>在客户端⾸次建⽴连接时的过程：</p><ol><li>客户端发送 SYN 报⽂，该报⽂包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie；</li><li>⽀持 TCP Fast Open 的服务器⽣成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以 发回客户端；</li><li>客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。</li></ol><p>所以，第⼀次发起 HTTP GET 请求的时候，还是需要正常的三次握⼿流程。</p><p>之后，如果客户端再次向服务器建⽴连接时的过程：</p><ol><li>客户端发送 SYN 报⽂，该报⽂包含「数据」（对于⾮ TFO 的普通 TCP 握⼿过程，SYN 报⽂中不 包含「数据」）以及此前记录的 Cookie；</li><li>⽀持 TCP Fast Open 的服务器会对收到 Cookie 进⾏校验：如果 Cookie 有效，服务器将在 SYNACK 报⽂中对 SYN 和「数据」进⾏确认，服务器随后将「数据」递送⾄相应的应⽤程序；如果 Cookie ⽆效，服务器将丢弃 SYN 报⽂中包含的「数据」，且其随后发出的 SYN-ACK 报⽂将只确 认 SYN 的对应序列号；</li><li>如果服务器接受了 SYN 报⽂中的「数据」，服务器可在握⼿完成之前发送「数据」，这就减少了 握⼿带来的 1 个 RTT 的时间消耗；</li><li>客户端将发送 ACK 确认服务器发回的 SYN 以及「数据」，但如果客户端在初始的 SYN 报⽂中发 送的「数据」没有被确认，则客户端将᯿新发送「数据」；</li><li>此后的 TCP 连接的数据传输过程和⾮ TFO 的正常情况⼀致。</li></ol><p>所以，之后发起 HTTP GET 请求的时候，可以绕过三次握⼿，这就减少了握⼿带来的 1 个 RTT 的时间消耗。</p><p>开启了 TFO 功能，cookie 的值是存放到 TCP option 字段⾥的：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418203616446.png" alt="image-20210418203616446"></p><p>注：客户端在请求并存储了 Fast Open Cookie 之后，可以不断᯿复 TCP Fast Open 直⾄服务器认为 Cookie ⽆效（通常为过期）。</p><h4 id="5-1-3-2、Linux-下如何打开-TCP-Fast-Open-功能"><a href="#5-1-3-2、Linux-下如何打开-TCP-Fast-Open-功能" class="headerlink" title="5.1.3.2、Linux 下如何打开 TCP Fast Open 功能"></a>5.1.3.2、Linux 下如何打开 TCP Fast Open 功能</h4><p><font color='orange'>Linux环境中可通过设置 tcp_fastopn 内核参数，来打开 Fast Open 功能：</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418203701456.png" alt="image-20210418203701456"></p><p>tcp_fastopn 各个值的意义：</p><ul><li>0 关闭 1 作为客户端使⽤ Fast Open 功能；</li><li>2 作为服务端使⽤ Fast Open 功能；</li><li>3 ⽆论作为客户端还是服务器，都可以使⽤ Fast Open 功能；</li></ul><p>TCP Fast Open 功能需要客户端和服务端同时⽀持，才有效果。</p><h3 id="5-1-4、小结"><a href="#5-1-4、小结" class="headerlink" title="5.1.4、小结"></a>5.1.4、小结</h3><p>本⼩结主要介绍了关于优化 TCP 三次握⼿的⼏个 TCP 参数。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418203828453.png" alt="image-20210418203828453"></p><h4 id="5-1-4-1、客户端优化"><a href="#5-1-4-1、客户端优化" class="headerlink" title="5.1.4.1、客户端优化"></a>5.1.4.1、客户端优化</h4><p><font color='orange'>当客户端发起 SYN 包时，可以通过 <code>tcp_syn_retries</code> 控制其重传次数。</font ></p><h4 id="5-1-4-2、服务端优化"><a href="#5-1-4-2、服务端优化" class="headerlink" title="5.1.4.2、服务端优化"></a>5.1.4.2、服务端优化</h4><p>当服务端 SYN 半连接队列溢出后，会导致后续连接被丢弃，可以通过 netstat -s 观察半连接队列溢出的情况，如果 SYN 半连接队列溢出情况⽐较严重，可以通过 <code>tcp_max_syn_backlog</code>、<code>somaxconn</code>、 <code>backlog</code> 参数来调整 SYN 半连接队列的⼤⼩。</p><p>服务端回复 SYN+ACK 的᯿传次数由 <code>tcp_synack_retries</code> 参数控制。如果遭受 SYN 攻击，应把 <code>tcp_syncookies</code> 参数设置为 1，表示仅在 SYN 队列满后开启 syncookie 功能，可以保证正常的连接 成功建⽴。</p><p>服务端收到客户端返回的 ACK，会把连接移⼊ accpet 队列，等待进⾏调⽤ accpet() 函数取出连接。</p><p>可以通过 ss -lnt 查看服务端进程的 accept 队列⻓度，如果 accept 队列溢出，系统默认丢弃 ACK，如果可以把 <code>tcp_abort_on_overflow</code> 设置为 1 ，表示⽤ RST 通知客户端连接建⽴失败。</p><p>如果 accpet 队列溢出严重，可以通过 listen 函数的 backlog 参数和 somaxconn 系统参数提⾼队列⼤ ⼩，accept 队列⻓度取决于 min(backlog, somaxconn)。</p><h4 id="5-1-4-3、绕过三次握手"><a href="#5-1-4-3、绕过三次握手" class="headerlink" title="5.1.4.3、绕过三次握手"></a>5.1.4.3、绕过三次握手</h4><p><font color='orange'>TCP Fast Open 功能可以绕过三次握⼿，使得 HTTP 请求减少 1 个 RTT 时间，Linux 下可以通过 <code>tcp_fastopen</code> 开启该功能，同时必须保证服务端和客户端同时⽀持。</font></p><h2 id="5-2、提升TCP四次挥手性能"><a href="#5-2、提升TCP四次挥手性能" class="headerlink" title="5.2、提升TCP四次挥手性能"></a>5.2、提升TCP四次挥手性能</h2><p>开始之前，需要先了解四次挥⼿状态变迁过程。 </p><p><font color='orange'>客户端和服务端双⽅都可以 主动断开连接，通常先关闭连接的⼀⽅称为 主动⽅，后关闭连接的⼀⽅称为 被动⽅。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418204051701.png" alt="image-20210418204051701"></p><p>可以看到，四次挥⼿过程只涉及了两种报⽂，分别是 FIN 和 ACK：</p><ul><li>FIN 就是结束连接的意思，谁发出 FIN 报⽂，就表示它将不会再发送任何数据，关闭这⼀⽅向上的 传输通道；</li><li>ACK 就是确认的意思，⽤来通知对⽅：你⽅的发送通道已经关闭；</li></ul><p>四次挥⼿过程：</p><ol><li>当主动⽅关闭连接时，会发送 FIN 报⽂，此时发送⽅的 TCP 连接将从 ESTABLISHED 变成 FIN_WAIT1。</li><li>当被动⽅收到 FIN 报⽂后会⾃动回复 ACK 报⽂，连接状态将从 ESTABLISHED 变成 CLOSE_WAIT，表示被动⽅在等待进程调⽤ close 函数关闭连接。</li><li>当主动⽅收到这个 ACK 后，连接状态由 FIN_WAIT1 变为 FIN_WAIT2，也就是表示主动⽅的发送通 道就关闭了。</li><li>当被动⽅进⼊ CLOSE_WAIT 时，被动⽅还会继续处理数据，等到进程的 read 函数返回 0 后，应⽤ 程序就会调⽤ close 函数，进⽽触发内核发送 FIN 报⽂，此时被动⽅的连接状态变为 LAST_ACK。</li><li>当主动⽅收到这个 FIN 报⽂后，内核会回复 ACK 报⽂给被动⽅，同时主动⽅的连接状态由 FIN_WAIT2 变为 TIME_WAIT，在 Linux 系统下⼤约等待 1 分钟后，TIME_WAIT 状态的连接才会 彻底关闭。</li><li>当被动⽅收到最后的 ACK 报⽂后，被动⽅的连接就会关闭。</li></ol><p>你可以看到，每个⽅向都需要⼀个 FIN 和⼀个 ACK，因此通常被称为 四次挥⼿。</p><p><font color='red'>注意：主动关闭连接的，才有 TIME_WAIT 状态。</font></p><h3 id="5-2-1、主动方优化"><a href="#5-2-1、主动方优化" class="headerlink" title="5.2.1、主动方优化"></a>5.2.1、主动方优化</h3><p><font color='orange'>关闭连接的⽅式通常有两种，分别是 RST报⽂关闭 和 FIN报⽂关闭。</font></p><p>如果进程异常退出了，内核就会发送 RST 报⽂来关闭，它可以不⾛四次挥⼿流程，是⼀个暴⼒关闭连接的⽅式。</p><p>安全关闭连接的⽅式必须通过四次挥⼿，它由进程调⽤ close 和 shutdown 函数发起 FIN 报⽂ （shutdown 参数须传⼊ <code>SHUT_WR</code> 或者 <code>SHUT_RDWR</code> 才会发送 FIN）。</p><h4 id="5-2-1-1、-close-函数和-shutdown-函数有什么区别？"><a href="#5-2-1-1、-close-函数和-shutdown-函数有什么区别？" class="headerlink" title="5.2.1.1、 close 函数和 shutdown 函数有什么区别？"></a>5.2.1.1、 close 函数和 shutdown 函数有什么区别？</h4><p>调⽤了 close 函数意味着完全断开连接，完全断开后⽆法传输数据，且也不能发送数据。 此时， 调⽤了 close 函数的⼀⽅的连接叫做「孤⼉连接」，如果你⽤ netstat -p 命令，会发现连接对应的进程名为空。</p><p>使⽤ close 函数关闭连接是不优雅的。于是，就出现了⼀种优雅关闭连接的 shutdown 函数，它可以控制只关闭⼀个⽅向的连接：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418204332745.png" alt="image-20210418204332745"></p><p>第⼆个参数决定断开连接的⽅式，主要有以下三种⽅式：</p><ul><li>SHUT_RD(0)：关闭连接的「读」这个⽅向，如果接收缓冲区有已接收的数据，则将会被丢弃，并 且后续再收到新的数据，会对数据进⾏ ACK，然后悄悄地丢弃。也就是说，对端还是会接收到 ACK，在这种情况下根本不知道数据已经被丢弃了。</li><li>SHUT_WR(1)：关闭连接的「写」这个⽅向，这就是常被称为「半关闭」的连接。如果发送缓冲区 还有未发送的数据，将被⽴即发送出去，并发送⼀个 FIN 报⽂给对端。</li><li>SHUT_RDWR(2)：相当于 SHUT_RD 和 SHUT_WR 操作各⼀次，关闭套接字的读和写两个⽅向。</li></ul><p>close 和 shutdown 函数都可以关闭连接，但这两种⽅式关闭的连接，不仅仅在功能上存在差异，控制它们的 Linux 参数也不相同。</p><h4 id="5-2-1-2、FIN-WAIT1-状态的优化"><a href="#5-2-1-2、FIN-WAIT1-状态的优化" class="headerlink" title="5.2.1.2、FIN_WAIT1 状态的优化"></a>5.2.1.2、FIN_WAIT1 状态的优化</h4><p>主动⽅发送 FIN 报⽂后，连接就处于 FIN_WAIT1 状态，正常情况下，如果能及时收到被动⽅的 ACK， 则会很快变为 FIN_WAIT2 状态。</p><p>但是当迟迟收不到对⽅返回的 ACK 时，连接就会⼀直处于 FIN_WAIT1 状态。此时，内核会定时重发 FIN 报⽂，其中重发次数由 <code>tcp_orphan_retries</code> 参数控制（注意，orphan 虽然是孤⼉的意思，该参数 却不只对孤⼉连接有效，事实上，它对所有 FIN_WAIT1 状态下的连接都有效），默认值是 0。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418204448802.png" alt="image-20210418204448802"></p><p>你可能会好奇，这 0 表示⼏次？实际上当为 0 时，特指 8 次，从下⾯的内核源码可知：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418204505382.png" alt="image-20210418204505382"></p><p>如果 FIN_WAIT1 状态连接很多，我们就需要考虑降低 tcp_orphan_retries 的值，当᯿传次数超过 tcp_orphan_retries 时，连接就会直接关闭掉。</p><p>对于普遍正常情况时，调低 tcp_orphan_retries 就已经可以了。如果遇到恶意攻击，FIN 报⽂根本⽆法 发送出去，这由 TCP 两个特性导致的：</p><ul><li>⾸先，TCP 必须保证报⽂是有序发送的，FIN 报⽂也不例外，当发送缓冲区还有数据没有发送时， FIN 报⽂也不能提前发送。</li><li>其次，TCP 有流量控制功能，当接收⽅接收窗⼝为 0 时，发送⽅就不能再发送数据。所以，当攻击 者下载⼤⽂件时，就可以通过接收窗⼝设为 0 ，这就会使得 FIN 报⽂都⽆法发送出去，那么连接会 ⼀直处于 FIN_WAIT1 状态。</li></ul><p>解决这种问题的⽅法，是调整 tcp_max_orphans 参数，它定义了「孤⼉连接」的最⼤数量：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418204559635.png" alt="image-20210418204559635"></p><p>当进程调⽤了 close 函数关闭连接，此时连接就会是「孤⼉连接」，因为它⽆法再发送和接收数据。 Linux 系统为了防⽌孤⼉连接过多，导致系统资源⻓时间被占⽤，就提供了 tcp_max_orphans 参数。 如果孤⼉连接数量⼤于它，新增的孤⼉连接将不再⾛四次挥⼿，⽽是直接发送 RST 复位报⽂强制关 闭。</p><h4 id="5-2-1-3、FIN-WAIT2-状态的优化"><a href="#5-2-1-3、FIN-WAIT2-状态的优化" class="headerlink" title="5.2.1.3、FIN_WAIT2 状态的优化"></a>5.2.1.3、FIN_WAIT2 状态的优化</h4><p>当主动⽅收到 ACK 报⽂后，会处于 FIN_WAIT2 状态，就表示主动⽅的发送通道已经关闭，接下来将等待对⽅发送 FIN 报⽂，关闭对⽅的发送通道。</p><p>这时，如果连接是⽤ shutdown 函数关闭的，连接可以⼀直处于 FIN_WAIT2 状态，因为它可能还可以 发送或接收数据。但对于 close 函数关闭的孤⼉连接，由于⽆法再发送和接收数据，所以这个状态不可以持续太久，⽽ tcp_fin_timeout 控制了这个状态下连接的持续时⻓，默认值是 60 秒：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418204818957.png" alt="image-20210418204818957"></p><p>它意味着对于孤⼉连接（调⽤ close 关闭的连接），如果在 60 秒后还没有收到 FIN 报⽂，连接就会直 接关闭。</p><p>这个 60 秒不是随便决定的，它与 TIME_WAIT 状态持续的时间是相同的，后⾯我们再来说说为什么是 60 秒。</p><h4 id="5-2-1-4、TIME-WAIT-状态的优化"><a href="#5-2-1-4、TIME-WAIT-状态的优化" class="headerlink" title="5.2.1.4、TIME_WAIT 状态的优化"></a>5.2.1.4、TIME_WAIT 状态的优化</h4><p>TIME_WAIT 是主动⽅四次挥⼿的最后⼀个状态，也是最常遇⻅的状态。</p><p>当收到被动⽅发来的 FIN 报⽂后，主动⽅会⽴刻回复 ACK，表示确认对⽅的发送通道已经关闭，接着 就处于 TIME_WAIT 状态。在 Linux 系统，TIME_WAIT 状态会持续 60 秒后才会进⼊关闭状态。</p><p>TIME_WAIT 状态的连接，在主动⽅看来确实快已经关闭了。然后，被动⽅没有收到 ACK 报⽂前，还是处于 <code>LAST_ACK</code> 状态。如果这个 ACK 报⽂没有到达被动⽅，被动⽅就会重发 FIN 报⽂。重发次数仍然由前⾯介绍过的 <code>tcp_orphan_retries</code>参数控制。</p><p>TIME-WAIT 的状态尤其重要，主要是两个原因：</p><ul><li>防⽌具有相同「四元组」的「旧」数据包被收到；</li><li>保证「被动关闭连接」的⼀⽅能被正确的关闭，即保证最后的 ACK 能让被动关闭⽅接收，从⽽帮 助其正常关闭；</li></ul><p><strong>原因⼀：防⽌旧连接的数据包</strong></p><p>TIME-WAIT 的⼀个作⽤是防⽌收到历史数据，从⽽导致数据错乱的问题。</p><p>假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发⽣什么呢？</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205021190.png" alt="image-20210418205021190"></p><ul><li>如上图⻩⾊框框服务端在关闭连接之前发送的 SEQ &#x3D; 301 报⽂，被⽹络延迟了。</li><li>这时有相同端⼝的 TCP 连接被复⽤后，被延迟的 SEQ &#x3D; 301 抵达了客户端，那么客户端是有可能 正常接收这个过期的报⽂，这就会产⽣数据错乱等严᯿的问题。</li></ul><p>所以，TCP 就设计出了这么⼀个机制，经过 2MSL 这个时间，⾜以让两个⽅向上的数据包都被丢弃， 使得原来连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣的。</p><p><strong>原因⼆：保证连接正确关闭</strong></p><p>TIME-WAIT 的另外⼀个作⽤是等待⾜够的时间以确保最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正 常关闭。</p><p>假设 TIME-WAIT 没有等待时间或时间过短，断开连接会造成什么问题呢？</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205117533.png" alt="image-20210418205117533"></p><ul><li>如上图红⾊框框客户端四次挥⼿的最后⼀个 ACK 报⽂如果在⽹络中被丢失了，此时如果客户端 TIME-WAIT 过短或没有，则就直接进⼊了 CLOSE 状态了，那么服务端则会⼀直处在 LAST-ACK 状态。</li><li>当客户端发起建⽴连接的 SYN 请求报⽂后，服务端会发送 RST 报⽂给客户端，连接建⽴的过程 就会被终⽌。</li></ul><p>我们再回过头来看看，为什么 TIME_WAIT 状态要保持 60 秒呢？这与孤⼉连接 FIN_WAIT2 状态默认保 留 60 秒的原理是⼀样的，因为这两个状态都需要保持 2MSL 时⻓。MSL 全称是 Maximum Segment Lifetime，它定义了⼀个报⽂在⽹络中的最⻓⽣存时间（报⽂每经过⼀次路由器的转发，IP 头部的 TTL 字段就会减 1，减到 0 时报⽂就被丢弃，这就限制了报⽂的最⻓存活时间）。</p><p>为什么是 2 MSL 的时⻓呢？这其实是相当于⾄少允许报⽂丢失⼀次。⽐如，若 ACK 在⼀个 MSL 内丢 失，这样被动⽅᯿发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。</p><p>为什么不是 4 或者 8 MSL 的时⻓呢？你可以想象⼀个丢包率达到百分之⼀的糟糕⽹络，连续两次丢包 的概率只有万分之⼀，这个概率实在是太⼩了，忽略它⽐解决它更具性价⽐。</p><p>因此，TIME_WAIT 和 FIN_WAIT2 状态的最⼤时⻓都是 2 MSL，由于在 Linux 系统中，MSL 的值固定 为 30 秒，所以它们都是 60 秒。</p><p>虽然 TIME_WAIT 状态有存在的必要，但它毕竟会消耗系统资源。如果发起连接⼀⽅的 TIME_WAIT 状 态过多，占满了所有端⼝资源，则会导致⽆法创建新连接。 </p><ul><li><p>客户端受端⼝资源限制</p><p>如果客户端 TIME_WAIT 过多，就会导致端⼝资源被占⽤，因为端⼝就 65536个，被占满就会导致⽆法创建新的连接；</p></li><li><p>服务端受系统资源限制</p><p>由于⼀个四元组表示TCP连接，理论上服务端可以建⽴很多连接，服务端 确实只监听⼀个端⼝，但是会把连接扔给处理线程，所以理论上监听的端⼝可以继续监听。但是线 程池处理不了那么多⼀直不断的连接了。所以当服务端出现⼤量 TIME_WAIT 时，系统资源被占满 时，会导致处理不过来新的连接；</p></li></ul><p>另外，Linux 提供了 tcp_max_tw_buckets 参数，当 TIME_WAIT 的连接数量超过该参数时，新关闭 的连接就不再经历 TIME_WAIT ⽽直接关闭：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205305424.png" alt="image-20210418205305424"></p><p>当服务器的并发连接增多时，相应地，同时处于 TIME_WAIT 状态的连接数量也会变多，此时就应当调 ⼤ tcp_max_tw_buckets 参数，减少不同连接间数据错乱的概率。</p><p>tcp_max_tw_buckets 也不是越⼤越好，毕竟内存和端⼝都是有限的。</p><p>有⼀种⽅式可以在建⽴新连接时，复⽤处于 TIME_WAIT 状态的连接，那就是打开 tcp_tw_reuse 参 数。但是需要注意，该参数是只⽤于客户端（建⽴连接的发起⽅），因为是在调⽤ connect() 时起作⽤ 的，⽽对于服务端（被动连接⽅）是没有⽤的。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205329777.png" alt="image-20210418205329777"></p><p>tcp_tw_reuse 从协议⻆度理解是安全可控的，可以复⽤处于 TIME_WAIT 的端⼝为新的连接所⽤。</p><p>什么是协议⻆度理解的安全可控呢？主要有两点：</p><ul><li>只适⽤于连接发起⽅，也就是 C&#x2F;S 模型中的客户端；</li><li>对应的 TIME_WAIT 状态的连接创建时间超过 1 秒才可以被复⽤。</li></ul><p>使⽤这个选项，还有⼀个前提，需要打开对 TCP 时间戳的⽀持（对⽅也要打开 ）：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205420700.png" alt="image-20210418205420700"></p><p>由于引⼊了时间戳，它能带来了些好处：</p><ul><li>我们在前⾯提到的 2MSL 问题就不复存在了，因为᯿复的数据包会因为时间戳过期被⾃然丢弃；</li><li>同时，它还可以防⽌序列号绕回，也是因为᯿复的数据包会由于时间戳过期被⾃然丢弃；</li></ul><p>时间戳是在 TCP 的选项字段⾥定义的，开启了时间戳功能，在 TCP 报⽂传输的时候会带上发送报⽂的 时间戳。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205502767.png" alt="image-20210418205502767"></p><p>我们来看看开启了 tcp_tw_reuse 功能，如果四次挥⼿中的最后⼀次 ACK 在⽹络中丢失了，会发⽣什么？</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205550656.png" alt="image-20210418205550656"></p><p>上图的流程：</p><ul><li>四次挥⼿中的最后⼀次 ACK 在⽹络中丢失了，服务端⼀直处于 LAST_ACK 状态；</li><li>客户端由于开启了 tcp_tw_reuse 功能，客户端再次发起新连接的时候，会复⽤超过 1 秒后的 time_wait 状态的连接。但客户端新发的 SYN 包会被忽略（由于时间戳），因为服务端⽐较了客户 端的上⼀个报⽂与 SYN 报⽂的时间戳，过期的报⽂就会被服务端丢弃；</li><li>服务端 FIN 报⽂迟迟没有收到四次挥⼿的最后⼀次 ACK，于是超时᯿发了 FIN 报⽂给客户端；</li><li>处于 SYN_SENT 状态的客户端，由于收到了 FIN 报⽂，则会回 RST 给服务端，于是服务端就离开 了 LAST_ACK 状态；</li><li>最初的客户端 SYN 报⽂超时重发了（ 1 秒钟后），此时就与服务端能正确的三次握⼿了。</li></ul><p>所以⼤家都会说开启了 tcp_tw_reuse，可以在复⽤了 time_wait 状态的 1 秒过后成功建⽴连接，这 1 秒 主要是花费在 SYN 包᯿传。</p><p>另外，⽼版本的 Linux 还提供了 tcp_tw_recycle 参数，但是当开启了它，就有两个坑：</p><ul><li>Linux 会加快客户端和服务端 TIME_WAIT 状态的时间，也就是它会使得 TIME_WAIT 状态会⼩于 60 秒，很容易导致数据错乱；</li><li>另外，Linux 会丢弃所有来⾃远端时间戳⼩于上次记录的时间戳（由同⼀个远端发送的）的任何数 据包。就是说要使⽤该选项，则必须保证数据包的时间戳是单调递增的。那么，问题在于，此处的 时间戳并不是我们通常意义上⾯的绝对时间，⽽是⼀个相对时间。很多情况下，我们是没法保证时 间戳单调递增的，⽐如使⽤了 NAT、LVS 等情况；</li></ul><p>所以，不建议设置为 1 ，在 Linux 4.12 版本后，Linux 内核直接取消了这⼀参数，建议关闭它：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205726162.png" alt="image-20210418205726162"></p><p>另外，我们可以在程序中设置 socket 选项，来设置调⽤ close 关闭连接⾏为。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205745092.png" alt="image-20210418205745092"></p><p>如果 l_onoff 为⾮ 0， 且 l_linger 值为 0，那么调⽤ close 后，会⽴该发送⼀个 RST 标志给对 端，该 TCP 连接将跳过四次挥⼿，也就跳过了 TIME_WAIT 状态，直接关闭。</p><p>但这为跨越 TIME_WAIT 状态提供了⼀个可能，不过是⼀个⾮常危险的⾏为，不值得提倡。</p><h3 id="5-2-2、被动方优化"><a href="#5-2-2、被动方优化" class="headerlink" title="5.2.2、被动方优化"></a>5.2.2、被动方优化</h3><p>当被动⽅收到 FIN 报⽂时，内核会⾃动回复 ACK，同时连接处于 CLOSE_WAIT 状态，顾名思义，它表示等待应⽤进程调⽤ close 函数关闭连接。</p><p>内核没有权利替代进程去关闭连接，因为如果主动⽅是通过 shutdown 关闭连接，那么它就是想在半关 闭连接上接收数据或发送数据。因此，Linux 并没有限制 CLOSE_WAIT 状态的持续时间。</p><p>当然，⼤多数应⽤程序并不使⽤ shutdown 函数关闭连接。所以，当你⽤ netstat 命令发现⼤量 CLOSE_WAIT 状态。就需要排查你的应⽤程序，因为可能因为应⽤程序出现了 Bug，read 函数返回 0 时，没有调⽤ close 函数。</p><p>处于 CLOSE_WAIT 状态时，调⽤了 close 函数，内核就会发出 FIN 报⽂关闭发送通道，同时连接进⼊ LAST_ACK 状态，等待主动⽅返回 ACK 来确认连接关闭。</p><p>如果迟迟收不到这个 ACK，内核就会重发 FIN 报⽂，᯿发次数仍然由 tcp_orphan_retries 参数控制，这 与主动⽅重发 FIN 报⽂的优化策略⼀致。</p><p>还有⼀点我们需要注意的，如果被动⽅迅速调⽤ close 函数，那么被动⽅的 ACK 和 FIN 有可能在⼀个 报⽂中发送，这样看起来，四次挥⼿会变成三次挥⼿，这只是⼀种特殊情况，不⽤在意。</p><h4 id="5-2-2-1、如果连接双⽅同时关闭连接，会怎么样？"><a href="#5-2-2-1、如果连接双⽅同时关闭连接，会怎么样？" class="headerlink" title="5.2.2.1、如果连接双⽅同时关闭连接，会怎么样？"></a>5.2.2.1、如果连接双⽅同时关闭连接，会怎么样？</h4><p>由于 TCP 是双全⼯的协议，所以是会出现两⽅同时关闭连接的现象，也就是同时发送了 FIN 报⽂。</p><p>此时，上⾯介绍的优化策略仍然适⽤。两⽅发送 FIN 报⽂时，都认为⾃⼰是主动⽅，所以都进⼊了 FIN_WAIT1 状态，FIN 报⽂的᯿发次数仍由 tcp_orphan_retries 参数控制。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205925842.png" alt="image-20210418205925842"></p><p>接下来，双⽅在等待 ACK 报⽂的过程中，都等来了 FIN 报⽂。这是⼀种新情况，所以连接会进⼊⼀种 叫做 CLOSING 的新状态，它替代了 FIN_WAIT2 状态。接着，双⽅内核回复 ACK 确认对⽅发送通道 的关闭后，进⼊ TIME_WAIT 状态，等待 2MSL 的时间后，连接⾃动关闭。</p><h3 id="5-2-3、小结"><a href="#5-2-3、小结" class="headerlink" title="5.2.3、小结"></a>5.2.3、小结</h3><p>针对 TCP 四次挥⼿的优化，我们需要根据主动⽅和被动⽅四次挥⼿状态变化来调整系统 TCP 内核参数。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418210021774.png" alt="image-20210418210021774"></p><h4 id="5-2-3-1、主动方优化"><a href="#5-2-3-1、主动方优化" class="headerlink" title="5.2.3.1、主动方优化"></a>5.2.3.1、主动方优化</h4><p>主动发起 FIN 报⽂断开连接的⼀⽅，如果迟迟没收到对⽅的 ACK 回复，则会重传 FIN 报⽂，重传次数 由 tcp_orphan_retries 参数决定。</p><p>当主动⽅收到 ACK 报⽂后，连接就进⼊ FIN_WAIT2 状态，根据关闭的⽅式不同，优化的⽅式也不同：</p><ul><li>如果这是 close 函数关闭的连接，那么它就是孤⼉连接。如果 tcp_fin_timeout 秒内没有收到对 ⽅的 FIN 报⽂，连接就直接关闭。同时，为了应对孤⼉连接占⽤太多的资源， tcp_max_orphans 定义了最⼤孤⼉连接的数量，超过时连接就会直接释放。</li><li>反之是 shutdown 函数关闭的连接，则不受此参数限制；</li></ul><p>当主动⽅接收到 FIN 报⽂，并返回 ACK 后，主动⽅的连接进⼊ TIME_WAIT 状态。这⼀状态会持续 1 分钟，为了防⽌ TIME_WAIT 状态占⽤太多的资源， tcp_max_tw_buckets 定义了最⼤数量，超过时连 接也会直接释放。</p><p>当 TIME_WAIT 状态过多时，还可以通过设置 tcp_tw_reuse 和 tcp_timestamps 为 1 ，将 TIME_WAIT 状态的端⼝复⽤于作为客户端的新连接，注意该参数只适⽤于客户端。</p><h4 id="5-2-3-2、被动⽅的优化"><a href="#5-2-3-2、被动⽅的优化" class="headerlink" title="5.2.3.2、被动⽅的优化"></a>5.2.3.2、被动⽅的优化</h4><p>被动关闭的连接⽅应对⾮常简单，它在回复 ACK 后就进⼊了 CLOSE_WAIT 状态，等待进程调⽤ close 函数关闭连接。因此，出现⼤量 CLOSE_WAIT 状态的连接时，应当从应⽤程序中找问题。</p><p>当被动⽅发送 FIN 报⽂后，连接就进⼊ LAST_ACK 状态，在未等到 ACK 时，会在 tcp_orphan_retries 参数的控制下重发 FIN 报⽂。</p><h2 id="5-3、提升TCP传输数据性能"><a href="#5-3、提升TCP传输数据性能" class="headerlink" title="5.3、提升TCP传输数据性能"></a>5.3、提升TCP传输数据性能</h2><p>在前⾯介绍的是三次握⼿和四次挥⼿的优化策略，接下来主要介绍的是 TCP 传输数据时的优化策略。</p><p><font color='orange'>TCP 连接由内核维护，内核会为每个连接建⽴内存缓冲区：</font></p><ul><li>如果连接的内存配置过⼩，就⽆法充分使⽤⽹络带宽，TCP 传输效率就会降低；</li><li>如果连接的内存配置过⼤，很容易把服务器资源耗尽，这样就会导致新连接⽆法建⽴；</li></ul><p>因此，我们必须理解 Linux 下 TCP 内存的⽤途，才能正确地配置内存⼤⼩。</p><h3 id="5-3-1、滑动窗⼝影响传输速度"><a href="#5-3-1、滑动窗⼝影响传输速度" class="headerlink" title="5.3.1、滑动窗⼝影响传输速度"></a>5.3.1、滑动窗⼝影响传输速度</h3><p>TCP 会保证每⼀个报⽂都能够抵达对⽅，它的机制是：报⽂发出去后，必须接收到对⽅返回的确认报⽂ ACK，如果迟迟未收到，就会超时重发该报⽂，直到收到对⽅的 ACK 为⽌。</p><p>所以，TCP 报⽂发出去后，并不会⽴⻢从内存中删除，因为重传时还需要⽤到它。</p><p>由于 TCP 是内核维护的，所以报⽂存放在内核缓冲区。如果连接⾮常多，我们可以通过 free 命令观察到 buff&#x2F;cache 内存是否增⼤。</p><p>如果 TCP 是每发送⼀个数据，都要进⾏⼀次确认应答。当上⼀个数据包收到了应答了， 再发送下⼀ 个。这个模式就有点像我和你⾯对⾯聊天，你⼀句我⼀句，但这种⽅式的缺点就是 效率很低。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418210742380.png" alt="image-20210418210742380"></p><p>所以，这样的传输⽅式有⼀个缺点：<font color='orange'>数据包的往返时间越⻓，通信的效率就越低。</font></p><p>要解决这⼀问题不难，并⾏批量发送报⽂，再批量确认报⽂即可。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418210838615.png" alt="image-20210418210838615"></p><p>然⽽，这引出了另⼀个问题，发送⽅可以随⼼所欲的发送报⽂吗？当然不行，我们还得考虑接收⽅的处理能⼒。</p><p>当接收⽅硬件不如发送⽅，或者系统繁忙、资源紧张时，是⽆法瞬间处理这么多报⽂的。于是，这些报 ⽂只能被丢掉，使得⽹络效率⾮常低。</p><p>为了解决这种现象发⽣，TCP 提供⼀种机制可以让「发送⽅」根据「接收⽅」的实际接收能⼒控制发送 的数据量，这就是滑动窗⼝的由来。</p><p>接收⽅根据它的缓冲区，可以计算出后续能够接收多少字节的报⽂，这个数字叫做接收窗⼝。当内核接 收到报⽂时，必须⽤缓冲区存放它们，这样剩余缓冲区空间变⼩，接收窗⼝也就变⼩了；当进程调⽤ read 函数后，数据被读⼊了⽤户空间，内核缓冲区就被清空，这意味着主机可以接收更多的报⽂，接收 窗⼝就会变⼤。</p><p>因此，接收窗⼝并不是恒定不变的，接收⽅会把当前可接收的⼤⼩放在 TCP 报⽂头部中的窗⼝字段， 这样就可以起到窗⼝⼤⼩通知的作⽤。</p><p>发送⽅的窗⼝等价于接收⽅的窗⼝吗？如果不考虑拥塞控制，发送⽅的窗⼝⼤⼩「约等于」接收⽅的窗⼝⼤⼩，因为窗⼝通知报⽂在⽹络传输是存在时延的，所以是约等于的关系。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418211048586.png" alt="image-20210418211048586"></p><p>从上图中可以看到，窗⼝字段只有 2 个字节，因此它最多能表达 65535 字节⼤⼩的窗⼝，也就是 64KB ⼤⼩。</p><p>这个窗⼝⼤⼩最⼤值，在当今⾼速⽹络下，很明显是不够⽤的。所以后续有了扩充窗⼝的⽅法：在 TCP 选项字段定义了窗⼝扩⼤因⼦，⽤于扩⼤ TCP 通告窗⼝，其值⼤⼩是 2^14，这样就使 TCP 的窗⼝⼤ ⼩从 16 位扩⼤为 30 位（2^16 * 2^ 14 &#x3D; 2^30），所以此时窗⼝的最⼤值可以达到 1GB。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418211130135.png" alt="image-20210418211130135"></p><p>Linux 中打开这⼀功能，需要把 <code>tcp_window_scaling</code> 配置设为 1（默认打开）：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418211148700.png" alt="image-20210418211148700"></p><p>要使⽤窗⼝扩⼤选项，通讯双⽅必须在各⾃的 SYN 报⽂中发送这个选项：</p><ul><li>主动建⽴连接的⼀⽅在 SYN 报⽂中发送这个选项；</li><li>⽽被动建⽴连接的⼀⽅只有在收到带窗⼝扩⼤选项的 SYN 报⽂之后才能发送这个选项。</li></ul><p>这样看来，只要进程能及时地调⽤ read 函数读取数据，并且接收缓冲区配置得⾜够⼤，那么接收窗⼝ 就可以⽆限地放⼤，发送⽅也就⽆限地提升发送速度。</p><p>这是不可能的，因为⽹络的传输能⼒是有限的，当发送⽅依据发送窗⼝，发送超过⽹络处理能⼒的报⽂ 时，路由器会直接丢弃这些报⽂。因此，缓冲区的内存并不是越⼤越好。</p><h3 id="5-3-2、确定最⼤传输速度"><a href="#5-3-2、确定最⼤传输速度" class="headerlink" title="5.3.2、确定最⼤传输速度"></a>5.3.2、确定最⼤传输速度</h3><p>我们知道 TCP 的传输速度受制于发送窗⼝与接收窗⼝，以及⽹络设备传输能⼒。其中，窗⼝⼤⼩由内核缓冲区⼤⼩决定。如果缓冲区与⽹络传输能⼒匹配，那么缓冲区的利⽤率就达到了最⼤化。</p><p>问题来了，如何计算⽹络的传输能⼒呢？</p><p>相信⼤家都知道⽹络是有「带宽」限制的，带宽描述的是⽹络传输能⼒，它与内核缓冲区的计量单位不同：</p><ul><li>带宽是单位时间内的流量，表达是「速度」，⽐如常⻅的带宽 100 MB&#x2F;s；</li><li>缓冲区单位是字节，当⽹络速度乘以时间才能得到字节数；</li></ul><p>这⾥需要说⼀个概念，就是带宽时延积，它决定⽹络中⻜⾏报⽂的⼤⼩，它的计算⽅式</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418211558531.png" alt="image-20210418211558531"></p><p>⽐如最⼤带宽是 100 MB&#x2F;s，⽹络时延（RTT）是 10ms 时，意味着客户端到服务端的⽹络⼀共可以存 放 100MB&#x2F;s * 0.01s &#x3D; 1MB 的字节。</p><p>这个 1MB 是带宽和时延的乘积，所以它就叫「带宽时延积」（缩写为 BDP，Bandwidth Delay Product）。同时，这 1MB 也表示「⻜⾏中」的 TCP 报⽂⼤⼩，它们就在⽹络线路、路由器等⽹络设 备上。如果⻜⾏报⽂超过了 1 MB，就会导致⽹络过载，容易丢包。</p><p>由于发送缓冲区⼤⼩决定了发送窗⼝的上限，⽽发送窗⼝⼜决定了「已发送未确认」的⻜⾏报⽂的上 限。因此，发送缓冲区不能超过「带宽时延积」。</p><p>发送缓冲区与带宽时延积的关系：</p><ul><li>如果发送缓冲区「超过」带宽时延积，超出的部分就没办法有效的⽹络传输，同时导致⽹络过载， 容易丢包；</li><li>如果发送缓冲区「⼩于」带宽时延积，就不能很好的发挥出⽹络的传输效率。</li></ul><p>所以，发送缓冲区的⼤⼩最好是往带宽时延积靠近。</p><h3 id="5-3-3、调整缓冲区大小"><a href="#5-3-3、调整缓冲区大小" class="headerlink" title="5.3.3、调整缓冲区大小"></a>5.3.3、调整缓冲区大小</h3><p><font color='orange'>在 Linux 中发送缓冲区和接收缓冲都可以⽤参数调节。设置完后，Linux 会根据你设置的缓冲区进⾏动态调节。</font></p><h4 id="5-3-3-1、调节发送缓冲区范围"><a href="#5-3-3-1、调节发送缓冲区范围" class="headerlink" title="5.3.3.1、调节发送缓冲区范围"></a>5.3.3.1、调节发送缓冲区范围</h4><p>先来看看发送缓冲区，它的范围通过 <code>tcp_wmem</code> 参数配置；</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418211755905.png" alt="image-20210418211755905"></p><p>上⾯三个数字单位都是字节，它们分别表示：</p><ul><li>第⼀个数值是动态范围的最⼩值，4096 byte &#x3D; 4K；</li><li>第⼆个数值是初始默认值，87380 byte ≈ 86K；</li><li>第三个数值是动态范围的最⼤值，4194304 byte &#x3D; 4096K（4M）；</li></ul><p>发送缓冲区是⾃⾏调节的，当发送⽅发送的数据被确认后，并且没有新的数据要发送，就会把发送缓冲区的内存释放掉。</p><h4 id="5-3-3-2、调节接收缓冲区范围"><a href="#5-3-3-2、调节接收缓冲区范围" class="headerlink" title="5.3.3.2、调节接收缓冲区范围"></a>5.3.3.2、调节接收缓冲区范围</h4><p>⽽接收缓冲区的调整就⽐较复杂⼀些，先来看看设置接收缓冲区范围的 tcp_rmem 参数：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418211857927.png" alt="image-20210418211857927"></p><p>上⾯三个数字单位都是字节，它们分别表示：</p><ul><li>第⼀个数值是动态范围的最⼩值，表示即使在内存压⼒下也可以保证的最⼩接收缓冲区⼤⼩，4096 byte &#x3D; 4K；</li><li>第⼆个数值是初始默认值，87380 byte ≈ 86K；</li><li>第三个数值是动态范围的最⼤值，6291456 byte &#x3D; 6144K（6M）；</li></ul><p>接收缓冲区可以根据系统空闲内存的⼤⼩来调节接收窗⼝：</p><ul><li>如果系统的空闲内存很多，就可以⾃动把缓冲区增⼤⼀些，这样传给对⽅的接收窗⼝也会变⼤，因 ⽽提升发送⽅发送的传输数据数量；</li><li>反之，如果系统的内存很紧张，就会减少缓冲区，这虽然会降低传输效率，可以保证更多的并发连 接正常⼯作；</li></ul><p>发送缓冲区的调节功能是⾃动开启的，⽽接收缓冲区则需要配置 <code>tcp_moderate_rcvbuf</code> 为 1 来开启调节功能：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418212006158.png" alt="image-20210418212006158"></p><h4 id="5-3-3-3、调节-TCP-内存范围"><a href="#5-3-3-3、调节-TCP-内存范围" class="headerlink" title="5.3.3.3、调节 TCP 内存范围"></a>5.3.3.3、调节 TCP 内存范围</h4><p>接收缓冲区调节时，怎么知道当前内存是否紧张或充分呢？这是通过 <code>tcp_mem</code> 配置完成的：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418212037121.png" alt="image-20210418212037121"></p><p>上⾯三个数字单位不是字节，⽽是「⻚⾯⼤⼩」，1 ⻚表示 4KB，它们分别表示：</p><ul><li>当 TCP 内存⼩于第 1 个值时，不需要进⾏⾃动调节；</li><li>在第 1 和第 2 个值之间时，内核开始调节接收缓冲区的⼤⼩；</li><li>⼤于第 3 个值时，内核不再为 TCP 分配新内存，此时新连接是⽆法建⽴的；</li></ul><p>⼀般情况下这些值是在系统启动时根据系统内存数量计算得到的。根据当前 <code>tcp_mem</code> 最⼤内存⻚⾯数是 177120，当内存为 (177120 * 4) &#x2F; 1024K ≈ 692M 时，系统将⽆法为新的 TCP 连接分配内存，即 TCP 连接将被拒绝。</p><h4 id="5-3-3-4、根据实际场景调节的策略"><a href="#5-3-3-4、根据实际场景调节的策略" class="headerlink" title="5.3.3.4、根据实际场景调节的策略"></a>5.3.3.4、根据实际场景调节的策略</h4><p>在⾼并发服务器中，为了兼顾⽹速与⼤量的并发连接，我们应当保证缓冲区的动态调整的最⼤值达到带宽时延积，⽽最⼩值保持默认的 4K 不变即可。⽽对于内存紧张的服务⽽⾔，调低默认值是提⾼并发的 有效⼿段。</p><p>同时，如果这是⽹络 IO 型服务器，那么，调⼤ <code>tcp_mem</code> 的上限可以让 TCP 连接使⽤更多的系统内存，这有利于提升并发能⼒。需要注意的是，<code>tcp_wmem</code> 和 <code>tcp_rmem</code> 的单位是字节，⽽ <code>tcp_mem</code> 的单位是⻚⾯⼤⼩。⽽且，千万不要在 socket 上直接设置 <code>SO_SNDBUF</code> 或者 <code>SO_RCVBUF</code>，这样会关闭缓冲区的动态调整功能。</p><h3 id="5-3-4、小结"><a href="#5-3-4、小结" class="headerlink" title="5.3.4、小结"></a>5.3.4、小结</h3><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418212216740.png" alt="image-20210418212216740"></p><p><font color='orange'>TCP 可靠性 通过 ACK 确认报⽂实现，⼜依赖滑动窗⼝提升了发送速度也兼顾了接收⽅的处理能⼒。</font></p><p>可是，默认的滑动窗⼝最⼤值只有 64 KB，不满⾜当今的⾼速⽹络要求，要提升发送速度必须提升滑动窗⼝上限，在 Linux 下是通过设置 <code>tcp_window_scaling</code> 为 1 做到，此时最⼤值可⾼达 1GB。</p><p>滑动窗⼝定义了⽹络中⻜⾏报⽂的最⼤字节数，当它超过带宽时延积时，⽹络过载，就会发⽣丢包。⽽当它⼩于带宽时延积时，就⽆法充分利⽤⽹络带宽。因此，滑动窗⼝的设置，必须参考带宽时延积。</p><p>内核缓冲区决定了滑动窗⼝的上限，缓冲区可分为：发送缓冲区 <code>tcp_wmem</code> 和接收缓冲区 <code>tcp_rmem</code>。</p><p>Linux 会对缓冲区动态调节，我们应该把缓冲区的上限设置为带宽时延积。发送缓冲区的调节功能是⾃ 动打开的，⽽接收缓冲区需要把 <code>tcp_moderate_rcvbuf</code> 设置为 1 来开启。其中，调节的依据是 TCP 内存范围 <code>tcp_mem</code>。</p><p>但需要注意的是，如果程序中的 socket 设置了 <code>SO_SNDBUF</code> 和 <code>SO_RCVBUF</code>，则会关闭缓冲区的动态调整功能，所以不建议在程序中设置它们，⽽是交给内核⾃动调整⽐较好。</p><p>有效配置这些参数后，既能够最⼤程度地保持并发性，也能让资源充裕时连接传输速度达到最⼤值。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系列-HTTP基础知识</title>
      <link href="/2023/07/30/http-ji-chu-zhi-shi/"/>
      <url>/2023/07/30/http-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="1、HTTP必知"><a href="#1、HTTP必知" class="headerlink" title="1、HTTP必知"></a>1、HTTP必知</h1><h2 id="1-1、啥是HTTP"><a href="#1-1、啥是HTTP" class="headerlink" title="1.1、啥是HTTP"></a>1.1、啥是HTTP</h2><p><font color='orange'>HTTP 是 HyperText Transfer Protocol 的缩写，中文定义：超⽂本传输协议。</font></p><p>超⽂本传输协议 可拆分为三个部分：</p><ol><li>超⽂本</li><li>传输</li><li>协议</li></ol><h3 id="1-1-1、协议"><a href="#1-1-1、协议" class="headerlink" title="1.1.1、协议"></a>1.1.1、协议</h3><p>HTTP 是计算机世界中的协议。它确⽴了计算机之间交流通信 的规范（两个以上的参与者），以及相关的各种控制和错误处理⽅式（⾏为约定和规范）。</p><h3 id="1-1-2、传输"><a href="#1-1-2、传输" class="headerlink" title="1.1.2、传输"></a>1.1.2、传输</h3><p>传输包含两项信息：</p><ol><li>HTTP 协议是⼀个双向协议。</li><li>数据虽然是在 A 和 B 之间传输，但允许中间有中转或接⼒。</li></ol><p>HTTP 是计算机中两点之间传输数据的约定和规范。</p><h3 id="1-1-3、超文本"><a href="#1-1-3、超文本" class="headerlink" title="1.1.3、超文本"></a>1.1.3、超文本</h3><p><font color='orange'>HTTP 传输的内容是「超⽂本」。</font></p><ul><li><p>⽂本：在互联⽹早期时只是简单的字符⽂字，但现在的含义已经可以扩展为图⽚、视频、压缩包等，在 HTTP 眼⾥这些都算作⽂本。</p></li><li><p>超⽂本：超越了普通⽂本的⽂本，它是⽂字、图⽚、视频等的混合体，最关键有超链接，能从⼀个超⽂本跳转到另外⼀个超⽂本。</p><p>HTML 就是最常⻅的超⽂本了，它本身只是纯⽂字⽂件，但内部⽤很多标签定义了图⽚、视频等的链接，再经过浏览器的解释，呈现给我们的就是⼀个有⽂字、有画⾯的⽹⻚。</p></li></ul><p><font color='orange'>HTTP 是⼀种在计算机世界⾥专⻔在「两点」之间「传输」⽂字、图⽚、⾳频、视频等「超⽂本」数据 的「约定和规范」。</font></p><h2 id="1-2、HTTP状态码"><a href="#1-2、HTTP状态码" class="headerlink" title="1.2、HTTP状态码"></a>1.2、HTTP状态码</h2><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415173000284.png" alt="image-20210415173000284"></p><h2 id="1-3、HTTP请求头字段"><a href="#1-3、HTTP请求头字段" class="headerlink" title="1.3、HTTP请求头字段"></a>1.3、HTTP请求头字段</h2><h3 id="1-3-1、user-agent（请求发送方-谁发的）"><a href="#1-3-1、user-agent（请求发送方-谁发的）" class="headerlink" title="1.3.1、user-agent（请求发送方 - 谁发的）"></a>1.3.1、user-agent（请求发送方 - 谁发的）</h3><h3 id="1-3-2、HOST（请求接收方-发给谁）"><a href="#1-3-2、HOST（请求接收方-发给谁）" class="headerlink" title="1.3.2、HOST（请求接收方 - 发给谁）"></a>1.3.2、HOST（请求接收方 - 发给谁）</h3><p><font color='orange'>客户端发送请求时，⽤来指定服务器的域名。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415173330840.png" alt="image-20210415173330840"></p><p>有了 Host 字段，就可以将请求发往「同⼀台」服务器上的不同⽹站。</p><h3 id="1-3-3、Connection（使用持久连接）"><a href="#1-3-3、Connection（使用持久连接）" class="headerlink" title="1.3.3、Connection（使用持久连接）"></a>1.3.3、Connection（使用持久连接）</h3><p><font color='orange'>Connection 字段常⽤于客户端告知服务器使⽤ TCP 持久连接，以便其他请求复⽤。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415173628892.png" alt="image-20210415173628892"></p><p>HTTP&#x2F;1.1 版本的默认连接都是持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection ⾸部字段的值为 Keep-Alive 。 ⼀个可以复⽤的 TCP 连接就建⽴了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。</p><h3 id="1-3-4、Content-Type（响应数据格式）"><a href="#1-3-4、Content-Type（响应数据格式）" class="headerlink" title="1.3.4、Content-Type（响应数据格式）"></a>1.3.4、Content-Type（响应数据格式）</h3><p><font color='orange'>Content-Type 字段⽤于服务器回应时，告诉客户端，本次数据是什么格式。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415173849046.png" alt="image-20210415173849046"></p><p>上⾯的类型表明，发送的是⽹⻚，⽽且编码是UTF-8。 客户端请求的时候，可以使⽤ Accept 字段声明⾃⼰可以接受哪些数据格式。</p><pre class="line-numbers language-http" data-language="http"><code class="language-http"># 客户端声明⾃⼰可以接受任何格式的数据Accept：*/*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-3-5、Content-Length（响应数据长度）"><a href="#1-3-5、Content-Length（响应数据长度）" class="headerlink" title="1.3.5、Content-Length（响应数据长度）"></a>1.3.5、Content-Length（响应数据长度）</h3><p><font color='orange'>服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据⻓度。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415173517081.png" alt="image-20210415173517081"></p><p>比如，上⾯就是告诉浏览器，本次服务器回应的数据⻓度是 1000 个字节，后⾯的字节就属于下⼀个回应了。</p><h3 id="1-3-6、Content-Encoding（响应数据的压缩格式）"><a href="#1-3-6、Content-Encoding（响应数据的压缩格式）" class="headerlink" title="1.3.6、Content-Encoding（响应数据的压缩格式）"></a>1.3.6、Content-Encoding（响应数据的压缩格式）</h3><p><font color='orange'>Content-Encoding 字段说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415174030419.png" alt="image-20210415174030419"></p><p>上⾯表示服务器返回的数据采⽤了 gzip ⽅式压缩，告知客户端需要⽤此⽅式解压。 客户端在请求时，⽤ Accept-Encoding 字段说明⾃⼰可以接受哪些压缩⽅法。</p><h2 id="1-4、HTTP请求和响应"><a href="#1-4、HTTP请求和响应" class="headerlink" title="1.4、HTTP请求和响应"></a>1.4、HTTP请求和响应</h2><h3 id="1-4-1、HTTP请求"><a href="#1-4-1、HTTP请求" class="headerlink" title="1.4.1、HTTP请求"></a>1.4.1、HTTP请求</h3><p><font color='orange'>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行 和 请求数据 4个部分组成，</font>请求报文的一般格式如下图：</p><p><img src="/%5Cimgs%5Cjavadev%5Chttp%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%8401.jpg"></p><p>下面针对每一项进行分析：</p><ol><li><p><font color='orange'>请求行</font></p><p><font color='orange'>请求行分为三个部分：请求方式、请求地址和协议版本。</font></p><ol><li><p><font color='orange'>请求方式</font></p><p>HTTP&#x2F;1.1 定义的请求方式有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</p><p>最常的两种GET和POST，如果是RestFul接口，则一般会用到GET、POST、DELETE、PUT。</p></li><li><p><font color='orange'>请求地址</font></p><p>组成：&lt;协议&gt;：&#x2F;&#x2F;&lt;主机&gt;：&lt;端口&gt;&#x2F;&lt;路径&gt;</p><p>端口和路径有时可以省略（HTTP默认端口号是80）：</p><p><img src="/%5Cimgs%5Cjavadev%5C%E8%AF%B7%E6%B1%82%E8%A1%8C-%E8%AF%B7%E6%B1%82%E5%9C%B0%E5%9D%80%E5%9B%BE%E7%A4%BA.jpg" alt="img"></p></li><li><p><font color='orange'>协议版本</font></p><p>协议版本的格式为：HTTP&#x2F;主版本号.次版本号，常用的有HTTP&#x2F;1.0和HTTP&#x2F;1.1。</p></li></ol><p>请求行示例如下：</p><pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token request-line"><span class="token method property">POST</span> <span class="token request-target url">/index.php</span>　<span class="token http-version property">HTTP/1.1</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><font color='orange'>请求头</font></p><p>请求头部为请求报文添加了一些附加信息，由“名&#x2F;值”对组成，每行一对，名和值之间使用冒号分隔。</p><p>常见请求头如下：</p><p><img src="/%5Cimgs%5Cjavadev%5C%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%9B%BE%E7%A4%BA.jpg" alt="img"></p><p>请求头示例如下：</p><pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">localhost</span></span><span class="token header"><span class="token header-name keyword">User-Agent</span><span class="token punctuation">:</span> <span class="token header-value">Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2</span></span><span class="token header"><span class="token header-name keyword">Accept</span><span class="token punctuation">:</span> <span class="token header-value">text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span></span><span class="token header"><span class="token header-name keyword">Accept-Language</span><span class="token punctuation">:</span> <span class="token header-value">zh-cn,zh;q=0.5</span></span><span class="token header"><span class="token header-name keyword">Accept-Encoding</span><span class="token punctuation">:</span> <span class="token header-value">gzip, deflate</span></span><span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span> <span class="token header-value">keep-alive</span></span><span class="token header"><span class="token header-name keyword">Referer</span><span class="token punctuation">:</span> <span class="token header-value">[http://localhost/](https://link.jianshu.com?t=http://localhost/)</span></span>Content-Length：25Content-Type：application/x-www-form-urlencoded<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><font color='orange'>空行</font></p><p>空行用于隔离请求头和请求体，否则服务器无法解析请求信息。</p><p>空行示例：</p><pre class="line-numbers language-none"><code class="language-none">这里就是一个空行。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><font color='orange'>请求数据</font></p><p>可选部分，比如GET请求就没有请求数据。</p><p>请求数据示例：</p><pre class="line-numbers language-http" data-language="http"><code class="language-http">username=aa&amp;password=1234<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="1-4-2、HTTP响应"><a href="#1-4-2、HTTP响应" class="headerlink" title="1.4.2、HTTP响应"></a>1.4.2、HTTP响应</h3><p><font color='orange'>HTTP响应报文主要由 状态行、响应头、空行 和 响应数据 组成。</font>结构如下图所示：</p><p><img src="/%5Cimgs%5Cjavadev%5CHTTP%E5%93%8D%E5%BA%94%E6%95%B4%E4%BD%93%E5%9B%BE%E7%A4%BA.jpg" alt="img"></p><p>下面针对每一项进行分析：</p><ol><li><p><font color='orange'>状态行</font></p><p>由3部分组成，分别为：协议版本，状态码，状态码描述。</p><p>其中协议版本与请求报文一致，状态码描述是对状态码的简单描述。</p><p>状态码分类如下：</p><table><thead><tr><th align="left">分类</th><th align="left">分类描述</th></tr></thead><tbody><tr><td align="left">1**</td><td align="left">信息，服务器收到请求，需要请求者继续执行操作。</td></tr><tr><td align="left">2**</td><td align="left">成功，操作被成功接收并处理。</td></tr><tr><td align="left">3**</td><td align="left">重定向，需要进一步的操作以完成请求。</td></tr><tr><td align="left">4**</td><td align="left">客户端错误，请求包含语法错误或无法完成请求。</td></tr><tr><td align="left">5**</td><td align="left">服务器错误，服务器在处理请求的过程中发生了错误。</td></tr></tbody></table><p>常见状态如下所示：</p><ul><li>200：响应成功。</li><li>302：跳转，其跳转地址通过响应头中的location属性来指定。</li><li>400：客户端请求有语法错误，不能被服务器识别。</li><li>403：服务器接收到请求，但拒绝提供服务（认证失败）。</li><li>404：请求资源不存在。</li><li>500：服务器内部错误。</li></ul><p>状态行示例如下：</p><pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">200</span> <span class="token reason-phrase string">OK</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><font color='orange'>响应头</font></p><p>与请求头部类似，为响应报文添加了一些附加信息。</p><p>常见响应头部如下：</p><p><img src="/%5Cimgs%5Cjavadev%5C%E5%93%8D%E5%BA%94%E5%A4%B4%E5%9B%BE%E7%A4%BA.jpg" alt="img"></p><p>响应头示例如下：</p><pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Date</span><span class="token punctuation">:</span> <span class="token header-value">Sun, 17 Mar 2013 08:12:54 GMT</span></span><span class="token header"><span class="token header-name keyword">Server</span><span class="token punctuation">:</span> <span class="token header-value">Apache/2.2.8 (Win32) PHP/5.2.5</span></span><span class="token header"><span class="token header-name keyword">X-Powered-By</span><span class="token punctuation">:</span> <span class="token header-value">PHP/5.2.5</span></span><span class="token header"><span class="token header-name keyword">Set-Cookie</span><span class="token punctuation">:</span> <span class="token header-value">PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/</span></span><span class="token header"><span class="token header-name keyword">Expires</span><span class="token punctuation">:</span> <span class="token header-value">Thu, 19 Nov 1981 08:52:00 GMT</span></span><span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">no-store, no-cache, must-revalidate, post-check=0, pre-check=0</span></span><span class="token header"><span class="token header-name keyword">Pragma</span><span class="token punctuation">:</span> <span class="token header-value">no-cache</span></span><span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span> <span class="token header-value">4393</span></span><span class="token header"><span class="token header-name keyword">Keep-Alive</span><span class="token punctuation">:</span> <span class="token header-value">timeout=5, max=100</span></span><span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span> <span class="token header-value">Keep-Alive</span></span><span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">text/html; charset=utf-8</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><font color='orange'>空行</font></p><p>至关重要，不能缺少。与请求中空行作用类似。</p></li><li><p><font color='orange'>响应数据</font></p><p>用于存放需要返回给客户端的数据信息。</p><p>响应数据示例：</p><pre class="line-numbers language-http" data-language="http"><code class="language-http">&lt;html>    &lt;head>    &lt;title>HTTP响应示例&lt;title>    &lt;/head>    &lt;body>    Hello HTTP!    &lt;/body>&lt;/html><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>通过以上步骤，数据已经传递完毕，HTTP&#x2F;1.1会维持持久连接，但持续一段时间后会关闭连接，此时需要断开TCP连接。</p><h3 id="1-4-3、关闭连接"><a href="#1-4-3、关闭连接" class="headerlink" title="1.4.3、关闭连接"></a>1.4.3、关闭连接</h3><p><font color='orange'>客户端或服务端都可以关闭连接。每个请求都是用一个单独的网络连接。</font></p><p><font color='red'>注意：服务器不会记忆前面一次的连接或者结果，这种不记忆过去请求的协议被称为 无状态(stateless)协议。</font></p><h1 id="2、GET与POST"><a href="#2、GET与POST" class="headerlink" title="2、GET与POST"></a>2、GET与POST</h1><h2 id="2-1、GET与POST区别"><a href="#2-1、GET与POST区别" class="headerlink" title="2.1、GET与POST区别"></a>2.1、GET与POST区别</h2><ul><li><font color='orange'>GET</font>：GET ⽅法是请求从服务器获取资源，这个资源可以是静态的⽂本、⻚⾯、图⽚视频等。</li><li><font color='orange'>POST</font>：POST ⽅法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报⽂的 body ⾥。</li></ul><h2 id="2-2、GET与POST的安全和幂等"><a href="#2-2、GET与POST的安全和幂等" class="headerlink" title="2.2、GET与POST的安全和幂等"></a>2.2、GET与POST的安全和幂等</h2><h3 id="2-2-1、安全和幂等概念"><a href="#2-2-1、安全和幂等概念" class="headerlink" title="2.2.1、安全和幂等概念"></a>2.2.1、安全和幂等概念</h3><p><font color='orange'>安全</font>：指请求⽅法不会「破坏」服务器上的资源。</p><p><font color='orange'>幂等</font>：多次执⾏相同的操作，结果与执行一次的结果是相同的。</p><h3 id="2-2-2、GET安全与幂等"><a href="#2-2-2、GET安全与幂等" class="headerlink" title="2.2.2、GET安全与幂等"></a>2.2.2、GET安全与幂等</h3><p><font color='orange'>GET ⽅法【安全且幂等】，因为它是「只读」操作，⽆论操作多少次，服务器上的数据 都是安全的，且每次的结果都是相同的。</font></p><h3 id="2-2-3、POST安全与幂等"><a href="#2-2-3、POST安全与幂等" class="headerlink" title="2.2.3、POST安全与幂等"></a>2.2.3、POST安全与幂等</h3><p><font color='orange'>POST 方法【非安全非幂等】，因为是「新增或提交数据」的操作，会创建和修改服务器上的资源，所以非安全非幂等。</font></p><h1 id="3、HTTP特性"><a href="#3、HTTP特性" class="headerlink" title="3、HTTP特性"></a>3、HTTP特性</h1><h2 id="3-1、HTTP1-1优点与缺点"><a href="#3-1、HTTP1-1优点与缺点" class="headerlink" title="3.1、HTTP1.1优点与缺点"></a>3.1、HTTP1.1优点与缺点</h2><h3 id="3-1-1、优点"><a href="#3-1-1、优点" class="headerlink" title="3.1.1、优点"></a>3.1.1、优点</h3><p><font color='orange'>HTTP 突出优点是「简单、灵活、易扩展、跨平台、应用广泛」。 </font></p><ol><li><p><font color='orange'>简单</font></p><p>HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式，易于理解， 降低了学习和使⽤的⻔槛。</p></li><li><p><font color='orange'>灵活易扩展</font></p><p>HTTP协议⾥的各类请求⽅法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许开 发⼈员⾃定义和扩充。 同时 HTTP 由于是⼯作在应⽤层（ OSI 第七层），则它下层可以随意变化。 HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL&#x2F;TLS 安全传输层，HTTP&#x2F;3 甚⾄把 TCP 层换成了基 于 UDP 的 QUIC。</p></li><li><p><font color='orange'>跨平台且应用广泛</font></p><p>互联⽹发展⾄今，HTTP 的应⽤范围⾮常的⼴泛，从台式机的浏览器到⼿机上的各种 APP，从看新闻、 刷贴吧到购物、理财、吃鸡，HTTP 的应⽤⽚地开花，同时天然具有跨平台的优越性。</p></li></ol><h3 id="3-1-2、缺点"><a href="#3-1-2、缺点" class="headerlink" title="3.1.2、缺点"></a>3.1.2、缺点</h3><p><font color='orange'>HTTP 协议是「⽆状态、明⽂传输」，不安全。 </font></p><ol><li><p><font color='orange'>⽆状态双刃剑</font></p><p>⽆状态的好处：因为服务器不会去记忆 HTTP 状态，这能减轻服务器的负担，减少资源占用。 </p><p>⽆状态的坏处：服务器没有记忆能⼒，在完成有关联性的操作时会⾮常麻烦。</p><p>对于⽆状态的问题，解法⽅案有很多种，其中⽐较简单的⽅式⽤ Cookie 技术。 Cookie 通过在请求和响应报⽂中写⼊ Cookie 信息来控制客户端的状态。 相当于，在客户端第⼀次请求后，服务器会下发⼀个装有客户信息的「⼩贴纸」，后续客户端请求服务器的时候，带上「⼩贴纸」，服务器就能认得。</p></li><li><p><font color='orange'>明⽂传输双刃剑</font></p><p>好处：明⽂意味着可⽅便阅读，可以直接⾁眼查看（通过浏览器的 F12 控制台或 Wireshark 抓包都可），提高了调试⼯作的便利性。 </p><p>坏处：HTTP 的所有信息都暴露了。在传输的漫⻓的过程中，很容易被窃取。</p></li><li><p><font color='orange'>不安全</font></p><p>HTTP ⽐较严重的缺点就是不安全：</p><ol><li>通信使⽤明⽂（不加密），内容可能会被窃听。⽐如，账号信息容易泄漏，那你号没了。</li><li>不验证通信⽅的身份，因此有可能遭遇伪装。⽐如，访问假的淘宝、拼多多，那你钱没了。</li><li>⽆法证明报⽂的完整性，所以有可能已遭篡改。⽐如，⽹⻚上植⼊垃圾⼴告，视觉污染，眼没了。</li></ol><p>HTTP 的安全问题，可以⽤ HTTPS 的⽅式解决，也就是通过引⼊ SSL&#x2F;TLS 层，使得在安全上达到了极 致。</p></li></ol><h2 id="3-2、HTTP1-1性能"><a href="#3-2、HTTP1-1性能" class="headerlink" title="3.2、HTTP1.1性能"></a>3.2、HTTP1.1性能</h2><p><font color='orange'>HTTP 协议是基于 TCP&#x2F;IP，且使⽤了「请求 - 应答」的通信模式，所以性能的关键就在这两点中。</font></p><ol><li>长连接</li><li>管道网络传输</li><li>队头阻塞</li></ol><h3 id="3-2-1、长连接"><a href="#3-2-1、长连接" class="headerlink" title="3.2.1、长连接"></a>3.2.1、长连接</h3><p>HTTP&#x2F;1.0中，每发起⼀个请求，都要建立⼀次 TCP 连接（三次握⼿），且是串⾏请求，增加了通信开销。 </p><p>HTTP&#x2F;1.1 提出了⻓连接通信⽅式，也叫持久连接。</p><p><font color='orange'>持久连接的特点是：只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415180426292.png" alt="image-20210415180426292"></p><h3 id="3-2-2、管道网络传输"><a href="#3-2-2、管道网络传输" class="headerlink" title="3.2.2、管道网络传输"></a>3.2.2、管道网络传输</h3><p><font color='orange'>HTTP&#x2F;1.1 采⽤了⻓连接，这使得管道（pipeline）⽹络传输成为了可能。</font></p><p>在同⼀个 TCP 连接中，客户端可以连续发起多个请求，后一个请求不必等待前一个请求处理完毕就可以发送。但是，服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是前⾯的回应特别慢，后⾯就会 有许多请求排队等着。这称为「队头堵塞」。</p><h3 id="3-2-3、队头阻塞"><a href="#3-2-3、队头阻塞" class="headerlink" title="3.2.3、队头阻塞"></a>3.2.3、队头阻塞</h3><p>当顺序发送的请求序列中有⼀个请求被阻塞时，后⾯排队的请求也会⼀同被阻塞，这会导致客户端⼀直请求不到数据，这就是「队头阻塞」。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415180822708.png" alt="image-20210415180822708"></p><h1 id="4、HTTP与HTTPS"><a href="#4、HTTP与HTTPS" class="headerlink" title="4、HTTP与HTTPS"></a>4、HTTP与HTTPS</h1><h2 id="4-1、HTTP与HTTPS区别"><a href="#4-1、HTTP与HTTPS区别" class="headerlink" title="4.1、HTTP与HTTPS区别"></a>4.1、HTTP与HTTPS区别</h2><ol><li><p><font color='orange'>安全性</font></p><p>HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP ⽹络层之间加⼊了 SSL&#x2F;TLS 安全协议，使得报⽂能够加密传输。</p></li><li><p><font color='orange'>建立连接</font></p><p>HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三 次握⼿之后，还需进⾏ SSL&#x2F;TLS 的握⼿过程，才可进⼊加密报⽂传输。</p></li><li><p><font color='orange'>端口号</font></p><p>HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。</p></li><li><p><font color='orange'>身份验证</font></p><p>HTTP不验证通信方的身份是否可信；</p><p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p></li></ol><h2 id="4-2、HTTPS解决了HTTP那些问题"><a href="#4-2、HTTPS解决了HTTP那些问题" class="headerlink" title="4.2、HTTPS解决了HTTP那些问题"></a>4.2、HTTPS解决了HTTP那些问题</h2><p>由于HTTP 是明⽂传输，所以安全上存在以下三个⻛险：</p><ol><li><font color='orange'>窃听⻛险</font>：⽐如通信链路上可以获取通信内容，⽤户号容易没。</li><li><font color='orange'>篡改⻛险</font>：⽐如强制植⼊垃圾⼴告，视觉污染，⽤户眼容易瞎。</li><li><font color='orange'>冒充⻛险</font>：⽐如冒充淘宝⽹站，⽤户钱容易没。</li></ol><p><font color='orange'>HTTPS 在 HTTP 与 TCP 层之间加⼊了 SSL&#x2F;TLS 协议，此方式可以很好解决了上述⻛险：</font></p><ol><li><font color='orange'>信息加密</font>：交互信息⽆法被窃取，但你的号会因为「⾃身忘记」账号⽽没。</li><li><font color='orange'>校验机制</font>：⽆法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾⼴告。</li><li><font color='orange'>身份证书</font>：证明淘宝是真的淘宝⽹，但你的钱还是会因为「剁⼿」⽽没。</li></ol><p>可⻅，只要⾃身不做「恶」，SSL&#x2F;TLS 协议可以保证通信安全。</p><h2 id="4-3、HTTPS加密原理"><a href="#4-3、HTTPS加密原理" class="headerlink" title="4.3、HTTPS加密原理"></a>4.3、HTTPS加密原理</h2><ol><li><font color='orange'>混合加密</font>：实现信息的机密性，解决了窃听⻛险。</li><li><font color='orange'>摘要算法</font>：实现完整性，能够生产校验数据完整性的指纹，解决了篡改⻛险。</li><li><font color='orange'>数字证书</font>：将服务器公钥放⼊到数字证书，解决了冒充⻛险。</li></ol><h3 id="4-3-1、混合加密"><a href="#4-3-1、混合加密" class="headerlink" title="4.3.1、混合加密"></a>4.3.1、混合加密</h3><p><font color='orange'>混合加密可以保证信息机密性，解决窃听⻛险。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415182015246.png" alt="image-20210415182015246"></p><p><font color='orange'>HTTPS 采⽤ 对称加密 和 ⾮对称加密 互相结合的「混合加密」⽅式：</font></p><ul><li>在通信建⽴前采⽤ ⾮对称加密 ⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。</li><li>在通信过程中全部使⽤ 对称加密 方式「会话秘钥」来加密明⽂数据。</li></ul><p><font color='orange'>采⽤「混合加密」方式的原因： </font></p><ol><li>对称加密只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换。</li><li>⾮对称加密使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥必须保密，解决了密钥交换的安全问题，但速度会变慢。</li></ol><h3 id="3-3-2、摘要算法"><a href="#3-3-2、摘要算法" class="headerlink" title="3.3.2、摘要算法"></a>3.3.2、摘要算法</h3><p><font color='orange'>摘要算法用于实现完整性，能生成校验数据完整性的指纹，解决了篡改⻛险。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415182326356.png" alt="image-20210415182326356"></p><p><font color='orange'>客户端通过 摘要算法 算出明⽂的「指纹」，然乎将「指纹 + 明⽂」⼀同加密后发送给服务器，服务器通过 相同的摘要算法 计算得出明⽂，通过对比客户端携带的「指纹」和当前 计算得出的「指纹，若「指纹」相同，说明数据完整。</font></p><h3 id="4-3-3、数字证书"><a href="#4-3-3、数字证书" class="headerlink" title="4.3.3、数字证书"></a>4.3.3、数字证书</h3><p><font color='orange'>客户端先向服务端索要公钥，然后⽤公钥加密信息，服务器收到密⽂后，⽤⾃⼰的私钥解密。</font> </p><p>这就存在些问题，如何保证公钥信任度和不被篡改呢？ </p><p>所以这⾥就需要借助第三⽅权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415182616713.png" alt="image-20210415182616713"></p><p><font color='orange'>通过数字证书的⽅式保证服务器公钥的身份，解决冒充的⻛险。</font></p><h2 id="4-4、HTTPS如何建立连接"><a href="#4-4、HTTPS如何建立连接" class="headerlink" title="4.4、HTTPS如何建立连接"></a>4.4、HTTPS如何建立连接</h2><h3 id="4-4-1、SSL-TLS协议基本流程"><a href="#4-4-1、SSL-TLS协议基本流程" class="headerlink" title="4.4.1、SSL&#x2F;TLS协议基本流程"></a>4.4.1、SSL&#x2F;TLS协议基本流程</h3><ol><li>客户端 向 服务器索要公钥并验证。 </li><li>双⽅协商⽣成「会话秘钥」。 </li><li>双⽅通过「会话秘钥」进⾏加密通信。</li></ol><p>前两步也就是 SSL&#x2F;TLS 握⼿阶段。</p><p>SSL&#x2F;TLS 的「握⼿阶段」涉及四次通信，可⻅下图：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415183012254.png" alt="image-20210415183012254"></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415183132165.png" alt="image-20210415183132165"></p><h3 id="4-4-2、SSL-TLS协议详细流程"><a href="#4-4-2、SSL-TLS协议详细流程" class="headerlink" title="4.4.2、SSL&#x2F;TLS协议详细流程"></a>4.4.2、SSL&#x2F;TLS协议详细流程</h3><p>SSL&#x2F;TLS 协议建⽴的详细流程： </p><ol><li><p><font color='orange'>Client Hello</font></p><p>⾸先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。 </p><p>在这⼀步，客户端主要向服务器发送以下信息： </p><ol><li>客户端⽀持的 SSL&#x2F;TLS 协议版本，如 TLS 1.2 版本。</li><li>客户端⽣成的随机数（ Client Random ），后⾯⽤于⽣产「会话秘钥」。</li><li>客户端⽀持的密码套件列表，如 RSA 加密算法。</li></ol></li><li><p><font color='orange'>Sever Hello</font></p><p>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello 。</p><p>服务器回应的内容有如下内容：</p><ol><li>确认 SSL&#x2F; TLS 协议版本，如果浏览器不⽀持，则关闭加密通信。</li><li>服务器⽣成随机数（ Server Random ），后⾯⽤于⽣产「会话秘钥」。</li><li>确认密码套件列表，如 RSA 加密算法。</li><li>服务器数字证书。</li></ol></li><li><p><font color='orange'>客户端回应</font></p><p><font color='orange'>客户端收到服务器回应之后，先通过浏览器或者操作系统中的 CA 公钥来确认服务器数字证书的真实性。 如果证书没有问题，客户端会从数字证书中取出服务器公钥，然后使⽤它加密报⽂，并向服务器发送如下信息：</font></p><ol><li><p>⼀个随机数（ pre-master key ）。该随机数会被服务器公钥加密。</p></li><li><p>加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。</p></li><li><p>客户端握⼿结束通知，表示客户端的握⼿阶段已经结束。这⼀项同时把之前所有内容发⽣的数据做个摘要，⽤来供服务端校验。</p></li></ol><p><font color='orange'>上⾯第1项中的随机数是整个握⼿阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就⽤双⽅协商的加密算法，各⾃⽣成本次通信的「会话秘钥」。</font></p></li><li><p><font color='orange'>服务器最后回应</font></p><p><font color='orange'>服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发送最后信息：</font></p><ol><li>加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。</li><li>服务器握⼿结束通知，表示服务器的握⼿阶段已经结束。这⼀项同时把之前所有内容发⽣的数据做个摘要，⽤来供客户端校验。</li></ol><p>⾄此，整个 SSL&#x2F;TLS 的握⼿阶段全部结束。接下来，客户端与服务器进⼊加密通信，就完全是使⽤普通的 HTTP 协议，只不过⽤「会话秘钥」加密内容。</p></li></ol><h1 id="5、HTTP版本演变"><a href="#5、HTTP版本演变" class="headerlink" title="5、HTTP版本演变"></a>5、HTTP版本演变</h1><h2 id="5-1、HTTP-1-0"><a href="#5-1、HTTP-1-0" class="headerlink" title="5.1、HTTP&#x2F;1.0"></a>5.1、HTTP&#x2F;1.0</h2><p>1996年5月，HTTP&#x2F;1.0 发布，为了提高系统的效率，<font color='orange'>HTTP&#x2F;1.0 规定浏览器与服务器只保持短暂连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。</font></p><p>TCP连接建立需要三次握手，很耗费，HTTP&#x2F;1.0的性能比较差。</p><h2 id="5-2、HTTP-1-1"><a href="#5-2、HTTP-1-1" class="headerlink" title="5.2、HTTP&#x2F;1.1"></a>5.2、HTTP&#x2F;1.1</h2><p>HTTP&#x2F;1.1 相⽐ HTTP&#x2F;1.0 性能上的改进： </p><ol><li><font color='orange'>TCP长连接</font>：使⽤ TCP⻓连接⽅式短连接的性能开销；</li><li><font color='orange'>管道（pipeline）⽹络传输</font>：只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。</li></ol><p>但是，HTTP&#x2F;1.1 也有如下缺点： </p><ol><li>请求 &#x2F; 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤。只能压缩 Body 的部分；</li><li>发送冗⻓的⾸部。每次互相发送相同的⾸部造成的浪费较多；</li><li>服务器是按请求顺序响应的，如果响应中的某个请求阻塞了，那么后面请求会被全部阻塞，会导致客户端⼀直请求不到数据，这就是队头阻塞； </li><li>没有请求优先级控制； </li><li>请求只能从客户端开始，服务器只能被动响应。</li></ol><h2 id="5-3、HTTP-2"><a href="#5-3、HTTP-2" class="headerlink" title="5.3、HTTP&#x2F;2"></a>5.3、HTTP&#x2F;2</h2><h3 id="5-3-1、HTTP-2性能"><a href="#5-3-1、HTTP-2性能" class="headerlink" title="5.3.1、HTTP&#x2F;2性能"></a>5.3.1、HTTP&#x2F;2性能</h3><p><font color='orange'>HTTP&#x2F;2 协议基于 HTTPS ，所以 HTTP&#x2F;2 的安全性有保障。 </font></p><p>HTTP&#x2F;2 相⽐ HTTP&#x2F;1.1，在性能上的改进如下：</p><ol><li><font color='orange'>头部压缩（Hpack压缩算法、QPack算法）</font></li><li><font color='orange'>二进制格式</font></li><li><font color='orange'>数据流（Stream）</font></li><li><font color='orange'>多路复用</font></li><li><font color='orange'>服务器推送</font></li></ol><h4 id="5-3-1-1、头部压缩"><a href="#5-3-1-1、头部压缩" class="headerlink" title="5.3.1.1、头部压缩"></a>5.3.1.1、头部压缩</h4><p>HTTP&#x2F;2 会压缩头（Header）如果你同时发出多个请求，且他们的头相同或相似时，协议就会帮你消除重复部分。</p><p>HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索引号，以后就不发送同样字段了，只发送索引号，这样就提⾼速度了。</p><h4 id="5-3-1-2、二进制格式"><a href="#5-3-1-2、二进制格式" class="headerlink" title="5.3.1.2、二进制格式"></a>5.3.1.2、二进制格式</h4><p>HTTP&#x2F;2 中不再有 HTTP&#x2F;1.1 中纯⽂本形式的报⽂了，⽽是全⾯采⽤⼆进制格式。头信息和数据体都是⼆进制，且统称为帧（frame）：头信息帧和数据帧。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415184254532.png" alt="image-20210415184254532"></p><p>计算机只懂⼆进制，故收到报⽂后就可以直接解析，避免了转换的步骤，增加了数据传输的效率。</p><h4 id="5-3-1-3、数据流"><a href="#5-3-1-3、数据流" class="headerlink" title="5.3.1.3、数据流"></a>5.3.1.3、数据流</h4><p>HTTP&#x2F;2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p><font color='orange'>每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。</font></p><p><font color='orange'>客户端还可以指定数据流优先级。优先级⾼的请求，服务器会优先对该请求响应。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415184608092.png" alt="image-20210415184608092"></p><h4 id="5-3-1-4、多路复用"><a href="#5-3-1-4、多路复用" class="headerlink" title="5.3.1.4、多路复用"></a>5.3.1.4、多路复用</h4><p><font color='orange'>HTTP&#x2F;2 可以在⼀个连接中并发执行多个请求或回应，且无需按照顺序⼀⼀对应。</font></p><p>移除 HTTP&#x2F;1.1 串⾏请求，无需排队等待，故也就不会再出现「队头阻塞」问题，降低了延迟， ⼤幅度提⾼了连接利⽤率。</p><p>举例来说，在⼀个 TCP 连接⾥，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程⾮常耗时，那么就会先回应 A 请求已经处理好的部分，然后回应 B 请求，当B请求的响应完成后，再回来继续回应 A 请求剩下的部分。</p><h4 id="5-3-1-5、服务器推送"><a href="#5-3-1-5、服务器推送" class="headerlink" title="5.3.1.5、服务器推送"></a>5.3.1.5、服务器推送</h4><p><font color='orange'>HTTP&#x2F;2 ⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务端不再是被动响应，也可以主动 向客户端发送消息。</font></p><p>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、CSS ⽂件等静态资源主动发给 客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。</p><h3 id="5-3-2、HTTP-2缺陷"><a href="#5-3-2、HTTP-2缺陷" class="headerlink" title="5.3.2、HTTP&#x2F;2缺陷"></a>5.3.2、HTTP&#x2F;2缺陷</h3><p>HTTP&#x2F;2 主要问题：<font color='orange'>多个 HTTP 请求复⽤⼀个 TCP 连接时，下层的 TCP 协议不会知道有多少 HTTP 请求。所以⼀旦发⽣了丢包现象，就会触发 TCP 重传机制，⼀个 TCP 连接中的所有 HTTP 请求都必须等待这个丢了的包被重传回来时才能继续走下去。</font></p><p>HTTP&#x2F;2丢包阻塞与HTTP&#x2F;1.1管道阻塞的区别如下：</p><ul><li>HTTP&#x2F;1.1 管道（ pipeline）传输中如果某个请求被阻塞了，那么该请求后的请求也会被统统阻塞住。 </li><li>HTTP&#x2F;2 多个请求复⽤⼀个TCP连接，⼀旦发⽣丢包，就会阻塞住所有的 HTTP 请求。</li></ul><h2 id="5-4、HTTP3"><a href="#5-4、HTTP3" class="headerlink" title="5.4、HTTP3"></a>5.4、HTTP3</h2><p><font color='orange'>HTTP&#x2F;2的缺陷来源于 TCP 传输层，故，HTTP&#x2F;3 把 HTTP 下层的 TCP 协议换成了 UDP。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415185214946.png" alt="image-20210415185214946"></p><p>UDP 不管顺序，也不管丢包，所以不会出现 HTTP&#x2F;1.1 的队头阻塞 和 HTTP&#x2F;2 的丢包全部重传问题。 </p><p><font color='orange'>UDP 是不可靠传输，但基于 UDP 的 QUIC 协议 可以帮助其达到类似 TCP 的可靠性传输效果。</font></p><ul><li><font color='orange'>QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性。当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到影响。</font></li><li><font color='orange'>TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack 。</font></li><li>HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是TCP三次握⼿，然后 TLS&#x2F;1.3 三次握⼿。 QUIC 直接把以往的 TCP 和 TLS&#x2F;1.3 的 6 次交互合并成了 3 次，减少了交互次数。</li></ul><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415185337860.png" alt="image-20210415185337860"></p><p>所以， QUIC 是⼀个在 UDP 之上的伪 TCP + TLS + HTTP&#x2F;2 的多路复⽤协议。</p><p>很多⽹络设根本不知道什么是 QUIC，只会当做 UDP，这样会出现新问题。所以 HTTP&#x2F;3 普及速度⾮常缓慢，未来 UDP 是否能够逆袭 TCP也很难说。</p><h1 id="6、HTTP-TCP-Keep-Alive"><a href="#6、HTTP-TCP-Keep-Alive" class="headerlink" title="6、HTTP&#x2F;TCP Keep-Alive"></a>6、HTTP&#x2F;TCP Keep-Alive</h1><h2 id="6-1、HTTP-Keep-Alive"><a href="#6-1、HTTP-Keep-Alive" class="headerlink" title="6.1、HTTP Keep-Alive"></a>6.1、HTTP Keep-Alive</h2><h3 id="6-1-1、为什么HTTP是短连接"><a href="#6-1-1、为什么HTTP是短连接" class="headerlink" title="6.1.1、为什么HTTP是短连接"></a>6.1.1、为什么HTTP是短连接</h3><p>众所周知，HTTP是短连接，client向server发送一个request，得到response后，连接就关闭。之所以这样设计使用，主要是考虑到实际情况。例如，用户通过浏览器访问一个web站点上的某个网页，当网页内容加载完毕之后，用户可能需要花费几分钟甚至更多的时间来浏览网页内容，此时完全没有必要继续维持底层连接。当用户需要访问其他网页时，再创建新的连接即可。</p><p>因此，HTTP连接的寿命通常都很短。这样做的好处是，可以极大的减轻服务端的压力。一般而言，一个站点能支撑的最大并发连接数也是有限的，面对这么多客户端浏览器，不可能长期维持所有连接。每个客户端取得自己所需的内容后，即关闭连接，更加合理。</p><h3 id="6-1-2、为什么要引入keep-alive"><a href="#6-1-2、为什么要引入keep-alive" class="headerlink" title="6.1.2、为什么要引入keep-alive"></a>6.1.2、为什么要引入keep-alive</h3><p>一个网页中，可能引入了几十个js、css文件，上百张图片，如果每请求一个资源就创建一个连接，代价会很大。</p><p>为解决该问题，只需保证一个连接能在<strong>短时间</strong>内得到复用即可，这就是HTTP协议中keep-alive属性的作用。</p><blockquote><ul><li>HTTP 1.0 默认关闭Keep-Alive，若要启用 则需要在http头中加入”Connection: Keep-Alive”；</li><li>HTTP 1.1 默认启用Keep-Alive，若要关闭 则需要在http头中加入”Connection: close “。</li></ul></blockquote><h3 id="6-1-3、Server端如何处理Keep-Alive"><a href="#6-1-3、Server端如何处理Keep-Alive" class="headerlink" title="6.1.3、Server端如何处理Keep-Alive"></a>6.1.3、Server端如何处理Keep-Alive</h3><p><font color='orange'>一个连接的复用时间长短，通常由web服务器控制。</font></p><p><font color='orange'>HTTP协议中，Keep-Alive属性保持连接的时间长短由服务端决定，通常都在几十秒左右。</font>除此之外，一些异常情况会导致 keepalive失效。</p><h3 id="6-1-4、JDK对keep-alive的支持"><a href="#6-1-4、JDK对keep-alive的支持" class="headerlink" title="6.1.4、JDK对keep-alive的支持"></a>6.1.4、JDK对keep-alive的支持</h3><p>当创建一个HttpUrlConnection对象时，底层实际上会创建一个对应的Socket对象。<font color='orange'>要复用的并非是HttpUrlConnection，而是底层的Socket。</font></p><p>JDK对keepalive的支持是默认开启，我们要做的是学会如何正确有效使用。</p><p>参见：<a href="https://link.zhihu.com/?target=https://docs.oracle.com/javase/8/docs/technotes/guides/net/http-keepalive.html">https://docs.oracle.com/javase/8/docs/technotes/guides/net/http-keepalive.html</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">When</span> the application finishes reading the response body or when the application calls <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> on the <span class="token class-name">InputStream</span> returned by <span class="token class-name">URLConnection</span><span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> the <span class="token constant">JDK</span>'s <span class="token constant">HTTP</span> protocol handler will <span class="token keyword">try</span> <span class="token keyword">to</span> <span class="token namespace">clean</span> up the connection and <span class="token keyword">if</span> successful<span class="token punctuation">,</span> put the connection into a connection cache <span class="token keyword">for</span> reuse by future <span class="token constant">HTTP</span> requests<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这段话的含义是：当通过URLConnection.getInputStream()读取响应数据之后(这里是HttpUrlConnection)，应该调用InputStream的close方法关闭输入流，JDK http协议处理器会将这个连接放到一个连接缓存中，以便后续HTTP请求来复用。</p><h2 id="6-2、TCP-Keep-Alive"><a href="#6-2、TCP-Keep-Alive" class="headerlink" title="6.2、TCP Keep-Alive"></a>6.2、TCP Keep-Alive</h2><h3 id="6-2-1、TCP-Keep-Alive探针"><a href="#6-2-1、TCP-Keep-Alive探针" class="headerlink" title="6.2.1、TCP Keep-Alive探针"></a>6.2.1、TCP Keep-Alive探针</h3><p><font color='orange'>对于一方发起的keepalive探针，另一方必须响应。</font>响应可能是以下三种形式之一：</p><ol><li><font color='orange'>对方回应了ACK</font>：说明一切OK。如果接下来2小时还没有数据传输，那么还会继续发送keepalive探针，以确保连接存活。</li><li><font color='orange'>对方回复RST</font>：表示这个连接已经不存在。例如一方服务宕机后重启，此时接收到探针，因为不存在对应的连接。</li><li><font color='orange'>没有回复</font>：说明socket已经被关闭了。</li></ol><ul><li><font color='orange'>tcp_keepalive_intvl</font>：keepalive探测包的发送间隔，默认为75秒。</li><li><font color='orange'>tcp_keepalive_probes</font>：如果对方不予应答，探测包的最大发送次数，默认为9次。即连续9次发送，都没有应答的话，则关闭连接。</li><li><font color='orange'>tcp_keepalive_time</font>：连接的最大空闲(idle)时间，默认为7200秒，即2个小时。需要注意的是，这2个小时，指的是只有keepalive探测包，如果期间存在其他数据传输，则重新计时。</li></ul><p>这些默认值在 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4 目录下可以找到，文件中的值就是默认值。</p><p><font color='orange'>TCP中的SO_KEEPALIVE是一个开关选项，默认关闭，需要在代码中显式开启。当开启后，通信双方没有数据传输时操作系统底层会定时发送keepalive探测包，以保证连接存活。</font></p><p>在Java 中可以通过Socket设置keepAlive为true：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Socket</span> socket<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>socket<span class="token punctuation">.</span><span class="token function">setKeepAlive</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//开启keep alive</span>socket<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="6-2-2、TCP-Keep-Alive缺点"><a href="#6-2-2、TCP-Keep-Alive缺点" class="headerlink" title="6.2.2、TCP Keep-Alive缺点"></a>6.2.2、TCP Keep-Alive缺点</h3><ol><li><font color='orange'>keep alive只能检测连接是否存活，不能检测连接是否可用。</font>例如，某一方发生了死锁，无法在连接上进行任何读写操作，但是操作系统仍然可以响应网络层keepalive包。</li><li><font color='orange'>TCP keepalive 机制依赖于操作系统实现，灵活性不够，默认关闭，且keepalive 心跳时间默认是两个小时，时间较长。</font></li><li><font color='orange'>代理(如socks proxy)、负载均衡器等工具会让tcp keep-alive失效。</font></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系列-IP图表分析</title>
      <link href="/2023/07/30/ip-tu-biao-jie-xi/"/>
      <url>/2023/07/30/ip-tu-biao-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="IP基本认识"><a href="#IP基本认识" class="headerlink" title="IP基本认识"></a>IP基本认识</h1><h2 id="IP作用"><a href="#IP作用" class="headerlink" title="IP作用"></a>IP作用</h2><p><font color='orange'>IP 在 TCP&#x2F;IP 参考模型中处于第三层，即 ⽹络层。</font></p><p><font color='orange'>⽹络层主要作⽤：实现主机之间的通信，也叫点对点（end to end）通信。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415201526742.png" alt="image-20210415201526742"></p><h2 id="IP与MAC关系"><a href="#IP与MAC关系" class="headerlink" title="IP与MAC关系"></a>IP与MAC关系</h2><p><font color='orange'>MAC 作⽤：实现两个直连设备间的通信；IP 实现两个无直连⽹络间的通信传输。</font></p><p>举个⽣活的栗⼦，⼩林要去⼀个很远的地⽅旅⾏，制定了⼀个⾏程表，其间需先后乘坐⻜机、地铁、公 交⻋才能抵达⽬的地，为此⼩林需要买⻜机票，地铁票等。⻜机票和地铁票都是去往特定的地点的，每张票只能够在某⼀限定区间内移动。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415202504342.png" alt="image-20210415202504342"></p><p>同时要注意，如果⼩林只有⾏程表⽽没有⻋票，就⽆法搭乘交通⼯具到达⽬的地。相反，如果除了⻋票⽽没有⾏程表，恐怕也很难到达⽬的地。因为⼩林不知道该坐什么⻋，也不知道该在哪⾥换乘。</p><p>针对以上描述，可总结如下：</p><ul><li>此处的「区间内移动」就如同数据链路层。</li><li>区间内的出发点好⽐源 MAC 地址，⽬标地点好⽐⽬的 MAC 地址。</li><li>整个旅游⾏程表就相当于⽹络层。</li><li>⾏程的开始好⽐源 IP，⾏程的终点好⽐⽬的 IP 地址。</li><li>计算机⽹络中同时需要「数据链路层」和「⽹络层」两个分层才能实现与最终⽬标地址的通信。</li><li>在⽹络数据包传输中，源IP地址和⽬标IP地址不会变化，只有源 MAC 地址和⽬标 MAC ⼀直在变化。</li></ul><h1 id="IP地址基础知识"><a href="#IP地址基础知识" class="headerlink" title="IP地址基础知识"></a>IP地址基础知识</h1><h2 id="IP地址定义"><a href="#IP地址定义" class="headerlink" title="IP地址定义"></a>IP地址定义</h2><p>TCP&#x2F;IP ⽹络通信时，为了保证正常通信，每个设备都需要配置正确的 IP 地址，否则⽆法实现正常通信。</p><p> <font color='orange'>IP 地址（IPv4 地址）由 32 位正整数表示，IP 在计算机中是以⼆进制⽅式处理。 ⽽⼈类为了⽅便记忆采⽤了点分⼗进制的标记⽅式，也就是将 32 位 IP 地址以每 8 位为1组，共分为 4 组，每组以「 . 」隔开，再将每组转换成⼗进制。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415203544505.png" alt="image-20210415203544505"></p><p>那么， <font color='orange'>IP 地址最⼤值就是：<code>2^32 = 4294967296</code>，也就是说最大允许43亿台计算机连接到网络。</font></p><p>实际上， <font color='orange'>IP 地址并非根据主机台数来配置，⽽是根据⽹卡来配置。</font> <font color='orange'>IP 地址是由「⽹络标识」和「主机标识」两个部分组成，能够连接到⽹络的计算机个数很少。</font></p><blockquote><p>电脑配了 IP， ⼿机、IPad 等电⼦设备都配了 IP， 照理来说肯定会超过 43 亿啦，那是怎么能够⽀持这么多 IP 的呢？因为会根据⼀种可以更换 IP 地址的技术 NAT ，使得可连接计算机数超过 43 亿台。 </p></blockquote><h2 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h2><h3 id="IP地址类型"><a href="#IP地址类型" class="headerlink" title="IP地址类型"></a>IP地址类型</h3><p>互联⽹诞⽣之初，IP 地址显得很充裕，于是计算机科学家们设计了分类地址。 </p><p> <font color='orange'>IP 地址分类成了 5 种类型：A 类、B 类、C 类、D 类、E 类。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415204302389.png" alt="image-20210415204302389"></p><p>上图中⻩⾊部分为分类号，⽤以区分 IP 地址类别。</p><h3 id="A、B、C类型地址"><a href="#A、B、C类型地址" class="headerlink" title="A、B、C类型地址"></a>A、B、C类型地址</h3><p> <font color='orange'>A、B、C 类IP地址主要分为两个部分，分别是⽹络号和主机号。</font></p><p>A、B、C 分类对应的地址范围、最⼤主机个数如下：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415204603352.png" alt="image-20210415204603352"></p><p> <font color='orange'>最⼤主机数，就是看主机号的位数</font>，如 C 类地址的主机号占 8 位，那么 C 类地址的最⼤主机个数：</p><pre class="line-numbers language-none"><code class="language-none">2^8 - 2 &#x3D; 254<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为什么要减 2 呢？ 因为在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和 全为 0 地址。</p><ul><li><font color='orange'>主机号全为 1 指的是 某个⽹络下的所有主机，⽤于⼴播。</font></li><li><font color='orange'>主机号全为 0 指的是 某个⽹络。</font></li></ul><h3 id="D、E类型地址"><a href="#D、E类型地址" class="headerlink" title="D、E类型地址"></a>D、E类型地址</h3><p> <font color='orange'>D 类和 E 类地址没有主机号，所以不可⽤于主机 IP，D 类常被⽤于多播，E 类是预留分类， 暂未使⽤。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415205817207.png" alt="image-20210415205817207"></p><p> <font color='orange'>多播地址作用：多播⽤于将包发送给特定组内的所有主机。</font></p><p>多播使⽤ D 类地址，其前四位是 1110 的就表示是多播地址，⽽剩下的 28 位是多播的组编号。 </p><p>从 224.0.0.0 ~ 239.255.255.255 都是多播的可⽤范围，其划分为以下三类：</p><ul><li>224.0.0.0 ~ 224.0.0.255 为预留的组播地址，只能在局域⽹中，路由器是不会进⾏转发的。</li><li>224.0.1.0 ~ 238.255.255.255 为⽤户可⽤的组播地址，可以⽤于 Internet 上。</li><li>239.0.0.0 ~ 239.255.255.255 为本地管理组播地址，可供内部⽹内部使⽤，仅在特定的本地范围有效。</li></ul><h3 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h3><p> <font color='orange'>⼴播地址⽤于在同⼀个链路中相互连接的主机之间发送数据包。</font></p><p>当主机号全为 1 时，就表示该⽹络的⼴播地址。</p><p>⼴播地址可以分为本地⼴播和直接⼴播两种：</p><ul><li><font color='orange'>本⽹络内进行⼴播 称为 本地⼴播</font></li></ul><p>  例如⽹络地址为 192.168.0.0&#x2F;24 的情况下，⼴播地址是 192.168.0.255 。因为这个⼴播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0&#x2F;24 以外的 其他链路上。</p><ul><li><font color='orange'>不同⽹络之间进行⼴播 称为 直接⼴播</font></li></ul><p>  例如⽹络地址为 192.168.0.0&#x2F;24 的主机向 192.168.1.255&#x2F;24 的⽬标地址发送 IP 包。收到这个包的路由器，将数据转发给 192.168.1.0&#x2F;24，从⽽使得所有 192.168.1.1~192.168.1.254 的主机都能收到这个包（由于直接⼴播有⼀定的安全问题，多数情况 下会在路由器上设置为不转发。） 。</p><h3 id="IP地址分类优劣"><a href="#IP地址分类优劣" class="headerlink" title="IP地址分类优劣"></a>IP地址分类优劣</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>简单明了、选路（基于⽹络地址）简单，通过判断首位是0还是1就能 快速找出 ⽹络地址和主机地址。</p><p>其余分类判断⽅式参考如下：</p><p>第一位为：</p><ul><li>0：A类地址</li><li>1：第二位为：<ul><li>0：B类地址</li><li>1：第三位为：<ul><li>0：C类地址</li><li>1：第四位：<ul><li>0：D类地址</li><li>1：E类地址</li></ul></li></ul></li></ul></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>同一网络下没有地址层次。</li><li>A、B、C类不能很好与现实网络匹配。</li></ol><p>以上两个缺点都可以 通过使用 CIDR无分类地址 来解决。</p><h2 id="CIDR（无分类IP地址）"><a href="#CIDR（无分类IP地址）" class="headerlink" title="CIDR（无分类IP地址）"></a>CIDR（无分类IP地址）</h2><h3 id="CIDR简介"><a href="#CIDR简介" class="headerlink" title="CIDR简介"></a>CIDR简介</h3><p> <font color='orange'>正因为 IP 分类存在许多缺点，所以提出⽆分类地址⽅案，即 CIDR。</font></p><p> <font color='orange'>CIDR不再分类地址，32 ⽐特的 IP 被划分为两部分：前⾯是⽹络号，后⾯是主机号。</font></p><h3 id="网络号和主机号划分"><a href="#网络号和主机号划分" class="headerlink" title="网络号和主机号划分"></a>网络号和主机号划分</h3><p> <font color='orange'>无分类地址格式为：a.b.c.d&#x2F;x ，其中 &#x2F;x 表示前 x 位属于⽹络号， x 的范围是 0 ~ 32 ，这使得 IP 地址更加灵活。</font></p><p>⽐如 10.100.122.2&#x2F;24，就是无分类地址，&#x2F;24 表示前 24 位是⽹络号，剩余的 8 位是主机号。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415211145547.png" alt="image-20210415211145547"></p><p> <font color='orange'>另⼀种 划分⽹络号与主机号 的方式是 ⼦⽹掩码，掩码就是掩盖掉主机号，剩下的是⽹络号。</font> </p><p> <font color='orange'>对 ⼦⽹掩码 和 IP地址 执行与运算，就可得到⽹络号。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415211234778.png" alt="image-20210415211234778"></p><p><strong>为何划分网络号和主机号</strong></p><p> <font color='orange'>因为 两台计算机想通讯就得先判断是否处于同⼀个⼴播域内，即⽹络地址是否相同。如果⽹络地址相同，表明接受⽅在本⽹络上且可以把数据包直接发送到⽬标主机。</font></p><p>路由器寻址 就是采用该方式来 找到 对应⽹络号，进⽽把 数据包 转发给 对应⽹络。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415211525393.png" alt="image-20210415211525393"></p><h3 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h3><h4 id="何为子网划分"><a href="#何为子网划分" class="headerlink" title="何为子网划分"></a>何为子网划分</h4><p> <font color='orange'>⼦⽹掩码 可以 划分出 ⽹络号 和 主机号，还可 划分⼦⽹。</font></p><p> <font color='orange'>⼦⽹划分实际上是将主机地址分为两个部分：⼦⽹⽹络地址 和 ⼦⽹主机地址</font>。形式如下：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415211605113.png" alt="image-20210415211605113"></p><ul><li>未做⼦⽹划分的 ip 地址：⽹络地址＋主机地址。</li><li>做⼦⽹划分后的 ip 地址：⽹络地址＋（⼦⽹⽹络地址＋⼦⽹主机地址）。</li></ul><h4 id="子网划分原理"><a href="#子网划分原理" class="headerlink" title="子网划分原理"></a>子网划分原理</h4><p>假设对 C 类地址进⾏⼦⽹划分，⽹络地址 192.168.1.0，使⽤⼦⽹掩码 255.255.255.192 对其进⾏⼦⽹划分。 </p><p>C 类地址中前 24 位是⽹络号，最后 8 位是主机号，根据⼦⽹掩码可知从 8 位主机号中借⽤ 2 位作为⼦⽹号。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415211738776.png" alt="image-20210415211738776"></p><p>由于⼦⽹⽹络地址被划分成 2 位，那么⼦⽹地址就有 4 个，分别是 00、01、10、11，具体划分如下图：</p><p><strong>子网0</strong></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415211918539.png" alt="image-20210415211918539"></p><p><strong>子网1</strong></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415211943850.png" alt="image-20210415211943850"></p><p><strong>子网2</strong></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415212003104.png" alt="image-20210415212003104"></p><p><strong>子网3</strong></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415212019344.png" alt="image-20210415212019344"></p><p>划分后的 4 个⼦⽹如下表格：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415212042823.png" alt="image-20210415212042823"></p><h2 id="公有IP地址与私有IP地址"><a href="#公有IP地址与私有IP地址" class="headerlink" title="公有IP地址与私有IP地址"></a>公有IP地址与私有IP地址</h2><h3 id="公私IP地址简介"><a href="#公私IP地址简介" class="headerlink" title="公私IP地址简介"></a>公私IP地址简介</h3><p> <font color='orange'>在 A、B、C 类地址中，实际上可分为公有 IP 地址和私有 IP 地址。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415212322287.png" alt="image-20210415212322287"></p><p>每个⼩区都有⾃⼰的楼编号和⻔牌号，你⼩区家可以叫 1 栋 101 号，我⼩区家也可以叫 1 栋 101，没有任何问题。但⼀旦出了⼩区，就需要带上中⼭路 666 号（公⽹ IP 地址），是国家统⼀分配 的，不能两个⼩区都叫中⼭路 666。</p><p>所以，公有 IP 地址是有个组织统⼀分配的，假设你要开⼀个博客⽹站，那么你就需要去申请购买⼀个 公有 IP，这样全世界的⼈才能访问。并且公有 IP 地址基本上要在整个互联⽹范围内保持唯⼀。</p><h3 id="公私IP地址管理机构"><a href="#公私IP地址管理机构" class="headerlink" title="公私IP地址管理机构"></a>公私IP地址管理机构</h3><p>私有 IP 地址通常 由 内部IT⼈员管理，公有 IP 由 ICANN 组织管理，中⽂叫「互联⽹名称与数字地址分配机构」。</p><p> <font color='orange'>IANA 是 ICANN中的⼀个机构，它负责分配互联⽹ IP 地址，是按州的⽅式层层分配。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415212554129.png" alt="image-20210415212554129"></p><ul><li>ARIN 北美地区</li><li>LACNIC 拉丁美洲和⼀些加勒⽐群岛</li><li>RIPE NCC 欧洲、中东和中亚</li><li>AfriNIC ⾮洲地区</li><li>APNIC 亚太地区</li></ul><p> <font color='orange'>在中国由 CNNIC 机构管理，它是国内唯⼀指定的全局 IP 地址管理组织。</font></p><h2 id="IP地址与路由控制"><a href="#IP地址与路由控制" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h2><p> <font color='orange'>IP地址的 ⽹络地址 部分⽤于进⾏路由控制。</font></p><p>路由控制表中记录着⽹络地址与下⼀步应该发送⾄路由器的地址。在主机和路由器上都会有各⾃的路由器控制表。</p><p> <font color='orange'>发送 IP 包时 要先 确定 IP 包⾸部中的⽬标地址，再从路由控制表中找到与该地址具有相同⽹络地址的记录，根据该记录将 IP 包转发给相应的下⼀个路由器。如果路由控制表中存在多条相同⽹络地址 的记录，就选择相同位数最多的⽹络地址，也就是最⻓匹配。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415212845042.png" alt="image-20210415212845042"></p><ol><li>主机 A 要发送⼀个 IP 包，其源地址是 10.1.1.30 和⽬标地址是 10.1.2.10 ，由于没有在主机 A 的路由表找到与⽬标地址 10.1.2.10 的⽹络地址，于是包被转发到默认路由（路由器 1 ）。</li><li>路由器 1 收到 IP 包后，也在路由器 1 的路由表匹配与⽬标地址相同的⽹络地址记录，发现匹配 到了，于是就把 IP 数据包转发到了 10.1.0.2 这台路由器 2。</li><li>路由器 2 收到后，同样对⽐⾃身的路由表，发现匹配到了，于是把 IP 包从路由器 2 的 10.1.2.1 这个接⼝出去，最终经过交换机把 IP 数据包转发到了⽬标主机。</li></ol><h3 id="环回地址"><a href="#环回地址" class="headerlink" title="环回地址"></a>环回地址</h3><p>环回地址 是在同⼀台计算机上的程序之间进⾏⽹络通信时所使⽤的默认地址。</p><p>计算机使⽤ 127.0.0.1 作为环回地址，与之相同的是主机名 localhost 。使⽤这个 IP 或主机名时，数据包不会流向⽹络。</p><h2 id="IP分片与重组"><a href="#IP分片与重组" class="headerlink" title="IP分片与重组"></a>IP分片与重组</h2><p>每种数据链路的最⼤传输单元 MTU 都不相同，如 FDDI 数据链路 MTU 为 4352、以太⽹ MTU 为 1500 字节等。</p><p>每种数据链路的 MTU 之所以不同，是因为不同类型的数据链路 其 使⽤⽬的不同，故可承载的 MTU 也就不同。</p><p> <font color='orange'>最常⻅的数据链路是以太⽹，它的 MTU 是 1500 字节。</font></p><p> <font color='orange'>当 IP 数据包⼤⼩⼤于 MTU 时， IP 数据包会被分⽚，分⽚后的 IP 数据包在被重组时，只能由⽬标主机进⾏，路由器不会进⾏重组。</font></p><p>假设发送⽅发送⼀个 4000 字节的⼤数据报，若要传输在以太⽹链路，则需要把数据报分⽚成 3 个⼩数 据报进⾏传输，再交由接收⽅重组成⼤数据报。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415213617493.png" alt="image-20210415213617493"></p><p> <font color='orange'>分⽚传输中，⼀旦某个分⽚丢失，会导致整个 IP 数据包作废，所以 TCP 引⼊了 MSS 也就是在 TCP 层进⾏分⽚而不在 IP 层分⽚，那么对于 UDP 我们尽量不要发送⼀个⼤于 MTU 的数据报⽂。</font></p><h2 id="IPV6基本认识"><a href="#IPV6基本认识" class="headerlink" title="IPV6基本认识"></a>IPV6基本认识</h2><h3 id="IPV6简介"><a href="#IPV6简介" class="headerlink" title="IPV6简介"></a>IPV6简介</h3><p> <font color='orange'>IPv4 地址是 32 位，⼤约有 43 亿个地址，但早在 2011 年 IPv4 地址就已经被分配完了。</font></p><p> <font color='orange'>IPv6 地址是 128 位，可分配地址数量非常多，且还有更好的安全性和扩展性</font>。</p><p>因IPv4 和 IPv6 不兼容，且IPV6要求电脑、手机要适配，也需要网络运营商的支持，所以ipv6普及较慢。</p><h3 id="IPV6亮点"><a href="#IPV6亮点" class="headerlink" title="IPV6亮点"></a>IPV6亮点</h3><p>IPv6 除了地址多，还有很多其它亮点：</p><ol><li><font color='orange'>IPv6 可⾃动配置，即使没有 DHCP 服务器也可实现 IP地址⾃动分配。</font></li><li><font color='orange'>IPv6 包头包⾸部⻓度固定为40 字节，去掉了包头校验，简化了⾸部结构，减轻了路由器负荷，⼤⼤提⾼了传输性能。</font></li><li><font color='orange'>IPv6 有防⽌线路窃听等功能，提升了安全性。</font></li></ol><h3 id="IPV6地址表示法"><a href="#IPV6地址表示法" class="headerlink" title="IPV6地址表示法"></a>IPV6地址表示法</h3><p>IPv4 地址⻓度共 32 位，是以每 8 位作为⼀组，并⽤点分⼗进制的表示⽅式。</p><p> <font color='orange'>IPv6 ⻓度 128 位，每 16 位为⼀组，每组⽤冒号 : 隔开。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415213924099.png" alt="image-20210415213924099"></p><p>如果出现连续的 0 时还可以将这些 0 省略，并⽤两个冒号 「::」隔开。但是，⼀个 IP 地址中只允许出 现⼀次两个连续的冒号。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415213947044.png" alt="image-20210415213947044"></p><h3 id="IPV6地址结构"><a href="#IPV6地址结构" class="headerlink" title="IPV6地址结构"></a>IPV6地址结构</h3><p>IPv6 类似 IPv4，同样采取IP地址前⼏位来标识 IP 地址的种类。</p><p>IPv6 地址主要有以下类型地址：</p><ul><li>单播地址，⽤于⼀对⼀的通信。</li><li>组播地址，⽤于⼀对多的通信。</li><li>任播地址，⽤于通信最近的节点，最近的节点是由路由协议决定。</li><li>没有⼴播地址。</li></ul><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415214100341.png" alt="image-20210415214100341"></p><h3 id="IPV6单播地址类型"><a href="#IPV6单播地址类型" class="headerlink" title="IPV6单播地址类型"></a>IPV6单播地址类型</h3><p>IPv6 地址主要分三类单播地址，每类地址有效范围都不同： </p><ul><li>同⼀链路单播通信，不经过路由器，可以使⽤链路本地单播地址，IPv4 没有此类型。</li><li>在内⽹⾥单播通信，可以使⽤唯⼀本地地址，相当于 IPv4 的私有 IP。</li><li>在互联⽹通信，可以使⽤全局单播地址，相当于 IPv4 的公有 IP。</li></ul><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415214210802.png" alt="image-20210415214210802"></p><h2 id="IPV4首部与IPV6首部"><a href="#IPV4首部与IPV6首部" class="headerlink" title="IPV4首部与IPV6首部"></a>IPV4首部与IPV6首部</h2><p>IPv4 与 IPv6 ⾸部差异如下：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415214300627.png" alt="image-20210415214300627"></p><p>IPv6 与 IPv4相比，其⾸部改进如下： </p><ol><li><font color='orange'>取消了⾸部校验和字段。</font> 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</li><li><font color='orange'>取消了分⽚&#x2F;重新组装相关字段。</font> 分⽚与重组是耗时的过程，IPv6不允许在中间路由器进⾏分⽚与重组，这种操作只能在源与⽬标主机，这将⼤⼤提⾼路由器转发速度。</li><li><font color='orange'>取消选项字段。</font>选项字段不再是标准 IP ⾸部的⼀部分，但它并没有消失，⽽是可能出现在 IPv6 ⾸部中的「下⼀个⾸部」指出的位置上。删除该选项字段使的 IPv6 的⾸部成为固定⻓度的 40 字 节。</li></ol><h1 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h1><h2 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h2><p>我们访问网站时，其网址通常是域名，而并非是IP地址，因为域名更便于理解和接受。</p><p>实现这⼀技术的就是 DNS 域名解析， <font color='orange'>DNS 可将域名⽹址⾃动转换为 IP地址。</font></p><p>DNS 中的域名都是⽤句点来分隔，⽐如<code>www.server.com</code> ，这⾥的句点代表了不同层次之间的界限。</p><p> <font color='orange'>域名中，越靠右的位置表示其层级越⾼，所以域名的层级关系类似⼀个树状结构</font>： </p><ul><li>根 DNS 服务器</li><li>顶级域 DNS 服务器（com）</li><li>权威 DNS 服务器（server.com）</li></ul><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415214715046.png" alt="image-20210415214715046"></p><p>根域 DNS 服务器信息保存在互联⽹中的所有 DNS 服务器中。这样⼀来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器。</p><p>因此，客户端只要能够找到任意⼀台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再⼀路顺藤摸⽠找到位于下层的某台⽬标 DNS 服务器。</p><h3 id="域名解析流程"><a href="#域名解析流程" class="headerlink" title="域名解析流程"></a>域名解析流程</h3><p><font color='orange'>浏览器会先看自己的缓存，没有就看系统缓存，还没有就检查本机域名解析⽂件 hosts ，如果还没有，就会通过 DNS 服务器来查询。</font></p><p>DNS服务器查询过程如下：</p><ol><li>客户端⾸先会发出⼀个 DNS 请求，问 <a href="http://www.server.com/">www.server.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP&#x2F;IP 设置中填写的 DNS 服务器地址）。</li><li>本地域名服务器收到客户端的请求后，如果缓存⾥的表格能找到 <a href="http://www.server.com,则它直接返回/">www.server.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“⽼⼤， 能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？” 根域名服务器是最⾼层次的，它不直接⽤于域名解析，但能指明⼀条道路。</li><li>根 DNS 收到来⾃本地 DNS 的请求后，发现后置是 .com，说：“<a href="http://www.server.com/">www.server.com</a> 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址，你去问它吧。”</li><li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“⽼⼆， 你能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？” </li><li>顶级域名服务器说：“我给你负责 <a href="http://www.server.com/">www.server.com</a> 区域的权威 DNS 服务器的地址，你去问它应该 能问到”。</li><li>本地 DNS 于是转向问权威 DNS 服务器：“⽼三，<a href="http://www.server.com对应的IP是啥呀？”">www.server.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，客户端和⽬标建⽴连接。</li></ol><p>⾄此，我们完成了 DNS 解析过程。现在总结⼀下，整个过程我画成了⼀个图。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415214931845.png" alt="image-20210415214931845"></p><h2 id="ARP与RARP协议（网络接口层）"><a href="#ARP与RARP协议（网络接口层）" class="headerlink" title="ARP与RARP协议（网络接口层）"></a>ARP与RARP协议（网络接口层）</h2><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>在传输⼀个 IP 数据报时，确定了源 IP 地址和⽬标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下⼀跳。然⽽，⽹络层的下⼀层是数据链路层，所以我们还要知道「下⼀跳」的 MAC 地址。</p><p> <font color='orange'>通过主机路由表可找到下⼀跳 IP 地址，根据 IP地址 和 ARP 协议，可得知下⼀跳 MAC 地址。</font></p><p>ARP 如何知道 对⽅MAC地址呢？</p><p> <font color='orange'>ARP 是借助 ARP 请求与 ARP 响应 两种类型的包 来确定 MAC 地址。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415215101949.png" alt="image-20210415215101949"></p><ul><li><font color='orange'>主机会通过⼴播发送 ARP 请求，这个包中包含了想要知道 MAC 地址的主机 IP 地址。</font></li><li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包⾥的内容，如果 ARP 请求包中的⽬标 IP 地址与⾃⼰的 IP 地址⼀致，那么这个设备就将⾃⼰的 MAC 地址塞⼊ ARP 响应包返回给主机。</li></ul><p> <font color='orange'>操作系统通常会把第⼀次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中拿。</font></p><p> <font color='red'>注意：MAC 地址缓存有时间限制，超过限定时间将清除已缓存内容。</font></p><h3 id="RARP协议"><a href="#RARP协议" class="headerlink" title="RARP协议"></a>RARP协议</h3><p> <font color='orange'>ARP 协议是已知 IP 地址求 MAC 地址， RARP 则是已知 MAC 地址求 IP 地址</font>。例如 将打印机服务器等⼩型嵌⼊式设备接⼊到⽹络时就经常会⽤得到。</p><p>通常需要架设⼀台 RARP 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接⼊到⽹络，接着：</p><ul><li>该设备会发送⼀条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。</li><li>RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备。</li></ul><p>最后，设备会从 RARP 服务器所收到的应答信息中找到IP地址并进行设置。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415215304596.png" alt="image-20210415215304596"></p><h2 id="DHCP动态获取IP地址"><a href="#DHCP动态获取IP地址" class="headerlink" title="DHCP动态获取IP地址"></a>DHCP动态获取IP地址</h2><p>我们的电脑通常都是通过 DHCP 动态获取 IP 地址，⼤⼤省去了配 IP 信息繁琐的过程。</p><p>接下来，我们来看看电脑是如何通过 4 个步骤获取到 IP。</p><p> <font color='red'>注意：DHCP 客户端进程监听的是 68 端⼝号，DHCP 服务端进程监听的是 67 端⼝号。</font></p><p>4 个步骤如下：</p><ol><li>客户端⾸先发起 DHCP 发现报⽂（DHCP DISCOVER） 的 IP 数据报，由于客户端没有 IP 地址， 也不知道 DHCP 服务器的地址，所以使⽤的是 UDP ⼴播通信，其使⽤的⼴播⽬的地址是 255.255.255.255（端⼝ 67） 并且使⽤ 0.0.0.0（端⼝ 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，然后链路层将帧⼴播到⽹络中的所有设备。</li><li>DHCP 服务器收到 DHCP 发现报⽂时，⽤ DHCP 提供报⽂（DHCP OFFER） 向客户端做出响应。该报⽂仍然使⽤ IP ⼴播地址 255.255.255.255，该报⽂信息携带服务器提供可租约的 IP 地址、⼦⽹掩码、默认⽹关、DNS 服务器以及 IP 地址租⽤期。</li><li>客户端收到⼀个或多个服务器的 DHCP 提供报⽂后，从中选择⼀个服务器，并向选中的服务器发送 DHCP 请求报⽂（DHCP REQUEST进⾏响应，回显配置的参数。</li><li>最后，服务端⽤ DHCP ACK 报⽂对 DHCP 请求报⽂进⾏响应，应答所要求的参数。</li></ol><p>⼀旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租⽤期内使⽤ DHCP 服务器分配的 IP 地址。</p><p>如果租约的 DHCP IP 地址快过期了，客户端会向服务器发送 DHCP 请求报⽂：</p><ul><li>服务器如果同意继续租⽤，则⽤ DHCP ACK 报⽂进⾏应答，客户端就会延⻓租期。</li><li>服务器如果不同意继续租⽤，则⽤ DHCP NACK 报⽂，客户端就要停⽌使⽤租约的 IP 地址。</li></ul><p>可以发现， <font color='orange'>DHCP 交互中，全程都是使⽤ UDP ⼴播通信。</font> </p><p>咦，⽤的是⼴播，那如果 DHCP 服务器和客户端不是在同⼀个局域⽹内，路由器⼜不会转发⼴播包，那不是每个⽹络都要配⼀个 DHCP 服务器？ </p><p>为解决该问题，就出现了 <strong>DHCP 中继代理</strong>。 <font color='orange'>有了 DHCP 中继代理以后，对不同⽹段的 IP 地址分配也可以由⼀个 DHCP 服务器统⼀进⾏管理。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415220738058.png" alt="image-20210415220738058"></p><ul><li>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，⽽ DHCP 中继代理在收到这个⼴播包以后，再以单播的形式发给 DHCP 服务器。</li><li>服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包⼴播给 DHCP 客户端 。</li></ul><p> 因此，DHCP 服务器即使不在同⼀个链路上也可以实现统⼀分配和管理IP地址。</p><h2 id="NAT（网络地址转换）"><a href="#NAT（网络地址转换）" class="headerlink" title="NAT（网络地址转换）"></a>NAT（网络地址转换）</h2><h3 id="NAT作用"><a href="#NAT作用" class="headerlink" title="NAT作用"></a>NAT作用</h3><p>IPv4 地址紧缺，故提出了 ⽹络地址转换方案 NAT，作用就是： <font color='orange'>将 私有IP地址 转换成 公有IP地址。</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415220931123.png" alt="image-20210415220931123"></p><p>思考：若这样，那不是 N 个私有 IP 地址，就需要 N 个公有 IP 地址？这怎么就缓解 IPv4 地址耗尽问题？ </p><p>确实是， <font color='orange'>普通 NAT转换没什么意义。由于绝⼤多数⽹络应⽤都使⽤传输层协议 TCP 或 UDP 来传输数据。 因此，可以把 IP 地址 + 端⼝号⼀起进⾏转换，这种转换技术叫 ⽹络地址与端⼝转换 NAPT。</font></p><p>很抽象？来，看下⾯的图解就能瞬间明⽩了。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415221031683.png" alt="image-20210415221031683"></p><p>图中有两个客户端 192.168.1.10 和 192.168.1.11 同时与服务器 183.232.231.172 进⾏通信，且两个客户端本地端⼝都是 1025。此时，两个私有 IP 地址将转换为公有地址 120.229.175.121，但是以不同的端⼝号作为区分。</p><p>于是，⽣成⼀个 NAPT 路由器转换表，就可以正确转换 地址与端⼝组合，令客户端 A、B 能同时与服务器之间进⾏通信。</p><p>这种转换表在 NAT 路由器上⾃动⽣成。例如，建⽴ TCP 连接⾸次握⼿时的 SYN 包 ⼀经发出，就会⽣成这个表。⽽后⼜随着收到关闭连接时发出 FIN 包的确认应答而从表中删除。</p><h3 id="NAT缺陷"><a href="#NAT缺陷" class="headerlink" title="NAT缺陷"></a>NAT缺陷</h3><p>因为 NAT&#x2F;NAPT 依赖⾃⼰的转换表，因此会有以下问题：</p><ol><li>外部⽆法主动与 NAT 内部服务器建⽴连接，因为 NAPT 转换表没有转换记录。</li><li>转换表的⽣成与转换操作都会产⽣性能开销。</li><li>通信过程中，如果 NAT 路由器重启了，所有TCP 连接都将被重置。</li></ol><h3 id="如何解决缺陷"><a href="#如何解决缺陷" class="headerlink" title="如何解决缺陷"></a>如何解决缺陷</h3><ol><li><font color='orange'>改用IPV6</font></li></ol><p>   IPv6 可⽤范围⾮常⼤，每台设备都可配置⼀个公有 IP 地址，但 IPv6 普及还需要时间。</p><ol start="2"><li><p><font color='orange'>NAT穿透技术</font></p><p><font color='orange'>NAT 穿透技术能够让⽹络应⽤程序主动发现⾃⼰位于 NAT 设备之后，并会主动获得 NAT 设备的公有 IP，并为⾃⼰建⽴端⼝映射条⽬，注意这些都由 NAT设备后的应⽤程序⾃动完成。</font></p></li></ol><p>   也就是说，在 NAT 穿透技术中，NAT设备后的应⽤程序处于主动地位，它已经明确地知道 NAT 设备要修改它外发的数据包，于是它主动配合 NAT 设备的操作，主动地建⽴好映射，这样就减少了NAT设备的工作。</p><p>   说⼈话，就是客户端主动从 NAT 设备获取公网 IP 地址，然后⾃⼰建⽴端⼝映射条⽬，然后⽤这个条⽬ 对外通信，就不需要 NAT 设备来进⾏转换了。</p><h2 id="ICMP（互联网控制报文协议-网络层）"><a href="#ICMP（互联网控制报文协议-网络层）" class="headerlink" title="ICMP（互联网控制报文协议 &#x2F; 网络层）"></a>ICMP（互联网控制报文协议 &#x2F; 网络层）</h2><h3 id="ICMP简介"><a href="#ICMP简介" class="headerlink" title="ICMP简介"></a>ICMP简介</h3><p> <font color='orange'>ICMP 全称是 Internet Control Message Protocol，也叫 互联⽹控制报⽂协议。</font></p><p>⾥⾯有个关键词 —— 控制，如何控制呢？</p><p>⽹络包 在 复杂⽹络传输中 会遇到各种问题。 当遇到问题时 需要 传出消息 并 报告异常问题，这样可以 调整传输策略 来控制 整个局⾯。</p><h3 id="ICMP功能"><a href="#ICMP功能" class="headerlink" title="ICMP功能"></a>ICMP功能</h3><p> <font color='orange'>ICMP 主要功能包括：确认 IP 包是否成功送达⽬标地址、报告发送过程中 IP 包被废弃的原因和改善⽹络设置等。</font></p><p>在 IP 通信中如果某个 IP 包因为某种原因未能达到⽬标地址，那么这个具体的原因将由 ICMP 负责通知。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415221514890.png" alt="image-20210415221514890"></p><p>如上图，主机 A发送数据包 给 主机B，但因为某些原因 导致 路由器 2 不能找到主机B，此时路由器 2 通过 IP 向主机 A 发送⼀个 ICMP ⽬标不可达数据包。</p><p> <font color='orange'>ICMP 的这种通知消息会使⽤ IP 进⾏发送 。</font></p><p>因此，从路由器 2 返回的 ICMP 包会按照往常的路由控制先经过路由器 1 再转发给主机 A 。收到该 ICMP 包的主机 A 则分解 ICMP 的⾸部和数据域以后得知具体发⽣问题的原因。</p><h3 id="ICMP类型"><a href="#ICMP类型" class="headerlink" title="ICMP类型"></a>ICMP类型</h3><p>ICMP ⼤致可以分为两⼤类：</p><ul><li>⽤于诊断的查询消息，也就是「查询报⽂类型」。</li><li>通知出错原因的错误消息，也就是「差错报⽂类型」。</li></ul><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415221644966.png" alt="image-20210415221644966"></p><h2 id="IGMP（因特网组管理协议-网络层）"><a href="#IGMP（因特网组管理协议-网络层）" class="headerlink" title="IGMP（因特网组管理协议 &#x2F; 网络层）"></a>IGMP（因特网组管理协议 &#x2F; 网络层）</h2><h3 id="IGMP简介"><a href="#IGMP简介" class="headerlink" title="IGMP简介"></a>IGMP简介</h3><p>ICMP 与 IGMP ⼀点关系都没有，就好比 周杰 与 周杰伦 的区别。</p><p>组播地址 说的是 只有在⼀组的主机才能收到数据包，那么如何确定是否在⼀个组呢？这需要 IGMP协议 来协助。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415221723705.png" alt="image-20210415221723705"></p><p>IGMP 是因特⽹组管理协议，⼯作在主机（组播成员）和最后⼀跳路由之间，如上图中蓝⾊部分。 </p><ul><li>IGMP 报⽂向路由器申请加⼊和退出组播组，默认情况下路由器不会转发组播包到连接中的主机，除⾮主机通过 IGMP 加⼊到组播组，主机申请加⼊到组播组时，路由器就会记录 IGMP 路由器表，路由器后续就会转发组播包到对应的主机了。</li><li>IGMP 报⽂采⽤ IP 封装，IP 头部的协议号为 2，⽽且 TTL 字段值通常为 1，因为 IGMP 是⼯作在主机与连接的路由器之间。</li></ul><h3 id="IGMP工作机制"><a href="#IGMP工作机制" class="headerlink" title="IGMP工作机制"></a>IGMP工作机制</h3><p> <font color='orange'>IGMP 分为三个版本，分别是：IGMPv1、IGMPv2、IGMPv3。</font></p><p>以 IGMPv2 为例⼦，说说 常规查询与响应 和 离开组播组 这两个⼯作机制。</p><p><strong>常规查询与响应⼯作机制</strong></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415221848921.png" alt="image-20210415221848921"></p><ol><li>路由器会周期性发送⽬的地址为 224.0.0.1 （表示同⼀⽹段内所有主机和路由器） IGMP 常规查询报⽂。 </li><li>主机1 和 主机 3 收到这个查询，随后会启动「报告延迟计时器」，计时器的时间是随机的，通常是 0~10 秒，计时器超时后主机就会发送 IGMP 成员关系报告报⽂（源 IP 地址为⾃⼰主机的 IP 地 址，⽬的 IP 地址为组播地址）。如果在定时器超时之前，收到同⼀个组内的其他主机发送的成员关系报告报⽂，则⾃⼰不再发送，这样可以减少⽹络中多余的 IGMP 报⽂数量。</li><li>路由器收到主机的成员关系报⽂后，就会在 IGMP 路由表中加⼊该组播组，后续⽹络中⼀旦该组播 地址的数据到达路由器，它会把数据包转发出去。</li></ol><p><strong>离开组播组⼯作机制</strong></p><p><font color='orange'>离开组播组的情况一，⽹段中仍有该组播组：</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415222033735.png" alt="image-20210415222033735"></p><ol><li>主机 1 要离开组 224.1.1.1，发送 IGMPv2 离组报⽂，报⽂的⽬的地址是 224.0.0.2（表示发向⽹段 内的所有路由器）。</li><li>路由器 收到该报⽂后，以 1 秒为间隔连续发送 IGMP 特定组查询报⽂（共计发送 2 个），以便确 认该⽹络是否还有 224.1.1.1 组的其他成员。</li><li>主机 3 仍然是组 224.1.1.1 的成员，因此它⽴即响应这个特定组查询。路由器知道该⽹络中仍然存 在该组播组的成员，于是继续向该⽹络转发 224.1.1.1 的组播数据包。</li></ol><p><font color='orange'>离开组播组的情况⼆，⽹段中没有该组播组：</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415222133007.png" alt="image-20210415222133007"></p><ol><li>主机 1 要离开组播组 224.1.1.1，发送 IGMP 离组报⽂。</li><li>路由器收到该报⽂后，以 1 秒为间隔连续发送 IGMP 特定组查询报⽂（共计发送 2 个）。此时在该⽹段内，组 224.1.1.1 已经没有其他成员了，因此没有主机响应这个查询。</li><li>⼀定时间后，路由器认为该⽹段中已经没有 224.1.1.1 组播组成员了，将不会再向这个⽹段转发该组播地址的数据包。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系列-HTTP常见问题</title>
      <link href="/2023/07/30/http-chang-jian-wen-da/"/>
      <url>/2023/07/30/http-chang-jian-wen-da/</url>
      
        <content type="html"><![CDATA[<h2 id="1、TLS-SSL"><a href="#1、TLS-SSL" class="headerlink" title="1、TLS&#x2F;SSL"></a>1、TLS&#x2F;SSL</h2><h2 id="1-1、概述"><a href="#1-1、概述" class="headerlink" title="1.1、概述"></a>1.1、概述</h2><p>1994年，网景（Netscape）公司发布SSL1.0，1996年正式发布SSL3.0。</p><p>1997年，互联网任务工程组（IETF）发布了基于SSL协议的TLS协议，1999年，IETF发布了正式的行业标准RFC2246，至此，SSL&#x2F;TLS正式成为通信安全标准。</p><p>SSL协议是基于公钥密码体制和X509数字证书技术，为网咯通信提供身份认证及数据传输保密性、安全性的一种协议。</p><p>SSL&#x2F;TLS协议由三部门组成：</p><ul><li>握手协议：协商加密算法、mac算法和会话密钥。</li><li>记录协议：对交换的数据进行加密和签名。</li><li>警报协议：解决出现的问题。</li></ul><h2 id="1-2、工作场景"><a href="#1-2、工作场景" class="headerlink" title="1.2、工作场景"></a>1.2、工作场景</h2><p>SSL&#x2F;TLS是工作于传输层和应用层之间的加密协议，对于应用层来说是透明的，应用层数据通过SSL&#x2F;TLS进行加密。</p><h2 id="2、SSL4次握手"><a href="#2、SSL4次握手" class="headerlink" title="2、SSL4次握手"></a>2、SSL4次握手</h2><p><font color='orange'>SSL&#x2F;TLS 1.2 需要 4次 握⼿，需要 2 个 RTT 时延</font>，图是把每个交互分开画了，实际上把他们合在⼀起发送，就是 4 次握⼿：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415200422278.png" alt="image-20210415200422278"></p><p><font color='orange'>SSL&#x2F;TLS 1.3 优化了过程，只需要 1 个 RTT 往返时延，也即 只需要 3 次握⼿：</font></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210415200504198.png" alt="image-20210415200504198"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系列-存储器</title>
      <link href="/2023/07/30/cun-chu-qi-zhi-shi-zong-jie/"/>
      <url>/2023/07/30/cun-chu-qi-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="1、存储器简介"><a href="#1、存储器简介" class="headerlink" title="1、存储器简介"></a>1、存储器简介</h1><p><font color='orange'>计算机的第二个主要部件就是 存储器。</font></p><p>理想情形下，存储器应该快、大 且 便宜。但目前 无法同时满足 这三项，于是存储器系统采用一种分层结构，如下图所示。</p><p><img src="/%5Cimgs%5Cjavadev%5C%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E5%9B%BE%E7%A4%BA.jpg" alt="img"></p><h1 id="2、存储分类"><a href="#2、存储分类" class="headerlink" title="2、存储分类"></a>2、存储分类</h1><h2 id="2-1、寄存器"><a href="#2-1、寄存器" class="headerlink" title="2.1、寄存器"></a>2.1、寄存器</h2><p><font color='orange'>存储器系统顶层 一般说的是 CPU中的寄存器。</font></p><p><font color='orange'>寄存器 使用与CPU相同的材料 制成，故与CPU一样快。</font></p><p>寄存器 存储容量 在32位CPU中为32×32位，在64位CPU中为64×64位。在两种情形下，其存储容量都小于1 KB。程序必须在软件中自行管理这些寄存器（即决定如何使用它们）。</p><h2 id="2-2、高速缓存"><a href="#2-2、高速缓存" class="headerlink" title="2.2、高速缓存"></a>2.2、高速缓存</h2><h3 id="2-2-1、简介"><a href="#2-2-1、简介" class="headerlink" title="2.2.1、简介"></a>2.2.1、简介</h3><p><font color='orange'>高速缓存 由 硬件 控制。高速缓存行大小通常为64个字节，地址0至63 对应 高速缓存行0，地址64至127 对应 高速缓存行1，以此类推。</font></p><p><font color='orange'>高速缓存行通常 会放在 CPU内部 或 接近CPU的高速缓存中。</font></p><h3 id="2-2-2、缓存命中"><a href="#2-2-2、缓存命中" class="headerlink" title="2.2.2、缓存命中"></a>2.2.2、缓存命中</h3><p><font color='orange'>当程序需要读一个存储字时，高速缓存 会检查自己的内存中 是否存在 需要的高速缓存行。如果存在，则称之为高速缓存命中。</font></p><blockquote><p>高速缓存命中 通常需要 两个时钟周期。</p><p>缓存满足了请求，就不需要通过总线把访问请求送往主存。高速缓存未命中就必须访问内存，这要消耗大量时间。</p></blockquote><h3 id="2-2-3、缓存功能"><a href="#2-2-3、缓存功能" class="headerlink" title="2.2.3、缓存功能"></a>2.2.3、缓存功能</h3><p><font color='orange'>缓存 通常可以 提高性能。</font></p><ol><li>在内存中 保存 频繁使用 的文件，以避免从磁盘中重复调取这些文件。</li><li>长路径名 转换成 文件所在磁盘地址的结果，也可以放入缓存，以避免重复寻找地址。</li><li>一个Web页面（URL）地址 转换为 网络地址（IP地址）后，转换结果可以缓存起来以供将来使用。</li></ol><h3 id="2-2-4、L1-L2-L3"><a href="#2-2-4、L1-L2-L3" class="headerlink" title="2.2.4、L1&#x2F;L2&#x2F;L3"></a>2.2.4、L1&#x2F;L2&#x2F;L3</h3><h4 id="2-2-4-1、简介"><a href="#2-2-4-1、简介" class="headerlink" title="2.2.4.1、简介"></a>2.2.4.1、简介</h4><ul><li><p>L1：L1缓存在CPU内部，其使命通常是将已解码指令调入CPU执行引擎。对于频繁使用的数据字，大多芯片都会有第二个L1缓存。通常L1缓存大小为16KB。</p></li><li><p>L2：L2缓存 用来存放 最近所使用过若干兆字节 内存字。</p></li><li><p>L3：L3缓存 通常作为共享内存 来为所有CPU提供服务。</p></li></ul><h4 id="2-2-4-2、所属位置"><a href="#2-2-4-2、所属位置" class="headerlink" title="2.2.4.2、所属位置"></a>2.2.4.2、所属位置</h4><p><img src="/%5Cimgs%5Cjavadev%5C%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-CPU%E4%B8%ADL1L2L3%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%8D%E7%BD%AE.jpg"></p><p>L1缓存 通常位于 内核中。L2缓存所属位置 通常有 2种类型：</p><ul><li><p><font color='orange'>所有核 共享L2缓存</font></p><p>应用案例：Intel多核芯片采用了这个方法。</p><p>缺点：共享L2缓存 依赖于复杂的缓存控制器。</p></li><li><p><font color='orange'>所有核中 都存在L2缓存</font></p><p>应用案例：AMD采用这个方法。</p><p>缺点：很难设法保持L2缓存的一致性。</p></li></ul><p><font color='orange'>L3缓存的位置 通常在 CPU外，L3缓存作为共享内存为所有CPU提供服务。</font></p><h2 id="2-3、主存"><a href="#2-3、主存" class="headerlink" title="2.3、主存"></a>2.3、主存</h2><h3 id="2-3-1、简介"><a href="#2-3-1、简介" class="headerlink" title="2.3.1、简介"></a>2.3.1、简介</h3><p><font color='orange'>主存位于第五层，是存储系统的主力。主存 通常称为 随机访问存储器（Random Access Memory，RAM）。</font></p><blockquote><p>过去有时称之为 磁芯存储器，因为 在20世纪 50年代 和 60年代，通常使用很小的可磁化的铁磁体制作主存。</p></blockquote><h3 id="2-3-2、非易失性存储器"><a href="#2-3-2、非易失性存储器" class="headerlink" title="2.3.2、非易失性存储器"></a>2.3.2、非易失性存储器</h3><p><font color='orange'>除了主存之外，许多计算机 已经在使用 少量的 非易失性随机访问存储器。它们与RAM不同，在电源切断之后，非易失性随机访问存储器并不丢失其内容。</font></p><p>只读存储器（Read Only Memory，ROM）在工厂中就被编程完毕，然后再也不能被修改。ROM速度快且便宜。</p><blockquote><p>个别计算机中，启动计算机 的引导加载模块 就存放在ROM中。另外，一些I&#x2F;O卡也采用ROM处理底层设备控制。</p></blockquote><p><font color='orange'>EEPROM（Electrically Erasable PROM，电可擦除可编程ROM）和闪存（flash memory）也是非易失性的，但与ROM相反的是 它们可以 擦除和重写。重写它们比写入RAM需要更多时间，所以其使用方式与ROM相同，而其 与众不同的特点 使它们 有可能通过 字段重写方式 纠正所保存程序中的错误。</font></p><h3 id="2-3-3、易失性存储器"><a href="#2-3-3、易失性存储器" class="headerlink" title="2.3.3、易失性存储器"></a>2.3.3、易失性存储器</h3><h4 id="2-3-3-1、简介"><a href="#2-3-3-1、简介" class="headerlink" title="2.3.3.1、简介"></a>2.3.3.1、简介</h4><p><font color='orange'>CMOS 是 易失性存储器。</font></p><p><font color='orange'>CMOS存储器可以保存 当前时间和日期。CMOS存储器和递增时间的时钟电路由一块小电池驱动，所以，即使计算机没有上电，时间也仍然可以正确地更新。</font></p><p><font color='orange'>CMOS存储器还可以保存配置参数，诸如，哪一个是启动磁盘等。</font></p><h4 id="2-3-3-2、CMOS优缺点"><a href="#2-3-3-2、CMOS优缺点" class="headerlink" title="2.3.3.2、CMOS优缺点"></a>2.3.3.2、CMOS优缺点</h4><p>CMOS耗电量 非常少，一块工厂原装电池能使用若干年。但是，当电池失效时，计算机就会出现“Alzheimer病症”。</p><h2 id="2-4、磁盘"><a href="#2-4、磁盘" class="headerlink" title="2.4、磁盘"></a>2.4、磁盘</h2><p><font color='red'>详情内容请参考 【磁盘管理知识总结.md】文档。</font></p><h2 id="2-5、磁带"><a href="#2-5、磁带" class="headerlink" title="2.5、磁带"></a>2.5、磁带</h2><h3 id="2-5-1、简介"><a href="#2-5-1、简介" class="headerlink" title="2.5.1、简介"></a>2.5.1、简介</h3><p><font color='orange'>存储器体系最后一层是磁带。该种介质通常用于磁盘备份，且可保存大量数据集。</font></p><p>访问磁带前 要把磁带装到磁带机上，可人工安装也可机器人安装（在大型数据库中通常安装有自动磁带处理设备）。然后，磁带可能还需要向前绕转以便读取所请求的数据块。</p><h3 id="2-5-2、磁带特点"><a href="#2-5-2、磁带特点" class="headerlink" title="2.5.2、磁带特点"></a>2.5.2、磁带特点</h3><p>磁带的每个二进制位成本极其便宜、可移动，为了在火灾、洪水、地震等灾害中能存活下来，离线存储的备份磁带非常重要。</p><h3 id="2-5-3、总结"><a href="#2-5-3、总结" class="headerlink" title="2.5.3、总结"></a>2.5.3、总结</h3><p>上面说过存储器体系结构是典型的，但有的安装系统并不具备所有层次，或者有所差别（诸如光盘）。不过，在所有的系统中，当层次下降时，其随机访问时间 会 明显增加，容量也增加，而每个二进制位的成本则大幅度下降。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 磁盘 </tag>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系列-磁盘管理</title>
      <link href="/2023/07/30/ci-pan-guan-li-zhi-shi-zong-jie/"/>
      <url>/2023/07/30/ci-pan-guan-li-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="1、磁盘存储"><a href="#1、磁盘存储" class="headerlink" title="1、磁盘存储"></a>1、磁盘存储</h1><h2 id="1-1、磁盘存储简介"><a href="#1-1、磁盘存储简介" class="headerlink" title="1.1、磁盘存储简介"></a>1.1、磁盘存储简介</h2><p><font color='orange'>为了提高计算机的IO性能，数据一般会通过一些容器存储起来，这些容器我们称之为“磁盘”或“硬盘”。</font></p><p>磁盘和硬盘 两者是有区别的，它们的区别如下：</p><ul><li><font color='orange'>主体不同</font><ul><li>磁盘：利用 磁记录技术 存储数据的存储器；</li><li>硬盘：计算机主要存储设备；</li></ul></li><li><font color='orange'>范围不同</font><ul><li>磁盘：计算机主要存储介质，包括软盘和硬盘；</li><li>硬盘：属于磁盘的一种，采用 温彻斯特式结构；</li></ul></li><li><font color='orange'>发展不同</font><ul><li>磁盘：软盘已经被淘汰，磁盘也正在被固态硬盘所取代；</li><li>硬盘：发展成 固态硬盘与机械硬盘相结合；</li></ul></li></ul><h2 id="1-2、硬盘分类"><a href="#1-2、硬盘分类" class="headerlink" title="1.2、硬盘分类"></a>1.2、硬盘分类</h2><h3 id="1-2-1、原理划分"><a href="#1-2-1、原理划分" class="headerlink" title="1.2.1、原理划分"></a>1.2.1、原理划分</h3><p>按 原理 可将 硬盘类型 分为以下几种：</p><ul><li><font color='orange'>机械硬盘（Hard Disk Drive，HDD）</font></li><li><font color='orange'>固态硬盘（Solid State Disk，SSD）</font></li><li><font color='orange'>固态混合硬盘（Solid State Hybrid Driver，SSHD）</font></li></ul><h4 id="1-2-1-1、机械硬盘（HDD）"><a href="#1-2-1-1、机械硬盘（HDD）" class="headerlink" title="1.2.1.1、机械硬盘（HDD）"></a>1.2.1.1、机械硬盘（HDD）</h4><p>机械硬盘 是 传统硬盘，是电脑主要存储媒介之一。由一个或者多个 铝制 或 玻璃 制成的【磁性碟片、磁头、转轴、控制电机、磁头控制器、数据转换器、接口和缓存】等几个部分组成。机械硬盘 是集【精密机械、微电子电路、电磁转换】为一体 的电脑存储设备。</p><p>机械硬盘工作时，磁头悬浮在高速旋转的碟片上进行读写数据。</p><p>机械硬盘物理结构 如下图所示：</p><p><img src="/%5Cimgs%5Cjavadev%5C%E6%9C%BA%E6%A2%B0%E7%A3%81%E7%9B%98%EF%BC%88HDD%EF%BC%89%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%8402.jpg" alt="img"></p><h4 id="1-2-1-2、固态硬盘（SSD）"><a href="#1-2-1-2、固态硬盘（SSD）" class="headerlink" title="1.2.1.2、固态硬盘（SSD）"></a>1.2.1.2、固态硬盘（SSD）</h4><p><font color='orange'>固态硬盘 是由多个 闪存芯片、主控、缓存 组成的阵列存储，属于 以固态电子存储芯片阵列 制成的硬盘。</font>相对机械硬盘，读取速度更快，寻道时间更少，可加快操作系统启动速度和软件启动速度。</p><p>固态硬盘物理结构 如下图所示：</p><p><img src="/%5Cimgs%5Cjavadev%5C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%EF%BC%88SSD%EF%BC%89%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%8402.jpg" alt="img"></p><h4 id="1-2-1-3、混合硬盘（SSHD）"><a href="#1-2-1-3、混合硬盘（SSHD）" class="headerlink" title="1.2.1.3、混合硬盘（SSHD）"></a>1.2.1.3、混合硬盘（SSHD）</h4><p><font color='orange'>混合硬盘是 机械硬盘 与 固态硬盘 的结合体，采用 容量较小的闪存颗粒 来存储常用文件。</font>磁盘是重要的存储介质，闪存仅起到了缓冲作用，将更多的常用文件保存到闪存内减小寻道时间，从而提升效率。</p><p>混合硬盘物理结构 如下图所示：</p><p><img src="/%5Cimgs%5Cjavadev%5C%E6%B7%B7%E5%90%88%E7%A1%AC%E7%9B%98%EF%BC%88SSHD%EF%BC%89%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%8402.jpg" alt="img"></p><h3 id="1-2-2、接口划分"><a href="#1-2-2、接口划分" class="headerlink" title="1.2.2、接口划分"></a>1.2.2、接口划分</h3><p>按 接口 可将 硬盘类型 分为以下几种：</p><ul><li><font color='orange'>IDE</font>：井口；</li><li><font color='orange'>SATA</font>：串口；</li><li><font color='orange'>SCSI</font>：SCSI 全称是 Small Computer System Interface，即 小型计算机系统接口；</li><li><font color='orange'>SAS</font>：SAS 全称是 Serial Attached SCSI，即 串行连接SCSI，是新一代SCSI技术</li><li><font color='orange'>FC</font>：光纤通道；</li></ul><h4 id="1-2-2-1、IDE"><a href="#1-2-2-1、IDE" class="headerlink" title="1.2.2.1、IDE"></a>1.2.2.1、IDE</h4><p>IDE 全称是 Integrated Drive Electronics，是指 控制器与盘体集成在一起的【硬盘驱动器】，是一种【硬盘传输接口】。另一种叫法是ATA，全称是 Advanced Technology Attachment，即相同的东西。</p><p><img src="/%5Cimgs%5Cjavadev%5CIDE.jpg" alt="image"></p><h4 id="1-2-2-2、SATA"><a href="#1-2-2-2、SATA" class="headerlink" title="1.2.2.2、SATA"></a>1.2.2.2、SATA</h4><p><font color='orange'>SATA 全称是 Serial ATA，SATA口的硬盘 又叫【串口硬盘】，SATA以它串行的数据发送方式而得名。</font>在数据传输过程中，数据线和信号线独立使用，并且传输的时钟频率保持独立，因此同PATA相比，SATA传输速率 可以 达到并行的30倍。可以说：SATA技术并非是PATA技术的改进，而是一种全新的总线架构。</p><p><img src="/%5Cimgs%5Cjavadev%5CSATA.jpg" alt="image"></p><h4 id="1-2-2-3、SCSI"><a href="#1-2-2-3、SCSI" class="headerlink" title="1.2.2.3、SCSI"></a>1.2.2.3、SCSI</h4><p>SCSI 全称是 Small Computer System Interface，它的出现主要是为了解决 IDE接口硬盘【转速太慢，传输速率太低】的问题。其实SCSI并不是专为硬盘设计，实际上它是一种【总线型接口】，独立于系统总线工作。</p><p><img src="/%5Cimgs%5Cjavadev%5CSCSI.jpg" alt="image"></p><h4 id="1-2-2-4、SAS"><a href="#1-2-2-4、SAS" class="headerlink" title="1.2.2.4、SAS"></a>1.2.2.4、SAS</h4><p><font color='orange'>SAS（Serial Attached SCSI）意为 串行连接SCSI，是新一代SCSI技术。</font>与Serial ATA（SATA）硬盘相同，同样采用串行技术来获得更高的传输速度，并通过缩短连结线改善内部空间等。SAS是 并行SCSI接口 之后开发出的全新接口。其目的是改善存储系统的效能、可用性和扩充性，并且提升与SATA硬盘的兼容性。</p><p><font color='orange'>SAS接口技术 可向下 兼容SATA。具体来说，二者的兼容性主要体现在 物理层和协议层 的兼容。</font></p><p><img src="/%5Cimgs%5Cjavadev%5CSAS.jpg" alt="image"></p><h4 id="1-2-2-5、FC"><a href="#1-2-2-5、FC" class="headerlink" title="1.2.2.5、FC"></a>1.2.2.5、FC</h4><p><font color='orange'>光纤通道的英文拼写是Fibre Channel，与SCIS接口一样，光纤通道最初是专门为网络系统设计，而并非是为磁盘设计。但随着存储系统对速度的需求和要求越来越高，后来才逐渐应用到硬盘系统中。</font></p><p>光纤通道硬盘 是为提高 多硬盘存储系统 速度和灵活性 而开发，它大大提高了多硬盘系统的通信速度。它以点对点(或是交换)的配置方式在系统之间采用了光缆连接。</p><p><font color='red'>注意：硬盘本身不具备FC接口，而插硬盘的机柜上会带有FC接口，通过光纤与光纤交换机互联。</font></p><h1 id="2、硬盘结构"><a href="#2、硬盘结构" class="headerlink" title="2、硬盘结构"></a>2、硬盘结构</h1><h2 id="2-1、机械硬盘"><a href="#2-1、机械硬盘" class="headerlink" title="2.1、机械硬盘"></a>2.1、机械硬盘</h2><p>机械硬盘结构 主要由以下几部分组成：</p><ol><li>盘片</li><li>磁头</li><li>磁道</li><li>扇区</li><li>柱面</li><li>……</li></ol><h3 id="2-1-1、盘片与磁头"><a href="#2-1-1、盘片与磁头" class="headerlink" title="2.1.1、盘片与磁头"></a>2.1.1、盘片与磁头</h3><p><font color='orange'>硬盘一般会由多个盘片组成，每个盘片都有上下两个面，每个面都有一个读&#x2F;写磁头。受到硬盘整体体积和生产成本的限制，盘片数量一般限制在5片以内。</font></p><p>盘片的编号自下向上从0递增，例如 最下边的盘片有0面和1面，那么相邻的上一个盘片就是2面和3面，其它同理。</p><p>硬盘整体结构 如下图所示：</p><p><img src="/%5Cimgs%5Cjavadev%5C%E7%A1%AC%E7%9B%98%E4%B8%8E%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.jpg" alt="img"></p><h3 id="2-1-2、扇区与磁道"><a href="#2-1-2、扇区与磁道" class="headerlink" title="2.1.2、扇区与磁道"></a>2.1.2、扇区与磁道</h3><p>以下图为例，该图是一个盘面。<font color='orange'>盘面中一圈圈灰色同心圆就是 磁道。从圆心向外画直线，可以将磁道划分为若干个弧段，每个磁道上的一个弧段就是一个扇区（绿色填充部分）。扇区是磁盘的最小组成单元，通常是512字节。</font>（如今由于磁盘容量越来越大，故每个扇区大小提高至4096字节）。</p><p>扇区与磁道 结构图 如下所示：</p><p><img src="/%5Cimgs%5Cjavadev%5C%E7%A3%81%E7%9B%98%E7%9B%98%E9%9D%A2%E7%BB%93%E6%9E%84%E5%9B%BE02.png"></p><h3 id="2-1-3、磁头和柱面"><a href="#2-1-3、磁头和柱面" class="headerlink" title="2.1.3、磁头和柱面"></a>2.1.3、磁头和柱面</h3><p><font color='orange'>硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。</font>磁盘的柱面数与一个盘面上的磁道数是相等的。由于每个盘面都有自己的磁头，因此，盘面数 &#x3D; 磁头总数。 </p><p>磁盘与柱面 结构图 如下所示：</p><p><img src="/%5Cimgs%5Cjavadev%5C%E7%A3%81%E7%9B%98%E4%B8%8E%E6%9F%B1%E9%9D%A2.jpg" alt="img"></p><h3 id="2-1-4、磁盘容量计算"><a href="#2-1-4、磁盘容量计算" class="headerlink" title="2.1.4、磁盘容量计算"></a>2.1.4、磁盘容量计算</h3><h4 id="2-1-4-1、计算公式"><a href="#2-1-4-1、计算公式" class="headerlink" title="2.1.4.1、计算公式"></a>2.1.4.1、计算公式</h4><p>磁盘存储容量 可通过 如下公式 计算获得：<br>$$<br>磁盘存储容量 &#x3D; 磁头数量 * 磁道(柱面)数量 * 每个磁道扇区数量 * 每个扇区字节数;<br>$$</p><h4 id="2-1-4-2、计算示例"><a href="#2-1-4-2、计算示例" class="headerlink" title="2.1.4.2、计算示例"></a>2.1.4.2、计算示例</h4><p>环境：磁盘DISKA有 3个盘片、6个磁头、7个柱面，每个磁道有 12个扇区，每个扇区512字节。</p><p>磁盘DISKA的存储容量计算如下：<br>$$<br>DISKA存储容量 &#x3D; 6 * 7 * 12 * 512 &#x3D; 258048字节;<br>$$</p><h3 id="2-1-5、磁盘读取时间"><a href="#2-1-5、磁盘读取时间" class="headerlink" title="2.1.5、磁盘读取时间"></a>2.1.5、磁盘读取时间</h3><p>磁盘读取涉及以下几个时间：</p><ul><li><p><font color='orange'>寻道时间</font></p><p>磁头从最初位置 移动到 数据所在位置所消耗的时间 称为 寻道时间。目前寻道时间一般在3－15ms之间。</p></li><li><p><font color='orange'>旋转延迟</font></p><p>将 请求盘片扇区中的数据 移动到 读写磁头下方 所消耗的时间 称为 旋转延迟。旋转延迟取决于磁盘转速，磁盘转速一般在5000rpm - 7200rpm之间。</p></li><li><p><font color='orange'>数据传输时间</font></p><p>传输完请求数据 所消耗的时间 称为 数据传输时间。</p></li></ul><p>为提高磁盘传输效率，软件应着重考虑减少 寻道时间 和 延迟时间。</p><h2 id="2-2、固态硬盘"><a href="#2-2、固态硬盘" class="headerlink" title="2.2、固态硬盘"></a>2.2、固态硬盘</h2><h2 id="2-3、混合硬盘"><a href="#2-3、混合硬盘" class="headerlink" title="2.3、混合硬盘"></a>2.3、混合硬盘</h2><h1 id="3、文件系统"><a href="#3、文件系统" class="headerlink" title="3、文件系统"></a>3、文件系统</h1><h2 id="3-1、文件系统简介"><a href="#3-1、文件系统简介" class="headerlink" title="3.1、文件系统简介"></a>3.1、文件系统简介</h2><h2 id="3-2、文件系统分类"><a href="#3-2、文件系统分类" class="headerlink" title="3.2、文件系统分类"></a>3.2、文件系统分类</h2><h2 id="3-3、块与族"><a href="#3-3、块与族" class="headerlink" title="3.3、块与族"></a>3.3、块与族</h2><h3 id="3-3-1、块与族简介"><a href="#3-3-1、块与族简介" class="headerlink" title="3.3.1、块与族简介"></a>3.3.1、块与族简介</h3><ul><li><p>块</p><p><font color='orange'>扇区 容量少且数量多，导致寻址较长，所以将 相邻的扇区组合在一起组成一个块，并以块为单位来执行相关操作。</font></p><p><font color='orange'>Linux下，如Ext4等文件系统中 称为块（block）。 操作系统与磁盘打交道的最小单位是磁盘块。</font></p></li><li><p>族</p><p><font color='orange'>Windows下，如NTFS等文件系统中 称为簇。每个簇或者块可以包括2、4、8、16、32、64…2的n次方个扇区。</font></p></li></ul><h2 id="3-4、Page页"><a href="#3-4、Page页" class="headerlink" title="3.4、Page页"></a>3.4、Page页</h2><h3 id="3-4-1、页简介"><a href="#3-4-1、页简介" class="headerlink" title="3.4.1、页简介"></a>3.4.1、页简介</h3><p>操作系统常与内存和硬盘打交道，故以“页”为单位的内存操作模式就出现了。</p><p><font color='orange'>注意：内存操作最小单位是“页”，硬盘操作最小单位是“块”。</font></p><h2 id="3-5、总结"><a href="#3-5、总结" class="headerlink" title="3.5、总结"></a>3.5、总结</h2><h3 id="3-5-1、扇区、块-族、Page页之间的关系"><a href="#3-5-1、扇区、块-族、Page页之间的关系" class="headerlink" title="3.5.1、扇区、块&#x2F;族、Page页之间的关系"></a>3.5.1、扇区、块&#x2F;族、Page页之间的关系</h3><ul><li><font color='orange'>扇区：硬盘读写 最小单位；</font></li><li><font color='orange'>块&#x2F;族：操作系统 读写磁盘 的最小单位；</font></li><li><font color='orange'>Page：操作系统 读写内存 的最小单位；</font></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 磁盘 </tag>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系列-Netty</title>
      <link href="/2023/07/30/netty-zhi-shi-dian-zong-jie/"/>
      <url>/2023/07/30/netty-zhi-shi-dian-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Netty"><a href="#1、Netty" class="headerlink" title="1、Netty"></a>1、Netty</h1><h2 id="1-1、Netty-NIO"><a href="#1-1、Netty-NIO" class="headerlink" title="1.1、Netty NIO"></a>1.1、Netty NIO</h2><h3 id="1-1-1、TCP粘包-拆包解决之道"><a href="#1-1-1、TCP粘包-拆包解决之道" class="headerlink" title="1.1.1、TCP粘包&#x2F;拆包解决之道"></a>1.1.1、TCP粘包&#x2F;拆包解决之道</h3><h4 id="TCP粘包-拆包问题"><a href="#TCP粘包-拆包问题" class="headerlink" title="TCP粘包&#x2F;拆包问题"></a>TCP粘包&#x2F;拆包问题</h4><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200926153613957.png" alt="image-20200926153613957"></p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200926153705885.png" alt="image-20200926153705885"></p><h4 id="TCP粘包-拆包发送的原因"><a href="#TCP粘包-拆包发送的原因" class="headerlink" title="TCP粘包&#x2F;拆包发送的原因"></a>TCP粘包&#x2F;拆包发送的原因</h4><ol><li>应用程序write写入的字节 大于 套接口发送缓冲区的大小。</li><li>进行MSS大小的TCP分段。</li><li>以太网帧的payload大于MTU进行IP分片。</li></ol><h4 id="TCP粘包-拆包解决策略"><a href="#TCP粘包-拆包解决策略" class="headerlink" title="TCP粘包&#x2F;拆包解决策略"></a>TCP粘包&#x2F;拆包解决策略</h4><ol><li>消息定长。</li><li>在包尾增加回车换行符进行分割，例如FTP协议。</li><li>将消息分为消息头和消息体，消息头中包含表示消息总长度的字段，通常设计思路为消息头的第一个字段使用int32来表示消息总长度。</li><li>更复杂的应用层协议。</li></ol><h4 id="利用LineBasedFrameDecoder解决TCP粘包问题"><a href="#利用LineBasedFrameDecoder解决TCP粘包问题" class="headerlink" title="利用LineBasedFrameDecoder解决TCP粘包问题"></a>利用LineBasedFrameDecoder解决TCP粘包问题</h4><h3 id="1-1-2、分隔符和定长解码器的应用"><a href="#1-1-2、分隔符和定长解码器的应用" class="headerlink" title="1.1.2、分隔符和定长解码器的应用"></a>1.1.2、分隔符和定长解码器的应用</h3><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200926154906270.png" alt="image-20200926154906270"></p><h4 id="DelimiterBasedFrameDecoder应用开发"><a href="#DelimiterBasedFrameDecoder应用开发" class="headerlink" title="DelimiterBasedFrameDecoder应用开发"></a>DelimiterBasedFrameDecoder应用开发</h4><p>通过DelimiterBasedFrameDecoder的使用，可以自动完成以分隔符作为码流结束标志的消息的解码。</p><h4 id="FixedLengthFrameDecoder应用开发"><a href="#FixedLengthFrameDecoder应用开发" class="headerlink" title="FixedLengthFrameDecoder应用开发"></a>FixedLengthFrameDecoder应用开发</h4><p>FixedLengthFrameDecoder是固定长度解码器，它能够按照指定长度对消息进行自动解码，开发者无需考虑TCP粘包&#x2F;拆包问题，非常实用。</p><h2 id="1-2、Netty编解码技术"><a href="#1-2、Netty编解码技术" class="headerlink" title="1.2、Netty编解码技术"></a>1.2、Netty编解码技术</h2><h3 id="1-2-1、编解码技术"><a href="#1-2-1、编解码技术" class="headerlink" title="1.2.1、编解码技术"></a>1.2.1、编解码技术</h3><h4 id="Java序列化缺点"><a href="#Java序列化缺点" class="headerlink" title="Java序列化缺点"></a>Java序列化缺点</h4><ol><li>无法跨语言。</li><li>序列化后码流太大。</li><li>序列化性能太低。</li></ol><h4 id="主流编解码框架"><a href="#主流编解码框架" class="headerlink" title="主流编解码框架"></a>主流编解码框架</h4><ol><li>Google的Protobuf。</li><li>Facebook的Thrift。</li><li>JBoss Marshalling。</li></ol><h3 id="1-2-2、MessagePack编解码"><a href="#1-2-2、MessagePack编解码" class="headerlink" title="1.2.2、MessagePack编解码"></a>1.2.2、MessagePack编解码</h3><h4 id="MessagePack特点"><a href="#MessagePack特点" class="headerlink" title="MessagePack特点"></a>MessagePack特点</h4><ol><li>编解码高效、性能高。</li><li>序列化后码流小。</li><li>支持跨语言。</li></ol><h4 id="粘包-半包支持"><a href="#粘包-半包支持" class="headerlink" title="粘包&#x2F;半包支持"></a>粘包&#x2F;半包支持</h4><p><font color='orange'>基于Netty的<code>LengthFieldPrepender</code>和<code>LengthFieldBasedFrameDecoder</code>并结合<code>MessagePark</code>，可以实现对TCP粘包&#x2F;半包的支持。</font></p><h3 id="1-2-3、Google-Protobuf编解码"><a href="#1-2-3、Google-Protobuf编解码" class="headerlink" title="1.2.3、Google Protobuf编解码"></a>1.2.3、Google Protobuf编解码</h3><h4 id="Protobuf优点"><a href="#Protobuf优点" class="headerlink" title="Protobuf优点"></a>Protobuf优点</h4><ol><li>谷歌内部长期使用，成熟度高。</li><li>跨语言支持。</li><li>编码后消息更小。</li><li>编解码性能非常高。</li><li>支持不同协议版本的向前兼容。</li><li>支持定义可选和必选字段。</li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>ProtobufDecoder仅负责解码，且不支持读半包。因此ProtobufDecoder前面一定要有能够处理读半包的解码器，其由以下三种方式可选择：<ol><li>使用Netty提供的ProtobufVarint32FrameDecoder，其可以处理半包消息。</li><li>继承Netty提供的通用半包解码器LengthFieldBasedFrameDecoder。</li><li>继承ByteToMessageDecoder类，自己处理半包消息。</li></ol></li></ol><h3 id="1-2-4、JBoss-Marshalling编解码"><a href="#1-2-4、JBoss-Marshalling编解码" class="headerlink" title="1.2.4、JBoss Marshalling编解码"></a>1.2.4、JBoss Marshalling编解码</h3><h2 id="1-3、HTTP协议开发应用"><a href="#1-3、HTTP协议开发应用" class="headerlink" title="1.3、HTTP协议开发应用"></a>1.3、HTTP协议开发应用</h2><h3 id="1-3-1、HTTP协议介绍"><a href="#1-3-1、HTTP协议介绍" class="headerlink" title="1.3.1、HTTP协议介绍"></a>1.3.1、HTTP协议介绍</h3><p>HTTP协议的主要特点：</p><ol><li>支持Client&#x2F;Server模式。</li><li>简单——客户端请求服务器时，只需指定URL，携带必要请求参数或消息体。</li><li>灵活——HTTP允许传递任意类型的数据对象，传输内容的类型由HTTP消息头中的Content-Type加以标记。</li><li>无状态——HTTP是无状态协议，无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要之前的消息，则它必须重传，这样可能导致每次连接传递的数据量增大。另一方面，在服务器不需要先前消息时它的应答就很快。</li></ol><h3 id="1-3-2、HTTP请求消息"><a href="#1-3-2、HTTP请求消息" class="headerlink" title="1.3.2、HTTP请求消息"></a>1.3.2、HTTP请求消息</h3><p>HTTP请求由三部分组成：</p><ol><li>HTTP请求行。</li><li>HTTP消息头。</li><li>HTTP请求正文。</li></ol><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200926145610266.png" alt="image-20200926145610266"></p><p>请求方法有多种，各方法作用如下：</p><ol><li>GET：请求获取 Request-URLI所标识的资源后附加新的提交数据；</li><li>POST：在 Request-URI所标识的资源后 附加新的提交数据；</li><li>HEAD：请求获取 由Request-URI 所标识的资源的响应消息报头；</li><li>PUT：请求服务器存储一个资源，并用 Request-URI 作为其标识；</li><li>DELETE：请求服务器删除 Request-URI 所标识的资源；</li><li>TRACE：请求服务器回收收到的请求信息，主要用于测试或诊断；</li><li>CONNECT：保留将来使用；</li><li>OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求；</li></ol><h3 id="1-3-3、HTTP响应消息"><a href="#1-3-3、HTTP响应消息" class="headerlink" title="1.3.3、HTTP响应消息"></a>1.3.3、HTTP响应消息</h3><p>HTTP响应由三部分组成：</p><ol><li><p>状态行。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200926150121923.png" alt="image-20200926150121923"></p><p>状态代码由三位数字组成：</p><img src="\imgs\javadev\image-20200926150229810.png" alt="image-20200926150229810" style="zoom:90%;float:left;" /><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200926150317627.png" alt="image-20200926150317627"></p></li><li><p>消息报头。</p></li><li><p>响应正文。</p></li></ol><h2 id="1-4、WebSocket协议开发"><a href="#1-4、WebSocket协议开发" class="headerlink" title="1.4、WebSocket协议开发"></a>1.4、WebSocket协议开发</h2><h3 id="1-4-1、HTTP协议弊端"><a href="#1-4-1、HTTP协议弊端" class="headerlink" title="1.4.1、HTTP协议弊端"></a>1.4.1、HTTP协议弊端</h3><ol><li><font color='orange'>HTTP是半双工协议。半双工指：数据可以在客户端和服务两个方向传输，但不能同时传输。</font></li><li><font color='orange'>HTTP消息冗长繁琐。HTTP消息包括消息头、消息体、换行符等，通常采用文本方式传输，相比其它二进制通信协议，冗长而繁琐。</font></li><li><font color='orange'>针对服务器推送的黑客攻击，例如长时间轮询。</font></li></ol><p><font color='orange'>为了解决其弊端，HTML5定义了WebSocket协议，能节省服务器资源和带宽并达到实时通信。</font></p><h3 id="1-4-2、WebSocket入门"><a href="#1-4-2、WebSocket入门" class="headerlink" title="1.4.2、WebSocket入门"></a>1.4.2、WebSocket入门</h3><p>WebSocket特点如下：</p><ol><li>单一TCP连接，采用全双工模式通信。</li><li>对代理、防火墙、路由器透明。</li><li>无头部信息、Cookie和身份验证。</li><li>无安全开销。</li><li>通过<code>ping/pong</code>帧保持链路激活。</li><li>服务器可以主动传递消息给客户端，不再需要客户端轮询。</li></ol><h4 id="WebSocket链接建立"><a href="#WebSocket链接建立" class="headerlink" title="WebSocket链接建立"></a>WebSocket链接建立</h4><p><font color='orange'>为建立一个WebSocket连接，客户端浏览器首选需要发送一个HTTP请求，该请求不同以往HTTP请求，该请求包含了一些附加头信息“Upgrade:WebSocket”，该附加头表明这是一个申请协议升级的请求。服务器解析附加头信息后，客户端和服务器就建立了连接，双方可以通过该连接通道互相传送消息，该连接会一直持续到客户端或服务端一方主动关闭连接。</font></p><h4 id="WebSocket生命周期"><a href="#WebSocket生命周期" class="headerlink" title="WebSocket生命周期"></a>WebSocket生命周期</h4><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20201220161719568.png" alt="image-20201220161719568"></p><h4 id="WebSocket连接关闭"><a href="#WebSocket连接关闭" class="headerlink" title="WebSocket连接关闭"></a>WebSocket连接关闭</h4><p>为关闭WebSocket连接，客和服需要通过一个安全的方法关闭底层的TCP链接以及TLS会话。如果合适，丢弃任何可能已经接收的字节，必要时，可以通过任何可用的手段关闭连接。</p><h3 id="1-4-3、Netty-WebSocket协议开发"><a href="#1-4-3、Netty-WebSocket协议开发" class="headerlink" title="1.4.3、Netty WebSocket协议开发"></a>1.4.3、Netty WebSocket协议开发</h3><p>Netty基于HTTP协议栈开发了WebSocket协议栈，利用Netty的WebSocket协议栈可以很方便开发出WebSocket客户端和服务端。</p><h2 id="1-5、私有协议栈开发"><a href="#1-5、私有协议栈开发" class="headerlink" title="1.5、私有协议栈开发"></a>1.5、私有协议栈开发</h2><h3 id="1-5-1、Netty协议栈功能设计"><a href="#1-5-1、Netty协议栈功能设计" class="headerlink" title="1.5.1、Netty协议栈功能设计"></a>1.5.1、Netty协议栈功能设计</h3><p>Netty协议栈用于内部各模块之间的通信，它基于TCP&#x2F;IP协议栈，是一个类HTTP协议的应用层协议栈，相比传统标准协议栈，它更轻巧、灵活和实用。</p><h4 id="Netty协议栈主要功能如下："><a href="#Netty协议栈主要功能如下：" class="headerlink" title="Netty协议栈主要功能如下："></a>Netty协议栈主要功能如下：</h4><ol><li>基于Netty的NIO通信框架，提供高性能的异步通信功能。</li><li>提供消息的编解码框架，可实现POJO的序列化和反序列化。</li><li>提供基于IP地址的白名单接入认证机制。</li><li>链路的有效性校验机制。</li><li>链路的断连重连机制。</li></ol><h4 id="Netty协议栈通信模型"><a href="#Netty协议栈通信模型" class="headerlink" title="Netty协议栈通信模型"></a>Netty协议栈通信模型</h4><img src="\imgs\javadev\image-20200925134651980.png" alt="image-20200925134651980" style="zoom:120%;float:left" /><h4 id="Netty协议栈消息定义包括两部分"><a href="#Netty协议栈消息定义包括两部分" class="headerlink" title="Netty协议栈消息定义包括两部分;"></a>Netty协议栈消息定义包括两部分;</h4><ol><li>消息头。</li><li>消息体。</li></ol><h4 id="Netty协议支持的字段数据类型如下图："><a href="#Netty协议支持的字段数据类型如下图：" class="headerlink" title="Netty协议支持的字段数据类型如下图："></a>Netty协议支持的字段数据类型如下图：</h4><img src="\imgs\javadev\image-20200925135153588.png" alt="image-20200925135153588"  /><h4 id="链路的建立"><a href="#链路的建立" class="headerlink" title="链路的建立"></a>链路的建立</h4><p>为了安全，链路的建立需要通过基于IP地址或者号段的黑白名单安全认证机制。</p><p>客户端与服务端链路建立成功后，由客户端发送握手请求消息。握手请求信息定义如下：</p><ol><li>消息头的 type 字段值为3；</li><li>可选附件个数为0；</li><li>消息体为空；</li><li>握手消息的长度为22个字符；</li></ol><p>服务端接收到握手请求消息后，会返回握手成功应答。握手应答定义如下：</p><ol><li>消息头的 type 字段值为4；</li><li>可选附件个数为0；</li><li>消息体为 byte 类型的结果，“0”表示认证成功；“-1”表示认证失败；</li></ol><h4 id="链路的关闭"><a href="#链路的关闭" class="headerlink" title="链路的关闭"></a>链路的关闭</h4><p>由于采用长连接通信，正常业务期间，双方通过心跳和业务消息维持链路，任何一方都无需主动关闭连接。</p><p>但在如下情况下，双方需要关闭连接：</p><ol><li>双方宕机或者重启，会主动关闭链路。由于采用TCP全双工通信，通信双方都需要关闭连接，释放资源。</li><li>消息读写过程中，发送了I&#x2F;O异常，需要主动关闭连接。</li><li>心跳消息读写过程中发生了I&#x2F;O异常，需要主动关闭连接。</li><li>心跳超时，需要主动关闭连接。</li><li>发生编码异常等不可恢复错误时，需要主动关闭连接。</li></ol><h4 id="可靠性设计"><a href="#可靠性设计" class="headerlink" title="可靠性设计"></a>可靠性设计</h4><ol><li>心跳机制</li><li>重连机制</li><li>重复登录保护</li><li>消息缓存重发</li></ol><h4 id="安全性设计"><a href="#安全性设计" class="headerlink" title="安全性设计"></a>安全性设计</h4><p>为了保证整个集群环境的安全，内部长连接采用基于 IP 地址的安全认证机制。服务端对握手请求消息的 IP 地址进行合法校验，如果在白名单内，则校验通过；否则，拒绝对方连接。</p><h4 id="可扩展性设计"><a href="#可扩展性设计" class="headerlink" title="可扩展性设计"></a>可扩展性设计</h4><p>Netty 协议需要具备一定的扩展能力。通过Netty消息头中的可选附件 attachment 字段，业务可以方便地进行自定义扩展。</p><h3 id="1-5-2、Netty协议栈开发"><a href="#1-5-2、Netty协议栈开发" class="headerlink" title="1.5.2、Netty协议栈开发"></a>1.5.2、Netty协议栈开发</h3><h4 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h4><h4 id="消息编解码"><a href="#消息编解码" class="headerlink" title="消息编解码"></a>消息编解码</h4><h4 id="握手和安全认证"><a href="#握手和安全认证" class="headerlink" title="握手和安全认证"></a>握手和安全认证</h4><h4 id="心跳检测机制"><a href="#心跳检测机制" class="headerlink" title="心跳检测机制"></a>心跳检测机制</h4><h4 id="断连重连"><a href="#断连重连" class="headerlink" title="断连重连"></a>断连重连</h4><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h2 id="1-6、ByteBuf和相关辅助类"><a href="#1-6、ByteBuf和相关辅助类" class="headerlink" title="1.6、ByteBuf和相关辅助类"></a>1.6、ByteBuf和相关辅助类</h2><h3 id="1-6-1、ByteBuf"><a href="#1-6-1、ByteBuf" class="headerlink" title="1.6.1、ByteBuf"></a>1.6.1、ByteBuf</h3><h4 id="ByteBuf如何工作"><a href="#ByteBuf如何工作" class="headerlink" title="ByteBuf如何工作"></a>ByteBuf如何工作</h4><p>ByteBuf 维护了两个不同的索引：一个用于读取，一个用于写入。当你从 ByteBuf 读取时，它的 readerIndex 将会被递增已经被读取的字节数。同样地，当你写入 ByteBuf 时，它的writerIndex 也会被递增。图 5-1 展示了一个空 ByteBuf 的布局结构和状态。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20201003133045657.png" alt="image-20201003133045657"></p><p>名称以 read 或者 write 开头的 ByteBuf 方法，将会推进其对应的索引，而名称以 set 或 者 get 开头的操作则不会。后面的这些方法将在作为一个参数传入的一个相对索引上执行操作。可以指定 ByteBuf 的最大容量。试图移动写索引（即 writerIndex）超过这个值将会触发一个异常。（默认的限制是 Integer.MAX_VALUE。）</p><h4 id="ByteBuf使用模式"><a href="#ByteBuf使用模式" class="headerlink" title="ByteBuf使用模式"></a>ByteBuf使用模式</h4><ol><li><p>堆缓冲区</p><p>最常用的 ByteBuf 模式是将数据存储在 JVM 的堆空间中。这种模式被称为支撑数组（backing array），它能在没有使用池化的情况下提供快速的分配和释放。这种方式非常适合于有遗留的数据需要处理的情况。</p></li><li><p>直接缓冲区</p><p>直接缓冲区是另外一种 ByteBuf 模式。我们期望用于对象创建的内存分配永远都来自于堆中，但这并不是必须的——NIO 在 JDK 1.4 中引入的 ByteBuffer 类允许 JVM 实现通过本地调用来分配内存。这主要是为了避免在每次调用本地 I&#x2F;O 操作之前（或者之后）将缓冲区的内容复制到一个中间缓冲区（或者从中间缓冲区把内容复制到缓冲区）。</p><blockquote><p>直接缓冲区的主要缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。如果你正在处理遗留代码，你也可能会遇到另外一个缺点：因为数据不是在堆上，所以你不得不进行一次复制.</p><p>显然，与使用支撑数组相比，这涉及的工作更多。因此，如果事先知道容器中的数据将会被作为数组来访问，你可能更愿意使用堆内存。</p></blockquote></li><li><p>复合缓冲区</p><p>该模式为多个 ByteBuf 提供一个聚合视图。在这里你可以根据需要添加或者删除 ByteBuf 实例，这是一个 JDK 的 ByteBuffer 实现完全缺失的特性。</p><p>Netty 通过一个 ByteBuf 子类——CompositeByteBuf——实现了这个模式，它提供了一个将多个缓冲区表示为单个合并缓冲区的虚拟表示。</p></li></ol><h4 id="ByteBuf工作原理"><a href="#ByteBuf工作原理" class="headerlink" title="ByteBuf工作原理"></a>ByteBuf工作原理</h4><p>ByteBuf依然是一个Byte数组的缓冲区，它的功能和JDK中的ByteBuffer一致，其基本功能如下：</p><ol><li>7种Java基础类型、byte数组、ByteBuffer等的读写。</li><li>缓冲区自身的copy和sice等。</li><li>设置网络字节序。</li><li>构造缓冲区实例。</li><li>操作位置指针等方法。</li></ol><p>NettyBuf的实现有两种策略：</p><ol><li>参考JDK ByteBuffer的实现，增加额外功能，解决原ByteBuffer的缺点。</li><li>聚合JDK ByteBuffer，通过Facade模式对其进行包装，可以减少自身的代码量。</li></ol><blockquote><p>由于JDK ByteBuffer只有一个位置指针用于处理读写操作，因此每次读写时需要额外调用flip()方法和clear()方法。</p></blockquote><h4 id="ByteBuf功能介绍"><a href="#ByteBuf功能介绍" class="headerlink" title="ByteBuf功能介绍"></a>ByteBuf功能介绍</h4><ul><li>顺序读操作</li><li>顺序写操作</li><li>readerIndex和writerIndex</li><li>Discardable bytes</li><li>Readable bytes 和 Writable bytes</li><li>Clear操作</li><li>Mark 和 Rset</li><li>查找操作</li><li>Derived buffers</li><li>转换成标准的ByteBuffer</li><li>随机读写</li></ul><h4 id="ByteBuf-API优点"><a href="#ByteBuf-API优点" class="headerlink" title="ByteBuf API优点"></a>ByteBuf API优点</h4><ol><li>它可以被用户自定义的缓冲区类型扩展； </li><li>通过内置的复合缓冲区类型实现了透明的零拷贝；</li><li>容量可以按需增长（类似于 JDK 的 StringBuilder）； </li><li>在读和写这两种模式之间切换不需要调用 ByteBuffer 的 flip()方法； </li><li>读和写使用了不同的索引； </li><li>支持方法的链式调用；</li><li>支持引用计数； </li><li>支持池化；</li></ol><h4 id="ByteBuf相关辅助类"><a href="#ByteBuf相关辅助类" class="headerlink" title="ByteBuf相关辅助类"></a>ByteBuf相关辅助类</h4><ol><li><p>ByteBufHolder</p><p>ByteBufHolder是ByteBuf的容器。</p></li><li><p>ByteBufAllocator</p><p>ByteBufAllocator是字节缓冲区分配器，按照Netty的缓冲区其实现有两种：</p><ol><li>基于内存池的字节缓冲区分配器。</li><li>普通的字节缓冲区分配器。</li></ol></li><li><p>CompositeByteBuf</p><p>CompositeByteBuf允许将多个ByteBuf的实例组装到一起，形成一个统一的视图。</p></li><li><p>ByteBufUtil</p><p>ByteBufUtil是一个实用工具类，提供一系列方法操作ByteBuf对象。</p></li></ol><h3 id="1-6-2、ByteBufHolder-接口"><a href="#1-6-2、ByteBufHolder-接口" class="headerlink" title="1.6.2、ByteBufHolder 接口"></a>1.6.2、ByteBufHolder 接口</h3><p>ByteBufHolder 为 Netty 的高级特性提供了支持，如缓冲区池化，其中可以从池中借用 ByteBuf，并且在需要时自动释放。</p><p>ByteBufHolder 只有几种用于访问底层数据和引用计数的方法。表 5-6 列出了它们（这里不包括它继承自 ReferenceCounted 的那些方法）。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20201003134433406.png" alt="image-20201003134433406"></p><p>如果想要实现一个将其有效负载存储在 ByteBuf 中的消息对象，那么 ByteBufHolder 将是个不错的选择。</p><h3 id="1-6-3、ByteBuf分配"><a href="#1-6-3、ByteBuf分配" class="headerlink" title="1.6.3、ByteBuf分配"></a>1.6.3、ByteBuf分配</h3><h4 id="按需分配：ByteBufAllocator-接口"><a href="#按需分配：ByteBufAllocator-接口" class="headerlink" title="按需分配：ByteBufAllocator 接口"></a>按需分配：ByteBufAllocator 接口</h4><p>为了降低分配和释放内存的开销，Netty 通过 interface ByteBufAllocator 实现了（ByteBuf 的）池化，它可以用来分配我们所描述过的任意类型的 ByteBuf 实例。使用池化是特定于应用程序的决定，其并不会以任何方式改变 ByteBuf API（的语义）</p><p>可以通过 Channel（每个都可以有一个不同的 ByteBufAllocator 实例）或者绑定到ChannelHandler 的 ChannelHandlerContext 获取一个到 ByteBufAllocator 的引用。</p><p>Netty提供了两种ByteBufAllocator实现：</p><ol><li>PooledByteBufAllocator（Netty默认）：池化了ByteBuf的实例以提高性能并最大限度地减少内存碎片。此现使用了一种称为jemalloc的已被大量现代操作系统所采用的高效方法来分配内存。</li><li>UnpooledByteBufAllocator：后者的实现不池化ByteBuf实例，并且在每次它被调用时都会返回一个新的实例。</li></ol><h4 id="Unpooled-缓冲区"><a href="#Unpooled-缓冲区" class="headerlink" title="Unpooled 缓冲区"></a>Unpooled 缓冲区</h4><p>可能某些情况下，你未能获取一个到 ByteBufAllocator 的引用。对于这种情况，Netty 提供了一个简单的称为 Unpooled 的工具类，它提供了静态的辅助方法来创建未池化的 ByteBuf实例。</p><p>Unpooled 类还使得 ByteBuf 同样可用于那些并不需要 Netty 的其他组件的非网络项目，使得其能得益于高性能的可扩展的缓冲区 API。</p><h4 id="ByteBufUtil-类"><a href="#ByteBufUtil-类" class="headerlink" title="ByteBufUtil 类"></a>ByteBufUtil 类</h4><p>ByteBufUtil 提供了用于操作 ByteBuf 的静态的辅助方法。因为这个 API 是通用的，并且和池化无关，所以这些方法已然在分配类的外部实现。</p><p>该类中有两个较为实用的方法：</p><ol><li>hexdump()方法，它以十六进制的表示形式打印ByteBuf 的内容。</li><li>equals(ByteBuf, ByteBuf)方法，它被用来判断两个 ByteBuf实例的相等性。如果你实现自己的 ByteBuf 子类，你可能会发现 ByteBufUtil 的其他有用方法。</li></ol><h3 id="1-6-4、引用计数"><a href="#1-6-4、引用计数" class="headerlink" title="1.6.4、引用计数"></a>1.6.4、引用计数</h3><p>引用计数是一种通过在某个对象所持有的资源不再被其他对象引用时释放该对象所持有的资源来优化内存使用和性能的技术。Netty 在第 4 版中为 ByteBuf 和 ByteBufHolder 引入了引用计数技术，它们都实现了 interface ReferenceCounted。</p><p>引用计数背后的想法并不是特别的复杂；它主要涉及跟踪到某个特定对象的活动引用的数量。一个 ReferenceCounted 实现的实例将通常以活动的引用计数为 1 作为开始。只要引用计数大于 0，就能保证对象不会被释放。当活动引用的数量减少到 0 时，该实例就会被释放。注意，虽然释放的确切语义可能是特定于实现的，但是至少已经释放的对象应该不可再用了。</p><p>引用计数对于池化实现（如 PooledByteBufAllocator）来说是至关重要的，它降低了内存分配的开销。</p><p>试图访问一个已经被释放的引用计数的对象，将会导致一个 IllegalReferenceCountException。</p><p>注意，一个特定的（ReferenceCounted 的实现）类，可以用它自己的独特方式来定义它的引用计数规则。例如，我们可以设想一个类，其 release()方法的实现总是将引用计数设为零，而不用关心它的当前值，从而一次性地使所有的活动引用都失效。</p><p><strong>谁负责释放：</strong>一般来说，是由最后访问（引用计数）对象的那一方来负责将它释放。在第 6 章中，我们将会解释这个概念和 ChannelHandler 以及 ChannelPipeline 的相关性。</p><h3 id="1-6-5、DirectByteBuffer内存释放"><a href="#1-6-5、DirectByteBuffer内存释放" class="headerlink" title="1.6.5、DirectByteBuffer内存释放"></a>1.6.5、DirectByteBuffer内存释放</h3><p>我们已经知道，在网络编程中，为了避免频繁的在用户空间与内核空间拷贝数据，通常会直接从内核空间中申请内存，存放数据，在Java中，把内核空间的内存称之为直接内存，nio包中的<code>ByteBuffer</code>的<code>allocateDirect</code>方法，就是帮助我们申请直接内存的，代码如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ByteBuffer</span> <span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectByteBuffer</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在上述代码片段中，返回的是一个<code>DirectByteBuffer</code>对象，其是ByteBuffer的子类，对于直接内存的分配，就是在这个类中实现的。</p><p>有经验的读者可能知道，在java中，直接内存的申请与释放是通过<code>Unsafe</code>类的<code>allocateMemory</code>方法和<code>freeMemory</code>方法来实现的，且对于直接内存的释放，必须手工调用freeMemory方法，因为JVM只能帮我们管理堆内存，直接内存不在其管理范围之内。</p><p>DirectByteBuffer帮我们简化了直接内存的使用，我们不需要直接操作Unsafe类来进行直接内存的申请与释放，那么其是如何实现的呢？</p><h4 id="直接内存申请："><a href="#直接内存申请：" class="headerlink" title="直接内存申请："></a>直接内存申请：</h4><p>在DirectByteBuffer实例通过构造方法创建的时候，会通过Unsafe类的allocateMemory方法 帮我们申请直接内存资源。</p><h4 id="直接内存释放："><a href="#直接内存释放：" class="headerlink" title="直接内存释放："></a>直接内存释放：</h4><p>DirectByteBuffer本身是一个Java对象，其是位于堆内存中的，JDK的GC机制可以自动帮我们回收，但是其申请的直接内存，不再GC范围之内，无法自动回收。好在JDK提供了一种机制，可以为堆内存对象注册一个钩子函数(其实就是实现Runnable接口的子类)，当堆内存对象被GC回收的时候，会回调run方法，我们可以在这个方法中执行释放DirectByteBuffer引用的直接内存，即在run方法中调用Unsafe 的freeMemory 方法。注册是通过<code>sun.misc.Cleaner</code>类来实现的。</p><h4 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">DirectByteBuffer</span> <span class="token keyword">extends</span> <span class="token class-name">MappedByteBuffer</span> <span class="token keyword">implements</span> <span class="token class-name">DirectBuffer</span><span class="token punctuation">&#123;</span> <span class="token comment">//构造方法</span> <span class="token class-name">DirectByteBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// package-private</span>     <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cap<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">boolean</span> pa <span class="token operator">=</span> <span class="token constant">VM</span><span class="token punctuation">.</span><span class="token function">isDirectMemoryPageAligned</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> ps <span class="token operator">=</span> <span class="token class-name">Bits</span><span class="token punctuation">.</span><span class="token function">pageSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">long</span> size <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>cap <span class="token operator">+</span> <span class="token punctuation">(</span>pa <span class="token operator">?</span> ps <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对申请的直接内存大小，进行重新计算</span>     <span class="token class-name">Bits</span><span class="token punctuation">.</span><span class="token function">reserveMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">long</span> base <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      base <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">allocateMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//分配直接内存，base表示的是直接内存的开始地址</span>     <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">OutOfMemoryError</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token class-name">Bits</span><span class="token punctuation">.</span><span class="token function">unreserveMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">throw</span> x<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     unsafe<span class="token punctuation">.</span><span class="token function">setMemory</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>pa <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>base <span class="token operator">%</span> ps <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// Round up to page boundary</span>     address <span class="token operator">=</span> base <span class="token operator">+</span> ps <span class="token operator">-</span> <span class="token punctuation">(</span>base <span class="token operator">&amp;</span> <span class="token punctuation">(</span>ps <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>     address <span class="token operator">=</span> base<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     <span class="token comment">//注册钩子函数，释放直接内存</span>     cleaner <span class="token operator">=</span> <span class="token class-name">Cleaner</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Deallocator</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     att <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//....</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到构造方法中的确是用了<code>unsafe.allocateMemory</code>方法帮我们分配了直接内存，另外，在构造方法的最后，通过 Cleaner.create方法注册了一个钩子函数，用于清除直接内存的引用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Cleaner</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var0<span class="token punctuation">,</span> <span class="token class-name">Runnable</span> var1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> var1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Cleaner</span><span class="token punctuation">(</span>var0<span class="token punctuation">,</span> var1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中第一个参数是一个堆内存对象，第二个参数是一个Runnable任务，表示这个堆内存对象被回收的时候，需要执行的回调方法。我们可以看到在DirectByteBuffer的最后一行中，传入的这两个参数分别是<code>this</code>，和一个<code>Deallocator</code>(实现了Runnable接口)，其中this表示就是当前DirectByteBuffer实例，也就是当前DirectByteBuffer被回收的时候，回调<code>Deallocator</code>的run方法。</p><p>Deallocator就是用于清除DirectByteBuffer引用的直接内存，代码如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Deallocator</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Unsafe</span> unsafe <span class="token operator">=</span> <span class="token class-name">Unsafe</span><span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> address<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Deallocator</span><span class="token punctuation">(</span><span class="token keyword">long</span> address<span class="token punctuation">,</span> <span class="token keyword">long</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">assert</span> <span class="token punctuation">(</span>address <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>address <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Paranoia</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 调用了unsafe.freeMemory方法释放了直接内存的引用。</span>        unsafe<span class="token punctuation">.</span><span class="token function">freeMemory</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>        address <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token class-name">Bits</span><span class="token punctuation">.</span><span class="token function">unreserveMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="System-gc对直接内存释放的影响："><a href="#System-gc对直接内存释放的影响：" class="headerlink" title="System.gc对直接内存释放的影响："></a>System.gc对直接内存释放的影响：</h4><p>在DirectByteBuffer实例创建的时候，分配内存之前调用了<code>Bits.reserveMemory</code>方法，如果分配失败调用了<code>Bits.unreserveMemory</code>，同时在Deallocator释放完直接内存的时候，也调用了<code>Bits.unreserveMemory</code>方法。</p><p>这两个方法，主要是记录jdk已经使用的直接内存的数量，当分配直接内存时，需要进行增加，当释放时，需要减少，源码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">reserveMemory</span><span class="token punctuation">(</span><span class="token keyword">long</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">//如果直接有足够多的直接内存可以用，直接增加直接内存引用的计数</span>     <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Bits</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>memoryLimitSet <span class="token operator">&amp;&amp;</span> <span class="token constant">VM</span><span class="token punctuation">.</span><span class="token function">isBooted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             maxMemory <span class="token operator">=</span> <span class="token constant">VM</span><span class="token punctuation">.</span><span class="token function">maxDirectMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             memoryLimitSet <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>         <span class="token comment">// -XX:MaxDirectMemorySize limits the total capacity rather than the</span>         <span class="token comment">// actual memory usage, which will differ when buffers are page</span>         <span class="token comment">// aligned.</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>cap <span class="token operator">&lt;=</span> maxMemory <span class="token operator">-</span> totalCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//维护已经使用的直接内存的数量</span>             reservedMemory <span class="token operator">+=</span> size<span class="token punctuation">;</span>             totalCapacity <span class="token operator">+=</span> cap<span class="token punctuation">;</span>             count<span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>     <span class="token comment">//如果没有有足够多的直接内存可以用，先进行垃圾回收</span>     <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>     <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//休眠100秒，等待垃圾回收完成</span>     <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">// Restore interrupt status</span>         <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Bits</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//休眠100毫秒后，增加直接内存引用的计数</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>totalCapacity <span class="token operator">+</span> cap <span class="token operator">></span> maxMemory<span class="token punctuation">)</span>         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token string">"Direct buffer memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                reservedMemory <span class="token operator">+=</span> size<span class="token punctuation">;</span>                totalCapacity <span class="token operator">+=</span> cap<span class="token punctuation">;</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//释放内存时，减少引用直接内存的计数</span><span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">unreserveMemory</span><span class="token punctuation">(</span><span class="token keyword">long</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reservedMemory <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        reservedMemory <span class="token operator">-=</span> size<span class="token punctuation">;</span>        totalCapacity <span class="token operator">-=</span> cap<span class="token punctuation">;</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">assert</span> <span class="token punctuation">(</span>reservedMemory <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面代码的分析，我们事实上可以认为<code>Bits</code>类是直接内存的分配担保，当有足够的直接内存可以用时，增加直接内存应用计数，否则，调用System.gc，进行垃圾回收，需要注意的是，<code>System.gc</code>只会回收堆内存中的对象，但是我们前面已经讲过，DirectByteBuffer对象被回收时，那么其引用的直接内存也会被回收，试想现在刚好有其他的DirectByteBuffer可以被回收，那么其被回收的直接内存就可以用于本次DirectByteBuffer直接的内存的分配。</p><p>有一些文章讲解在使用Nio的时候，不要禁用System.gc，也就是启动JVM的时候，不要传入<code>-XX:+DisableExplicitGC</code>参数，因为这样可能会造成直接内存溢出。道理很明显，因为直接内存的释放与获取比堆内存更加耗时，每次创建DirectByteBuffer实例分配直接内存的时候，都调用System.gc，可以让已经使用完的DirectByteBuffer得到及时的回收。</p><p>虽然System.gc只是建议JVM去垃圾回收，可能JVM并不会立即回收，但是频繁的建议，JVM总不会视而不见。</p><p>不过，这并不是绝对的，因为System.gc导致的是FullGC，可能会暂停用户线程，也就是JVM不能继续响应用户的请求，对于一些要求延时比较短的应用，是不希望JVM频繁的进行FullGC的。</p><p>所以建议：禁用System.gc，调大最大可以使用的直接内存。如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-XX:+DisableExplicitGC</span> <span class="token parameter variable">-XX:MaxDirectMemorySize</span><span class="token operator">=</span>256M<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-7、Channel和Unsafe"><a href="#1-7、Channel和Unsafe" class="headerlink" title="1.7、Channel和Unsafe"></a>1.7、Channel和Unsafe</h2><h3 id="1-7-1、Channel"><a href="#1-7-1、Channel" class="headerlink" title="1.7.1、Channel"></a>1.7.1、Channel</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>Channel是Netty抽象出来的网络I&#x2F;O读写相关接口。</p><h4 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h4><ol><li>网络 I&#x2F;O 操作</li><li>其它常用API</li></ol><h3 id="1-7-2、Unsafe"><a href="#1-7-2、Unsafe" class="headerlink" title="1.7.2、Unsafe"></a>1.7.2、Unsafe</h3><h4 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h4><p>Unsade接口实际上是Channel接口的辅助接口，它不应该被用户直接使用。实际的读写操作都是由Unsafe接口完成的。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>实际的网络 I&#x2F;O 操作基本都是由 Unsafe 功能类负责实现的。</p><h2 id="1-8、ChannelHandler和ChannelPipeline"><a href="#1-8、ChannelHandler和ChannelPipeline" class="headerlink" title="1.8、ChannelHandler和ChannelPipeline"></a>1.8、ChannelHandler和ChannelPipeline</h2><p>ChannelPipeline 和 ChannelHandler 机制类似于 Servlet 和 Filter 过滤器，这种拦截器实际上是职责链模式的一种变形。</p><h3 id="1-8-1、ChannelHandler"><a href="#1-8-1、ChannelHandler" class="headerlink" title="1.8.1、ChannelHandler"></a>1.8.1、ChannelHandler</h3><p>Netty 的主要组件是 ChannelHandler，它充当了所有处理入站和出站数据的应用程序逻辑的容器。因为 ChannelHandler 的方法是由网络事件触发的。</p><p>ChannelHandler类似于Servlet的Filter过滤器，负责对I&#x2F;O事件或I&#x2F;O操作进行拦截和处理，它可以选择性的拦截和处理自己感兴趣的事件，也可以透传和终止事件的传递。</p><h4 id="Channel生命周期"><a href="#Channel生命周期" class="headerlink" title="Channel生命周期"></a>Channel生命周期</h4><p>Channel 的正常生命周期如图 6-1 所示。当这些状态发生改变时，将会生成对应的事件。这些事件将会被转发给 ChannelPipeline 中的 ChannelHandler，其可以随后对它们做出响应。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20201003165119330.png" alt="image-20201003165119330"></p><h4 id="ChannelHandler生命周期"><a href="#ChannelHandler生命周期" class="headerlink" title="ChannelHandler生命周期"></a>ChannelHandler生命周期</h4><p>表 6-2 中列出了 interface ChannelHandler 定义的生命周期操作，在 ChannelHandler被添加到 ChannelPipeline 中或者被从 ChannelPipeline 中移除时会调用这些操作。这些方法中的每一个都接受一个 ChannelHandlerContext 参数。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20201003165259567.png" alt="image-20201003165259567"></p><p>Netty 定义了下面两个重要的 ChannelHandler 子接口： </p><ol><li>ChannelInboundHandler——处理入站数据以及各种状态变化； </li><li>ChannelOutboundHandler——处理出站数据并且允许拦截所有的操作。</li></ol><h4 id="ChannelInboundHandler-接口"><a href="#ChannelInboundHandler-接口" class="headerlink" title="ChannelInboundHandler 接口"></a>ChannelInboundHandler 接口</h4><p>当某个 ChannelInboundHandler 的实现重写 channelRead()方法时，它将负责显式地释放与池化的 ByteBuf 实例相关的内存。Netty 为此提供了一个实用方法 ReferenceCountUtil.release()。</p><p>由于 SimpleChannelInboundHandler 会自动释放资源，所以你不应该存储指向任何消息的引用供将来使用，因为这些引用都将会失效。</p><h4 id="ChannelOutboundHandler-接口"><a href="#ChannelOutboundHandler-接口" class="headerlink" title="ChannelOutboundHandler 接口"></a>ChannelOutboundHandler 接口</h4><p>出站操作和数据将由 ChannelOutboundHandler 处理。它的方法将被 Channel、ChannelPipeline 以及 ChannelHandlerContext 调用。</p><p>ChannelOutboundHandler 的一个强大的功能是可以按需推迟操作或者事件，这使得可以通过一些复杂的方法来处理请求。例如，如果到远程节点的写入被暂停了，那么你可以推迟冲 刷操作并在稍后继续。</p><h4 id="ChannelHandler-适配器"><a href="#ChannelHandler-适配器" class="headerlink" title="ChannelHandler 适配器"></a>ChannelHandler 适配器</h4><p>你可以使用 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter类作为自己的 ChannelHandler 的起始点。这两个适配器分别提供了 ChannelInboundHandler 和 ChannelOutboundHandler 的基本实现。通过扩展抽象类 ChannelHandlerAdapter，它们获得了它们共同的超接口 ChannelHandler 的方法。</p><p>ChannelHandlerAdapter 还提供了实用方法 isSharable()。如果其对应的实现被标注为 Sharable，那么这个方法将返回 true，表示它可以被添加到多个 ChannelPipeline中</p><p>在 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter 中所提供的方法体调用了其相关联的 ChannelHandlerContext 上的等效方法，从而将事件转发到了 ChannelPipeline 中的下一个 ChannelHandler 中。</p><h4 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h4><p>每当通过调用 ChannelInboundHandler.channelRead()或者 ChannelOutboundHandler.write()方法来处理数据时，你都需要确保没有任何的资源泄漏。</p><p>为了帮助你诊断潜在的（资源泄漏）问题，Netty提供了class ResourceLeakDetector，它将对你应用程序的缓冲区分配做大约 1%的采样来检测内存泄露。相关的开销是非常小的。</p><p>如果检测到了内存泄露，将会产生类似于下面的日志消息：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">LEAK<span class="token punctuation">:</span> ByteBuf<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> was <span class="token keyword">not</span> called <span class="token keyword">before</span> it's garbage<span class="token operator">-</span>collected<span class="token punctuation">.</span> Enableadvanced leak reporting to find out where the leak occurred<span class="token punctuation">.</span> To enableadvanced leak reporting<span class="token punctuation">,</span> <span class="token keyword">specify</span> the JVM option'<span class="token operator">-</span>Dio<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>leakDetectionLevel<span class="token operator">=</span>ADVANCED' <span class="token keyword">or</span> callResourceLeakDetector<span class="token punctuation">.</span><span class="token function">setLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Netty 目前定义了 4 种泄漏检测级别，如表 6-5 所示：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20201003170533335.png" alt="image-20201003170533335"></p><p>泄露检测级别可以通过将下面的 Java 系统属性设置为表中的一个值来定义：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> <span class="token parameter variable">-Dio.netty.leakDetectionLevel</span><span class="token operator">=</span>ADVANCED<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在出站方向这边，如果你处理了 write()操作并丢弃了一个消息，那么你也应该负责释放它。重要的是，不仅要释放资源，还要通知 ChannelPromise。否则可能会出现 ChannelFutureListener 收不到某个消息已经被处理了的通知的情况。</p><h3 id="1-8-2、ChannelPipeline"><a href="#1-8-2、ChannelPipeline" class="headerlink" title="1.8.2、ChannelPipeline"></a>1.8.2、ChannelPipeline</h3><p>ChannelPipeline 提供了 ChannelHandler 链的容器，并定义了用于在该链上传播入站和出站事件流的 API。当 Channel 被创建时，它会被自动地分配到它专属的 ChannelPipeline。</p><p>ChannelHandler 安装到 ChannelPipeline 中的过程如下： </p><ol><li>一个ChannelInitializer的实现被注册到了ServerBootstrap中； </li><li>当 ChannelInitializer.initChannel()方法被调用时，ChannelInitializer将在ChannelPipeline中安装一组自定义的 ChannelHandler； </li><li>ChannelInitializer 将它自己从 ChannelPipeline 中移除。</li></ol><p>一个 Netty 应用程序中入站和出站数据流之间的区别：从一个客户端应用程序的角度来看，如果事件的运动方向是从客户端到服务器端，那么我们称这些事件为出站的，反之则称为入站的。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20201003111119360.png" alt="image-20201003111119360"></p><p>鉴于出站操作和入站操作是不同的，你可能会想知道如果将两个类别的 ChannelHandler都混合添加到同一个 ChannelPipeline 中会发生什么。虽然 ChannelInboundHandle 和ChannelOutboundHandle 都扩展自ChannelHandler，但是 Netty 能区分 ChannelInboundHandler 实现和 ChannelOutboundHandler 实现，并确保数据只会在具有相同定向类型的两个 ChannelHandler 之间传递。</p><p>当ChannelHandler 被添加到ChannelPipeline 时，它将会被分配一个ChannelHandlerContext，其代表了 ChannelHandler 和 ChannelPipeline 之间的绑定。虽然这个对象可以被用于获取底层的 Channel，但是它主要还是被用于写出站数据。</p><p>在 Netty 中，有两种发送消息的方式：</p><ol><li>直接写到 Channel 中，该方式将会导致消息从ChannelPipeline 的尾端开始流动。</li><li>写到和 ChannelHandler相关联的ChannelHandlerContext对象中，该方式会导致消息从 ChannelPipeline 中的下一个 ChannelHander开始流动。</li></ol><p>在 ChannelPipeline 传播事件时，它会测试 ChannelPipeline 中的下一个 ChannelHandler 的类型是否和事件的运动方向相匹配。如果不匹配，ChannelPipeline 将跳过该ChannelHandler 并前进到下一个，直到它找到和该事件所期望的方向相匹配的为止。</p><h4 id="修改ChannelPipeline"><a href="#修改ChannelPipeline" class="headerlink" title="修改ChannelPipeline"></a>修改ChannelPipeline</h4><p>ChannelHandler 可以通过添加、删除或者替换其他的 ChannelHandler 来实时地修改ChannelPipeline 的布局。</p><blockquote><p>通常 ChannelPipeline 中的每一个 ChannelHandler 都是通过它的 EventLoop（I&#x2F;O 线程）来处理传递给它的事件的。所以至关重要的是不要阻塞这个线程，因为这会对整体的 I&#x2F;O 处理产生负面的影响。</p><p>但有时可能需要与那些使用阻塞 API 的遗留代码进行交互。对于这种情况，ChannelPipeline 有一些接受一个 EventExecutorGroup 的 add()方法。如果一个事件被传递给一个自定义的 EventExecutorGroup，它将被包含在这个 EventExecutorGroup 中的某个 EventExecutor 所处理，从而被从该Channel 本身的 EventLoop 中移除。对于这种用例，Netty 提供了一个叫 DefaultEventExecutorGroup 的默认实现。</p></blockquote><h3 id="1-8-3、ChannelHandlerContext-接口"><a href="#1-8-3、ChannelHandlerContext-接口" class="headerlink" title="1.8.3、ChannelHandlerContext 接口"></a>1.8.3、ChannelHandlerContext 接口</h3><p>ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandlerContext。ChannelHandlerContext 的主要功能是管理它所关联的 ChannelHandler 和在同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互。</p><p>当使用 ChannelHandlerContext 的 API 的时候，请牢记以下两点： </p><ol><li>ChannelHandlerContext 和 ChannelHandler 之间的关联（绑定）是永远不会改变的，所以缓存对它的引用是安全的； </li><li>如同我们在本节开头所解释的一样，相对于其他类的同名方法，ChannelHandler Context的方法将产生更短的事件流，应该尽可能地利用这个特性来获得最大的性能。</li></ol><h4 id="使用-ChannelHandlerContext"><a href="#使用-ChannelHandlerContext" class="headerlink" title="使用 ChannelHandlerContext"></a>使用 ChannelHandlerContext</h4><p>ChannelHandlerContext、Channel 和 ChannelPipeline之间的关系如下图所示：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20201003181432006.png" alt="image-20201003181432006"></p><p>通过 Channel 或者 ChannelPipeline 进行的事件传播：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20201003181705767.png" alt="image-20201003181705767"></p><p>为什么会想要从 ChannelPipeline 中的某个特定点开始传播事件呢？ </p><ol><li>为了减少将事件传经对它不感兴趣的 ChannelHandler 所带来的开销。</li><li>为了避免将事件传经那些可能会对它感兴趣的 ChannelHandler。</li></ol><p>要想调用从某个特定的 ChannelHandler 开始的处理过程，必须获取到在（ChannelPipeline）该 ChannelHandler 之前的 ChannelHandler 所关联的 ChannelHandlerContext。这个 ChannelHandlerContext 将调用和它所关联的 ChannelHandler 之后的 ChannelHandler。</p><h3 id="1-8-4、编解码器"><a href="#1-8-4、编解码器" class="headerlink" title="1.8.4、编解码器"></a>1.8.4、编解码器</h3><p>当你通过 Netty 发送或者接收一个消息的时候，就将会发生一次数据转换。入站消息会被解码；也就是说，从字节转换为另一种格式，通常是一个 Java 对象。如果是出站消息，则会发生相反方向的转换：它将从它的当前格式被编码为字节。这两种方向的转换的原因很简单：网络数据总是一系列的字节。</p><p>对应于特定的需要，Netty 为编码器和解码器提供了不同类型的抽象类。所有由 Netty 提供的编码器&#x2F;解码器适配器类都实现了 ChannelOutboundHandler 或者 ChannelInboundHandler 接口。</p><p>对于入站数据来说，channelRead 方法&#x2F;事件已经被重写了。对于每个从入站Channel 读取的消息，这个方法都将会被调用。随后，它将调用由预置解码器所提供的 decode()方法，并将已解码的字节转发给 ChannelPipeline 中的下一个 ChannelInboundHandler。出站消息的模式是相反方向的：编码器将消息转换为字节，并将它们转发给下一个ChannelOutboundHandler。</p><h3 id="1-8-5、抽象类-SimpleChannelInboundHandler"><a href="#1-8-5、抽象类-SimpleChannelInboundHandler" class="headerlink" title="1.8.5、抽象类 SimpleChannelInboundHandler"></a>1.8.5、抽象类 SimpleChannelInboundHandler</h3><p>最常见的情况是，你的应用程序会利用一个 ChannelHandler 来接收解码消息，并对该数据应用业务逻辑。要创建一个这样的 ChannelHandler，你只需要扩展基类 SimpleChannelInboundHandler<T>，其中 T 是你要处理的消息的 Java 类型 。</p><p>在这种类型的 ChannelHandler 中，最重要的方法是 channelRead0(ChannelHandlerContext,T)。除了要求不要阻塞当前的 I&#x2F;O 线程之外，其具体实现完全取决于你。</p><h3 id="1-8-6、异常处理"><a href="#1-8-6、异常处理" class="headerlink" title="1.8.6、异常处理"></a>1.8.6、异常处理</h3><p>异常处理是任何真实应用程序的重要组成部分，它也可以通过多种方式来实现。</p><h4 id="处理入站异常"><a href="#处理入站异常" class="headerlink" title="处理入站异常"></a>处理入站异常</h4><p>如果在处理入站事件的过程中有异常被抛出，那么它将从它在 ChannelInboundHandler里被触发的那一点开始流经 ChannelPipeline。要想处理这种类型的入站异常，你需要在你的 ChannelInboundHandler 实现中重写下面的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exceptionCaught</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为异常将会继续按照入站方向流动（就像所有的入站事件一样），所以实现了前面所示逻辑的 ChannelInboundHandler 通常位于 ChannelPipeline 的最后。这确保了所有的入站异常都总是会被处理，无论它们可能会发生在 ChannelPipeline 中的什么位置。</p><p>总结一下：</p><ol><li>ChannelHandler.exceptionCaught()的默认实现是简单地将当前异常转发给ChannelPipeline 中的下一个 ChannelHandler； </li><li>如果异常到达了 ChannelPipeline 的尾端，它将会被记录为未被处理； </li><li>要想定义自定义的处理逻辑，你需要重写 exceptionCaught()方法。然后你需要决定是否需要将该异常传播出去。</li></ol><h4 id="处理出站异常"><a href="#处理出站异常" class="headerlink" title="处理出站异常"></a>处理出站异常</h4><p>用于处理出站操作中的正常完成以及异常的选项，都基于以下的通知机制。 </p><ol><li><p>每个出站操作都将返回一个 ChannelFuture。注册到 ChannelFuture 的 ChannelFutureListener 将在操作完成时被通知该操作是成功了还是出错了。 </p></li><li><p>几乎所有的 ChannelOutboundHandler 上的方法都会传入一个 ChannelPromise的实例。作为 ChannelFuture 的子类，ChannelPromise 也可以被分配用于异步通知的监听器。但是，ChannelPromise 还具有提供立即通知的可写方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ChannelPromise</span> <span class="token function">setSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ChannelPromise</span> <span class="token function">setFailure</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><p>添加 ChannelFutureListener 有两种方式：</p><ol><li><p>调用出站操作（如 write()方法）所返回的 ChannelFuture 上的 addListener()方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ChannelFuture</span> future <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>someMessage<span class="token punctuation">)</span><span class="token punctuation">;</span>future<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelFutureListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationComplete</span><span class="token punctuation">(</span><span class="token class-name">ChannelFuture</span> f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>f<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            f<span class="token punctuation">.</span><span class="token function">cause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            f<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将 ChannelFutureListener 添加到即将作为参数传递给 ChannelOutboundHandler 的方法的 ChannelPromise。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OutboundExceptionHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelOutboundHandlerAdapter</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> msg<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        promise<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelFutureListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationComplete</span><span class="token punctuation">(</span><span class="token class-name">ChannelFuture</span> f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>f<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    f<span class="token punctuation">.</span><span class="token function">cause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    f<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>             <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>ChannelPromise 的可写方法：通过调用 ChannelPromise 上的 setSuccess()和 setFailure()方法，可以使一个操作的状态在 ChannelHandler 的方法返回给其调用者时便即刻被感知到。</p></blockquote></li></ol><h2 id="1-9、EventLoop和EventLoopGroup"><a href="#1-9、EventLoop和EventLoopGroup" class="headerlink" title="1.9、EventLoop和EventLoopGroup"></a>1.9、EventLoop和EventLoopGroup</h2><h3 id="1-9-1、EventLoop-接口"><a href="#1-9-1、EventLoop-接口" class="headerlink" title="1.9.1、EventLoop 接口"></a>1.9.1、EventLoop 接口</h3><p>Netty 的 EventLoop 是协同设计的一部分，它采用了两个基本的 API：并发和网络编程。首先，io.netty.util.concurrent 包构建在 JDK 的 java.util.concurrent 包上，用来提供线程执行器。其次，io.netty.channel 包中的类，为了与 Channel 的事件进行交互，扩展了这些接口&#x2F;类。</p><p>在这个模型中，一个 EventLoop 将由一个永远都不会改变的 Thread 驱动，同时任务（Runnable 或者 Callable）可以直接提交给 EventLoop 实现，以立即执行或者调度执行。根据配置和可用核心的不同，可能会创建多个 EventLoop 实例用以优化资源的使用，并且单个EventLoop 可能会被指派用于服务多个 Channel。</p><blockquote><p><strong>事件&#x2F;任务的执行顺序：</strong>事件和任务是以先进先出（FIFO）的顺序执行的。这样可以通过保证字节内容总是按正确的顺序被处理，消除潜在的数据损坏的可能性。</p></blockquote><h3 id="1-9-2、任务调度"><a href="#1-9-2、任务调度" class="headerlink" title="1.9.2、任务调度"></a>1.9.2、任务调度</h3><h4 id="JDK-的任务调度-API"><a href="#JDK-的任务调度-API" class="headerlink" title="JDK 的任务调度 API"></a>JDK 的任务调度 API</h4><p>在 Java 5 之前，任务调度是建立在 java.util.Timer 类之上的，其使用了一个后台 Thread，并且具有与标准线程相同的限制。随后，JDK 提供了 java.util.concurrent 包，它定义了interface ScheduledExecutorService。</p><p>虽然 ScheduledExecutorService API 是直截了当的，但是在高负载下它将带来性能上的负担。</p><h4 id="使用-EventLoop-调度任务"><a href="#使用-EventLoop-调度任务" class="headerlink" title="使用 EventLoop 调度任务"></a>使用 EventLoop 调度任务</h4><p>ScheduledExecutorService 的实现具有局限性，例如，事实上作为线程池管理的一部分，将会有额外的线程创建。如果有大量任务被紧凑地调度，那么这将成为一个瓶颈。Netty 通过 Channel 的 EventLoop 实现任务调度解决了这一问题，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Channel</span> ch <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> future <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"60 seconds later"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要想取消或者检查（被调度任务的）执行状态，可以使用每个异步操作所返回的 ScheduledFuture。</p><h3 id="1-9-3、实现细节"><a href="#1-9-3、实现细节" class="headerlink" title="1.9.3、实现细节"></a>1.9.3、实现细节</h3><h4 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h4><p>Netty线程模型的卓越性能取决于对于当前执行的Thread的身份的确定，也就是说，确定它是否是分配给当前Channel以及它的EventLoop的那一个线程。</p><p>如果（当前）调用线程正是支撑 EventLoop 的线程，那么所提交的代码块将会被（直接）执行。否则，EventLoop 将调度该任务以便稍后执行，并将它放入到内部队列中。当 EventLoop下次处理它的事件时，它会执行队列中的那些任务&#x2F;事件。这也就解释了任何的 Thread 是如何与 Channel 直接交互而无需在 ChannelHandler 中进行额外同步的。</p><p>注意，每个 EventLoop 都有它自已的任务队列，独立于任何其他的 EventLoop。</p><h4 id="EventLoop-线程的分配"><a href="#EventLoop-线程的分配" class="headerlink" title="EventLoop&#x2F;线程的分配"></a>EventLoop&#x2F;线程的分配</h4><p>服务于 Channel 的 I&#x2F;O 和事件的 EventLoop 包含在 EventLoopGroup 中。根据不同的传输实现，EventLoop 的创建和分配方式也不同。</p><ol><li><p>异步传输</p><p>异步传输实现只使用了少量的 EventLoop（以及和它们相关联的 Thread），而且在当前的线程模型中，它们可能会被多个 Channel 所共享。这使得可以通过尽可能少量的 Thread 来支撑大量的 Channel，而不是每个 Channel 分配一个 Thread。</p></li><li><p>阻塞传输</p><p>每一个 Channel 都将被分配给一个 EventLoop（以及它的 Thread）。得到的保证是每个 Channel 的 I&#x2F;O 事件都将只会被一个 Thread（用于支撑该 Channel 的 EventLoop 的那个 Thread）处理。这也是另一个 Netty 设计一致性的例子，它（这种设计上的一致性）对 Netty 的可靠性和易用性做出了巨大贡献。</p></li></ol><h3 id="1-9-4、Netty线程模型"><a href="#1-9-4、Netty线程模型" class="headerlink" title="1.9.4、Netty线程模型"></a>1.9.4、Netty线程模型</h3><h4 id="Reactor单线程模型"><a href="#Reactor单线程模型" class="headerlink" title="Reactor单线程模型"></a>Reactor单线程模型</h4><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200926143305077.png" alt="image-20200926143305077"></p><h4 id="Reactor多线程模型"><a href="#Reactor多线程模型" class="headerlink" title="Reactor多线程模型"></a>Reactor多线程模型</h4><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200926143349772.png" alt="image-20200926143349772"></p><h4 id="主从Reactor多线程模型"><a href="#主从Reactor多线程模型" class="headerlink" title="主从Reactor多线程模型"></a>主从Reactor多线程模型</h4><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200926143448810.png" alt="image-20200926143448810"></p><h4 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h4><p>Netty的线程模型并发一成不变，它实际取决于用户的启动参数配置。通过配置，Netty可以同时支持Reactor单线程模型、Reactor多线程模型、主从Reactor多线程模型。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200925151324727.png" alt="image-20200925151324727"></p><h3 id="1-9-5、NioEventLoop"><a href="#1-9-5、NioEventLoop" class="headerlink" title="1.9.5、NioEventLoop"></a>1.9.5、NioEventLoop</h3><h4 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h4><p>NioEventLoop并非一个纯粹的I&#x2F;O线程，它除了负责I&#x2F;O读写外，还兼顾处理如下两类任务：</p><ol><li>系统Task。</li><li>定时任务。</li></ol><h2 id="1-10、Future和Promise"><a href="#1-10、Future和Promise" class="headerlink" title="1.10、Future和Promise"></a>1.10、Future和Promise</h2><h3 id="1-10-1、Future功能"><a href="#1-10-1、Future功能" class="headerlink" title="1.10.1、Future功能"></a>1.10.1、Future功能</h3><p>Future最早来源于JDK的<code>java.util.concurrent.Future</code>，它代表异步操作的结果。</p><p>Netty中的Future都是与异步I&#x2F;O操作相关，因此，将其命名为ChannelFuture，代表与channel操作相关。</p><h3 id="1-10-2、Promise功能"><a href="#1-10-2、Promise功能" class="headerlink" title="1.10.2、Promise功能"></a>1.10.2、Promise功能</h3><p>Promise是可写的Future，Future本身并没有写操作相关的接口，Netty通过Promise对Future进行扩展，用于设置I&#x2F;O操作的结果。</p><h2 id="1-11、引导"><a href="#1-11、引导" class="headerlink" title="1.11、引导"></a>1.11、引导</h2><h3 id="1-11-1、引导分类"><a href="#1-11-1、引导分类" class="headerlink" title="1.11.1、引导分类"></a>1.11.1、引导分类</h3><p>有两种类型的引导：</p><ol><li>一种用于客户端（简单地称为 Bootstrap）；</li><li>而另一种（ServerBootstrap）用于服务器；</li></ol><p>无论你的应用程序使用哪种协议或者处理哪种类型的数据，唯一决定它使用哪种引导类的是它是作为一个客户端还是作为一个服务器。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20201003121533517.png" alt="image-20201003121533517"></p><p>引导一个客户端只需要一个 EventLoopGroup，但是一个ServerBootstrap 则需要两个（也可以是同一个实例）。为什么呢？</p><p>因为服务器需要两组不同的 Channel。第一组将只包含一个 ServerChannel，代表服务器自身的已绑定到某个本地端口的正在监听的套接字。而第二组将包含所有已创建的用来处理传入客户端连接（对于每个服务器已经接受的连接都有一个）的 Channel。图 3-4 说明了这个模型，并且展示了为何需要两个不同的 EventLoopGroup。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20201003122021907.png" alt="image-20201003122021907"></p><p>与 ServerChannel 相关联的 EventLoopGroup 将分配一个负责为传入连接请求创建Channel 的 EventLoop。一旦连接被接受，第二个 EventLoopGroup 就会给它的 Channel分配一个 EventLoop。</p><h3 id="1-11-2、从-Channel-引导客户端"><a href="#1-11-2、从-Channel-引导客户端" class="headerlink" title="1.11.2、从 Channel 引导客户端"></a>1.11.2、从 Channel 引导客户端</h3><p>假设你的服务器正在处理一个客户端的请求，这个请求需要它充当第三方系统的客户端。当一个应用程序（如一个代理服务器）必须要和组织现有的系统（如 Web 服务或者数据库）集成时，就可能发生这种情况。在这种情况下，将需要从已经被接受的子 Channel 中引导一个客户端 Channel。</p><p>一个更好的解决方案是：通过将已被接受的子 Channel 的 EventLoop 传递给 Bootstrap的 group()方法来共享该 EventLoop。因为分配给 EventLoop 的所有 Channel 都使用同一个线程，所以这避免了额外的线程创建，以及前面所提到的相关的上下文切换。这个共享的解决方案如图 8-4 所示。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20201004110224106.png" alt="image-20201004110224106"></p><h3 id="1-11-3、在引导过程中添加多个-ChannelHandler"><a href="#1-11-3、在引导过程中添加多个-ChannelHandler" class="headerlink" title="1.11.3、在引导过程中添加多个 ChannelHandler"></a>1.11.3、在引导过程中添加多个 ChannelHandler</h3><p>Netty 提供了一个特殊的 ChannelInboundHandlerAdapter 子类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">C</span> <span class="token keyword">extends</span> <span class="token class-name">Channel</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它定义了下面的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">C</span> ch<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个方法提供了一种将多个 ChannelHandler 添加到一个 ChannelPipeline 中的简便方法。你只需要简单地向 Bootstrap 或 ServerBootstrap 的实例提供你的 ChannelInitializer 实现即可，并且一旦 Channel 被注册到了它的 EventLoop 之后，就会调用你的initChannel()版本。在该方法返回之后，ChannelInitializer 的实例将会从 ChannelPipeline 中移除它自己。</p><h3 id="1-11-4、使用-Netty-的-ChannelOption-和属性"><a href="#1-11-4、使用-Netty-的-ChannelOption-和属性" class="headerlink" title="1.11.4、使用 Netty 的 ChannelOption 和属性"></a>1.11.4、使用 Netty 的 ChannelOption 和属性</h3><p>在每个 Channel 创建时都手动配置它可能会变得相当乏味。幸运的是，你不必这样做。相反，你可以使用 option()方法来将 ChannelOption 应用到引导。你所提供的值将会被自动应用到引导所创建的所有 Channel。可用的 ChannelOption 包括了底层连接的详细信息，如keep-alive 或者超时属性以及缓冲区设置。</p><h3 id="1-11-5、引导-DatagramChannel"><a href="#1-11-5、引导-DatagramChannel" class="headerlink" title="1.11.5、引导 DatagramChannel"></a>1.11.5、引导 DatagramChannel</h3><p>引导使用不仅可以基于 TCP 协议的 SocketChannel，也可以被用于无连接的协议。为此，Netty 提供了各种 DatagramChannel 的实现。唯一区别就是，不再调用 connect()方法，而是只调用 bind()方法，</p><h3 id="1-11-6、关闭"><a href="#1-11-6、关闭" class="headerlink" title="1.11.6、关闭"></a>1.11.6、关闭</h3><p>引导使你的应用程序启动并且运行起来，但是迟早你都需要优雅地将它关闭。最重要的是，你需要关闭 EventLoopGroup，它将处理任何挂起的事件和任务，并且随后释放所有活动的线程。这就是调用 EventLoopGroup.shutdownGracefully()方法的作用。这个方法调用将会返回一个 Future，这个 Future 将在关闭完成时接收到通知。需要注意的是，shutdownGracefully()方法也是一个异步的操作，所以你需要阻塞等待直到它完成，或者向所返回的 Future 注册一个监听器以在关闭完成时获得通知。</p><h1 id="2、Netty架构剖析"><a href="#2、Netty架构剖析" class="headerlink" title="2、Netty架构剖析"></a>2、Netty架构剖析</h1><h2 id="2-1、Netty逻辑架构"><a href="#2-1、Netty逻辑架构" class="headerlink" title="2.1、Netty逻辑架构"></a>2.1、Netty逻辑架构</h2><p>Netty采用三层网络架构进行设计和开发，逻辑架构如图：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200925153422674.png" alt="image-20200925153422674"></p><h3 id="2-1-1、Reactor通信调度层"><a href="#2-1-1、Reactor通信调度层" class="headerlink" title="2.1.1、Reactor通信调度层"></a>2.1.1、Reactor通信调度层</h3><h3 id="2-1-2、职责链ChannelPipeline"><a href="#2-1-2、职责链ChannelPipeline" class="headerlink" title="2.1.2、职责链ChannelPipeline"></a>2.1.2、职责链ChannelPipeline</h3><h3 id="2-1-3、业务逻辑编排层（Service-ChannelHandler）"><a href="#2-1-3、业务逻辑编排层（Service-ChannelHandler）" class="headerlink" title="2.1.3、业务逻辑编排层（Service ChannelHandler）"></a>2.1.3、业务逻辑编排层（Service ChannelHandler）</h3><h2 id="2-2、关键架构质量属性"><a href="#2-2、关键架构质量属性" class="headerlink" title="2.2、关键架构质量属性"></a>2.2、关键架构质量属性</h2><h3 id="2-2-1、高性能"><a href="#2-2-1、高性能" class="headerlink" title="2.2.1、高性能"></a>2.2.1、高性能</h3><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200925153953385.png" alt="image-20200925153953385"></p><h3 id="2-2-2、可靠性"><a href="#2-2-2、可靠性" class="headerlink" title="2.2.2、可靠性"></a>2.2.2、可靠性</h3><ol><li>链路有效性检测</li><li>内存保护机制</li><li>优雅停机</li></ol><h3 id="2-2-3、可定制性"><a href="#2-2-3、可定制性" class="headerlink" title="2.2.3、可定制性"></a>2.2.3、可定制性</h3><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200925154201341.png" alt="image-20200925154201341"></p><h3 id="2-2-4、可扩展性"><a href="#2-2-4、可扩展性" class="headerlink" title="2.2.4、可扩展性"></a>2.2.4、可扩展性</h3><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200925154324225.png" alt="image-20200925154324225"></p><h1 id="3、Java多线程在Netty中的应用"><a href="#3、Java多线程在Netty中的应用" class="headerlink" title="3、Java多线程在Netty中的应用"></a>3、Java多线程在Netty中的应用</h1><h2 id="3-1、Netty并发编程实践"><a href="#3-1、Netty并发编程实践" class="headerlink" title="3.1、Netty并发编程实践"></a>3.1、Netty并发编程实践</h2><h3 id="3-1-1、对共享可变数据进行正确同步"><a href="#3-1-1、对共享可变数据进行正确同步" class="headerlink" title="3.1.1、对共享可变数据进行正确同步"></a>3.1.1、对共享可变数据进行正确同步</h3><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200925154944535.png" alt="image-20200925154944535"></p><h3 id="3-1-2、正确使用锁"><a href="#3-1-2、正确使用锁" class="headerlink" title="3.1.2、正确使用锁"></a>3.1.2、正确使用锁</h3><p>参考ForkJoinTask源码。</p><h3 id="3-1-3、正确使用volatile"><a href="#3-1-3、正确使用volatile" class="headerlink" title="3.1.3、正确使用volatile"></a>3.1.3、正确使用volatile</h3><p>参考NioEventLoop源码。</p><h3 id="3-1-4、CAS指令和原子类"><a href="#3-1-4、CAS指令和原子类" class="headerlink" title="3.1.4、CAS指令和原子类"></a>3.1.4、CAS指令和原子类</h3><p>参考ChannelOutboundBuffer源码，分析如何对发送的总字节数进行计数和更新操作。</p><h3 id="3-1-5、线程安全类的应用"><a href="#3-1-5、线程安全类的应用" class="headerlink" title="3.1.5、线程安全类的应用"></a>3.1.5、线程安全类的应用</h3><p>参考NioEventLoop源码。</p><h3 id="3-1-6、读写锁的应用"><a href="#3-1-6、读写锁的应用" class="headerlink" title="3.1.6、读写锁的应用"></a>3.1.6、读写锁的应用</h3><p>参考HashedWheelTimer源码。</p><h1 id="4、Netty高性能之道"><a href="#4、Netty高性能之道" class="headerlink" title="4、Netty高性能之道"></a>4、Netty高性能之道</h1><h2 id="4-1、RPC调用性能模型分析"><a href="#4-1、RPC调用性能模型分析" class="headerlink" title="4.1、RPC调用性能模型分析"></a>4.1、RPC调用性能模型分析</h2><h3 id="4-1-1、传统RPC调用性能差的三宗罪"><a href="#4-1-1、传统RPC调用性能差的三宗罪" class="headerlink" title="4.1.1、传统RPC调用性能差的三宗罪"></a>4.1.1、传统RPC调用性能差的三宗罪</h3><ol><li><p>网络传输方式</p><p>传统RPC基于同步阻塞I&#x2F;O实现。</p></li><li><p>序列化性能差</p><p>Java序列化存在几个问题：</p><ol><li>Java序列化机制是Java内部的一种对象编解码技术，无法跨语言使用。</li><li>相比其它开源序列化框架，Java序列化后的码流太大，无论网络传输还是持久化磁盘，都会导致额外资源占用。</li><li>序列化性能差，资源占用率高（主要是CPU资源）。</li></ol></li><li><p>线程模型问题</p><p>采用同步阻塞I&#x2F;O，故每个TCP连接都会占用一个线程，这样一来，I&#x2F;O读写阻塞导致线程无法释放时，会导致系统性能急剧下降，严重会导致虚拟机无法创建新的线程。</p></li></ol><h3 id="4-1-2、I-O通信性能三原则"><a href="#4-1-2、I-O通信性能三原则" class="headerlink" title="4.1.2、I&#x2F;O通信性能三原则"></a>4.1.2、I&#x2F;O通信性能三原则</h3><ol><li>传输：I&#x2F;O模型很大程度上决定了通信性能。</li><li>协议：采用什么通信协议，协议不同，性能也不同。相比公有协议，内部私有协议的性能通常可以被设计的更好。</li><li>线程：数据报如何读取？读取后编解码让哪个线程去做？编解码后消息如何派发？Reactor线程模型的不同，对性能影响也非常大。</li></ol><h2 id="4-2、Netty高性能之道"><a href="#4-2、Netty高性能之道" class="headerlink" title="4.2、Netty高性能之道"></a>4.2、Netty高性能之道</h2><h3 id="4-2-1、异步非阻塞通信"><a href="#4-2-1、异步非阻塞通信" class="headerlink" title="4.2.1、异步非阻塞通信"></a>4.2.1、异步非阻塞通信</h3><h3 id="4-2-2、高效的Reactor线程模型"><a href="#4-2-2、高效的Reactor线程模型" class="headerlink" title="4.2.2、高效的Reactor线程模型"></a>4.2.2、高效的Reactor线程模型</h3><h3 id="4-2-3、无锁化的串行设计"><a href="#4-2-3、无锁化的串行设计" class="headerlink" title="4.2.3、无锁化的串行设计"></a>4.2.3、无锁化的串行设计</h3><h3 id="4-2-4、高效的并发编程"><a href="#4-2-4、高效的并发编程" class="headerlink" title="4.2.4、高效的并发编程"></a>4.2.4、高效的并发编程</h3><ol><li>volatile大量、正确的使用。</li><li>CAS和原子类的广泛使用。</li><li>线程安全容器的使用。</li><li>通过读写锁提升并发性能。</li></ol><h3 id="4-2-5、高性能的序列化框架"><a href="#4-2-5、高性能的序列化框架" class="headerlink" title="4.2.5、高性能的序列化框架"></a>4.2.5、高性能的序列化框架</h3><p>影响序列化性能的关键因素如下：</p><ol><li>序列化后的码流太大（网络带宽占用）。</li><li>序列化和反序列化的性能（CPU资源占用）。</li><li>是否支持跨语言（异构系统的对接和开发语言切换）。</li></ol><h3 id="4-2-6、零拷贝"><a href="#4-2-6、零拷贝" class="headerlink" title="4.2.6、零拷贝"></a>4.2.6、零拷贝</h3><h4 id="传统意义上的拷贝"><a href="#传统意义上的拷贝" class="headerlink" title="传统意义上的拷贝"></a>传统意义上的拷贝</h4><ol><li>数据从磁盘读取到内核的read buffer</li><li>数据从内核缓冲区拷贝到用户缓冲区</li><li>数据从用户缓冲区拷贝到内核的socket buffer</li><li>数据从内核的socket buffer拷贝到网卡接口（硬件）的缓冲区</li></ol><h4 id="零拷贝的概念"><a href="#零拷贝的概念" class="headerlink" title="零拷贝的概念"></a>零拷贝的概念</h4><p>明显上面的第二步和第三步是没有必要的，通过java的FileChannel.transferTo方法，可以避免上面两次多余的拷贝（当然这需要底层操作系统支持）</p><ol><li>调用transferTo，数据从文件由DMA引擎拷贝到内核read buffer。</li><li>接着DMA从内核read buffer将数据拷贝到网卡接口buffer上面的两次操作都不需要CPU参与，所以就达到了零拷贝。</li></ol><h4 id="Netty零拷贝实现"><a href="#Netty零拷贝实现" class="headerlink" title="Netty零拷贝实现"></a>Netty零拷贝实现</h4><ol><li>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。</li><li>零拷贝的实现CompositeByteBuf对外将多个ByteBuf封装成一个ByteBuf，对外提供统一封装后的ByteBuf接口。</li><li>文件传输，Netty文件传输类DefaultFileRegion通过transferTo方法将文件发送到目标Channel中。</li></ol><h3 id="4-2-7、内存池"><a href="#4-2-7、内存池" class="headerlink" title="4.2.7、内存池"></a>4.2.7、内存池</h3><h3 id="4-2-8、灵活的TCP参数配置能力"><a href="#4-2-8、灵活的TCP参数配置能力" class="headerlink" title="4.2.8、灵活的TCP参数配置能力"></a>4.2.8、灵活的TCP参数配置能力</h3><p>对性能影响较大的配置项：</p><ol><li>SO_RCVBUF和SO_SNDBUF：建议值为128K或者256K。</li><li>SO_TCPNODELAY：NAGLE算法通过将缓冲区内的小封包自动相连组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但对于时延敏感的场景需要关闭该优化算法：</li><li>软中断。</li></ol><h1 id="5、Netty参数配置表"><a href="#5、Netty参数配置表" class="headerlink" title="5、Netty参数配置表"></a>5、Netty参数配置表</h1><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200926142549088.png" alt="image-20200926142549088"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系列-IO</title>
      <link href="/2023/07/30/io-zhi-shi-zong-jie/"/>
      <url>/2023/07/30/io-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="1、IO简介"><a href="#1、IO简介" class="headerlink" title="1、IO简介"></a>1、IO简介</h1><h2 id="1-1、前言"><a href="#1-1、前言" class="headerlink" title="1.1、前言"></a>1.1、前言</h2><p>Linux 2.6以后，Java中NIO和AIO都是通过epoll来实现，而在Windows上，AIO是通过IOCP来实现。</p><p>Epoll 与 IOCP 区别如下：</p><ol><li>Epoll 适用于 Linux；而 IOCP 适用于 Windows；</li><li>Epoll 会在事件资源满足时 发出可处理的通知消息；而 IOCP 会在 事件完成时 发出完成通知消息；</li><li>从应用程序的角度来看， Epoll 本质上是同步非阻塞，IOCP 本质上则是异步操作；</li></ol><p><font color='orange'>Java中的BIO、NIO和AIO就是对操作系统中各种IO模型的封装。程序员在使用相关API时，无需关心系统底层知识，也无需编写不同的代码，而直接使用Java提供的API即可。</font></p><p><font color='orange'>Linux(UNIX)操作系统共有五种IO模型：阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动IO模型、异步IO模型。</font></p><h2 id="1-2、到底什么是IO"><a href="#1-2、到底什么是IO" class="headerlink" title="1.2、到底什么是IO"></a>1.2、到底什么是IO</h2><p><font color='orange'>常说的IO通常指的是文件的输入和输出</font>，而在操作系统层面又是如何定义IO的呢？</p><p><font color='orange'>拿一次磁盘文件读取为例，IO就是把数据从硬件（硬盘）中读取到用户空间中的一个过程。</font></p><p>其实真正的文件读取还涉及到缓存等细节，这里不再展开。关于用户空间、内核空间以及硬件等的关系如果不理解的话，可以通过钓鱼的例子来帮助理解。</p><p>钓鱼过程：我们通过鱼竿将鱼从鱼塘中钓上来并放入鱼篓中。</p><p>其中的鱼塘就可以看成是磁盘，鱼钩可以映射成内核空间，鱼篓可以映射成用户空间。一次完整的钓鱼（IO）操作，是鱼（文件）从鱼塘（硬盘）中转移（拷贝）到鱼篓（用户空间）的过程。</p><p>对于一个network IO (以read举例)，它会涉及到两个系统对象：一个是调用IO的进程，另一个就是系统内核(kernel)。</p><p>对于一次IO访问（以read举例），数据先拷贝至系统内核的缓冲区中，然后再拷贝到应用程序的地址空间。所以，一个read操作会经历两个阶段：</p><ul><li><font color='orange'>阶段1：等待数据准备 (Waiting for the data to be ready)。</font></li><li><font color='orange'>阶段2： 将数据 从内核 拷贝到 进程中 (Copying the data from the kernel to the process)。</font></li></ul><p>因为这两个阶段，linux系统生成了五种网络模式：</p><ul><li>阻塞 I&#x2F;O（blocking IO）</li><li>非阻塞 I&#x2F;O（nonblocking IO）</li><li>信号驱动 I&#x2F;O（ signal driven IO）</li><li>I&#x2F;O 多路复用（ IO multiplexing）</li><li>异步 I&#x2F;O（asynchronous IO）</li></ul><h2 id="1-3、阻塞IO模型（同步）"><a href="#1-3、阻塞IO模型（同步）" class="headerlink" title="1.3、阻塞IO模型（同步）"></a>1.3、阻塞IO模型（同步）</h2><p>我们钓鱼的时候，有一种方式比较惬意，比较轻松，那就是我们坐在鱼竿面前，这个过程中我们什么也不做，双手一直把着鱼竿，就静静的等着鱼儿咬钩。一旦手上感受到鱼的力道，就把鱼钓起来放入鱼篓中。然后再钓下一条鱼。</p><p>映射到Linux操作系统中，这就是一种最简单的IO模型，即阻塞IO。 阻塞 I&#x2F;O 是最简单的 I&#x2F;O 模型，一般表现为进程或线程等待某个条件，如果条件不满足，则一直等下去。直到条件满足再进行下一步操作。</p><p>这种钓鱼方式相对来说比较简单，对于钓鱼的人来说，不需要什么特制的鱼竿，拿一根够长的木棍就可以悠闲的开始钓鱼了（实现简单）。缺点就是比较耗费时间，比较适合那种对鱼的需求量小的情况（并发低，时效性要求低）。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200927130712324.png" alt="image-20200927130712324"></p><p>如上图，当用户进程执行了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整 个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除 block的状态，重新运行起来。</p><h2 id="1-4、非阻塞IO模型（同步）"><a href="#1-4、非阻塞IO模型（同步）" class="headerlink" title="1.4、非阻塞IO模型（同步）"></a>1.4、非阻塞IO模型（同步）</h2><p>我们钓鱼的时候，在等待鱼儿咬钩的过程中，我们可以做点别的事情，比如玩一把王者荣耀、看一集《延禧攻略》等等。但是，我们要时不时的去看一下鱼竿，一旦发现有鱼儿上钩了，就把鱼钓上来。</p><p>映射到Linux操作系统中，这就是非阻塞的IO模型。应用进程与内核交互，目的未达到之前，不再一味的等着，而是直接返回。然后通过轮询的方式，不停的去问内核数据有没有准备好。如果某一次轮询发现数据已经准备好了，那就把数据拷贝到用户空间中。</p><p>这种方式钓鱼，和阻塞IO比，所使用的工具没有什么变化，但是钓鱼的时候可以做些其他事情，增加时间的利用率。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200927131236060.png" alt="image-20200927131236060"></p><p>从上图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。 从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次 发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><p>所以，用户进程第一个阶段不是阻塞的，需要不断的主动询问kernel数据好了没有；第二个阶段依然是阻塞的。</p><h2 id="1-5、信号驱动模型（同步）"><a href="#1-5、信号驱动模型（同步）" class="headerlink" title="1.5、信号驱动模型（同步）"></a>1.5、信号驱动模型（同步）</h2><p>我们钓鱼的时候，为了避免自己一遍一遍的去查看鱼竿，我们可以给鱼竿安装一个报警器。当有鱼儿咬钩的时候立刻报警。然后我们再收到报警后，去把鱼钓起来。</p><p>映射到Linux操作系统中，这就是信号驱动IO。应用进程在读取文件时通知内核，如果某个 socket 的某个事件发生时，请向我发一个信号。在收到信号后，信号对应的处理函数会进行后续处理。</p><p>这种方式钓鱼，和前几种相比，所使用的工具有了一些变化，需要有一些定制（实现复杂）。但是钓鱼的人就可以在鱼儿咬钩之前彻底做别的事儿去了。等着报警器响就行了。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200927132311222.png" alt="image-20200927132311222"></p><p>据上图所示，用户进程预先向内核注册一个信号处理函数，然后用户进程返回，并且不阻塞，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中。</p><h2 id="1-6、IO多路复用模型（同步）"><a href="#1-6、IO多路复用模型（同步）" class="headerlink" title="1.6、IO多路复用模型（同步）"></a>1.6、IO多路复用模型（同步）</h2><p>我们钓鱼的时候，为了保证可以最短的时间钓到最多的鱼，我们同一时间摆放多个鱼竿，同时钓鱼。然后哪个鱼竿有鱼儿咬钩了，我们就把哪个鱼竿上面的鱼钓起来。映射到Linux操作系统中，这就是IO复用模型。多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。</p><p><strong>IO multiplexing（IO多路复用）就是常说的select，poll，epoll，有时也称为event driven IO</strong>。IO复用同非阻塞IO本质一样，不过利用了新的select系统调用，由内核来负责本来是请求进程该做的轮询操作。看似比非阻塞IO还多了一个系统调用开销，不过因为可以支持多路IO，才算提高了效率。</p><p>这种通过 增加鱼竿 的方式，可有效提升效率。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200927131649129.png" alt="image-20200927131649129"></p><p>据上图可知，当用户进程调用了<code>select</code>，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个 socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p><p>select&#x2F;epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。在IO multiplexing Model中，实际对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被 block的。只不过process是被select这个函数block，而不是被socket IO给block。</p><h2 id="1-7、异步IO模型（异步）"><a href="#1-7、异步IO模型（异步）" class="headerlink" title="1.7、异步IO模型（异步）"></a>1.7、异步IO模型（异步）</h2><p>我们钓鱼的时候，采用一种高科技钓鱼竿，即全自动钓鱼竿。可以自动感应鱼上钩，自动收竿，更厉害的可以自动把鱼放进鱼篓里。然后，通知我们鱼已经钓到了，他就继续去钓下一条鱼去了。</p><p>映射到Linux操作系统中，这就是异步IO模型。应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200927132414881.png" alt="image-20200927132414881"></p><p>如上图所示，用户进程发起<code>aio_read</code>操作之后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作完成时，如何通知进程，然后就立刻去做其他事情了。当内核收到<code>aio_read</code>后，会立刻返回，然后内核开始等待数据准备，数据准备好以后，直接把数据拷贝到用户空间，然后再通知进程本次IO已经完成。</p><p>这种钓鱼方式，最省事，只需要交给鱼竿就可以了。</p><h2 id="1-8、总结"><a href="#1-8、总结" class="headerlink" title="1.8、总结"></a>1.8、总结</h2><h3 id="1-8-1、前四种都是同步IO模型"><a href="#1-8-1、前四种都是同步IO模型" class="headerlink" title="1.8.1、前四种都是同步IO模型"></a>1.8.1、前四种都是同步IO模型</h3><p>我们说阻塞IO模型、非阻塞IO模型、IO复用模型和信号驱动IO模型都是同步的IO模型。原因是因为，无论以上那种模型，真正的数据拷贝过程，都是同步进行。</p><p><font color='orange'>信号驱动逻辑是：内核在数据准备好之后通知进程，然后进程通过<code>recvfrom</code>操作进行数据拷贝。可以认为数据准备阶段是异步的，数据拷贝操作是同步的。所以，整个IO过程不能认为是异步。</font></p><h3 id="1-8-2、五种-IO-模型对比"><a href="#1-8-2、五种-IO-模型对比" class="headerlink" title="1.8.2、五种 IO 模型对比"></a>1.8.2、五种 IO 模型对比</h3><img src="\imgs\javadev\5种IO模型对比01.png" style="zoom:100%;float:left;" /><h1 id="2、IO多路复用"><a href="#2、IO多路复用" class="headerlink" title="2、IO多路复用"></a>2、IO多路复用</h1><h2 id="2-1、必知知识"><a href="#2-1、必知知识" class="headerlink" title="2.1、必知知识"></a>2.1、必知知识</h2><h3 id="2-1-1、用户空间和内核空间"><a href="#2-1-1、用户空间和内核空间" class="headerlink" title="2.1.1、用户空间和内核空间"></a>2.1.1、用户空间和内核空间</h3><p>如今的操作系统大都采用虚拟存储器，32位操作系统的寻址空间（虚拟存储空间）为4G（2的32次方）。</p><p><font color='orange'>操作系统核心是内核，独立于普通应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。</font></p><p><font color='orange'>为了限制进程直接操作内核（kernel），保证内核安全，操作系统将虚拟空间划分为两部分：</font></p><ul><li><p><font color='orange'>内核空间</font></p><p>针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF）供内核使用，称为内核空间。</p></li><li><p><font color='orange'>用户空间</font></p><p>将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF）供进程使用，称为用户空间。</p></li></ul><h3 id="2-1-2、进程切换"><a href="#2-1-2、进程切换" class="headerlink" title="2.1.2、进程切换"></a>2.1.2、进程切换</h3><p><font color='orange'>为了控制进程执行，内核必须有能力挂起正在CPU上运行的进程和恢复被挂起的某个进程，这种行为被称为进程切换。可以说，任何进程的运行都依赖于操作系统内核的支持。</font></p><p><font color='orange'>从一个进程的运行转到另一个进程上运行，其过程变化如下：</font></p><ol><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ol><p>注：总而言之就是很耗资源，具体可参考这篇文章：<a href="http://guojing.me/linux-kernel-architecture/posts/process-switch/">进程切换</a></p><h3 id="2-1-3、进程阻塞"><a href="#2-1-3、进程阻塞" class="headerlink" title="2.1.3、进程阻塞"></a>2.1.3、进程阻塞</h3><p><font color='orange'>正在执行的进程，若期待的某些事件未发生，则系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。</font></p><p><font color='orange'>进程的阻塞是进程自身的一种主动行为，因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态时不会占用CPU资源。</font></p><h3 id="2-1-4、文件描述符FD"><a href="#2-1-4、文件描述符FD" class="headerlink" title="2.1.4、文件描述符FD"></a>2.1.4、文件描述符FD</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><font color='orange'>文件描述符（File descriptor）是计算机科学中的一个术语，是一个表述 指向文件的引用抽象化概念。</font></p><p><font color='orange'>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核会向进程返回一个文件描述符。</font></p><p><font color='red'>注意：在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</font></p><h4 id="文件描述符原理"><a href="#文件描述符原理" class="headerlink" title="文件描述符原理"></a>文件描述符原理</h4><p>系统为了维护文件描述符建立了3张表：</p><ul><li><p><font color='orange'>进程级文件描述符表</font></p><p>主要记录了以下两项内容：</p><ol><li>文件描述符标志。</li><li>文件指针（open file handle）。</li></ol></li><li><p><font color='orange'>系统级文件描述符表</font></p><p>记录内容如下：</p><ol><li>当前文件偏移量。</li><li>状态标识。</li><li>文件访问模式（读、写、读和写）。</li><li>对该文件i-nod对象的引用。</li><li>文件类型（常规文件、套接字、FIFO….）。</li><li>访问权限。</li><li>一个指向该文件所持有的索引表的指针。</li><li>文件的各种属性。</li><li>与信号驱动相关设置。</li></ol></li><li><p><font color='orange'>文件系统i-node表</font></p><p>记录内容如下：</p><ol><li>文件类型。</li><li>文件锁。</li></ol></li></ul><h4 id="文件描述符限制"><a href="#文件描述符限制" class="headerlink" title="文件描述符限制"></a>文件描述符限制</h4><p><font color='orange'>文件描述符是一个重要的系统资源，理论上，可以打开多少个文件描述符取决于系统内存的大小，但内核会有系统级限制，以及用户级限制（不让某一个应用程序进程消耗掉所有的文件资源，可以使用ulimit -n 查看）。</font></p><p><strong>用户级限制</strong></p><ul><li><p>查看</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">ulimit</span> <span class="token parameter variable">-n</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>修改</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 重启后失效</span><span class="token builtin class-name">ulimit</span> <span class="token parameter variable">-SHn</span> <span class="token number">65535</span><span class="token comment"># 永久生效</span>修改配置文件/etc/security/limits.conf，在最后一行加入：* - nofile <span class="token number">65535</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>系统级限制</strong></p><ul><li><p>查看</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sysctl</span> <span class="token parameter variable">-a</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> file-max --color<span class="token punctuation">;</span>---<span class="token function">cat</span> /proc/sys/fs/file-max<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>修改</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 重启后失效</span><span class="token function">sysctl</span> <span class="token parameter variable">-w</span> fs.file-max<span class="token operator">=</span><span class="token number">65535</span><span class="token punctuation">;</span>---<span class="token builtin class-name">echo</span> <span class="token number">65535</span> <span class="token operator">></span> /proc/sys/fs/file-max<span class="token comment">#永久生效</span>修改配置文件/etc/sysctl.conf，在最后一行加入fs.file-max<span class="token operator">=</span><span class="token number">65535</span>。执行访问，触发生效。<span class="token function">sysctl</span> <span class="token parameter variable">-p</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="2-1-5、缓存I-O"><a href="#2-1-5、缓存I-O" class="headerlink" title="2.1.5、缓存I&#x2F;O"></a>2.1.5、缓存I&#x2F;O</h3><p><font color='orange'>缓存 I&#x2F;O 又被 称作 标准 I&#x2F;O，大多数文件系统的默认 I&#x2F;O 都是缓存 I&#x2F;O。</font></p><p>Linux 缓存 I&#x2F;O 机制中，操作系统会将 I&#x2F;O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据先被拷贝至系统内核的缓冲区中，然后再拷贝到应用程序的地址空间。</p><h3 id="2-1-6、IO多路复用简介"><a href="#2-1-6、IO多路复用简介" class="headerlink" title="2.1.6、IO多路复用简介"></a>2.1.6、IO多路复用简介</h3><p><font color='orange'>IO多路复用是指：内核一旦发现进程指定的一个或者多个IO条件符合要求时就会通知该进程。</font></p><p>与多进程和多线程技术相比，I&#x2F;O多路复用的最大优势就是系统开销小，系统不必创建进程&#x2F;线程，也不必维护这些进程&#x2F;线程，从而大大减小了系统的开销。</p><p>目前支持I&#x2F;O多路复用的系统调用有 <code>select、pselect、poll、epoll</code>，I&#x2F;O多路复用就是通过一种机制来实现一个进程监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作<code>。</code></p><p><code>select、pselect、poll、epoll</code>本质上都是同步I&#x2F;O，需要在读写事件就绪后自己负责进行读写，这个读写过程是阻塞的，而异步I&#x2F;O无需自己读写，其实现会自动把数据从内核拷贝到用户空间。</p><p><code>epoll</code>跟<code>select</code>都能提供I&#x2F;O多路复用的解决方案。现在的Linux内核都能支持，其中<code>epoll</code>是Linux所特有，而<code>select</code>则是<code>POSIX</code>所规定，一般操作系统均有实现。</p><p><font color='orange'>select，poll，epoll都是I&#x2F;O多路复用的具体实现，他们的出现有先后顺序。</font></p><h2 id="2-2、select（1983）"><a href="#2-2、select（1983）" class="headerlink" title="2.2、select（1983）"></a>2.2、select（1983）</h2><p>I&#x2F;O多路复用 被提出来后，select是第一个实现 (1983 左右在BSD里实现)。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> select <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span> struct timeval <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-1、原理"><a href="#2-2-1、原理" class="headerlink" title="2.2.1、原理"></a>2.2.1、原理</h3><p><code>select</code>函数监视的文件描述符 分3类，分别是<code>writefds、readfds、exceptfds</code>。调用select函数后会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（<code>timeout</code>指定等待时间，如果立即返回设为<code>null</code>即可）后函数才返回。当select函数返回后，只能通过遍历<code>fdset</code>，来找到就绪的描述符。</p><h3 id="2-2-2、优缺点"><a href="#2-2-2、优缺点" class="headerlink" title="2.2.2、优缺点"></a>2.2.2、优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p><font color='orange'><code>select</code>目前几乎在所有的平台上都支持，其良好跨平台支持也是它的一个优点。</font></p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><font color='orange'>select 会修改传入的参数数组。</font>这个对于一个需要调用很多次的函数，是非常不友好的。</li><li>select 中的任何一个sock(I&#x2F;O stream)出现了数据，<font color='orange'>select 仅仅会返回，但并不告诉你哪个sock上有数据，</font>于是只能遍历一遍才能找到，这开销可想而知。</li><li><font color='orange'>select 只能监视1024个链接。</font>这个和草榴没啥关系，linux 定义在头文件中的，参见<em>FD_SETSIZE。</em></li><li><font color='orange'>select 线程不安全。</font>如果你把一个sock加入到select，然后突然另外一个线程发现，尼玛，这个sock不用，要收回。对不起，这个select不支持的，如果你丧心病狂的竟然关掉这个sock，select的标准行为是。呃。不可预测的，这个可是写在文档中的哦。</li></ol><h2 id="2-3、poll（1997）"><a href="#2-3、poll（1997）" class="headerlink" title="2.3、poll（1997）"></a>2.3、poll（1997）</h2><p>1997年实现了poll。</p><p>与select使用三个位图来表示三个<code>fdset</code>的方式不同，poll使用一个<code>pollfd</code>指针实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">struct pollfd <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span> <span class="token comment">/* file descriptor */</span>    <span class="token keyword">short</span> events<span class="token punctuation">;</span> <span class="token comment">/* requested events to watch */</span>    <span class="token keyword">short</span> revents<span class="token punctuation">;</span> <span class="token comment">/* returned events witnessed */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>pollfd结构包含了要监视的 event 和发生的 event，不再使用 select的 “参数-值”传递方式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> poll <span class="token punctuation">(</span>struct pollfd <span class="token operator">*</span>fds<span class="token punctuation">,</span> unsigned <span class="token keyword">int</span> nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-3-1、原理"><a href="#2-3-1、原理" class="headerlink" title="2.3.1、原理"></a>2.3.1、原理</h3><p><font color='orange'><code>poll</code>本质上和<code>select</code>没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历。如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时。挂起的线程被唤醒后会再次遍历fd。这个过程经历了多次无意义的遍历。</font></p><h3 id="2-3-2、优缺点"><a href="#2-3-2、优缺点" class="headerlink" title="2.3.2、优缺点"></a>2.3.2、优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li><font color='orange'>没有最大连接数的限制，因为是基于链表来存储。</font></li><li><font color='orange'>不再修改传入数组，不过这个要看平台了，所以小心为妙。</font></li></ol><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li><font color='orange'>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</font></li><li><font color='orange'><code>poll</code>有一个特点是“水平触发。如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</font></li><li><font color='orange'>线程非安全。</font></li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p><font color='orange'>从上面看，<code>select</code>和<code>poll</code>都需要在返回后，通过遍历文件描述符来获取已经就绪的<code>socket</code>。事实上，同时连接的大量客户端可能只有很少数处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</font></p><h2 id="2-4、epoll（2002）"><a href="#2-4、epoll（2002）" class="headerlink" title="2.4、epoll（2002）"></a>2.4、epoll（2002）</h2><h3 id="2-4-1、简介"><a href="#2-4-1、简介" class="headerlink" title="2.4.1、简介"></a>2.4.1、简介</h3><p>2002，大神 Davide Libenzi 实现了epoll，在内核2.6中提出。</p><p>epoll 是 select 和 poll 的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。<font color='orange'>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</font></p><h3 id="2-4-2、原理"><a href="#2-4-2、原理" class="headerlink" title="2.4.2、原理"></a>2.4.2、原理</h3><p><font color='orange'><code>epoll</code>支持水平触发和边缘触发。最大特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。</font>还有一个特点是<code>epoll</code>使用“事件”就绪通知的方式，通过<code>epoll_ctl</code>注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p><h3 id="2-4-3、工作过程"><a href="#2-4-3、工作过程" class="headerlink" title="2.4.3、工作过程"></a>2.4.3、工作过程</h3><p>epoll操作过程需要三个接口，分别如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span>；<span class="token comment">// 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> struct epoll_event <span class="token operator">*</span>event<span class="token punctuation">)</span>；<span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> struct epoll_event <span class="token operator">*</span> events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p><font color='orange'>epoll_create(int size)</font></p><p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。 当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看&#x2F;proc&#x2F;进程id&#x2F;fd&#x2F;，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p></li><li><p><font color='orange'>epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</font></p><ul><li><p>epfd：是epoll_create()的返回值。</p></li><li><p>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</p></li><li><p>fd：是需要监听的fd（文件描述符）</p></li><li><p>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">struct epoll_event <span class="token punctuation">&#123;</span>    __uint32_t events<span class="token punctuation">;</span>     <span class="token comment">/* Epoll events / epoll_data_t data; / User data variable */</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>events可以是以下几个宏的集合： </p><ol><li><font color='orange'>EPOLLIN </font>：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</li><li><font color='orange'>EPOLLOUT</font>：表示对应的文件描述符可以写； </li><li><font color='orange'>EPOLLPRI</font>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）； </li><li><font color='orange'>EPOLLERR</font>：表示对应的文件描述符发生错误；</li><li><font color='orange'>EPOLLHUP</font>：表示对应的文件描述符被挂断； </li><li><font color='orange'>EPOLLET</font>： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。 </li><li><font color='orange'>EPOLLONESHOT</font>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。</li></ol></li></ul></li><li><p><font color='orange'>epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)</font></p><p>等待epfd上的io事件，最多返回maxevents个事件。 参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p></li></ul><h3 id="2-4-4、优缺点"><a href="#2-4-4、优缺点" class="headerlink" title="2.4.4、优缺点"></a>2.4.4、优缺点</h3><ul><li><p>优点</p><ol><li>没有最大并发连接的限制，能打开的FD上限远大于1024（1G的内存上能监听约10万个端口）。</li><li>线程安全。</li><li>效率提升，它并不采用轮询的方式，不会随着FD数目的增加而效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li><li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</li></ol></li><li><p>缺点</p><p>epoll 有个致命缺点。只有linux支持。比如BSD上面对应的实现是kqueue。</p></li></ul><h3 id="2-4-5、工作模式"><a href="#2-4-5、工作模式" class="headerlink" title="2.4.5、工作模式"></a>2.4.5、工作模式</h3><p><font color='orange'>epoll对文件描述符的操作有两种模式：LT（level trigger，水平触发，默认）和 ET（edge trigger，边缘触发）。</font>两者的区别如下：</p><ul><li><p><font color='orange'>LT模式（事件发生就通知你，你不管，那就一直通知你。）</font></p><p>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p><p><code>LT(level triggered)</code>是默认的工作方式，并且同时支持<code>block和no-block socket</code>。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的&#96;。</p></li><li><p><font color='orange'>ET模式（事件发生就通知你，你不管，那不好意思，只会通知一次。）</font></p><p>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p><p><code>ET(edge-triggered)</code>是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)。</p><p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p></li></ul><p>如果存在大量活跃连接，select&#x2F;poll效率会较高一点，但如果活跃连接数量较少，就会发现epoll的效率高于select&#x2F;poll。</p><h2 id="2-5、kqueue"><a href="#2-5、kqueue" class="headerlink" title="2.5、kqueue"></a>2.5、kqueue</h2><h3 id="2-5-1、简介"><a href="#2-5-1、简介" class="headerlink" title="2.5.1、简介"></a>2.5.1、简介</h3><p>与 epoll 类似，仅存于 FreeBSD（一种类UNIX操作系统）。</p><h2 id="2-6、总结"><a href="#2-6、总结" class="headerlink" title="2.6、总结"></a>2.6、总结</h2><h3 id="2-6-1、select、poll、epoll区别"><a href="#2-6-1、select、poll、epoll区别" class="headerlink" title="2.6.1、select、poll、epoll区别"></a>2.6.1、select、poll、epoll区别</h3><ol><li><p>一个进程所能打开的最大连接数</p><img src="\imgs\javadev\select-poll-epoll区别_一个进程支持的最大连接数01.png" style="zoom:50%;float:left;"/></li><li><p>FD剧增后带来的IO效率问题</p><img src="\imgs\javadev\select-poll-epoll区别_FD剧增后带来的效率问题01.png" style="zoom:50%;float:left;" /></li><li><p>消息传递方式</p><img src="\imgs\javadev\select-poll-epoll区别_消息传递方式01.png" style="zoom:50%;float:left;" /></li></ol><h3 id="2-6-2、场景助记"><a href="#2-6-2、场景助记" class="headerlink" title="2.6.2、场景助记"></a>2.6.2、场景助记</h3><p>一个epoll场景：一个酒吧服务员（一个线程），前面趴了一群醉汉，突然一个吼一声“倒酒”（事件），你小跑过去给他倒一杯，然后随他去吧，突然又一个要倒酒，你又过去倒上，就这样一个服务员服务好多人，有时没人喝酒，服务员处于空闲状态，可以玩玩手机。</p><p>至于epoll与select，poll的区别在于后两者的场景中醉汉不说话，你要挨个问要不要酒，没时间玩手机了。I&#x2F;O多路复用大概就是指这几个醉汉共用一个服务员。</p><h3 id="2-6-3、三者如何选择"><a href="#2-6-3、三者如何选择" class="headerlink" title="2.6.3、三者如何选择"></a>2.6.3、三者如何选择</h3><ol><li><font color='orange'>通常认为<code>epoll</code>性能最好，但在连接数少且连接都十分活跃的情况下，<code>select</code>和<code>poll</code>的性能可能要比<code>epoll</code>更好，毕竟<code>epoll</code>的通知机制需要很多函数回调。</font></li><li><font color='orange'><code>select</code>低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计进行改善。</font></li></ol><h1 id="3、BIO（Blocking-Input-Output）"><a href="#3、BIO（Blocking-Input-Output）" class="headerlink" title="3、BIO（Blocking Input&#x2F;Output）"></a>3、BIO（Blocking Input&#x2F;Output）</h1><h2 id="3-1、简介"><a href="#3-1、简介" class="headerlink" title="3.1、简介"></a>3.1、简介</h2><p><font color='orange'>BIO是一个同步阻塞IO。同步阻塞I&#x2F;O模式下，数据的读取写入必须阻塞在一个线程内等待其完成。</font></p><p>通过经典的烧开水例子来帮助理解，这里假设一个烧开水的场景，有一排水壶在烧开水，BIO的工作模式就是， 叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。但是实际上线程在等待水壶烧开的时间段什么都没有做。</p><h2 id="3-2、特点"><a href="#3-2、特点" class="headerlink" title="3.2、特点"></a>3.2、特点</h2><ol><li><font color='orange'>一个线程对应一个请求。每进来一个请求就会创建一个线程。</font></li></ol><h2 id="3-3、阻塞方法"><a href="#3-3、阻塞方法" class="headerlink" title="3.3、阻塞方法"></a>3.3、阻塞方法</h2><ol><li>InputStream.read()</li><li>OutputStream.write()</li><li>ServerSocket.accept()</li></ol><h2 id="3-4、优缺点"><a href="#3-4、优缺点" class="headerlink" title="3.4、优缺点"></a>3.4、优缺点</h2><ul><li><p><font color='orange'>优点：（同步、使用复杂。）</font></p><p>BIO模型程序开发起来较为简单，易于把握。（因为这是最基本与简单的I&#x2F;O操作方式，其根本特性是做完一件事再去做另一件事，一件事一定要等前一件事做完，这很符合程序员传统的顺序开发思想。）</p></li><li><p><font color='orange'>缺点：（阻塞、同步，三次握手耗时。）</font></p><p>BIO模型下的线程阻塞会导致线程的频繁切换，进而影响整个系统性能。因为BIO模型下，一个线程同时只能做一个工作，如果线程在执行过程中依赖于需要等待的资源，那么该线程会长期处于阻塞状态，我们知道在整个操作系统中，线程是系统执行的基本单位。</p></li></ul><h2 id="3-5、使用场景"><a href="#3-5、使用场景" class="headerlink" title="3.5、使用场景"></a>3.5、使用场景</h2><p><font color='orange'>BIO方式适用于连接数量少且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</font></p><h2 id="3-6、注意事项"><a href="#3-6、注意事项" class="headerlink" title="3.6、注意事项"></a>3.6、注意事项</h2><p><font color='orange'>系统开发中，线程的生命周期一定要准确控制，对于大并发的场景，尽量使用线程池来确保线程的创建数量在一个合理范围之内，切勿编写代码来限制线程创建上限。</font></p><h1 id="4、NIO（New-Input-Output）"><a href="#4、NIO（New-Input-Output）" class="headerlink" title="4、NIO（New Input&#x2F;Output）"></a>4、NIO（New Input&#x2F;Output）</h1><h2 id="4-1、简介"><a href="#4-1、简介" class="headerlink" title="4.1、简介"></a>4.1、简介</h2><p><font color='orange'>NIO是一种同步非阻塞的I&#x2F;O模型，Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。</font></p><p>NIO中的N可以理解为Non-blocking，而不单纯是New。它支持面向缓冲的，基于通道的I&#x2F;O操作方法。 NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种套接字通道实现，两种通道都支持阻塞和非阻塞两种模式。</p><p>阻塞模式比较简单，但性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I&#x2F;O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 非阻塞模式来应对。</p><p><font color='orange'>NIO编程中，需要理解3个对象：Channel、Buffer和Selector。</font></p><h2 id="4-2、Channel"><a href="#4-2、Channel" class="headerlink" title="4.2、Channel"></a>4.2、Channel</h2><p>Channel和IO中的Stream(流)是差不多一个等级。只不过Stream是单向的，譬如：InputStream, OutputStream。而Channel是双向的，既可以用来进行读操作，又可以用来进行写操作，NIO中的Channel实现有：</p><ol><li>FileChannel——文件IO</li><li>DatagramChannel——UDP</li><li>SocketChannel——TCP Client</li><li>ServerSocketChannel——TCP Server</li></ol><h2 id="4-3、Buffer"><a href="#4-3、Buffer" class="headerlink" title="4.3、Buffer"></a>4.3、Buffer</h2><p>NIO中的Buffer实现有：ByteBuffer、CharBuffer、DoubleBuffer、 FloatBuffer、IntBuffer、 LongBuffer、ShortBuffer，分别对应基本数据类型: byte、char、double、 float、int、 long、 short。当然NIO中还有MappedByteBuffer、HeapByteBuffer、DirectByteBuffer等。</p><h3 id="4-3-1、DirectByteBuffer-VS-HeapByteBuffer"><a href="#4-3-1、DirectByteBuffer-VS-HeapByteBuffer" class="headerlink" title="4.3.1、DirectByteBuffer VS HeapByteBuffer"></a>4.3.1、DirectByteBuffer VS HeapByteBuffer</h3><p>它们是ByteBuffer分配内存的两种方式。</p><ol><li>HeapByteBuffer内存空间在JVM堆上分配，可以看做是jdk对于byte[]数组的封装；而DirectByteBuffer则直接利用了系统接口进行内存申请，其内存分配在C的heap中，这样就减少了内存之间的拷贝操作，如此一来，在使用 DirectByteBuffer 时，系统就可以直接从内存将数据写入到Channel中，而无需进行Java堆的内存申请，复制等操作，提高了性能。</li><li>DirectByteBuffer使用起来相对于完全托管于Java内存管理的HeapByteBuffer来说更复杂一些，如果用不好可能会引起OOM。因为DirectByteBuffer通过FGC来回收内存，且会自己检测情况是否调用system.gc()。如果参数中使用了DisableExplicitGC那么就无法回收该快内存了，-XX:+DisableExplicitGC标志会让System.gc()方法失效，失效后如果还想回收就需要我们手动来回收内存了。</li><li>DirectByteBuffer的内存大小受 -XX:MaxDirectMemorySize JVM参数控制（默认大小64M），在 DirectByteBuffer申请内存空间达到该设置大小后，会触发FGC。</li></ol><h2 id="4-4、Selector"><a href="#4-4、Selector" class="headerlink" title="4.4、Selector"></a>4.4、Selector</h2><h3 id="4-4-1、简介"><a href="#4-4-1、简介" class="headerlink" title="4.4.1、简介"></a>4.4.1、简介</h3><p><font color='orange'>Selector通过单线程处理多个Channel，如果你的应用打开了多个通道，且每个连接的流量都很低，那么Selector就是绝配。</font></p><h3 id="4-4-2、优缺点"><a href="#4-4-2、优缺点" class="headerlink" title="4.4.2、优缺点"></a>4.4.2、优缺点</h3><h3 id="4-4-3、使用场景"><a href="#4-4-3、使用场景" class="headerlink" title="4.4.3、使用场景"></a>4.4.3、使用场景</h3><p><font color='orange'>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</font></p><h2 id="4-5、总结"><a href="#4-5、总结" class="headerlink" title="4.5、总结"></a>4.5、总结</h2><h3 id="4-5-1、NIO特性-NIO与IO的区别"><a href="#4-5-1、NIO特性-NIO与IO的区别" class="headerlink" title="4.5.1、NIO特性&#x2F;NIO与IO的区别"></a>4.5.1、NIO特性&#x2F;NIO与IO的区别</h3><ul><li><p><font color='orange'>Non-Blocking IO</font></p><p>IO流是阻塞的，NIO流不阻塞。</p></li><li><p><font color='orange'>Buffer（缓冲区）</font></p><p>IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。</p><p>Buffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I&#x2F;O的一个重要区别。在面向流的I&#x2F;O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。</p></li><li><p><font color='orange'>Channel（通道）</font></p><p>NIO 基于通道进行读写。通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互，故可以异步地读写。</p></li><li><p><font color='orange'>Selector（选择器）</font></p><p>NIO有选择器，而IO没有。</p><p>选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。</p></li></ul><h3 id="4-5-2、NIO-VS-BIO"><a href="#4-5-2、NIO-VS-BIO" class="headerlink" title="4.5.2、NIO VS BIO"></a>4.5.2、NIO VS BIO</h3><ol><li><font color='orange'>BIO是以流的方式处理数据，而NIO以块的方式处理数据。块IO的效率要比流IO高。</font></li><li><font color='orange'>BIO是阻塞的，而NIO非阻塞。</font></li><li><font color='orange'>BIO基于字节流和字符流进行操作，而NIO基于Channel和Buffer进行操作，数据既可以从Channel读到Buffer中，也可以从Buffer写入Channel中，Selector用于监听多个通道，故单个线程就可以监听多个客户端。</font></li></ol><h1 id="5、AIO（Asynchronous-Input-Output）"><a href="#5、AIO（Asynchronous-Input-Output）" class="headerlink" title="5、AIO（Asynchronous Input&#x2F;Output）"></a>5、AIO（Asynchronous Input&#x2F;Output）</h1><h2 id="5-1、简介"><a href="#5-1、简介" class="headerlink" title="5.1、简介"></a>5.1、简介</h2><p>AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2，它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p>AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。（除了 AIO 其他的 IO 类型都是同步的，这一点可以从底层IO线程模型解释。</p><h2 id="5-2、特点"><a href="#5-2、特点" class="headerlink" title="5.2、特点"></a>5.2、特点</h2><p>在进行IO操作时，不需要阻塞等待操作完成，期间可以执行其它操作，一旦操作完成会直接返回结果给你。</p><h2 id="5-3、优缺点"><a href="#5-3、优缺点" class="headerlink" title="5.3、优缺点"></a>5.3、优缺点</h2><p>优点：提升IO操作的效率和系统的并发性能。</p><p>缺点：系统对其的支持不够完善，且实现较为复杂，只适用于大数据量的IO操作场景。</p><h2 id="5-4、使用场景"><a href="#5-4、使用场景" class="headerlink" title="5.4、使用场景"></a>5.4、使用场景</h2><p><font color='orange'>AIO方式适用于连接数目多且连接较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</font></p><h1 id="6、IO多路复用模式"><a href="#6、IO多路复用模式" class="headerlink" title="6、IO多路复用模式"></a>6、IO多路复用模式</h1><p><font color='orange'>一般地，I&#x2F;O多路复用机制都依赖于一个事件多路分离器(Event Demultiplexer)。分离器对象可将 来自事件源 的I&#x2F;O事件分离出来，然后分发到对应的read&#x2F;write事件处理器(Event Handler)。开发人员预先注册需要处理的事件及其事件处理器（或回调函数）；事件分离器负责将请求事件传递给事件处理器。</font></p><p><font color='orange'>两个与 事件分离器 有关的模式是Reactor和Proactor。Reactor模式采用同步IO，而Proactor采用异步IO。</font></p><p>在Reactor中，事件分离器负责 等待 文件描述符或socket为读写操作 准备就绪，然后将就绪事件传递给对应的处理器，最后由处理器负责完成实际的读写工作。</p><p>在Proactor中，处理器或兼任处理器的事件分离器，只负责发起异步读写操作。IO操作本身由操作系统来完成。传递给操作系统的参数需要包含用户定义的数据缓冲区地址和数据大小，操作系统才能从中得到写出操作所需数据，或写入从socket读到的数据。事件分离器捕获IO操作完成事件，然后将事件传递给对应事件处理器。比如，在windows上，处理器发起一个异步IO操作，再由事件分离器等待IOCompletion事件。典型的异步模式实现，都建立在操作系统支持异步API的基础之上，我们将这种实现称为“系统级”异步或“真”异步，因为应用程序完全依赖操作系统执行真正的IO工作。</p><h2 id="6-1、Reactor模式"><a href="#6-1、Reactor模式" class="headerlink" title="6.1、Reactor模式"></a>6.1、Reactor模式</h2><h3 id="6-x-1、读操作"><a href="#6-x-1、读操作" class="headerlink" title="6.x.1、读操作"></a>6.x.1、读操作</h3><ol><li>注册读就绪事件和相关的事件处理器。</li><li>事件分离器等待事件发生。</li><li>当读就绪事件发生时，事件分离器调用第一步中的事件处理器。</li><li>事件处理器首先执行读取操作，处理读到的数据，注册新的事件，然后返还控制权。</li></ol><h3 id="6-x-2、写操作"><a href="#6-x-2、写操作" class="headerlink" title="6.x.2、写操作"></a>6.x.2、写操作</h3><p>写入操作类似于读取操作，只不过第一步注册的是写就绪事件。</p><h3 id="6-x-3、class结构"><a href="#6-x-3、class结构" class="headerlink" title="6.x.3、class结构"></a>6.x.3、class结构</h3><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210130120424783.png" alt="image-20210130120424783"></p><p>Reactor包含如下角色：</p><ul><li>Handle 句柄；用来标识socket连接或是打开文件；</li><li>Synchronous Event Demultiplexer：同步事件多路分解器：由操作系统内核实现的一个函数；用于阻塞等待发生在句柄集合上的一个或多个事件；（如select&#x2F;epoll；）</li><li>Event Handler：事件处理接口</li><li>Concrete Event HandlerA：实现应用程序所提供的特定事件处理逻辑；</li><li>Reactor：反应器，定义一个接口，实现以下功能：<ol><li>供应用程序注册和删除关注的事件句柄；</li><li>运行事件循环；</li><li>有就绪事件到来时，分发事件到之前注册的回调函数上处理；</li></ol></li></ul><p><font color='orange'>“反应器”名字中”反应“的由来：“反应”即“倒置”，“控制逆转”。</font></p><p>具体事件处理程序不调用反应器，而是由反应器分配一个具体事件处理程序，具体事件处理程序对某个指定的事件发生做出反应；这种控制逆转又称为“好莱坞法则”（不要调用我，让我来调用你）。</p><p>业务流程时序图：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210130120745134.png" alt="image-20210130120745134"></p><ol><li>应用启动，将关注的事件handle注册到Reactor中；</li><li>调用Reactor，进入无限事件循环，等待注册的事件到来；</li><li>事件到来，select返回，Reactor将事件分发到之前注册的回调函数中处理；</li></ol><h2 id="6-2、Proactor模式"><a href="#6-2、Proactor模式" class="headerlink" title="6.2、Proactor模式"></a>6.2、Proactor模式</h2><h3 id="6-x-1、读操作-1"><a href="#6-x-1、读操作-1" class="headerlink" title="6.x.1、读操作"></a>6.x.1、读操作</h3><ol><li>应用程序初始化一个异步读取操作，然后注册事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。 </li><li>事件分离器等待读取操作完成事件。</li><li>在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作（异步IO都是操作系统负责将数据读写到应用传递进来的缓冲区供应用程序操作，操作系统扮演了重要角色），并将读取的内容放入用户传递过来的缓存区中。Proactor中，应用程序需要传递缓存区，这也是区别于Reactor的一点。 </li><li>事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。</li></ol><h3 id="6-x-2、写操作-1"><a href="#6-x-2、写操作-1" class="headerlink" title="6.x.2、写操作"></a>6.x.2、写操作</h3><p>写操作与读操作类似。</p><h3 id="6-x-3、class结构-1"><a href="#6-x-3、class结构-1" class="headerlink" title="6.x.3、class结构"></a>6.x.3、class结构</h3><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210130121111912.png" alt="image-20210130121111912"></p><p><strong>Proactor主动器模式包含如下角色</strong></p><ul><li>Handle 句柄；用来标识socket连接或是打开文件；</li><li>Asynchronous Operation Processor：异步操作处理器；负责执行异步操作，一般由操作系统内核实现；</li><li>Asynchronous Operation：异步操作;</li><li>Completion Event Queue：完成事件队列；异步操作完成的结果放到队列中等待后续使用;</li><li>Proactor：主动器；为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，分发调用相应的后续处理逻辑；</li><li>Completion Handler：完成事件接口；一般是由回调函数组成的接口；</li><li>Concrete Completion Handler：完成事件处理逻辑；实现接口定义特定的应用处理逻辑；</li></ul><p>业务流程时序图：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210130121212731.png" alt="image-20210130121212731"></p><ol><li>应用程序启动，调用异步操作处理器提供的异步操作接口函数，调用之后应用程序和异步操作处理就独立运行；应用程序可以调用新的异步操作，而其它操作可以并发进行；</li><li>应用程序启动Proactor主动器，进行无限的事件循环，等待完成事件到来；</li><li>异步操作处理器执行异步操作，完成后将结果放入到完成事件队列；</li><li>主动器从完成事件队列中取出结果，分发到相应的完成事件回调函数处理逻辑中；</li></ol><h2 id="6-3、总结"><a href="#6-3、总结" class="headerlink" title="6.3、总结"></a>6.3、总结</h2><h3 id="6-3-1、主动与被动"><a href="#6-3-1、主动与被动" class="headerlink" title="6.3.1、主动与被动"></a>6.3.1、主动与被动</h3><p>以主动写为例：</p><ul><li><font color='orange'>Reactor将handle放到select()，等待可写就绪，然后调用write()写入数据；写完后 处理后续逻辑；</font></li><li><font color='orange'>Proactor调用aoi_write后立刻返回，由内核负责写操作，写完后调用相应的回调函数处理后续逻辑；</font></li></ul><h3 id="6-3-2、实现"><a href="#6-3-2、实现" class="headerlink" title="6.3.2、实现"></a>6.3.2、实现</h3><p><font color='orange'>Reactor实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应。</font></p><p><font color='orange'>Proactor实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）。</font></p><h3 id="6-3-3、优劣"><a href="#6-3-3、优劣" class="headerlink" title="6.3.3、优劣"></a>6.3.3、优劣</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>Reactor<ol><li><font color='orange'>Reactor实现相对简单，对于耗时短的处理场景处理高效；</font></li><li><font color='orange'>操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性；</font></li><li><font color='orange'>事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁；</font></li><li><font color='orange'>事务分离：将与应用无关的多路分解、分配机制 和 与应用相关的回调函数 分离开来。</font></li></ol></li><li>Proactor<ol><li><font color='orange'>Proactor性能更高，能够处理耗时长的并发场景；</font></li></ol></li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>Reactor</p><p><font color='orange'>Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理；</font></p></li><li><p>Proactor</p><ol><li><font color='orange'>Proactor实现逻辑复杂；</font></li><li><font color='orange'>依赖操作系统对异步的支持；</font>（目前纯异步的操作系统较少，但有优秀实现如windows IOCP，但由于windows系统用于服务器的局限性，目前应用范围较小；）</li><li><font color='orange'>Unix&#x2F;Linux系统对纯异步支持有限，应用事件驱动的主流还是通过select&#x2F;epoll来实现；</font></li></ol></li></ul><h3 id="6-3-4、适用场景"><a href="#6-3-4、适用场景" class="headerlink" title="6.3.4、适用场景"></a>6.3.4、适用场景</h3><ul><li><p>Reactor</p><p><font color='orange'>同时接收多个服务请求，且依次同步处理它们的事件驱动程序；</font></p></li><li><p>Proactor</p><p><font color='orange'>异步接收和同时处理多个服务请求的事件驱动程序；</font></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系列-CPU</title>
      <link href="/2023/07/30/cpu-zhi-shi-zong-jie/"/>
      <url>/2023/07/30/cpu-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="1、CPU"><a href="#1、CPU" class="headerlink" title="1、CPU"></a>1、CPU</h1><h2 id="1-1、认识CPU"><a href="#1-1、认识CPU" class="headerlink" title="1.1、认识CPU"></a>1.1、认识CPU</h2><h3 id="1-1-1、CPU简介"><a href="#1-1-1、CPU简介" class="headerlink" title="1.1.1、CPU简介"></a>1.1.1、CPU简介</h3><p><font color='orange'>CPU 是英文 Central Processing Unit 的首字母缩写，中文意为 中央处理器。</font></p><p><font color='orange'>CPU相当于计算机的大脑，其内部 由 数百万 至 数亿 个晶体管 组成。</font></p><p><font color='orange'>CPU是各种功能寄存器的集合体。</font></p><h3 id="1-1-2、CPU周期"><a href="#1-1-2、CPU周期" class="headerlink" title="1.1.2、CPU周期"></a>1.1.2、CPU周期</h3><p>CPU周期可描述为：<font color='orange'>首先从内存中取出指令，解码以确定其类型和操作数，接着执行之，然后取指、解码并执行下一条指令。</font>按照该方式，程序被执行完成。</p><h3 id="1-1-3、CPU指令集"><a href="#1-1-3、CPU指令集" class="headerlink" title="1.1.3、CPU指令集"></a>1.1.3、CPU指令集</h3><p><font color='orange'>每个CPU都有一套可执行的 专属指令集。</font>所以，Pentium不能执行SPARC程序，而SPARC也不能执行Pentium程序。</p><p>由于用来访问内存以得到指令或数据的时间要比执行指令花费的时间长得多，因此，<font color='orange'>所有的CPU内都有一些用来保存关键变量和临时数据的寄存器。</font></p><h3 id="1-1-4、CPU流水线"><a href="#1-1-4、CPU流水线" class="headerlink" title="1.1.4、CPU流水线"></a>1.1.4、CPU流水线</h3><p>一个CPU可以有分开的取指单元、解码单元和执行单元，当它执行指令n时，它还可以对指令n+1解码，并且读取指令n+2。这样一种机制称为流水线(pipeline)。</p><p>对于多数流水线来说，一旦一条指令被 放入 流水线中，它就必须被执行完毕，即便前一条指令是条件转移，它也必须被执行完毕。</p><p><font color='orange'>比流水线更先进的设计是一种 超标量CPU。</font></p><p>超标量CPU 中有 多个执行单元，两个或更多的指令被同时取出、解码并装入一个保持缓冲区中，直至它们执行完毕。只要有一个执行单元空闲，就检查保持缓冲区中是否还有可处理的指令，如果有，就把指令从缓冲区中移出并执行之。</p><p>这种设计存在一种隐含的作用，即<font color='orange'>程序指令经常不按顺序执行。</font>在多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同，但是，仍然有部分令人烦恼的复杂情形被强加给操作系统处理</p><h3 id="1-1-5、用户态与内核态"><a href="#1-1-5、用户态与内核态" class="headerlink" title="1.1.5、用户态与内核态"></a>1.1.5、用户态与内核态</h3><p><font color='orange'>多数CPU都有 用户态 和 内核态 两种模式。程序状态字(Program Status Word，PSW)寄存器中有一个 二进制位 控制这两种模式。</font></p><p>用户态 和 内核态 的权限也不同，区别分析如下：</p><ul><li><p><font color='orange'>内核态</font></p><p>当在内核态运行时，CPU可以执行指令集中的每一条指令，并且使用硬件的每种功能。</p></li><li><p><font color='orange'>用户态</font></p><p>在用户态下运行时，仅允许执行整个指令集的一个子集和访问所有功能的一个子集。</p></li></ul><h2 id="1-2、CPU内部组成"><a href="#1-2、CPU内部组成" class="headerlink" title="1.2、CPU内部组成"></a>1.2、CPU内部组成</h2><p>CPU和内存 是由 许多晶体管组成的【电子部件】，通常称为 IC(Integrated Circuit，集成电路)。从功能上来说，CPU内部由【寄存器、控制器、运算器、时钟】四个部分构成，各部分之间通过 电流信号 相互连通。</p><h3 id="1-2-1、寄存器"><a href="#1-2-1、寄存器" class="headerlink" title="1.2.1、寄存器"></a>1.2.1、寄存器</h3><h4 id="1-2-1-1、寄存器简介"><a href="#1-2-1-1、寄存器简介" class="headerlink" title="1.2.1.1、寄存器简介"></a>1.2.1.1、寄存器简介</h4><p><font color='orange'>寄存器 中存储的是 指令 和 数据。数据分为 用于运算的数值 和 表示内存地址的数值 两种。</font></p><p>寄存器特点如下：</p><ol><li>不同类型的CPU，其内部寄存器的数量、种类 以及 寄存器存储的数值范围 都不相同。</li><li>CPU中每个寄存器的功能都不同。</li><li>数据种类不同，存储该数据的寄存器也不同。</li></ol><h4 id="1-2-1-2、寄存器分类"><a href="#1-2-1-2、寄存器分类" class="headerlink" title="1.2.1.2、寄存器分类"></a>1.2.1.2、寄存器分类</h4><p>根据功能不同，寄存器可大致分为以下八种：</p><ol><li><font color='orange'>累加寄存器(accumulator register)</font>：存储 运算数据 和 运算后数据。</li><li><font color='orange'>标志寄存器(flag register)</font>：存储 运算处理后的 CPU状态。</li><li><font color='orange'>程序计数器(program counter)</font>：存储 下一条指令所在内存的 地址。</li><li><font color='orange'>基址寄存器(base register)</font>：存储 数据内存的 起始地址。</li><li><font color='orange'>变址寄存器(index register)</font>：存储 基址寄存器的 相对地址。</li><li><font color='orange'>通用寄存器(general purpose register)</font>：存储 任意数据。</li><li><font color='orange'>指令寄存器(instruction register)</font>：存储 指令。CPU内部使用，程序员无法干预。</li><li><font color='orange'>栈寄存器(stack register)</font>：存储 栈区域的 起始地址。</li></ol><p><font color='orange'>每一种寄存器允许存在的数量也有限制</font>，分析如下：</p><ul><li>允许一个：累加寄存器、标志寄存器、程序计数器、指令寄存器、栈寄存器；</li><li>允许多个：基址寄存器、变址寄存器、通用寄存器。</li></ul><p>除了以上寄存器外，还有一个 <font color='orange'>程序状态字（Program Status Word，PSW）寄存器。该寄存器包含了条件码位（由比较指令设置）、CPU优先级、模式（用户态或内核态），以及各种其他控制位。用户程序通常读入整个PSW，但是，只对其中的少量字段写入。在系统调用和I&#x2F;O中，PSW的作用很重要。</font></p><h3 id="1-2-2、控制器"><a href="#1-2-2、控制器" class="headerlink" title="1.2.2、控制器"></a>1.2.2、控制器</h3><p>控制器使命：把内存中的指令、数据等读入寄存器，并根据指令结果来控制整个计算机。</p><h3 id="1-2-3、运算器"><a href="#1-2-3、运算器" class="headerlink" title="1.2.3、运算器"></a>1.2.3、运算器</h3><p>运算器使命：运算 从内存 读入寄存器 的数据。</p><h3 id="1-2-4、时钟"><a href="#1-2-4、时钟" class="headerlink" title="1.2.4、时钟"></a>1.2.4、时钟</h3><p>时钟使命：负责 发出 CPU开始计时的 时钟信号。</p><blockquote><p>时钟信号 英文叫做 clock puzzle。Pentium 2GHz 表示 时钟信号的频率为 2GHz（1GHz &#x3D; 10亿次&#x2F;秒）。也就是说，时钟信号的频率越高，CPU运行速度越快。</p></blockquote><p><font color='red'>注意：有些计算机的时钟 位于 CPU外部。</font></p><h3 id="1-2-5、总结"><a href="#1-2-5、总结" class="headerlink" title="1.2.5、总结"></a>1.2.5、总结</h3><p>寄存器、控制器、运算器和时钟之间的工作方式和关系 可描述如下：</p><p><font color='orange'>程序启动后，控制器 会根据 时钟信号 从内存中 读取 指令和数据。通过 对这些 指令加以 解释和运行，运算器 会 运算这些数据，控制器 根据 运算结果 来控制计算机。</font></p><blockquote><p>控制 指的是 数据运算外的处理（主要是 数据输入输出的 时机控制）。</p></blockquote><h2 id="1-3、内存"><a href="#1-3、内存" class="headerlink" title="1.3、内存"></a>1.3、内存</h2><h3 id="1-3-1、简介"><a href="#1-3-1、简介" class="headerlink" title="1.3.1、简介"></a>1.3.1、简介</h3><p><font color='orange'>通常所说的 内存 指的是 计算机主存储器(main memory)，简称 主存。主存 通过 控制芯片 与 CPU 相连，主要负责 存储 指令和数据。</font></p><p>主存 由 可读写的元素 构成，每个字节都带有一个地址编号。CPU可以通过 该地址 读取主存中的指令和数据 和 写入数据。</p><p><font color='red'>注意：主存中存储的 指令和数据 会随着计算机的 关机 而 自动清除。</font></p><h2 id="1-4、CPU是寄存器集合体"><a href="#1-4、CPU是寄存器集合体" class="headerlink" title="1.4、CPU是寄存器集合体"></a>1.4、CPU是寄存器集合体</h2><h3 id="1-4-1、简介"><a href="#1-4-1、简介" class="headerlink" title="1.4.1、简介"></a>1.4.1、简介</h3><p>CPU四个组成部分中，需要重点了解 寄存器，其余三个可不用太过关注。因为 程序是把寄存器 作为对象 来描述的。</p><h3 id="1-4-2、汇编与反汇编"><a href="#1-4-2、汇编与反汇编" class="headerlink" title="1.4.2、汇编与反汇编"></a>1.4.2、汇编与反汇编</h3><p><font color='orange'>汇编语言 采用 助记符(memonic) 来编写程序，每一个原本是 电器信号 的机器语言指令 都会有一个 与其相应的 助记符，助记符通常是 指令功能的英语单词的简写。</font>例如 mov 和 add 分别是数据的 存储(move) 和 相加(addition) 的简写。</p><p>汇编语言 和 机器语言 基本上是 一一对应。</p><ul><li><font color='orange'>汇编</font>：将 汇编语言编写的程序 转化成 机器语言 的过程 称为 汇编。</li><li><font color='orange'>反汇编</font>：将 机器语言程序 转化成 汇编语言程序 的过程 称为 反汇编。</li></ul><p><font color='red'>注意：汇编语言 是 80386以上的CPU 所使用的语言。</font></p><p>汇编示例程序如下所示：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov eax, dword ptr [ebp-8]     ; 把 数值 从内存 复制到 eaxadd eax, dword ptr [ebp-0Ch]   ; exa的数值 和 内存数值 相加mov dword ptr [ebp-4], eax     ; 把 eax的数值（上一步计算结果）存储在内存中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例代码解析如下：</p><ul><li><font color='orange'>eax</font>：表示 累加寄存器。</li><li><font color='orange'>ebp</font>：表示 基址寄存器。</li></ul><h3 id="1-4-3、程序计数器"><a href="#1-4-3、程序计数器" class="headerlink" title="1.4.3、程序计数器"></a>1.4.3、程序计数器</h3><p>对于 123 和 456 两个数值相加，内存内容模型如下图所示：</p><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210808233333149.png" alt="image-20210808233333149"></p><p><font color='orange'>存储 指令和数据 的内存 是通过 地址 来划分。</font>一个命令和数据 通常被存储于 多个地址上，但为了便于说明，上图中把 指令、数据 分配到了一个地址中。</p><p>程序执行过程中，内存内容变化描述如下：</p><p><font color='orange'>地址0100 是程序运行的开始位置。Windows等操作系统 把 程序 从硬盘复制到内存后，会将 程序计数器 设定为0100，然后程序开始运行。CPU每执行一个指令，程序计数器的值 就会自动加 1。</font></p><h3 id="1-4-4、条件分支和循环机制"><a href="#1-4-4、条件分支和循环机制" class="headerlink" title="1.4.4、条件分支和循环机制"></a>1.4.4、条件分支和循环机制</h3><p><font color='orange'>程序的流程分为 顺序执行、条件分支和循环 三种。</font></p><ul><li><font color='orange'>顺序执行</font>：按照 地址内容的顺序 执行指令。</li><li><font color='orange'>条件分支</font>：根据条件 执行 任意地址的 指令。</li><li><font color='orange'>循环</font>：重复执行同一地址的指令。</li></ul><p><font color='orange'>条件分支 和 循环 中使用的跳转指令，会参照 当前执行的运算结果 来判断是否跳转。</font></p><p><font color='orange'>无论当前 累加寄存器运算结果 是负数、零还是正数，标志寄存器都会将其保存。</font></p><p><font color='orange'>CPU运算时，标志寄存器 的数值 会根据 运算结果 自动设定。条件分支 在跳转指令前 会进行 比较运算。是否跳转指令，则由CPU 参考 寄存器数值 后进行判断。运行结果的正、零、负三种状态由标志寄存器的三个位来表示。</font></p><ol><li>第一字节位为1时，表示 正数。</li><li>第二字节位为1时，表示 零。</li><li>第三字节位为1时，表示 负数。</li></ol><h3 id="1-4-5、函数调用"><a href="#1-4-5、函数调用" class="headerlink" title="1.4.5、函数调用"></a>1.4.5、函数调用</h3><h4 id="1-4-5-1、简介"><a href="#1-4-5-1、简介" class="headerlink" title="1.4.5.1、简介"></a>1.4.5.1、简介</h4><p><font color='orange'>函数调用 一般是通过 把程序计数器的值 设定成 函数的存储地址 来实现。</font></p><p><font color='orange'>函数调用 需要 在完成函数内部处理后，使得处理流程再返回到函数调用点。</font></p><p><font color='orange'>函数的 调用原点 和 被调用函数地址 之间的数据传递，可以通过 内存 或 寄存器 来实现。</font></p><h4 id="1-4-5-2、调用指令"><a href="#1-4-5-2、调用指令" class="headerlink" title="1.4.5.2、调用指令"></a>1.4.5.2、调用指令</h4><p><font color='orange'>函数调用使用的是 call指令，而不是 跳转指令。</font></p><p>在将 函数入口地址 设定到 程序计数器 之前，call指令 会把 调用函数后要执行的 指令地址 存储在 名为栈的主内存。函数处理完毕后，再通过 函数出口 来执行 return命令。return命令 功能是 把保存在栈中的地址 设定到 程序计数器中。</p><h3 id="1-4-6、CPU可执行的指令"><a href="#1-4-6、CPU可执行的指令" class="headerlink" title="1.4.6、CPU可执行的指令"></a>1.4.6、CPU可执行的指令</h3><p>按照功能划分，可将CPU能执行的机器语言指令 分为以下几种：</p><ul><li><font color='orange'>数据转送指令</font>：寄存器和内存、内存和内存、寄存器和外围设备 之间的 数据读写操作。</li><li><font color='orange'>运算指令</font>：使用 累加寄存器 执行算术运算、逻辑运算、比较运算 和 移位运算。</li><li><font color='orange'>跳转指令</font>：实现 条件分支、循环、强制跳转。</li><li><font color='orange'>call&#x2F;return指令</font>：函数调用 &#x2F; 返回调用前的地址。</li></ul><p>CPU可以执行的 指令 非常少。虽然编写的程序看起来非常复杂，但CPU实际处理很简单。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-theme-matery主题使用指南</title>
      <link href="/2023/07/29/hexo-theme-matery-zhu-ti-shi-yong-zhi-nan/"/>
      <url>/2023/07/29/hexo-theme-matery-zhu-ti-shi-yong-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-theme-matery"><a href="#hexo-theme-matery" class="headerlink" title="hexo-theme-matery"></a>hexo-theme-matery</h1><p><a href="http://hits.dwyl.io/blinkfox/hexo-theme-matery"><img src="http://hits.dwyl.io/blinkfox/hexo-theme-matery.svg" alt="HitCount"></a> <a href="https://gitter.im/hexo-theme-matery/Lobby?utm_source=badge"><img src="https://img.shields.io/gitter/room/blinkfox/hexo-theme-matery.svg" alt="Gitter"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/issues"><img src="https://img.shields.io/github/issues/blinkfox/hexo-theme-matery.svg" alt="GitHub issues"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/blob/master/LICENSE"><img src="https://img.shields.io/github/license/blinkfox/hexo-theme-matery.svg" alt="GitHub license"></a> <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master"><img src="https://img.shields.io/badge/downloads-master-green.svg" alt="Download"></a> <a href="http://hexo.io/"><img src="https://img.shields.io/badge/hexo-%3E%3D%205.0.0-blue.svg" alt="Hexo Version"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/network"><img src="https://img.shields.io/github/forks/blinkfox/hexo-theme-matery.svg" alt="GitHub forks"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/stargazers"><img src="https://img.shields.io/github/stars/blinkfox/hexo-theme-matery.svg" alt="GitHub stars"></a></p><p><a href="README.md">🇺🇸English Document</a> | <a href="http://blinkfox.com/">国内访问示例 (http://blinkfox.com)</a> | <a href="https://blinkfox.github.io/">Github 部署演示示例 (https://blinkfox.github.io)</a> </p><p>QQ 交流群1（已满）: <a href="https://jq.qq.com/?_wv=1027&k=5zMDYHT"><code>926552981</code></a> | QQ 交流群2（已满）: <a href="https://jq.qq.com/?_wv=1027&k=53q2Ayp"><code>971887688</code></a> | QQ 交流群3（推荐）: <a href="https://qm.qq.com/cgi-bin/qm/qr?k=fC1-kU-_aTn4q-JQq4GsYKr4WcKdgfGa&jump_from=webapi"><code>670694035</code></a></p><blockquote><p>这是一个采用 <code>Material Design</code> 和响应式设计的 Hexo 博客主题。</p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>简单漂亮，文章内容美观易读</li><li><a href="https://material.io/">Material Design</a> 设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>首页轮播文章及每天动态切换 <code>Banner</code> 图片</li><li>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</li><li>时间轴式的归档页</li><li><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持文章置顶和文章打赏</li><li>支持 <code>MathJax</code></li><li>支持中文繁简转换</li><li><code>TOC</code> 目录</li><li>可设置复制文章内容时追加版权信息</li><li>可设置阅读文章时做密码验证</li><li><a href="https://gitalk.github.io/">Gitalk</a>、<a href="https://imsun.github.io/gitment/">Gitment</a>、<a href="https://valine.js.org/">Valine</a> 和 <a href="https://disqus.com/">Disqus</a> 评论模块（推荐使用 <code>Gitalk</code>）</li><li>集成了<a href="http://busuanzi.ibruce.info/">不蒜子统计</a>、谷歌分析（<code>Google Analytics</code>）和文章字数统计等功能</li><li>支持在首页的音乐播放和视频播放功能</li><li>支持<code>emoji</code>表情，用<code>markdown emoji</code>语法书写直接生成对应的能<strong>跳跃</strong>的表情。</li><li>支持 <a href="http://www.daovoice.io/">DaoVoice</a>、<a href="https://www.tidio.com/">Tidio</a> 在线聊天功能。</li></ul><h2 id="贡献者"><a href="#贡献者" class="headerlink" title="贡献者"></a>贡献者</h2><p>感谢下面列出的贡献者，没有他们，hexo-theme-matery 不会这么完美。</p><ul><li><a href="https://github.com/HarborZeng">@HarborZeng</a></li><li><a href="https://github.com/shw2018">@shw2018</a></li><li><a href="https://github.com/L1cardo">@L1cardo</a></li><li><a href="https://github.com/Five-great">@Five-great</a></li></ul><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>本主题<strong>推荐你使用 Hexo 5.0.0 及以上的版本</strong>。如果，你已经有一个自己的 <a href="https://hexo.io/zh-cn/">Hexo</a> 博客了，建议你将 Hexo 升级到最新稳定的版本。</p><p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到你 Hexo 的 <code>themes</code> 文件夹中即可。</p><p>当然你也可以在你的 <code>themes</code> 文件夹下使用 <code>git clone</code> 命令来下载:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/blinkfox/hexo-theme-matery.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的  <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml-文件的其它修改建议"><a href="#config-yml-文件的其它修改建议" class="headerlink" title="_config.yml 文件的其它修改建议:"></a><code>_config.yml</code> 文件的其它修改建议:</h4><ul><li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"tags"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> tags<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 18:23:38</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"about"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> about<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建留言板-contact-页（可选的）"><a href="#新建留言板-contact-页（可选的）" class="headerlink" title="新建留言板 contact 页（可选的）"></a>新建留言板 contact 页（可选的）</h3><p><code>contact</code> 页是用来展示<strong>留言板</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>contact/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"contact"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/contact/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> contact<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"contact"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"contact"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：本留言板功能依赖于第三方评论系统，请<strong>激活</strong>你的评论系统才有效果。并且在主题的 <code>_config.yml</code> 文件中，第 <code>19</code> 至 <code>21</code> 行的“<strong>菜单</strong>”配置，取消关于留言板的注释即可。</p></blockquote><h3 id="新建友情链接-friends-页（可选的）"><a href="#新建友情链接-friends-页（可选的）" class="headerlink" title="新建友情链接 friends 页（可选的）"></a>新建友情链接 friends 页（可选的）</h3><p><code>friends</code> 页是用来展示<strong>友情链接</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"friends"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> friends<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-12-12 21:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">&#123;</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/1_qq_27922023.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"码酱"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"我不是大佬，只是在追寻大佬的脚步"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://luokangyuan.com/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/4027734.jpeg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"闪烁之狐"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://blinkfox.github.io/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/avatar.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ja_rome"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"平凡的脚步也可以走出伟大的行程"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://me.csdn.net/jlh912008548"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建-404-页"><a href="#新建-404-页" class="headerlink" title="新建 404 页"></a>新建 404 页</h3><p>如果在你的博客 <code>source</code> 目录下还没有 <code>404.md</code> 文件，那么你就需要新建一个。编辑你刚刚新建的页面文件 <code>/source/404.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> <span class="token number">404</span><span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"404"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"404"</span><span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"Oops～，我崩溃了！找不到你想要的页面 :("</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="菜单导航配置"><a href="#菜单导航配置" class="headerlink" title="菜单导航配置"></a>菜单导航配置</h3><h4 id="配置基本菜单导航的名称、路径url和图标icon"><a href="#配置基本菜单导航的名称、路径url和图标icon" class="headerlink" title="配置基本菜单导航的名称、路径url和图标icon."></a>配置基本菜单导航的名称、路径url和图标icon.</h4><p>1.菜单导航名称可以是中文也可以是英文(如：<code>Index</code>或<code>主页</code>)<br>2.图标icon 可以在<a href="https://fontawesome.com/icons">Font Awesome</a> 中查找   </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">menu</span><span class="token punctuation">:</span>  <span class="token key atrule">Index</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>home  <span class="token key atrule">Tags</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /tags    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>tags  <span class="token key atrule">Categories</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /categories    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>bookmark  <span class="token key atrule">Archives</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /archives    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>archive  <span class="token key atrule">About</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /about    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>user<span class="token punctuation">-</span>circle  <span class="token key atrule">Friends</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /friends    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>address<span class="token punctuation">-</span>book<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二级菜单配置方法"><a href="#二级菜单配置方法" class="headerlink" title="二级菜单配置方法"></a>二级菜单配置方法</h4><p>如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作</p><ol><li>在需要添加二级菜单的一级菜单下添加<code>children</code>关键字(如:<code>About</code>菜单下添加<code>children</code>)     </li><li>在<code>children</code>下创建二级菜单的 名称name,路径url和图标icon.      </li><li>注意每个二级菜单模块前要加 <code>-</code>.     </li><li>注意缩进格式</li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">menu</span><span class="token punctuation">:</span>  <span class="token key atrule">Index</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>home  <span class="token key atrule">Tags</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /tags    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>tags  <span class="token key atrule">Categories</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /categories    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>bookmark  <span class="token key atrule">Archives</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /archives    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>archive  <span class="token key atrule">About</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /about    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>user<span class="token punctuation">-</span>circle<span class="token punctuation">-</span>o  <span class="token key atrule">Friends</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /friends    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>address<span class="token punctuation">-</span>book  <span class="token key atrule">Medias</span><span class="token punctuation">:</span>    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>list    <span class="token key atrule">children</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Music        <span class="token key atrule">url</span><span class="token punctuation">:</span> /music        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>music      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Movies        <span class="token key atrule">url</span><span class="token punctuation">:</span> /movies        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>film      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Books        <span class="token key atrule">url</span><span class="token punctuation">:</span> /books        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>book      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Galleries        <span class="token key atrule">url</span><span class="token punctuation">:</span> /galleries        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>image<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>从 Hexo5.0 版本开始自带了 <code>prismjs</code> 代码语法高亮的支持，本主题对此进行了改造支持。</p><p>如果你的博客中曾经安装过 <code>hexo-prism-plugin</code> 的插件，那么你须要执行 <code>npm uninstall hexo-prism-plugin</code> 来卸载掉它，否则生成的代码中会有 <code>&amp;#123;</code> 和 <code>&amp;#125;</code> 的转义字符。</p><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并将 <code>prismjs.enable</code> 的值设置为 <code>true</code>，主要配置如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">auto_detect</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span>  <span class="token key atrule">wrap</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">hljs</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prismjs</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">preprocess</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主题中默认的 <code>prismjs</code> 主题是 <code>Tomorrow Night</code>，如果你想定制自己的主题，可以前往 <a href="https://prismjs.com/download.html">prismjs 下载页面</a> 定制下载自己喜欢的主题 <code>css</code> 文件，然后将此 css 主题文件取名为 <code>prism.css</code>，替换掉 <code>hexo-theme-matery</code> 主题文件夹中的 <code>source/libs/prism/prism.css</code> 文件即可。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="中文链接转拼音（建议安装）"><a href="#中文链接转拼音（建议安装）" class="headerlink" title="中文链接转拼音（建议安装）"></a>中文链接转拼音（建议安装）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i hexo-permalink-pinyin <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment"># default: '-'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><h3 id="文章字数统计插件（建议安装）"><a href="#文章字数统计插件（建议安装）" class="headerlink" title="文章字数统计插件（建议安装）"></a>文章字数统计插件（建议安装）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i <span class="token parameter variable">--save</span> hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">postInfo</span><span class="token punctuation">:</span>  <span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">update</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">wordCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置文章字数统计为 true.</span>  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置站点文章总字数统计为 true.</span>  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 阅读时长.</span>  <span class="token key atrule">readCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 阅读次数.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加emoji表情支持（可选的）"><a href="#添加emoji表情支持（可选的）" class="headerlink" title="添加emoji表情支持（可选的）"></a>添加emoji表情支持（可选的）</h3><p>本主题新增了对<code>emoji</code>表情的支持，使用到了 <a href="https://npm.taobao.org/package/hexo-filter-github-emojis">hexo-filter-github-emojis</a> 的 Hexo 插件来支持 <code>emoji</code>表情的生成，把对应的<code>markdown emoji</code>语法（<code>::</code>,例如：<code>:smile:</code>）转变成会跳跃的<code>emoji</code>表情，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-filter-github-emojis <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">githubEmojis</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">className</span><span class="token punctuation">:</span> github<span class="token punctuation">-</span>emoji  <span class="token key atrule">inject</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">styles</span><span class="token punctuation">:</span>  customEmojis<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后就可以在文章中对应位置看到你用<code>emoji</code>语法写的表情了。</p><h3 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">feed</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> atom  <span class="token key atrule">path</span><span class="token punctuation">:</span> atom.xml  <span class="token key atrule">limit</span><span class="token punctuation">:</span> <span class="token number">20</span>  <span class="token key atrule">hub</span><span class="token punctuation">:</span>  <span class="token key atrule">content</span><span class="token punctuation">:</span>  <span class="token key atrule">content_limit</span><span class="token punctuation">:</span> <span class="token number">140</span>  <span class="token key atrule">content_limit_delim</span><span class="token punctuation">:</span> <span class="token string">' '</span>  <span class="token key atrule">order_by</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>date<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h3 id="添加-DaoVoice-在线聊天功能（可选的）"><a href="#添加-DaoVoice-在线聊天功能（可选的）" class="headerlink" title="添加 DaoVoice 在线聊天功能（可选的）"></a>添加 <a href="http://www.daovoice.io/">DaoVoice</a> 在线聊天功能（可选的）</h3><p>前往 <a href="http://www.daovoice.io/">DaoVoice</a> 官网注册并且获取 <code>app_id</code>，并将 <code>app_id</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="添加-Tidio-在线聊天功能（可选的）"><a href="#添加-Tidio-在线聊天功能（可选的）" class="headerlink" title="添加 Tidio 在线聊天功能（可选的）"></a>添加 <a href="https://www.tidio.com/">Tidio</a> 在线聊天功能（可选的）</h3><p>前往 <a href="https://www.tidio.com/">Tidio</a> 官网注册并且获取 <code>Public Key</code>，并将 <code>Public Key</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="添加中文繁简转换"><a href="#添加中文繁简转换" class="headerlink" title="添加中文繁简转换"></a>添加中文繁简转换</h3><p>在主题的 <code>_config.yml</code> 文件中，开启 translate 为 enable。</p><blockquote><p>开启中文繁简转换如下修改。默认不开启。<br>实例演示： <a href="https://blog.17lai.site/">繁简转换</a> 底下 footer 栏</p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">translate</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱等的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;% if (theme.socialLink.github) &#123; %>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&lt;%= theme.socialLink.github %><span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span> <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fab fa-github<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>&lt;% &#125; %><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fab fa-facebook</code></li><li>Twitter: <code>fab fa-twitter</code></li><li>Google-plus: <code>fab fa-google-plus</code></li><li>Linkedin: <code>fab fa-linkedin</code></li><li>Tumblr: <code>fab fa-tumblr</code></li><li>Medium: <code>fab fa-medium</code></li><li>Slack: <code>fab fa-slack</code></li><li>Sina Weibo: <code>fab fa-weibo</code></li><li>Wechat: <code>fab fa-weixin</code></li><li>QQ: <code>fab fa-qq</code></li><li>Zhihu: <code>fab fa-zhihu</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的 <code>Font Awesome</code> 版本为 <code>5.11.0</code>。</p></blockquote><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="配置音乐播放器（可选的）"><a href="#配置音乐播放器（可选的）" class="headerlink" title="配置音乐播放器（可选的）"></a>配置音乐播放器（可选的）</h3><p>要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活music配置即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 是否在首页显示音乐</span><span class="token key atrule">music</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">title</span><span class="token punctuation">:</span>         <span class="token comment"># 非吸底模式有效</span>    <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">show</span><span class="token punctuation">:</span> 听听音乐  <span class="token key atrule">server</span><span class="token punctuation">:</span> netease   <span class="token comment"># require music platform: netease, tencent, kugou, xiami, baidu</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> playlist    <span class="token comment"># require song, playlist, album, search, artist</span>  <span class="token key atrule">id</span><span class="token punctuation">:</span> <span class="token number">503838841</span>     <span class="token comment"># require song id / playlist id / album id / search keyword</span>  <span class="token key atrule">fixed</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>      <span class="token comment"># 开启吸底模式</span>  <span class="token key atrule">autoplay</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>   <span class="token comment"># 是否自动播放</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'#42b983'</span>  <span class="token key atrule">loop</span><span class="token punctuation">:</span> <span class="token string">'all'</span>       <span class="token comment"># 音频循环播放, 可选值: 'all', 'one', 'none'</span>  <span class="token key atrule">order</span><span class="token punctuation">:</span> <span class="token string">'random'</span>   <span class="token comment"># 音频循环顺序, 可选值: 'list', 'random'</span>  <span class="token key atrule">preload</span><span class="token punctuation">:</span> <span class="token string">'auto'</span>   <span class="token comment"># 预加载，可选值: 'none', 'metadata', 'auto'</span>  <span class="token key atrule">volume</span><span class="token punctuation">:</span> <span class="token number">0.7</span>       <span class="token comment"># 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</span>  <span class="token key atrule">listFolded</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token comment"># 列表默认折叠</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>server</code>可选<code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），</p><p><code>baidu</code>（百度音乐）。</p><p><code>type</code>可选<code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）</p><p><code>id</code>获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，<code>playlist</code>的<code>id</code></p><p>即为这串数字。</p></blockquote><h3 id="添加note"><a href="#添加note" class="headerlink" title="添加note"></a>添加note</h3><blockquote><p><a href="https://blog.17lai.site/posts/cf0f47fd/#tag-note">演示</a></p></blockquote><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><pre class="line-numbers language-none"><code class="language-none">&#123;% note [class] [no-icon] [summary] %&#125;Any content (support inline tags too).&#123;% endnote %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>[class]</code> : <em>Optional parameter.</em> Supported values: default | primary | success | info | warning | danger.</li><li><code>[no-icon]</code> : <em>Optional parameter.</em> Disable icon in note.</li><li><code>[summary]</code> : <em>Optional parameter.</em> Optional summary of the note.</li></ul><p>All parameters are optional.</p><h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><pre class="line-numbers language-none"><code class="language-none">&#123;% note %&#125;#### Header(without define class style)&#123;% endnote %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加button"><a href="#添加button" class="headerlink" title="添加button"></a>添加button</h3><blockquote><p><a href="https://blog.17lai.site/posts/cf0f47fd/#tag-button">演示</a></p></blockquote><h4 id="Usage-1"><a href="#Usage-1" class="headerlink" title="Usage"></a>Usage</h4><pre class="line-numbers language-none"><code class="language-none">&#123;% button url, text, icon [class], [title] %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>or</p><pre class="line-numbers language-none"><code class="language-none">&#123;% btn url, text, icon [class], [title] %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>url</code> : Absolute or relative path to URL.</li><li><code>text</code> : Button text. Required if no icon specified.</li><li><code>icon</code> : Font Awesome icon name. Required if no text specified.</li><li><code>[class]</code> : <em>Optional parameter.</em> Font Awesome class(es): <code>fa-fw</code> | <code>fa-lg</code> | <code>fa-2x</code> | <code>fa-3x</code> | <code>fa-4x</code> | <code>fa-5x</code></li><li><code>[title]</code> : <em>Optional parameter.</em> Tooltip at mouseover.</li></ul><h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><pre class="line-numbers language-none"><code class="language-none">&#123;% button #, Text %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><code>false</code></td><td>隐藏文章，如果<code>hide</code>值为<code>true</code>，则文章不会在首页显示</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 赵奇<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">hide</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><p><img src="http://static.blinkfox.com/matery-20181202-1.png" alt="首页"></p><p><img src="http://static.blinkfox.com/matery-20181202-2.png" alt="首页推荐文章"></p><p><img src="http://static.blinkfox.com/matery-20181202-3.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-7.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-8.png" alt="首页文章列表"></p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span><span class="token selector">.bg-color</span> <span class="token punctuation">&#123;</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right<span class="token punctuation">,</span> #4cbf30 0%<span class="token punctuation">,</span> #0f9d58 100%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token atrule"><span class="token rule">@-webkit-keyframes</span> rainbow</span> <span class="token punctuation">&#123;</span>   <span class="token comment">/* 动态切换背景颜色. */</span><span class="token punctuation">&#125;</span><span class="token atrule"><span class="token rule">@keyframes</span> rainbow</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 动态切换背景颜色. */</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.bg-cover'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'background-image'</span><span class="token punctuation">,</span> <span class="token string">'url(/medias/banner/'</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h2 id="版本变更记录"><a href="#版本变更记录" class="headerlink" title="版本变更记录"></a>版本变更记录</h2><p>参见 <a href="https://github.com/blinkfox/hexo-theme-matery/blob/master/CHANGELOG.md">CHANGELOG.md</a></p><h2 id="更多部署方式"><a href="#更多部署方式" class="headerlink" title="更多部署方式"></a>更多部署方式</h2><blockquote><p>Jsdelivr 已经被封了，这两个可以加速访问快一点</p></blockquote><h3 id="vercel-部署"><a href="#vercel-部署" class="headerlink" title="vercel 部署"></a><a href="https://blog.17lai.site/posts/5311b619/#vercel-%E9%83%A8%E7%BD%B2">vercel 部署</a></h3><h3 id="cloudflare-Pages-部署"><a href="#cloudflare-Pages-部署" class="headerlink" title="cloudflare Pages 部署"></a><a href="https://blog.17lai.site/posts/5311b619/#cloudflare-Pages-%E9%83%A8%E7%BD%B2">cloudflare Pages 部署</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> hexo主题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
