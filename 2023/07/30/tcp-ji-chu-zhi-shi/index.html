<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="计算机系列-TCP基础知识, 豪哥博客">
    <meta name="description" content="豪哥个人博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>计算机系列-TCP基础知识 | 豪哥博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">豪哥博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">豪哥博客</div>
        <div class="logo-desc">
            
            豪哥个人博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/11.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">计算机系列-TCP基础知识</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">
                                <span class="chip bg-color">网络协议</span>
                            </a>
                        
                            <a href="/tags/TCP/">
                                <span class="chip bg-color">TCP</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="post-category">
                                计算机
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-07-30
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    20.6k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="1、必备知识"><a href="#1、必备知识" class="headerlink" title="1、必备知识"></a>1、必备知识</h1><h2 id="1-1、协议分类"><a href="#1-1、协议分类" class="headerlink" title="1.1、协议分类"></a>1.1、协议分类</h2><ul>
<li><font color='orange'>IP：Internet Protocol－⽹络协议。</font></li>
<li><font color='orange'>TCP：Transmission Control Protocol－传输控制协议。</font></li>
</ul>
<p>四层协议，五层协议和七层协议的关系如下：</p>
<ul>
<li><p><font color='orange'>OSI七层协议模型包括</font>：应⽤层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、⽹络层（Network）、数据链路层（Data Link）、物理层（Physical）。</p>
</li>
<li><p><font color='orange'>TCP&#x2F;IP四层体系结构包括</font>：应⽤层、运输层、⽹际层和⽹络接⼝层。</p>
</li>
</ul>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200908153007750.png" alt="image-20200908153007750"></p>
<blockquote>
<p>注：五层协议体系结构只是为了介绍⽹络原理⽽设计，实际应⽤还是 TCP&#x2F;IP 四层体系结构。</p>
</blockquote>
<h2 id="1-2、OSI七层协议"><a href="#1-2、OSI七层协议" class="headerlink" title="1.2、OSI七层协议"></a>1.2、OSI七层协议</h2><ol>
<li><font color='orange'>物理层（Physical）</font>：网线、网卡、集线器、调制解调器；</li>
<li><font color='orange'>数据链路层（Data Link）</font>：网桥、交换机、基于mac地址的物理寻址；例如以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP。</li>
<li><font color='orange'>⽹络层（Network）</font>：路由器；例如IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、 X.25。</li>
<li><font color='orange'>传输层（Transport）</font>：TLS协议、SSL协议；例如TCP、UDP、RTP、SCTP、SPX、ATP、IL。</li>
<li><font color='orange'>会话层（Session）</font>：例如ASAP、TLS、SSH、ISO 8327 &#x2F; CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets。</li>
<li><font color='orange'>表示层（Presentation）</font>：例如XDR、ASN.1、SMB、AFP、NCP。</li>
<li><font color='orange'>应⽤层（Application）</font>：例如HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP。</li>
</ol>
<blockquote>
<p> 传输层安全性协议（英语：Transport Layer Security，缩写TLS）的前身是安全套接层（Secure Sockets Layer，缩写作SSL）协议。该协议主要为互联网通信提供安全及数据完整性保障。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。</font></p>
<p> TLS协议采用主从式架构模型，用于在两个应用程序间透过网络创建安全连线，防止在交换数据时被窃听及篡改。</p>
</blockquote>
<h2 id="1-3、TCP-IP四层协议"><a href="#1-3、TCP-IP四层协议" class="headerlink" title="1.3、TCP&#x2F;IP四层协议"></a>1.3、TCP&#x2F;IP四层协议</h2><p>TCP&#x2F;IP 被分为 4 层，每层的 任务 和 ⼯作⽅式 都不同，每层封装上层数据的⽅式也不同：</p>
<ol>
<li><font color='orange'>应⽤层</font>：应⽤程序通过该层访问⽹络，该层协议有HTTP、FTP、TFTP、SMTP、SNMP、DNS 和 TELNET；数据格式为数据报文。</li>
<li><font color='orange'>传输层</font>：TCP协议、UDP协议；数据格式为 数据段。</li>
<li><font color='orange'>⽹络层</font>：IP协议、ICMP协议、IGMP协议等；数据格式为 数据包。</li>
<li><font color='orange'>⽹络接⼝层</font>：ARP协议、RARP协议；该层是TCP&#x2F;IP 协议的基层，负责数据帧的发送和接收。数据格式为 数据帧和bit。</li>
</ol>
<h1 id="2、TCP深度剖析"><a href="#2、TCP深度剖析" class="headerlink" title="2、TCP深度剖析"></a>2、TCP深度剖析</h1><h2 id="2-1、TCP与UDP"><a href="#2-1、TCP与UDP" class="headerlink" title="2.1、TCP与UDP"></a>2.1、TCP与UDP</h2><ul>
<li><font color='orange'>TCP（传输控制协议）</font>：提供⾯向连接的，可靠的数据传输服务。</li>
<li><font color='orange'>UDP（⽤户数据协议）</font>：提供⽆连接的，尽最⼤努⼒的数据传输服务（不保证数据传输的可靠性）。</li>
</ul>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200908153446067.png" alt="image-20200908153446067"></p>
<h2 id="2-2、TCP-IP数据包结构"><a href="#2-2、TCP-IP数据包结构" class="headerlink" title="2.2、TCP&#x2F;IP数据包结构"></a>2.2、TCP&#x2F;IP数据包结构</h2><h3 id="2-2-1、TCP数据包结构"><a href="#2-2-1、TCP数据包结构" class="headerlink" title="2.2.1、TCP数据包结构"></a>2.2.1、TCP数据包结构</h3><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200908153709918.png" alt="image-20200908153709918"></p>
<ol>
<li>第一行：源端口2字节，目的端口2字节；</li>
</ol>
<p>   表示发送方和接收方的端口号。</p>
<ol start="2">
<li><p>第二、三行：序列号4字节，确认号4字节；</p>
<ul>
<li>序列号是指该报文段在发送方数据字节流中的位置，在TCP字节流中，每个数据字节都被编号；</li>
<li>确认号是指本机希望收到的下一个字节的序号；</li>
<li>序列号和确认号分别对应报文发送方向和相反方向的数据流；</li>
<li>报文被分解成多个报文段时，序列号就是首字节在整个报文中的偏移量，确认号指定下一个期待的字节；</li>
<li>序列号和确认号的最大表示范围均为2^32-1&#x3D;4294967295≈42.9亿；</li>
</ul>
</li>
<li><p>第四行：首部长度4位，保留6位，标志位6位，窗口大小16位；</p>
<ul>
<li><p>首部长度：指明首部共有多少行（每行4个字节），则TCP首部的最大长度为（2^4-1)*4&#x3D;60字节；</p>
</li>
<li><p>标志位：公有6位，每一项含义分别如下：</p>
<ol>
<li><font color='orange'>SYN：建立连接 - 同步序号用来发起一个连接。</font></li>
<li><font color='orange'>FIN：关闭连接 - 发端完成发送任务。</font></li>
<li><font color='orange'>ACK：响应 - 确认序号有效。</font></li>
<li><font color='orange'>PSH：有data数据传输 - 接收方尽快将这个报文段交给应用层。</font></li>
<li><font color='orange'>RST：重建连接。</font></li>
<li><font color='orange'>URG：紧急指针有效。</font></li>
</ol>
</li>
<li><p>窗口大小：即发送数据的窗口大小，告诉对方在不等待确认的情况下，可以发来多大的数据；这里表示的最大长度是2^16-1&#x3D;65535，如需要使用更大的窗口大小，需要使用选项中的窗口扩大因子选项；</p>
</li>
</ul>
</li>
<li><p>第五行：TCP校验和16位，紧急指针16位；</p>
<ul>
<li><font color='orange'>TCP校验和</font>：【待补充】</li>
<li><font color='orange'>紧急指针</font>：当URG标志为1时紧急指针才有效，紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号（即序列号到紧急指针之间的数据为紧急数据，后面的数据才是正常数据）。</li>
</ul>
</li>
<li><p>第六行开始是选项部分：每个选项的开头是1字节的kind字段，表示选项类型。</p>
</li>
</ol>
<h3 id="2-2-2、IP数据包结构"><a href="#2-2-2、IP数据包结构" class="headerlink" title="2.2.2、IP数据包结构"></a>2.2.2、IP数据包结构</h3><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200908154657846.png" alt="image-20200908154657846"></p>
<h1 id="3、TCP传输"><a href="#3、TCP传输" class="headerlink" title="3、TCP传输"></a>3、TCP传输</h1><h2 id="3-1、三次握手"><a href="#3-1、三次握手" class="headerlink" title="3.1、三次握手"></a>3.1、三次握手</h2><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200908154817025.png" alt="image-20200908154817025"></p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200908154934881.png" alt="image-20200908154934881"></p>
<h2 id="3-2、四次挥手"><a href="#3-2、四次挥手" class="headerlink" title="3.2、四次挥手"></a>3.2、四次挥手</h2><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20200908155442522.png" alt="image-20200908155442522"></p>
<p> <font color='orange'>最⼤分段寿命（MSL, Maximum Segment Lifetime）表示⼀个 TCP 分段可以存在于互联⽹系统中的最⼤时间，由 TCP 实现，超出这个寿命的分⽚都会被丢弃。</font></p>
<p> <font color='orange'>centOS 上，它被定义为 30s，我们可以通过<code>/proc/sys/net/ipv4/tcp_fin_timeout</code>这个⽂件查看和修改这个值。</font></p>
<blockquote>
<p><font color='orange'>Socket：套接字，ip + port : ip + port。</font></p>
<p><font color='orange'>每台主机可以有65535个连接。</font></p>
</blockquote>
<h2 id="3-3、总结"><a href="#3-3、总结" class="headerlink" title="3.3、总结"></a>3.3、总结</h2><h3 id="3-3-1、为何需要三次握手？"><a href="#3-3-1、为何需要三次握手？" class="headerlink" title="3.3.1、为何需要三次握手？"></a>3.3.1、为何需要三次握手？</h3><p> A-&gt;B    —&gt;     B-&gt;A    —&gt;     A-&gt;B</p>
<p> <font color='orange'>因为需要考虑连接时的丢包问题。</font></p>
<p>如果只握⼿两次，即 B响应A后就开始收发数据。假如此时B响应A的确认包在传送过程中丢失了，且A因为⼀直无法收到B的确认包可能会关掉⾃⼰的socket，而B认为A一直在就会一直发送资源，最终会⽩⽩浪费掉B的资源。如果存在三次握⼿，就可避免上述问题。因为B在⼀段时间内没有收到A的确认ack报⽂，那么就会重发SYN报⽂段给A，A收到重发报⽂段后会再次发送确认ack报⽂给B。</p>
<h3 id="3-3-2、为何握手要三次，而挥手要四次？"><a href="#3-3-2、为何握手要三次，而挥手要四次？" class="headerlink" title="3.3.2、为何握手要三次，而挥手要四次？"></a>3.3.2、为何握手要三次，而挥手要四次？</h3><ol>
<li><p>A -&gt; <em>FIN</em> -&gt; B</p>
</li>
<li><p>B -&gt; <em>ACK</em> -&gt; A</p>
<p>……….数据传输………</p>
</li>
<li><p>B -&gt; <em>FIN</em> -&gt; A</p>
</li>
<li><p>A -&gt; <em>ACK</em> -&gt; B</p>
</li>
<li><p>B收到A的回应后立即关闭，A则等待2MSL，若期间无任何动静再立即关闭。</p>
</li>
</ol>
<p><font color='orange'>因为只有在客户端和服务端都没有数据要发送时才能断开TCP。</font>A发送FIN报⽂时只能证明A没有数据要发了，服务端B是否还有数据发给客户端A是不知道的。⽽服务端B收到客户端A的FIN报⽂后只能先回复客户端A⼀个确认报⽂我已收到，但我服务端B还有⼀些数据没发完，等这些数据发完了服务端B才能给客户端A发FIN报⽂(所以不能⼀次性将确认报⽂和FIN报⽂发给客户端，就是这⾥多出来了⼀次)。</p>
<h3 id="3-3-3、为何客户端第四次发送确认报文后还要等2MSL后才关闭？"><a href="#3-3-3、为何客户端第四次发送确认报文后还要等2MSL后才关闭？" class="headerlink" title="3.3.3、为何客户端第四次发送确认报文后还要等2MSL后才关闭？"></a>3.3.3、为何客户端第四次发送确认报文后还要等2MSL后才关闭？</h3><p> <font color='orange'>因为同样是考虑到丢包问题。</font></p>
<p>第4次挥⼿报⽂发过之后，A并不知道B是否接到⾃⼰的ACK。但是A发送ACK后只有两种结果：</p>
<ol>
<li><font color='orange'>如果B没有收到A发送的ACK，B会超时重传FIN，那么A再次接到重传FIN，进而会再次发送ACK。</font></li>
<li><font color='orange'>如果B收到了A发送的ACK，被动关闭的B⽆需任何wait time，直接释放资源。也不会再发任何消息，包括ACK。</font></li>
</ol>
<p>所以A要取这两种情况等待时间的最⼤值，以应对最坏情况发⽣，<font color='orange'>最坏情况就是第⼀种情况：去向ACK消息最⼤存活时间（MSL) + 来向FIN消息最⼤存活时间(MSL)，刚好是2MSL( Maximum Segment Life)。等待2MSL时间，A就可以放⼼地释放TCP占⽤的资源、端⼝号，此时可以使⽤该端⼝号连接任何服务器。</font></p>
<p>还有⼀个重要概念——端⼝重⽤。</p>
<blockquote>
<p> <font color='orange'>每个MSL是2分钟，2个MSL就是4分钟。MSL是<code>maximium segment lifetime</code>的缩写，意为最长报文寿命。这个时间由官方RFC协议规定。</font></p>
</blockquote>
<h3 id="3-3-4、若已经建立连接，但客户端突然出现故障，那如何解决？"><a href="#3-3-4、若已经建立连接，但客户端突然出现故障，那如何解决？" class="headerlink" title="3.3.4、若已经建立连接，但客户端突然出现故障，那如何解决？"></a>3.3.4、若已经建立连接，但客户端突然出现故障，那如何解决？</h3><p> <font color='orange'>因 TCP 有⼀个保活计时器，故 客户端出现故障时不会导致服务器⼀直等下去。</font></p>
<p>服务器每次收到客户端请求后都会重新复位计时器，时间通常为2⼩时，若两⼩时后依然没有收到客户端任何数据，则服务器就会发送探测报⽂段来进行判断。以每75秒发送⼀次连续发送10次后依然无响应，则服务器就会认为客户端出了故障，然后关闭连接。</p>
<h1 id="4、TCP可靠传输"><a href="#4、TCP可靠传输" class="headerlink" title="4、TCP可靠传输"></a>4、TCP可靠传输</h1><p><font color='orange'>TCP 是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</font></p>
<h2 id="4-1、重传机制"><a href="#4-1、重传机制" class="headerlink" title="4.1、重传机制"></a>4.1、重传机制</h2><p> <font color='orange'>TCP 实现 可靠传输 的⽅式之⼀就是 通过序列号与确认应答。</font></p>
<p>TCP传输中，主机B在收到主机A的请求后会发送响应给主机A。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417191856726.png" alt="image-20210417191856726"></p>
<p>在错综复杂的⽹络中，顺利进行数据传输是不一定成立的，所以  <font color='orange'>TCP 针对数据包丢失的情况，会⽤重传机制解决。</font> </p>
<p>常⻅重传机制有：</p>
<ol>
<li><font color='orange'>超时重传</font></li>
<li><font color='orange'>快速重传</font></li>
<li><font color='orange'>SACK</font></li>
<li><font color='orange'>D-SACK</font></li>
</ol>
<h3 id="5-1-1、超时重传"><a href="#5-1-1、超时重传" class="headerlink" title="5.1.1、超时重传"></a>5.1.1、超时重传</h3><h4 id="何为超时重传"><a href="#何为超时重传" class="headerlink" title="何为超时重传"></a>何为超时重传</h4><p><font color='orange'>在发送数据时，设定⼀个定时器，当超过指定的时间后，没有收到对⽅ ACK 确认应答报⽂时，就会重发该数据，也就是我们常说的超时重传。</font></p>
<h4 id="触发超时重传"><a href="#触发超时重传" class="headerlink" title="触发超时重传"></a>触发超时重传</h4><p>TCP 会在以下两种情况中 执行 超时重传操作：</p>
<ol>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ol>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417192440953.png" alt="image-20210417192440953"></p>
<h4 id="设置超时时间"><a href="#设置超时时间" class="headerlink" title="设置超时时间"></a>设置超时时间</h4><p>何为RTT（Round-Trip Time 往返时延），可从下图中找到答案：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417192532442.png" alt="image-20210417192532442"></p>
<p><font color='orange'>RTT 就是数据从⽹络⼀端传送到另⼀端所需的时间，也就是包的往返时间。</font></p>
<p><font color='orange'>超时重传时间会以 RTO （Retransmission Timeout 超时重传时间）表示。</font></p>
<p>重传环境下，超时时间 RTO 「较⻓或较短」时，会发⽣什么？</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417192649183.png" alt="image-20210417192649183"></p>
<p>上图中有两种超时时间不同的情况：</p>
<ul>
<li>当超时时间 RTO 较⼤时，重发就慢，丢了⽼半天才重发，没有效率，性能差；</li>
<li>当超时时间 RTO 较⼩时，会导致可能并没有丢就重发，于是重发就快，会增加⽹络拥塞，导致 更多超时，更多超时导致更多重发。</li>
</ul>
<p>精确的测量超时时间 RTO 的值是⾮常重要的，这可让我们的重传机制更⾼效。 </p>
<p>根据上述的两种情况，我们可以得知： <font color='orange'>超时重传时间 RTO 的值应该略⼤于报⽂往返 RTT 的值。</font></p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417192824629.png" alt="image-20210417192824629"></p>
<p>⾄此，可能⼤家觉得超时᯿传时间 RTO 的值计算，也不是很复杂嘛。</p>
<p>好像就是在发送端发包时记下 t0 ，然后接收端再把这个 ack 回来时再记⼀个 t1 ，于是 RTT &#x3D; t1 – t0 。没那么简单，这只是⼀个采样，不能代表普遍情况。</p>
<p>实际上「报⽂往返 RTT 的值」是经常变化的，因为我们的⽹络也是时常变化的。也就因为「报⽂往返 RTT 的值」 是经常波动变化的，所以「超时᯿传时间 RTO 的值」应该是⼀个动态变化的值。</p>
<p>我们来看看 Linux 是如何计算 RTO 的呢？</p>
<p> <font color='orange'>估计往返时间，需要参考如下两项：</font></p>
<ol>
<li>TCP 通过采样 RTT 时间，然后进⾏加权平均，算出⼀个平滑 RTT 值，⽽且该值还是要 不断变化的，因为⽹络状况不断地变化。</li>
<li>除了采样 RTT，还要采样 RTT 的波动范围，这样就避免了 RTT 若有⼀个⼤波动的话，就会很难被发现的情况。</li>
</ol>
<p>RFC6289 建议使⽤以下的公式计算 RTO：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417192939108.png" alt="image-20210417192939108"></p>
<p><font color='orange'>其中，SRTT 是计算平滑RTT ， DevRTR 是计算平滑RTT 与 最新 RTT 的差距。</font></p>
<p>在 Linux 下，α &#x3D; 0.125，β &#x3D; 0.25， μ &#x3D; 1，∂ &#x3D; 4。别问怎么来的，问就是⼤量实验中调出来的。</p>
<p> <font color='orange'>如果超时重发的数据，再次超时且⼜需要重传时，TCP 的策略是超时间隔加倍。</font></p>
<p>也就是每当遇到⼀次超时重传的时候，都会将下⼀次超时时间间隔设为先前值的两倍。两次超时，就说明⽹络环境差，不宜频繁反复发送。</p>
<p>超时重传存在的问题是，超时周期可能相对较⻓。那是不是有更快的⽅式呢？</p>
<p> <font color='orange'>于是就可以⽤「快速重传」机制来解决超时重发的时间等待。</font></p>
<h3 id="5-1-2、快速重传"><a href="#5-1-2、快速重传" class="headerlink" title="5.1.2、快速重传"></a>5.1.2、快速重传</h3><p> <font color='orange'>快速重传（Fast Retransmit）机制不以时间为驱动，⽽是以数据驱动重传。</font></p>
<p>快速重传机制，是如何⼯作的呢？其实很简单，⼀图胜千⾔。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417232739572.png" alt="image-20210417232739572"></p>
<p>在上图，发送⽅发出了 1，2，3，4，5 份数据： </p>
<ol>
<li>第⼀份 Seq1 先送到了，于是就 Ack 回 2；</li>
<li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li>
<li>后⾯的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li>
<li>发送端收到了三个 Ack &#x3D; 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失 的 Seq2。</li>
<li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li>
</ol>
<p>所以， <font color='orange'>快速重传的⼯作⽅式是当收到三个相同 ACK 报⽂时，会在定时器过期之前，重传丢失的报⽂段。</font></p>
<p><font color='orange'>快速重传机制只解决了超时时间问题，还有重传一个，还是重传所有的问题。</font></p>
<p>⽐如对于上⾯的例⼦，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清 楚这连续的三个 Ack 2 是谁传回来的。</p>
<p><font color='orange'>因为TCP的不同实现，故以上两种情况都有可能发生。这是⼀把双刃剑。</font></p>
<p><font color='orange'>通过 SACK ⽅法可以解决 到底该重传哪些 TCP 报⽂的问题。</font></p>
<h3 id="5-1-3、SACK"><a href="#5-1-3、SACK" class="headerlink" title="5.1.3、SACK"></a>5.1.3、SACK</h3><p><font color='orange'>SACK （ Selective Acknowledgment 选择性确认）需要在 TCP 头部「选项」字段中加⼀个 SACK，它可以将缓存的地图 送给 发送⽅， 发送方可根据该地图来判断哪些收到了哪些没有收到，然后只重发那些没有收到的。</font></p>
<p>如下图，发送⽅收到了三次同样的 ACK 确认报⽂，于是就会触发快速重发机制，通过 SACK 信息发现 只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进⾏重复。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417233420965.png" alt="image-20210417233420965"></p>
<p><font color='orange'>如果要⽀持 SACK ，必须双⽅都要⽀持。在 Linux 下，可以通过 net.ipv4.tcp_sack 参数打开这个功能（Linux 2.4 后默认打开）。</font></p>
<h3 id="5-1-4、D-SACK"><a href="#5-1-4、D-SACK" class="headerlink" title="5.1.4、D-SACK"></a>5.1.4、D-SACK</h3><p><font color='orange'>Duplicate SACK ⼜称 D-SACK ，主要通过 SACK 来告诉「发送⽅」哪些数据被重复接收了。</font></p>
<p>下⾯举两个栗⼦，来说明 D-SACK 的作⽤。</p>
<p><strong>栗⼦⼀号：ACK 丢包</strong></p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417233640884.png" alt="image-20210417233640884"></p>
<ul>
<li>「接收⽅」发给「发送⽅」的两个 ACK 确认应答都丢失了，所以发送⽅超时后，᯿传第⼀个数据 包（3000 ~ 3499）</li>
<li>于是「接收⽅」发现数据是重复收到的，于是回了⼀个 SACK &#x3D; 3000<del>3500，告诉「发送⽅」 3000</del>3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都 已收到，所以这个 SACK 就代表着 D-SACK 。</li>
<li>这样「发送⽅」就知道了，数据没有丢，是「接收⽅」的 ACK 确认报⽂丢了。</li>
</ul>
<p><strong>栗子二号：网络延时</strong></p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417233800922.png" alt="image-20210417233800922"></p>
<ul>
<li>数据包（1000~1499） 被⽹络延迟了，导致「发送⽅」没有收到 Ack 1500 的确认报⽂。</li>
<li>⽽后⾯报⽂到达的三个相同的 ACK 确认报⽂，就触发了快速᯿传机制，但是在᯿传后，被延迟的 数据包（1000~1499）⼜到了「接收⽅」；</li>
<li>所以「接收⽅」回了⼀个 SACK&#x3D;1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 DSACK，表示收到了重复的包。</li>
<li>这样发送⽅就知道快速᯿传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，⽽ 是因为⽹络延迟了。</li>
</ul>
<p>可⻅， D-SACK 有这么⼏个好处： </p>
<ol>
<li>可以让「发送⽅」知道，是发出去的包丢了，还是接收⽅回应的 ACK 包丢了；</li>
<li>可以知道是不是「发送⽅」的数据包被⽹络延迟了；</li>
<li>可以知道⽹络中是不是把「发送⽅」的数据包给复制了;</li>
</ol>
<p><font color='orange'>Linux 下可以通过 net.ipv4.tcp_dsack 参数开启&#x2F;关闭这个功能（Linux 2.4 后默认打开）。</font></p>
<h2 id="4-2、滑动窗口"><a href="#4-2、滑动窗口" class="headerlink" title="4.2、滑动窗口"></a>4.2、滑动窗口</h2><h3 id="4-2-1、窗口作用"><a href="#4-2-1、窗口作用" class="headerlink" title="4.2.1、窗口作用"></a>4.2.1、窗口作用</h3><p>我们都知道 TCP 每发送⼀个数据，都要进⾏⼀次确认应答。当上⼀个数据包收到了应答， 再发送下⼀个。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417234245342.png" alt="image-20210417234245342"></p>
<p>所以，这样的传输⽅式有⼀个缺点：数据包的往返时间越⻓，通信的效率就越低。 </p>
<p>为解决这个问题，TCP 引⼊了窗⼝这个概念。</p>
<p><font color='orange'>有了窗⼝，就可以指定窗⼝⼤⼩，窗⼝⼤⼩是指：⽆需等待确认应答就可以继续发送数据的最⼤值。</font></p>
<p><font color='orange'>窗⼝的实现实际上是操作系统开辟的⼀个缓存空间，发送⽅主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</font></p>
<p>假设窗⼝⼤⼩为 3 个 TCP 段，那么发送⽅就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下⼀个确认应答进⾏确认」。如下图：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417234516493.png" alt="image-20210417234516493"></p>
<p>图中的 ACK 600 确认应答报⽂丢失，也没关系，因为可以通过下⼀个确认应答进⾏确认，只要发送⽅ 收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收⽅」都收到了。这个模式就叫累计确认或者累计应答。</p>
<h3 id="4-2-2、窗口大小谁来决定"><a href="#4-2-2、窗口大小谁来决定" class="headerlink" title="4.2.2、窗口大小谁来决定"></a>4.2.2、窗口大小谁来决定</h3><p>TCP 头⾥有⼀个字段叫 Window ，也就是窗⼝⼤⼩。 这个字段是接收端告诉发送端⾃⼰还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能⼒来发送数据，⽽不会导致接收端处理不过来。 所以，<font color='orange'>通常窗⼝的⼤⼩是由接收⽅窗⼝⼤⼩来决定的。</font> 发送⽅发送的数据⼤⼩不能超过接收⽅的窗⼝⼤⼩，否则接收⽅就⽆法正常接收到数据。</p>
<h3 id="4-2-3、发送方窗口"><a href="#4-2-3、发送方窗口" class="headerlink" title="4.2.3、发送方窗口"></a>4.2.3、发送方窗口</h3><p>我们先来看看发送⽅窗⼝，下图就是发送⽅缓存数据，根据处理的情况分成四个部分，其中 深蓝⾊⽅框 是发送窗⼝，紫⾊⽅框是可⽤窗⼝：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417234958826.png" alt="image-20210417234958826"></p>
<ul>
<li>#1 是已发送并收到 ACK确认的数据：1~31 字节。</li>
<li>#2 是已发送但未收到 ACK确认的数据：32~45 字节。</li>
<li>#3 是未发送但总⼤⼩在接收⽅处理范围内（接收⽅还有空间）：46~51字节。</li>
<li>#4 是未发送但总⼤⼩超过接收⽅处理范围（接收⽅没有空间）：52字节以后。</li>
</ul>
<p>在下图，当发送⽅把数据「全部」都⼀下发送出去后，可⽤窗⼝的⼤⼩就为 0 了，表明可⽤窗⼝耗尽， 在没收到 ACK 确认之前是⽆法继续发送数据了。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417235253264.png" alt="image-20210417235253264"></p>
<p>在下图，当收到之前发送的数据 32<del>36 字节的 ACK 确认应答后，如果发送窗⼝的⼤⼩没有变化，则 滑动窗⼝往右边移动 5 个字节，因为有 5 个字节的数据被应答确认，接下来 52</del>56 字节⼜变成了可⽤ 窗⼝，那么后续也就可以发送 52~56 这 5 个字节的数据了。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417235319675.png" alt="image-20210417235319675"></p>
<p><strong>程序如何表示发送方四个部分呢？</strong></p>
<p>TCP 滑动窗⼝⽅案使⽤三个指针来跟踪在四个传输类别中的每⼀个类别中的字节。其中两个指针是绝对 指针（指特定的序列号），⼀个是相对指针（需要做偏移）。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417235701045.png" alt="image-20210417235701045"></p>
<ul>
<li>SND.WND ：表示发送窗⼝的⼤⼩（⼤⼩是由接收⽅指定的）；</li>
<li>SND.UNA ：是⼀个绝对指针，它指向的是已发送但未收到确认的第⼀个字节的序列号，也就是 #2 的第⼀个字节。</li>
<li>SND.NXT ：也是⼀个绝对指针，它指向未发送但可发送范围的第⼀个字节的序列号，也就是 #3 的 第⼀个字节。</li>
<li>指向 #4 的第⼀个字节是个相对指针，它需要 SND.UNA 指针加上 SND.WND ⼤⼩的偏移量，就可以 指向 #4 的第⼀个字节了。</li>
</ul>
<p>那么可⽤窗⼝⼤⼩的计算公式就是： <code>可⽤窗⼝⼤ = SND.WND -（SND.NXT - SND.UNA）</code>。</p>
<h3 id="4-2-4、接收方窗口"><a href="#4-2-4、接收方窗口" class="headerlink" title="4.2.4、接收方窗口"></a>4.2.4、接收方窗口</h3><p>接下来我们看看接收⽅窗⼝，接收窗⼝相对简单⼀些，根据处理情况分成三个部分：</p>
<ul>
<li>#1 + #2 是已成功接收并确认的数据（等待应⽤进程读取）；</li>
<li>#3 是未收到数据但可以接收的数据；</li>
<li>#4 未收到数据并不可以接收的数据；</li>
</ul>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210417235921203.png" alt="image-20210417235921203"></p>
<p>其中三个接收部分，使⽤两个指针进⾏划分：</p>
<ul>
<li>RCV.WND 表示接收窗⼝的⼤⼩，它会通告给发送⽅。</li>
<li>RCV.NXT ：是⼀个指针，它指向期望从发送⽅发送来的下⼀个数据字节的序列号，也就是 #3 的第 ⼀个字节。</li>
<li>指向 #4 的第⼀个字节是个相对指针，它需要 RCV.NXT 指针加上 RCV.WND ⼤⼩的偏移量，就可以指向 #4 的第⼀个字节了。</li>
</ul>
<p><strong>接收窗口和发送窗口大小一样吗？</strong></p>
<p>并不是完全相等，<strong>接收窗⼝⼤⼩ 约等于 发送窗⼝⼤⼩</strong>。</p>
<p>因为滑动窗⼝并不是⼀成不变的。⽐如，当接收⽅的应⽤进程读取数据的速度⾮常快的话，接收窗⼝可以很快的腾出空闲空间。那么新的接收窗⼝⼤⼩，是通过 TCP 报⽂中的 Windows 字段来告诉发送⽅。那么这个传输过程是存在时延的，所以接收窗⼝的大小和发送窗⼝是约等于的关系。</p>
<h2 id="4-3、流量控制"><a href="#4-3、流量控制" class="headerlink" title="4.3、流量控制"></a>4.3、流量控制</h2><h3 id="4-3-1、流量控制来源"><a href="#4-3-1、流量控制来源" class="headerlink" title="4.3.1、流量控制来源"></a>4.3.1、流量控制来源</h3><p>发送⽅不能⽆脑的发数据给接收⽅，要考虑接收⽅处理能⼒。</p>
<p>如果⼀直⽆脑的发数据给对⽅，但对⽅处理不过来，那么就会导致触发重发机制，从⽽导致⽹络流量的⽆端的浪费。</p>
<p>为了解决这种现象发⽣，<strong>TCP 提供⼀种机制可以让「发送⽅」根据「接收⽅」的实际接收能⼒ 控制发送的数据量，这就是所谓的流量控制</strong>。</p>
<p>下⾯举个栗⼦，为了简单起⻅，假设以下场景：</p>
<ul>
<li>客户端是接收⽅，服务端是发送⽅。</li>
<li>假设接收窗⼝和发送窗⼝相同，都为 200。</li>
<li>假设两个设备在整个传输过程中都保持相同的窗⼝⼤⼩，不受外界影响。</li>
</ul>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418180447932.png" alt="image-20210418180447932"></p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418180514513.png" alt="image-20210418180514513"></p>
<p>根据上图的流量控制，说明下每个过程：</p>
<ol>
<li>客户端向服务端发送请求数据报⽂。这⾥要说明下，本次例⼦是把服务端作为发送⽅，所以没有画 出服务端的接收窗⼝。</li>
<li>服务端收到请求报⽂后，发送确认报⽂和 80 字节的数据，于是可⽤窗⼝ Usable 减少为 120 字 节，同时 SND.NXT 指针也向右偏移 80 字节后，指向 321，这意味着下次发送数据的时候，序列号 是 321。</li>
<li>客户端收到 80 字节数据后，于是接收窗⼝往右移动 80 字节， RCV.NXT 也就指向 321，这意味着 客户端期望的下⼀个报⽂的序列号是 321，接着发送确认报⽂给服务端。</li>
<li>服务端再次发送了 120 字节数据，于是可⽤窗⼝耗尽为 0，服务端⽆法再继续发送数据。</li>
<li>客户端收到 120 字节的数据后，于是接收窗⼝往右移动 120 字节， RCV.NXT 也就指向 441，接着 发送确认报⽂给服务端。</li>
<li>服务端收到对 80 字节数据的确认报⽂后， SND.UNA 指针往右偏移后指向 321，于是可⽤窗⼝ Usable 增⼤到 80。</li>
<li>服务端收到对 120 字节数据的确认报⽂后， SND.UNA 指针往右偏移后指向 441，于是可⽤窗⼝ Usable 增⼤到 200。</li>
<li>服务端可以继续发送了，于是发送了 160 字节的数据后， SND.NXT 指向 601，于是可⽤窗⼝ Usable 减少到 40。</li>
<li>客户端收到 160 字节后，接收窗⼝往右移动了 160 字节， RCV.NXT 也就是指向了 601，接着发送 确认报⽂给服务端。</li>
<li>服务端收到对 160 字节数据的确认报⽂后，发送窗⼝往右移动了 160 字节，于是 SND.UNA 指针偏 移了 160 后指向 601，可⽤窗⼝ Usable 也就增⼤⾄了 200。</li>
</ol>
<h3 id="4-3-2、操作系统缓冲区与滑动窗口的关系"><a href="#4-3-2、操作系统缓冲区与滑动窗口的关系" class="headerlink" title="4.3.2、操作系统缓冲区与滑动窗口的关系"></a>4.3.2、操作系统缓冲区与滑动窗口的关系</h3><p>假定了发送窗⼝和接收窗⼝是不变的，但实际上，发送窗⼝和接收窗⼝中所存放的字节数，都是放在操作系统内存缓冲区中，⽽操作系统的缓冲区，会被操作系统调整。</p>
<p>当应⽤进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。</p>
<h4 id="4-3-2-1、缓冲区如何响应发送-接收窗口"><a href="#4-3-2-1、缓冲区如何响应发送-接收窗口" class="headerlink" title="4.3.2.1、缓冲区如何响应发送&#x2F;接收窗口"></a>4.3.2.1、缓冲区如何响应发送&#x2F;接收窗口</h4><p><strong>例⼦一</strong></p>
<p>当应⽤程序没有及时读取缓存时，发送窗⼝和接收窗⼝的变化。</p>
<p>考虑以下场景：</p>
<ul>
<li>客户端作为发送⽅，服务端作为接收⽅，发送窗⼝和接收窗⼝初始⼤⼩为 360 ；</li>
<li>服务端⾮常的繁忙，当收到客户端的数据时，应⽤层不能及时读取数据。</li>
</ul>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418181534600.png" alt="image-20210418181534600"></p>
<p>根据上图的流量控制，说明下每个过程：</p>
<ol>
<li>客户端发送 140 字节数据后，可⽤窗⼝变为 220 （360 - 140）。</li>
<li>服务端收到 140 字节数据，但是服务端⾮常繁忙，应⽤进程只读取了 40 个字节，还有 100 字节占 ⽤着缓冲区，于是接收窗⼝收缩到了 260 （360 - 100），最后发送确认信息时，将窗⼝⼤⼩通告 给客户端。</li>
<li>客户端收到确认和窗⼝通告报⽂后，发送窗⼝减少为 260。</li>
<li>客户端发送 180 字节数据，此时可⽤窗⼝减少到 80。</li>
<li>服务端收到 180 字节数据，但是应⽤程序没有读取任何数据，这 180 字节直接就留在了缓冲区，于 是接收窗⼝收缩到了 80 （260 - 180），并在发送确认信息时，通过窗⼝⼤⼩给客户端。</li>
<li>客户端收到确认和窗⼝通告报⽂后，发送窗⼝减少为 80。</li>
<li>客户端发送 80 字节数据后，可⽤窗⼝耗尽。</li>
<li>服务端收到 80 字节数据，但是应⽤程序依然没有读取任何数据，这 80 字节留在了缓冲区，于是接 收窗⼝收缩到了 0，并在发送确认信息时，通过窗⼝⼤⼩给客户端。</li>
<li>客户端收到确认和窗⼝通告报⽂后，发送窗⼝减少为 0。</li>
</ol>
<p>可⻅最后窗⼝都收缩为 0 了，也就是发⽣了窗⼝关闭。当发送⽅可⽤窗⼝变为 0 时，发送⽅实际上会定 时发送窗⼝探测报⽂，以便知道接收⽅的窗⼝是否发⽣了改变，这个内容后⾯会说，这⾥先简单提⼀ 下。</p>
<p><strong>例⼦二</strong> </p>
<p>当服务端系统资源⾮常紧张的时候，操⼼系统可能会直接减少了接收缓冲区⼤⼩，这时应⽤程序⼜⽆法 及时读取缓存数据，那么这时候就有严᯿的事情发⽣了，会出现数据包丢失的现象</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418181843933.png" alt="image-20210418181843933"></p>
<p>说明下每个过程：</p>
<ol>
<li>客户端发送 140 字节的数据，于是可⽤窗⼝减少到了 220。</li>
<li>服务端因为现在⾮常的繁忙，操作系统于是就把接收缓存减少了 120 字节，当收到 140 字节数据 后，⼜因为应⽤程序没有读取任何数据，所以 140 字节留在了缓冲区中，于是接收窗⼝⼤⼩从 360 收缩成了 100，最后发送确认信息时，通告窗⼝⼤⼩给对⽅。</li>
<li>此时客户端因为还没有收到服务端的通告窗⼝报⽂，所以不知道此时接收窗⼝收缩成了 100，客户 端只会看⾃⼰的可⽤窗⼝还有 220，所以客户端就发送了 180 字节数据，于是可⽤窗⼝减少到 40。</li>
<li>服务端收到了 180 字节数据时，发现数据⼤⼩超过了接收窗⼝的⼤⼩，于是就把数据包丢失了。</li>
<li>客户端收到第 2 步时，服务端发送的确认报⽂和通告窗⼝报⽂，尝试减少发送窗⼝到 100，把窗⼝ 的右端向左收缩了 80，此时可⽤窗⼝的⼤⼩就会出现诡异的负值。</li>
</ol>
<p>所以，如果发⽣了先减少缓存，再收缩窗⼝，就会出现丢包的现象。</p>
<p>为了防⽌这种情况发⽣，TCP 规定是不允许同时减少缓存⼜收缩窗⼝的，⽽是采⽤先收缩窗⼝，过段时 间再减少缓存，这样就可以避免了丢包情况。</p>
<h3 id="4-3-3、窗口关闭"><a href="#4-3-3、窗口关闭" class="headerlink" title="4.3.3、窗口关闭"></a>4.3.3、窗口关闭</h3><p>在前⾯我们都看到了，TCP 通过让接收⽅指明希望从发送⽅接收的数据⼤⼩（窗⼝⼤⼩）来进⾏流量控 制。</p>
<p><strong>窗⼝⼤⼩为 0 时，就会阻⽌发送⽅给接收⽅传递数据，直到窗⼝变为⾮ 0 为⽌，这就是窗⼝关闭</strong>。</p>
<h4 id="5-3-3-1、窗口关闭潜在危险"><a href="#5-3-3-1、窗口关闭潜在危险" class="headerlink" title="5.3.3.1、窗口关闭潜在危险"></a>5.3.3.1、窗口关闭潜在危险</h4><p><strong>接收⽅向发送⽅通告窗⼝⼤⼩时，是通过 ACK 报⽂来通告的</strong>。</p>
<p><strong>当发⽣窗⼝关闭时，接收⽅处理完数据后，会向发送⽅通告⼀个窗⼝⾮ 0 的 ACK 报⽂，如果这个通告窗⼝的 ACK 报⽂在⽹络中丢失了，那麻烦就⼤了</strong>。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418182234840.png" alt="image-20210418182234840"></p>
<p>这会导致<strong>发送⽅⼀直等待接收⽅的⾮ 0 窗⼝通知，接收⽅也⼀直等待发送⽅的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象</strong>。</p>
<h4 id="5-3-3-2、如何解决窗口关闭时的死锁现象"><a href="#5-3-3-2、如何解决窗口关闭时的死锁现象" class="headerlink" title="5.3.3.2、如何解决窗口关闭时的死锁现象"></a>5.3.3.2、如何解决窗口关闭时的死锁现象</h4><p><strong>为了解决这个问题，TCP 为每个连接设有⼀个持续定时器，只要 TCP 连接⼀⽅收到对⽅的零窗⼝通知，就启动持续计时器</strong>。</p>
<p><strong>如果持续计时器超时，就会发送窗⼝探测 ( Window probe ) 报⽂，⽽对⽅在确认这个探测报⽂时，给出⾃⼰现在的接收窗⼝⼤⼩</strong>。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418182508676.png" alt="image-20210418182508676"></p>
<ul>
<li>如果接收窗⼝仍然为 0，那么收到这个报⽂的⼀⽅就会᯿新启动持续计时器；</li>
<li>如果接收窗⼝不是 0，那么死锁的局⾯就可以被打破了。</li>
</ul>
<p><strong>窗⼝探测的次数⼀般为 3 次，每次⼤约 30-60 秒（不同的实现可能会不⼀样）。如果 3 次过后接收窗⼝还是 0 的话，有的 TCP 实现就会发 RST 报⽂来中断连接</strong>。</p>
<h3 id="5-3-4、糊涂窗口综合症"><a href="#5-3-4、糊涂窗口综合症" class="headerlink" title="5.3.4、糊涂窗口综合症"></a>5.3.4、糊涂窗口综合症</h3><p>如果接收⽅太忙了，来不及取⾛接收窗⼝⾥的数据，那么就会导致发送⽅的发送窗⼝越来越⼩。</p>
<p>到最后，如果接收⽅腾出⼏个字节并告诉发送⽅现在有⼏个字节的窗⼝，⽽发送⽅会义⽆反顾地发送这⼏个字节，这就是糊涂窗⼝综合症。</p>
<p>要知道，我们的 TCP + IP 头有 40 个字节，为了传输那⼏个字节的数据，要达上这么⼤的开销，这太不经济了。</p>
<p>就好像⼀个可以承载 50 ⼈的⼤巴⻋，每次来了⼀两个⼈，就直接发⻋。除⾮家⾥有矿的⼤巴司机，才敢这样玩，不然迟早破产。要解决这个问题也不难，⼤巴司机等乘客数量超过了 25 个，才认定可以发车。</p>
<p>现举个糊涂窗⼝综合症的栗⼦，考虑以下场景：</p>
<p>接收⽅的窗⼝⼤⼩是 360 字节，但接收⽅由于某些原因陷⼊困境，假设接收⽅的应⽤层读取的能⼒如下：</p>
<ul>
<li>接收⽅每接收 3 个字节，应⽤程序就只能从缓冲区中读取 1 个字节的数据；</li>
<li>在下⼀个发送⽅的 TCP 段到达之前，应⽤程序还从缓冲区中读取了 40 个额外的字节；</li>
</ul>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418182907615.png" alt="image-20210418182907615"></p>
<p>每个过程的窗⼝⼤⼩的变化，在图中都描述的很清楚了，可以发现窗⼝不断减少了，并且发送的数据都 是⽐较⼩的了。</p>
<p>所以，糊涂窗⼝综合症的现象是可以发⽣在发送⽅和接收⽅：</p>
<ul>
<li>接收⽅可以通告⼀个⼩的窗⼝。</li>
<li>⽽发送⽅可以发送⼩数据。</li>
</ul>
<p>于是，要解决糊涂窗⼝综合症，就解决上⾯两个问题就可以了</p>
<ul>
<li>让接收⽅不通告⼩窗⼝给发送⽅。</li>
<li>让发送⽅避免发送⼩数据。</li>
</ul>
<h4 id="5-3-4-1、如何让接收方不通告小窗口"><a href="#5-3-4-1、如何让接收方不通告小窗口" class="headerlink" title="5.3.4.1、如何让接收方不通告小窗口"></a>5.3.4.1、如何让接收方不通告小窗口</h4><p>接收⽅通常的策略如下：</p>
<p><strong>当「窗⼝⼤⼩」⼩于 min( MSS，缓存空间&#x2F;2 ) ，也就是⼩于 MSS 与 1&#x2F;2 缓存⼤⼩中的最⼩值时，就会向发送⽅通告窗⼝为 0 ，也就阻⽌了发送⽅再发数据过来</strong>。</p>
<p>等到接收⽅处理了⼀些数据后，窗⼝⼤⼩ &gt;&#x3D; MSS，或者接收⽅缓存空间有⼀半可以使⽤，就可以把窗⼝打开让发送⽅发送数据过来。</p>
<h4 id="5-3-4-2、如何让发送方避免发送小数据"><a href="#5-3-4-2、如何让发送方避免发送小数据" class="headerlink" title="5.3.4.2、如何让发送方避免发送小数据"></a>5.3.4.2、如何让发送方避免发送小数据</h4><p>发送⽅通常的策略：</p>
<p><strong>使⽤ Nagle 算法，该算法的思路是延时处理，它满⾜以下两个条件中的⼀条才可以发送数据</strong>：</p>
<ul>
<li>要等到窗⼝⼤⼩ &gt;&#x3D; MSS 或是数据⼤⼩ &gt;&#x3D; MSS</li>
<li>收到之前发送数据的 ack 回包</li>
</ul>
<p><strong>只要没满⾜上⾯条件中的⼀条，发送⽅⼀直在囤积数据，直到满⾜上⾯的发送条件</strong>。</p>
<p>另外，<strong>Nagle 算法默认打开</strong>，如果对于⼀些需要⼩数据包交互的场景的程序，⽐如，telnet 或 ssh 这样的交互性⽐较强的程序，则需要关闭 Nagle 算法。</p>
<p>可以在 Socket 设置 TCP_NODELAY 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每 个应⽤⾃⼰的特点来关闭）</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">setsockopt</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">,</span> <span class="token constant">IPPROTO_TCP</span><span class="token punctuation">,</span> <span class="token constant">TCP_NODELAY</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>value<span class="token punctuation">,</span> <span class="token function">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="4-4、拥塞控制"><a href="#4-4、拥塞控制" class="headerlink" title="4.4、拥塞控制"></a>4.4、拥塞控制</h2><h3 id="4-4-1、简介"><a href="#4-4-1、简介" class="headerlink" title="4.4.1、简介"></a>4.4.1、简介</h3><h4 id="4-4-1-1、为何需要拥塞控制"><a href="#4-4-1-1、为何需要拥塞控制" class="headerlink" title="4.4.1.1、为何需要拥塞控制"></a>4.4.1.1、为何需要拥塞控制</h4><p>前⾯的流量控制是避免「发送⽅」的数据填满「接收⽅」的缓存，但是并不知道⽹络中发⽣了什么。</p>
<p> ⼀般来说，计算机⽹络都处在⼀个共享的环境。因此也有可能会因为其他主机之间的通信使得⽹络拥堵。</p>
<p>在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传 数据，但是⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进 ⼊恶性循环被不断地放⼤…. 。</p>
<p>所以，TCP 不能忽略⽹络中发⽣的事，它被设计成⼀个⽆私的协议，当⽹络发送拥塞时，TCP 会⾃我 牺牲，降低发送的数据量。</p>
<p>于是，就有了<strong>拥塞控制，控制的⽬的就是避免「发送⽅」的数据填满整个⽹络</strong>。</p>
<p><strong>为了调节「发送⽅」所要发送数据的量，定义了⼀个叫做「拥塞窗⼝」的概念</strong>。</p>
<h4 id="4-4-1-2、何为拥塞窗口，与发送窗口有啥关系？"><a href="#4-4-1-2、何为拥塞窗口，与发送窗口有啥关系？" class="headerlink" title="4.4.1.2、何为拥塞窗口，与发送窗口有啥关系？"></a>4.4.1.2、何为拥塞窗口，与发送窗口有啥关系？</h4><p>拥塞窗⼝ cwnd是发送⽅维护的⼀个状态变量，它会根据⽹络的拥塞程度动态变化。</p>
<p>我们在前⾯提到过发送窗⼝ swnd 和接收窗⼝ rwnd 是约等于的关系，那么加⼊拥塞窗⼝的概念后，此时发送窗⼝的值是swnd &#x3D; min(cwnd, rwnd)，也就是拥塞窗⼝和接收窗⼝中的最⼩值。</p>
<p>拥塞窗⼝ cwnd 变化规则：</p>
<ul>
<li>⽹络中没有出现拥塞， cwnd 就会增⼤；</li>
<li>⽹络中出现了拥塞， cwnd 就减少；</li>
</ul>
<h4 id="4-4-1-3、如何判断网络拥塞了？"><a href="#4-4-1-3、如何判断网络拥塞了？" class="headerlink" title="4.4.1.3、如何判断网络拥塞了？"></a>4.4.1.3、如何判断网络拥塞了？</h4><p><strong>只要「发送⽅」没有在规定时间内接收到 ACK 应答报⽂，也就是发⽣了超时重传，就会认为⽹络出现了拥塞</strong>。</p>
<h4 id="4-4-1-4、拥塞控制算法"><a href="#4-4-1-4、拥塞控制算法" class="headerlink" title="4.4.1.4、拥塞控制算法"></a>4.4.1.4、拥塞控制算法</h4><p>拥塞控制主要四个算法：</p>
<ol>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发⽣</li>
<li>快速恢复</li>
</ol>
<h3 id="4-4-2、慢启动"><a href="#4-4-2、慢启动" class="headerlink" title="4.4.2、慢启动"></a>4.4.2、慢启动</h3><p><strong>TCP 在刚建⽴连接完成后，⾸先有个慢启动过程，这个慢启动意思就是⼀点⼀点提⾼发送数据包的数量</strong>。如果⼀上来就发⼤量的数据，这不是给⽹络添堵吗？</p>
<p><strong>慢启动算法记住⼀个规则就⾏：当发送⽅每收到⼀个 ACK，拥塞窗⼝ cwnd 的⼤⼩就会加 1</strong>。</p>
<p>这⾥假定拥塞窗⼝ cwnd 和发送窗⼝ swnd 相等，下⾯举个栗⼦：</p>
<ul>
<li>连接建⽴完成后，⼀开始初始化 cwnd &#x3D; 1 ，表示可以传⼀个 MSS ⼤⼩的数据。</li>
<li>当收到⼀个 ACK 确认应答后，cwnd 增加 1，于是⼀次能够发送 2 个 </li>
<li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以⽐之前多发2 个，所以这⼀次能够发送 4 个</li>
<li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以⽐ 之前多发 4 个，所以这⼀次能够发送 8 个。</li>
</ul>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418184842512.png" alt="image-20210418184842512"></p>
<p>可以看出慢启动算法，发包的个数是指数性的增⻓。</p>
<h4 id="4-4-2-1、慢启动涨到什么时候结束"><a href="#4-4-2-1、慢启动涨到什么时候结束" class="headerlink" title="4.4.2.1、慢启动涨到什么时候结束"></a>4.4.2.1、慢启动涨到什么时候结束</h4><p>有⼀个叫慢启动⻔限 ssthresh （slow start threshold）状态变量。</p>
<ul>
<li>当 cwnd &lt; ssthresh 时，使⽤慢启动算法。</li>
<li>当 cwnd &gt;&#x3D; ssthresh 时，就会使⽤「拥塞避免算法」。</li>
</ul>
<h3 id="4-4-3、拥塞避免算法"><a href="#4-4-3、拥塞避免算法" class="headerlink" title="4.4.3、拥塞避免算法"></a>4.4.3、拥塞避免算法</h3><p>前⾯说道，当拥塞窗⼝ cwnd 「超过」慢启动⻔限 ssthresh 就会进⼊拥塞避免算法。</p>
<p>⼀般来说 ssthresh 的⼤⼩是 65535 字节。</p>
<p>那么进⼊拥塞避免算法后，它的规则是：每当收到⼀个 ACK 时，cwnd 增加 1&#x2F;cwnd。</p>
<p>接上前⾯的慢启动的栗⼦，现假定 ssthresh 为 8 ：</p>
<ul>
<li>当 8 个 ACK 应答确认到来时，每个确认增加 1&#x2F;8，8 个 ACK 确认 cwnd ⼀共增加 1，于是这⼀次 能够发送 9 个 MSS ⼤⼩的数据，变成了线性增⻓。</li>
</ul>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418190150299.png" alt="image-20210418190150299"></p>
<p>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增⻓变成了线性增⻓，还是增⻓阶 段，但是增⻓速度缓慢了⼀些。</p>
<p>就这么⼀直增⻓着后，⽹络就会慢慢进⼊了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失 的数据包进⾏᯿传。</p>
<p>当触发了重传机制，也就进⼊了「拥塞发⽣算法」</p>
<h3 id="4-4-4、拥塞发生"><a href="#4-4-4、拥塞发生" class="headerlink" title="4.4.4、拥塞发生"></a>4.4.4、拥塞发生</h3><p>当⽹络出现拥塞，也就是会发⽣数据包᯿传，重传机制主要有两种：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
</ul>
<h4 id="4-4-4-1、超时重传拥塞发生算法"><a href="#4-4-4-1、超时重传拥塞发生算法" class="headerlink" title="4.4.4.1、超时重传拥塞发生算法"></a>4.4.4.1、超时重传拥塞发生算法</h4><p>当发⽣了「超时重传」，则就会使⽤拥塞发⽣算法。</p>
<p>这个时候，ssthresh 和 cwnd 的值会发⽣变化：</p>
<ul>
<li>ssthresh 设为 cwnd&#x2F;2。</li>
<li>cwnd ᯿置为 1。</li>
</ul>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418190500847.png" alt="image-20210418190500847"></p>
<p>接着，就᯿新开始慢启动，慢启动是会突然减少数据流的。这真是⼀旦「超时᯿传」，⻢上回到解放 前。但是这种⽅式太激进了，反应也很强烈，会造成⽹络卡顿。</p>
<p>就好像本来在秋名⼭⾼速漂移着，突然来个紧急刹⻋，轮胎受得了吗。</p>
<h4 id="4-4-4-2、快速重传拥塞发生算法"><a href="#4-4-4-2、快速重传拥塞发生算法" class="headerlink" title="4.4.4.2、快速重传拥塞发生算法"></a>4.4.4.2、快速重传拥塞发生算法</h4><p>还有更好的⽅式，前⾯我们讲过「快速᯿传算法」。当接收⽅发现丢了⼀个中间包的时候，发送三次前⼀个包的 ACK，于是发送端就会快速地᯿传，不必等待超时再᯿传。</p>
<p>TCP 认为这种情况不严重，因为⼤部分没丢，只丢了⼀⼩部分，则 ssthresh 和 cwnd 变化如下：</p>
<ul>
<li>cwnd &#x3D; cwnd&#x2F;2 ，也就是设置为原来的⼀半;</li>
<li>ssthresh &#x3D; cwnd ;</li>
<li>进⼊快速恢复算法</li>
</ul>
<h3 id="4-4-5、快速恢复"><a href="#4-4-5、快速恢复" class="headerlink" title="4.4.5、快速恢复"></a>4.4.5、快速恢复</h3><p>快速重传和快速恢复算法⼀般同时使⽤，快速恢复算法是认为，你还能收到 3 个᯿复 ACK 说明⽹络也 不那么糟糕，所以没有必要像 RTO 超时那么强烈。</p>
<p>正如前⾯所说，进⼊快速恢复之前， cwnd 和 ssthresh 已被更新了：</p>
<ul>
<li>cwnd &#x3D; cwnd&#x2F;2 ，也就是设置为原来的⼀半;</li>
<li>ssthresh &#x3D; cwnd ;</li>
</ul>
<p>然后，进⼊快速恢复算法如下： </p>
<ul>
<li>拥塞窗⼝ cwnd &#x3D; ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到᯿复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第⼀步中的 ssthresh 的值，原因是该 ACK 确认了新 的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的 状态了，也即再次进⼊拥塞避免状态；</li>
</ul>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418190824253.png" alt="image-20210418190824253"></p>
<p>也就是没有像「超时᯿传」⼀夜回到解放前，⽽是还在⽐较⾼的值，后续呈线性增⻓。</p>
<h3 id="4-4-6、拥塞算法示意图"><a href="#4-4-6、拥塞算法示意图" class="headerlink" title="4.4.6、拥塞算法示意图"></a>4.4.6、拥塞算法示意图</h3><p>好了，以上就是拥塞控制的全部内容了，看完后，你再来看下⾯这张图⽚，每个过程我相信你都能明⽩：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418190933705.png" alt="image-20210418190933705"></p>
<h1 id="5、TCP性能传输"><a href="#5、TCP性能传输" class="headerlink" title="5、TCP性能传输"></a>5、TCP性能传输</h1><h2 id="5-1、提升TCP三次握手性能"><a href="#5-1、提升TCP三次握手性能" class="headerlink" title="5.1、提升TCP三次握手性能"></a>5.1、提升TCP三次握手性能</h2><p><font color='orange'>TCP 是⾯向连接的、可靠的、双向传输的传输层通信协议。在传输数据之前需要经过三次握⼿才能 建⽴连接。</font></p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418200853587.png" alt="image-20210418200853587"></p>
<p>那么，三次握⼿时间消耗在⼀个 HTTP 请求的平均时间中占⽐ 10% 以上，在⽹络状态不佳、⾼并发或者遭遇 SYN 攻击等场景中，如果不能有效正确的调节三次握⼿中的参数，就会对性能产⽣很多的影响。</p>
<p>如何正确有效的使⽤这些参数，来提⾼ TCP 三次握⼿的性能，这就需要理解「三次握⼿的状态变迁」，<font color='orange'>当出现问题时，先⽤ netstat 命令查看是哪个握⼿阶段出现问题，再来对症下药，⽽不是病急乱投医。</font></p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418200928818.png" alt="image-20210418200928818"></p>
<p><font color='orange'>客户端和服务端都可以通过三次握⼿优化性能。主动发起连接的客户端优化相对简单些，⽽服务端需要 监听端⼝，属于被动连接⽅，其间保持许多的中间状态，优化⽅法相对复杂⼀些。</font></p>
<p>所以，客户端（主动发起连接⽅）和服务端（被动连接⽅）优化的⽅式是不同的，接下来分别针对客户端和服务端来进行优化。</p>
<h3 id="5-1-1、客户端优化"><a href="#5-1-1、客户端优化" class="headerlink" title="5.1.1、客户端优化"></a>5.1.1、客户端优化</h3><p><font color='orange'>三次握⼿ 建⽴连接 ⾸要⽬的是 同步序列号</font>。</p>
<p>SYN 的全称就叫 Synchronize Sequence Numbers（同步序列号）。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418201102398.png" alt="image-20210418201102398"></p>
<h4 id="5-1-1-1、SYN-SENT-状态优化"><a href="#5-1-1-1、SYN-SENT-状态优化" class="headerlink" title="5.1.1.1、SYN_SENT 状态优化"></a>5.1.1.1、SYN_SENT 状态优化</h4><p>客户端 先发送 SYN 包，然后进入 SYN_SENT 状态。</p>
<p>如果客户端⻓时间没有收到 SYN+ACK 报⽂，则会重发 SYN 包，重发次数由 tcp_syn_retries 参数控制， 默认是 5 次：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202018005.png" alt="image-20210418202018005"></p>
<p>通常，第⼀次超时重传是在 1 秒后，第⼆次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。<font color='orange'>每次超时的时间是上⼀次的 2 倍。</font>当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就会终⽌三次握⼿。</p>
<p><font color='orange'>所以，总耗时是 1+2+4+8+16+32&#x3D;63 秒，⼤约 1 分钟左右。</font></p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202153188.png" alt="image-20210418202153188"></p>
<p>客户端优化参考如下：<font color="orange">根据 ⽹络稳定性 和 服务器繁忙程度 来修改 SYN 重传次数，调整客户端三次握⼿时间上限。</font></p>
<h3 id="5-1-2、服务端优化"><a href="#5-1-2、服务端优化" class="headerlink" title="5.1.2、服务端优化"></a>5.1.2、服务端优化</h3><p>服务端收到 SYN 包后会⽴⻢回复 SYN+ACK 包，表明收到了客户端序列号，同时也把⾃⼰的序列号发给对⽅。</p>
<p><font color='orange'>服务端 收到 新连接 就会 进入SYN_RCV状态，同时 Linux 内核就会建⽴⼀个「半连接队列」来维护「未完成」的握⼿信息，当半连接队列溢出后，服务端就⽆法再建⽴新连接。</font></p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202233550.png" alt="image-20210418202233550"></p>
<p>SYN 攻击半连接队列。</p>
<h4 id="5-1-2-1、如何查看由于-SYN-半连接队列已满⽽被丢弃连接的情况？"><a href="#5-1-2-1、如何查看由于-SYN-半连接队列已满⽽被丢弃连接的情况？" class="headerlink" title="5.1.2.1、如何查看由于 SYN 半连接队列已满⽽被丢弃连接的情况？"></a>5.1.2.1、如何查看由于 SYN 半连接队列已满⽽被丢弃连接的情况？</h4><p><font color='orange'>可以从 <code>netstat -s</code> 命令返回的统计结果中得到由于半连接队列已满而引发的失败次数：</font></p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202341149.png" alt="image-20210418202341149"></p>
<p>上⾯输出的数值是累计值，表示共有多少个 TCP 连接因半连接队列溢出⽽被丢弃。隔⼏秒执⾏⼏次，如果有上升趋势，说明当前存在半连接队列溢出现象。</p>
<h4 id="5-1-2-2、如何调整-SYN-半连接队列⼤⼩？"><a href="#5-1-2-2、如何调整-SYN-半连接队列⼤⼩？" class="headerlink" title="5.1.2.2、如何调整 SYN 半连接队列⼤⼩？"></a>5.1.2.2、如何调整 SYN 半连接队列⼤⼩？</h4><p><font color='orange'>要想增⼤ 半连接队列，不仅需要增大 <code>tcp_max_syn_backlog</code> 的值，还需增⼤ accept 队列。两者缺一不可，否则⽆效。</font></p>
<p>增⼤ <code>tcp_max_syn_backlog</code> 和 <code>somaxconn</code> 的⽅法是修改 Linux 内核参数：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202433581.png" alt="image-20210418202433581"></p>
<p>增⼤ backlog 的⽅式，每个 Web 服务都不同，⽐如 Nginx 增⼤ backlog 的⽅法如下：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202450402.png" alt="image-20210418202450402"></p>
<p>最后，改变了如上这些参数后，要᯿启 Nginx 服务，因为 SYN 半连接队列和 accept 队列都是在 listen() 初始化的。</p>
<h4 id="5-1-2-3、如果-SYN-半连接队列已满，只能丢弃连接吗？"><a href="#5-1-2-3、如果-SYN-半连接队列已满，只能丢弃连接吗？" class="headerlink" title="5.1.2.3、如果 SYN 半连接队列已满，只能丢弃连接吗？"></a>5.1.2.3、如果 SYN 半连接队列已满，只能丢弃连接吗？</h4><p><font color='orange'>事实并非如此，开启 syncookies 功能就可实现不使⽤ SYN 半连接队列的情况下成功建⽴连接。</font></p>
<p><font color='orange'>syncookies ⼯作原理：服务器根据当前状态计算出⼀个值，放在⼰⽅的 SYN+ACK 报⽂中并发出，当客户端返回 ACK 报⽂时，取出该值验证，如果合法，就认为连接建⽴成功，</font>如下图所示。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202537593.png" alt="image-20210418202537593"></p>
<p>syncookies 参数主要有以下三个值：</p>
<ul>
<li>0：表示关闭该功能；</li>
<li>1：表示仅当 SYN 半连接队列放不下时，再启⽤它；</li>
<li>2：表示⽆条件开启功能；</li>
</ul>
<p><font color='orange'>在应对 SYN 攻击时，只需设为 1 即可：</font></p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202615907.png" alt="image-20210418202615907"></p>
<h4 id="5-1-2-4、SYN-RCV-状态优化"><a href="#5-1-2-4、SYN-RCV-状态优化" class="headerlink" title="5.1.2.4、SYN_RCV 状态优化"></a>5.1.2.4、SYN_RCV 状态优化</h4><p>当客户端接收到服务器发来的 SYN+ACK 报⽂后，就会回复 ACK 给服务器，同时客户端连接状态从 SYN_SENT 转换为 ESTABLISHED，表示连接建⽴成功。</p>
<p>服务器端连接成功建⽴的时间还要再往后，等到服务端收到客户端的 ACK 后，服务端的连接状态才变 为 ESTABLISHED。</p>
<p>如果服务器没有收到 ACK，就会重发 SYN+ACK 报⽂，同时⼀直处于 SYN_RCV 状态。</p>
<p>当⽹络繁忙、不稳定时，报⽂丢失就会变严重，此时应该调⼤᯿发次数。反之则可以调⼩重发次数。修改重发次数的⽅法是，调整 tcp_synack_retries 参数：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202715040.png" alt="image-20210418202715040"></p>
<p>tcp_synack_retries 的默认重试次数是 5 次，与客户端重传 SYN 类似，它的重传会经历 1、2、4、8、 16 秒，最后⼀次重传后会继续等待 32 秒，如果服务端仍然没有收到 ACK，才会关闭连接，故共需要等待 63 秒。</p>
<p>服务器收到 ACK 后连接建⽴成功，此时，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调⽤ accept 函数时把连接取出来。</p>
<p>如果进程不能及时地调⽤ accept 函数，就会造成 accept 队列（也称全连接队列）溢出，最终导致建⽴ 好的 TCP 连接被丢弃。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202743734.png" alt="image-20210418202743734"></p>
<h4 id="5-1-2-5、accept-队列已满，只能丢弃连接吗？"><a href="#5-1-2-5、accept-队列已满，只能丢弃连接吗？" class="headerlink" title="5.1.2.5、accept 队列已满，只能丢弃连接吗？"></a>5.1.2.5、accept 队列已满，只能丢弃连接吗？</h4><p>丢弃连接只是 Linux 的默认⾏为，我们还可以选择向客户端发送 RST 复位报⽂，告诉客户端连接已经 建⽴失败。打开这⼀功能需要将 tcp_abort_on_overflow 参数设置为 1。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202819569.png" alt="image-20210418202819569"></p>
<p>tcp_abort_on_overflow 共有两个值分别是 0 和 1，其分别表示：</p>
<ul>
<li>0 ：如果 accept 队列满了，那么 server 扔掉 client 发过来的 ack ；</li>
<li>1 ：如果 accept 队列满了，server 发送⼀个 RST 包给 client，表示废掉这个握⼿过程和这个连接；</li>
</ul>
<p>如果要想知道客户端连接不上服务端，是不是服务端 TCP 全连接队列满的原因，那么可以把 tcp_abort_on_overflow 设置为 1，这时如果在客户端异常中可以看到很多 connection reset by peer 的错误，那么就可以证明是由于服务端 TCP 全连接队列溢出的问题。</p>
<p>通常情况下，应当把 tcp_abort_on_overflow 设置为 0，因为这样更有利于应对突发流量。</p>
<p>举个例⼦，当 accept 队列满导致服务器丢掉了 ACK，与此同时，客户端的连接状态却是 ESTABLISHED，客户端进程就在建⽴好的连接上发送请求。只要服务器没有为请求回复 ACK，客户端 的请求就会被多次「᯿发」。如果服务器上的进程只是短暂的繁忙造成 accept 队列满，那么当 accept 队列有空位时，再次接收到的请求报⽂由于含有 ACK，仍然会触发服务器端成功建⽴连接。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202908422.png" alt="image-20210418202908422"></p>
<p>所以，tcp_abort_on_overflow 设为 0 可以提⾼连接建⽴的成功率，只有你⾮常肯定 TCP 全连接队列会 ⻓期溢出时，才能设置为 1 以尽快通知客户端。</p>
<h4 id="5-1-2-6、如何调整-accept-队列的⻓度？"><a href="#5-1-2-6、如何调整-accept-队列的⻓度？" class="headerlink" title="5.1.2.6、如何调整 accept 队列的⻓度？"></a>5.1.2.6、如何调整 accept 队列的⻓度？</h4><p>可以通过 ss -lnt 命令查看：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418202957783.png" alt="image-20210418202957783"></p>
<ul>
<li>Recv-Q：当前 accept 队列的⼤⼩，也就是当前已完成三次握⼿并等待服务端 accept() 的 TCP 连接；</li>
<li>Send-Q：accept 队列最⼤⻓度，上⾯的输出结果说明监听 8088 端⼝的 TCP 服务，accept 队列的 最⼤⻓度为 128；</li>
</ul>
<h4 id="5-1-2-7、如何查看由于-accept-连接队列已满，⽽被丢弃的连接？"><a href="#5-1-2-7、如何查看由于-accept-连接队列已满，⽽被丢弃的连接？" class="headerlink" title="5.1.2.7、如何查看由于 accept 连接队列已满，⽽被丢弃的连接？"></a>5.1.2.7、如何查看由于 accept 连接队列已满，⽽被丢弃的连接？</h4><p><font color='orange'>当超过了 accept 连接队列，服务端则会丢掉后续进来的 TCP 连接，丢掉的 TCP 连接的个数会被统计 起来，我们可以使⽤ netstat -s 命令来查看：</font></p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418203046836.png" alt="image-20210418203046836"></p>
<p>上⾯看到的 41150 times ，表示 accept 队列溢出的次数，注意这个是累计值。可以隔⼏秒钟执⾏下， 如果这个数字⼀直在增加的话，说明 accept 连接队列偶尔满了。</p>
<p>如果持续不断地有连接因为 accept 队列溢出被丢弃，就应该调⼤ backlog 以及 somaxconn 参数。</p>
<h3 id="5-1-3、如何绕过三次握手"><a href="#5-1-3、如何绕过三次握手" class="headerlink" title="5.1.3、如何绕过三次握手"></a>5.1.3、如何绕过三次握手</h3><p>下面我们看看如何绕过三次握⼿发送数据。</p>
<p>三次握⼿建⽴连接造成的后果就是，HTTP 请求必须在⼀个 RTT（客户端到服务器⼀个往返时间） 后才能发送。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418203159568.png" alt="image-20210418203159568"></p>
<p><font color='orange'>在 Linux 3.7 内核版本之后，提供了 TCP Fast Open 功能，这个功能可以减少 TCP 连接建⽴的时延。</font></p>
<h4 id="5-1-3-1、TCP-Fast-Open-⼯作⽅式。"><a href="#5-1-3-1、TCP-Fast-Open-⼯作⽅式。" class="headerlink" title="5.1.3.1、TCP Fast Open ⼯作⽅式。"></a>5.1.3.1、TCP Fast Open ⼯作⽅式。</h4><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418203407354.png" alt="image-20210418203407354"></p>
<p>在客户端⾸次建⽴连接时的过程：</p>
<ol>
<li>客户端发送 SYN 报⽂，该报⽂包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie；</li>
<li>⽀持 TCP Fast Open 的服务器⽣成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以 发回客户端；</li>
<li>客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。</li>
</ol>
<p>所以，第⼀次发起 HTTP GET 请求的时候，还是需要正常的三次握⼿流程。</p>
<p>之后，如果客户端再次向服务器建⽴连接时的过程：</p>
<ol>
<li>客户端发送 SYN 报⽂，该报⽂包含「数据」（对于⾮ TFO 的普通 TCP 握⼿过程，SYN 报⽂中不 包含「数据」）以及此前记录的 Cookie；</li>
<li>⽀持 TCP Fast Open 的服务器会对收到 Cookie 进⾏校验：如果 Cookie 有效，服务器将在 SYNACK 报⽂中对 SYN 和「数据」进⾏确认，服务器随后将「数据」递送⾄相应的应⽤程序；如果 Cookie ⽆效，服务器将丢弃 SYN 报⽂中包含的「数据」，且其随后发出的 SYN-ACK 报⽂将只确 认 SYN 的对应序列号；</li>
<li>如果服务器接受了 SYN 报⽂中的「数据」，服务器可在握⼿完成之前发送「数据」，这就减少了 握⼿带来的 1 个 RTT 的时间消耗；</li>
<li>客户端将发送 ACK 确认服务器发回的 SYN 以及「数据」，但如果客户端在初始的 SYN 报⽂中发 送的「数据」没有被确认，则客户端将᯿新发送「数据」；</li>
<li>此后的 TCP 连接的数据传输过程和⾮ TFO 的正常情况⼀致。</li>
</ol>
<p>所以，之后发起 HTTP GET 请求的时候，可以绕过三次握⼿，这就减少了握⼿带来的 1 个 RTT 的时间消耗。</p>
<p>开启了 TFO 功能，cookie 的值是存放到 TCP option 字段⾥的：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418203616446.png" alt="image-20210418203616446"></p>
<p>注：客户端在请求并存储了 Fast Open Cookie 之后，可以不断᯿复 TCP Fast Open 直⾄服务器认为 Cookie ⽆效（通常为过期）。</p>
<h4 id="5-1-3-2、Linux-下如何打开-TCP-Fast-Open-功能"><a href="#5-1-3-2、Linux-下如何打开-TCP-Fast-Open-功能" class="headerlink" title="5.1.3.2、Linux 下如何打开 TCP Fast Open 功能"></a>5.1.3.2、Linux 下如何打开 TCP Fast Open 功能</h4><p><font color='orange'>Linux环境中可通过设置 tcp_fastopn 内核参数，来打开 Fast Open 功能：</font></p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418203701456.png" alt="image-20210418203701456"></p>
<p>tcp_fastopn 各个值的意义：</p>
<ul>
<li>0 关闭 1 作为客户端使⽤ Fast Open 功能；</li>
<li>2 作为服务端使⽤ Fast Open 功能；</li>
<li>3 ⽆论作为客户端还是服务器，都可以使⽤ Fast Open 功能；</li>
</ul>
<p>TCP Fast Open 功能需要客户端和服务端同时⽀持，才有效果。</p>
<h3 id="5-1-4、小结"><a href="#5-1-4、小结" class="headerlink" title="5.1.4、小结"></a>5.1.4、小结</h3><p>本⼩结主要介绍了关于优化 TCP 三次握⼿的⼏个 TCP 参数。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418203828453.png" alt="image-20210418203828453"></p>
<h4 id="5-1-4-1、客户端优化"><a href="#5-1-4-1、客户端优化" class="headerlink" title="5.1.4.1、客户端优化"></a>5.1.4.1、客户端优化</h4><p><font color='orange'>当客户端发起 SYN 包时，可以通过 <code>tcp_syn_retries</code> 控制其重传次数。</font ></p>
<h4 id="5-1-4-2、服务端优化"><a href="#5-1-4-2、服务端优化" class="headerlink" title="5.1.4.2、服务端优化"></a>5.1.4.2、服务端优化</h4><p>当服务端 SYN 半连接队列溢出后，会导致后续连接被丢弃，可以通过 netstat -s 观察半连接队列溢出的情况，如果 SYN 半连接队列溢出情况⽐较严重，可以通过 <code>tcp_max_syn_backlog</code>、<code>somaxconn</code>、 <code>backlog</code> 参数来调整 SYN 半连接队列的⼤⼩。</p>
<p>服务端回复 SYN+ACK 的᯿传次数由 <code>tcp_synack_retries</code> 参数控制。如果遭受 SYN 攻击，应把 <code>tcp_syncookies</code> 参数设置为 1，表示仅在 SYN 队列满后开启 syncookie 功能，可以保证正常的连接 成功建⽴。</p>
<p>服务端收到客户端返回的 ACK，会把连接移⼊ accpet 队列，等待进⾏调⽤ accpet() 函数取出连接。</p>
<p>可以通过 ss -lnt 查看服务端进程的 accept 队列⻓度，如果 accept 队列溢出，系统默认丢弃 ACK，如果可以把 <code>tcp_abort_on_overflow</code> 设置为 1 ，表示⽤ RST 通知客户端连接建⽴失败。</p>
<p>如果 accpet 队列溢出严重，可以通过 listen 函数的 backlog 参数和 somaxconn 系统参数提⾼队列⼤ ⼩，accept 队列⻓度取决于 min(backlog, somaxconn)。</p>
<h4 id="5-1-4-3、绕过三次握手"><a href="#5-1-4-3、绕过三次握手" class="headerlink" title="5.1.4.3、绕过三次握手"></a>5.1.4.3、绕过三次握手</h4><p><font color='orange'>TCP Fast Open 功能可以绕过三次握⼿，使得 HTTP 请求减少 1 个 RTT 时间，Linux 下可以通过 <code>tcp_fastopen</code> 开启该功能，同时必须保证服务端和客户端同时⽀持。</font></p>
<h2 id="5-2、提升TCP四次挥手性能"><a href="#5-2、提升TCP四次挥手性能" class="headerlink" title="5.2、提升TCP四次挥手性能"></a>5.2、提升TCP四次挥手性能</h2><p>开始之前，需要先了解四次挥⼿状态变迁过程。 </p>
<p><font color='orange'>客户端和服务端双⽅都可以 主动断开连接，通常先关闭连接的⼀⽅称为 主动⽅，后关闭连接的⼀⽅称为 被动⽅。</font></p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418204051701.png" alt="image-20210418204051701"></p>
<p>可以看到，四次挥⼿过程只涉及了两种报⽂，分别是 FIN 和 ACK：</p>
<ul>
<li>FIN 就是结束连接的意思，谁发出 FIN 报⽂，就表示它将不会再发送任何数据，关闭这⼀⽅向上的 传输通道；</li>
<li>ACK 就是确认的意思，⽤来通知对⽅：你⽅的发送通道已经关闭；</li>
</ul>
<p>四次挥⼿过程：</p>
<ol>
<li>当主动⽅关闭连接时，会发送 FIN 报⽂，此时发送⽅的 TCP 连接将从 ESTABLISHED 变成 FIN_WAIT1。</li>
<li>当被动⽅收到 FIN 报⽂后会⾃动回复 ACK 报⽂，连接状态将从 ESTABLISHED 变成 CLOSE_WAIT，表示被动⽅在等待进程调⽤ close 函数关闭连接。</li>
<li>当主动⽅收到这个 ACK 后，连接状态由 FIN_WAIT1 变为 FIN_WAIT2，也就是表示主动⽅的发送通 道就关闭了。</li>
<li>当被动⽅进⼊ CLOSE_WAIT 时，被动⽅还会继续处理数据，等到进程的 read 函数返回 0 后，应⽤ 程序就会调⽤ close 函数，进⽽触发内核发送 FIN 报⽂，此时被动⽅的连接状态变为 LAST_ACK。</li>
<li>当主动⽅收到这个 FIN 报⽂后，内核会回复 ACK 报⽂给被动⽅，同时主动⽅的连接状态由 FIN_WAIT2 变为 TIME_WAIT，在 Linux 系统下⼤约等待 1 分钟后，TIME_WAIT 状态的连接才会 彻底关闭。</li>
<li>当被动⽅收到最后的 ACK 报⽂后，被动⽅的连接就会关闭。</li>
</ol>
<p>你可以看到，每个⽅向都需要⼀个 FIN 和⼀个 ACK，因此通常被称为 四次挥⼿。</p>
<p><font color='red'>注意：主动关闭连接的，才有 TIME_WAIT 状态。</font></p>
<h3 id="5-2-1、主动方优化"><a href="#5-2-1、主动方优化" class="headerlink" title="5.2.1、主动方优化"></a>5.2.1、主动方优化</h3><p><font color='orange'>关闭连接的⽅式通常有两种，分别是 RST报⽂关闭 和 FIN报⽂关闭。</font></p>
<p>如果进程异常退出了，内核就会发送 RST 报⽂来关闭，它可以不⾛四次挥⼿流程，是⼀个暴⼒关闭连接的⽅式。</p>
<p>安全关闭连接的⽅式必须通过四次挥⼿，它由进程调⽤ close 和 shutdown 函数发起 FIN 报⽂ （shutdown 参数须传⼊ <code>SHUT_WR</code> 或者 <code>SHUT_RDWR</code> 才会发送 FIN）。</p>
<h4 id="5-2-1-1、-close-函数和-shutdown-函数有什么区别？"><a href="#5-2-1-1、-close-函数和-shutdown-函数有什么区别？" class="headerlink" title="5.2.1.1、 close 函数和 shutdown 函数有什么区别？"></a>5.2.1.1、 close 函数和 shutdown 函数有什么区别？</h4><p>调⽤了 close 函数意味着完全断开连接，完全断开后⽆法传输数据，且也不能发送数据。 此时， 调⽤了 close 函数的⼀⽅的连接叫做「孤⼉连接」，如果你⽤ netstat -p 命令，会发现连接对应的进程名为空。</p>
<p>使⽤ close 函数关闭连接是不优雅的。于是，就出现了⼀种优雅关闭连接的 shutdown 函数，它可以控制只关闭⼀个⽅向的连接：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418204332745.png" alt="image-20210418204332745"></p>
<p>第⼆个参数决定断开连接的⽅式，主要有以下三种⽅式：</p>
<ul>
<li>SHUT_RD(0)：关闭连接的「读」这个⽅向，如果接收缓冲区有已接收的数据，则将会被丢弃，并 且后续再收到新的数据，会对数据进⾏ ACK，然后悄悄地丢弃。也就是说，对端还是会接收到 ACK，在这种情况下根本不知道数据已经被丢弃了。</li>
<li>SHUT_WR(1)：关闭连接的「写」这个⽅向，这就是常被称为「半关闭」的连接。如果发送缓冲区 还有未发送的数据，将被⽴即发送出去，并发送⼀个 FIN 报⽂给对端。</li>
<li>SHUT_RDWR(2)：相当于 SHUT_RD 和 SHUT_WR 操作各⼀次，关闭套接字的读和写两个⽅向。</li>
</ul>
<p>close 和 shutdown 函数都可以关闭连接，但这两种⽅式关闭的连接，不仅仅在功能上存在差异，控制它们的 Linux 参数也不相同。</p>
<h4 id="5-2-1-2、FIN-WAIT1-状态的优化"><a href="#5-2-1-2、FIN-WAIT1-状态的优化" class="headerlink" title="5.2.1.2、FIN_WAIT1 状态的优化"></a>5.2.1.2、FIN_WAIT1 状态的优化</h4><p>主动⽅发送 FIN 报⽂后，连接就处于 FIN_WAIT1 状态，正常情况下，如果能及时收到被动⽅的 ACK， 则会很快变为 FIN_WAIT2 状态。</p>
<p>但是当迟迟收不到对⽅返回的 ACK 时，连接就会⼀直处于 FIN_WAIT1 状态。此时，内核会定时重发 FIN 报⽂，其中重发次数由 <code>tcp_orphan_retries</code> 参数控制（注意，orphan 虽然是孤⼉的意思，该参数 却不只对孤⼉连接有效，事实上，它对所有 FIN_WAIT1 状态下的连接都有效），默认值是 0。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418204448802.png" alt="image-20210418204448802"></p>
<p>你可能会好奇，这 0 表示⼏次？实际上当为 0 时，特指 8 次，从下⾯的内核源码可知：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418204505382.png" alt="image-20210418204505382"></p>
<p>如果 FIN_WAIT1 状态连接很多，我们就需要考虑降低 tcp_orphan_retries 的值，当᯿传次数超过 tcp_orphan_retries 时，连接就会直接关闭掉。</p>
<p>对于普遍正常情况时，调低 tcp_orphan_retries 就已经可以了。如果遇到恶意攻击，FIN 报⽂根本⽆法 发送出去，这由 TCP 两个特性导致的：</p>
<ul>
<li>⾸先，TCP 必须保证报⽂是有序发送的，FIN 报⽂也不例外，当发送缓冲区还有数据没有发送时， FIN 报⽂也不能提前发送。</li>
<li>其次，TCP 有流量控制功能，当接收⽅接收窗⼝为 0 时，发送⽅就不能再发送数据。所以，当攻击 者下载⼤⽂件时，就可以通过接收窗⼝设为 0 ，这就会使得 FIN 报⽂都⽆法发送出去，那么连接会 ⼀直处于 FIN_WAIT1 状态。</li>
</ul>
<p>解决这种问题的⽅法，是调整 tcp_max_orphans 参数，它定义了「孤⼉连接」的最⼤数量：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418204559635.png" alt="image-20210418204559635"></p>
<p>当进程调⽤了 close 函数关闭连接，此时连接就会是「孤⼉连接」，因为它⽆法再发送和接收数据。 Linux 系统为了防⽌孤⼉连接过多，导致系统资源⻓时间被占⽤，就提供了 tcp_max_orphans 参数。 如果孤⼉连接数量⼤于它，新增的孤⼉连接将不再⾛四次挥⼿，⽽是直接发送 RST 复位报⽂强制关 闭。</p>
<h4 id="5-2-1-3、FIN-WAIT2-状态的优化"><a href="#5-2-1-3、FIN-WAIT2-状态的优化" class="headerlink" title="5.2.1.3、FIN_WAIT2 状态的优化"></a>5.2.1.3、FIN_WAIT2 状态的优化</h4><p>当主动⽅收到 ACK 报⽂后，会处于 FIN_WAIT2 状态，就表示主动⽅的发送通道已经关闭，接下来将等待对⽅发送 FIN 报⽂，关闭对⽅的发送通道。</p>
<p>这时，如果连接是⽤ shutdown 函数关闭的，连接可以⼀直处于 FIN_WAIT2 状态，因为它可能还可以 发送或接收数据。但对于 close 函数关闭的孤⼉连接，由于⽆法再发送和接收数据，所以这个状态不可以持续太久，⽽ tcp_fin_timeout 控制了这个状态下连接的持续时⻓，默认值是 60 秒：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418204818957.png" alt="image-20210418204818957"></p>
<p>它意味着对于孤⼉连接（调⽤ close 关闭的连接），如果在 60 秒后还没有收到 FIN 报⽂，连接就会直 接关闭。</p>
<p>这个 60 秒不是随便决定的，它与 TIME_WAIT 状态持续的时间是相同的，后⾯我们再来说说为什么是 60 秒。</p>
<h4 id="5-2-1-4、TIME-WAIT-状态的优化"><a href="#5-2-1-4、TIME-WAIT-状态的优化" class="headerlink" title="5.2.1.4、TIME_WAIT 状态的优化"></a>5.2.1.4、TIME_WAIT 状态的优化</h4><p>TIME_WAIT 是主动⽅四次挥⼿的最后⼀个状态，也是最常遇⻅的状态。</p>
<p>当收到被动⽅发来的 FIN 报⽂后，主动⽅会⽴刻回复 ACK，表示确认对⽅的发送通道已经关闭，接着 就处于 TIME_WAIT 状态。在 Linux 系统，TIME_WAIT 状态会持续 60 秒后才会进⼊关闭状态。</p>
<p>TIME_WAIT 状态的连接，在主动⽅看来确实快已经关闭了。然后，被动⽅没有收到 ACK 报⽂前，还是处于 <code>LAST_ACK</code> 状态。如果这个 ACK 报⽂没有到达被动⽅，被动⽅就会重发 FIN 报⽂。重发次数仍然由前⾯介绍过的 <code>tcp_orphan_retries</code>参数控制。</p>
<p>TIME-WAIT 的状态尤其重要，主要是两个原因：</p>
<ul>
<li>防⽌具有相同「四元组」的「旧」数据包被收到；</li>
<li>保证「被动关闭连接」的⼀⽅能被正确的关闭，即保证最后的 ACK 能让被动关闭⽅接收，从⽽帮 助其正常关闭；</li>
</ul>
<p><strong>原因⼀：防⽌旧连接的数据包</strong></p>
<p>TIME-WAIT 的⼀个作⽤是防⽌收到历史数据，从⽽导致数据错乱的问题。</p>
<p>假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发⽣什么呢？</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205021190.png" alt="image-20210418205021190"></p>
<ul>
<li>如上图⻩⾊框框服务端在关闭连接之前发送的 SEQ &#x3D; 301 报⽂，被⽹络延迟了。</li>
<li>这时有相同端⼝的 TCP 连接被复⽤后，被延迟的 SEQ &#x3D; 301 抵达了客户端，那么客户端是有可能 正常接收这个过期的报⽂，这就会产⽣数据错乱等严᯿的问题。</li>
</ul>
<p>所以，TCP 就设计出了这么⼀个机制，经过 2MSL 这个时间，⾜以让两个⽅向上的数据包都被丢弃， 使得原来连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣的。</p>
<p><strong>原因⼆：保证连接正确关闭</strong></p>
<p>TIME-WAIT 的另外⼀个作⽤是等待⾜够的时间以确保最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正 常关闭。</p>
<p>假设 TIME-WAIT 没有等待时间或时间过短，断开连接会造成什么问题呢？</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205117533.png" alt="image-20210418205117533"></p>
<ul>
<li>如上图红⾊框框客户端四次挥⼿的最后⼀个 ACK 报⽂如果在⽹络中被丢失了，此时如果客户端 TIME-WAIT 过短或没有，则就直接进⼊了 CLOSE 状态了，那么服务端则会⼀直处在 LAST-ACK 状态。</li>
<li>当客户端发起建⽴连接的 SYN 请求报⽂后，服务端会发送 RST 报⽂给客户端，连接建⽴的过程 就会被终⽌。</li>
</ul>
<p>我们再回过头来看看，为什么 TIME_WAIT 状态要保持 60 秒呢？这与孤⼉连接 FIN_WAIT2 状态默认保 留 60 秒的原理是⼀样的，因为这两个状态都需要保持 2MSL 时⻓。MSL 全称是 Maximum Segment Lifetime，它定义了⼀个报⽂在⽹络中的最⻓⽣存时间（报⽂每经过⼀次路由器的转发，IP 头部的 TTL 字段就会减 1，减到 0 时报⽂就被丢弃，这就限制了报⽂的最⻓存活时间）。</p>
<p>为什么是 2 MSL 的时⻓呢？这其实是相当于⾄少允许报⽂丢失⼀次。⽐如，若 ACK 在⼀个 MSL 内丢 失，这样被动⽅᯿发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。</p>
<p>为什么不是 4 或者 8 MSL 的时⻓呢？你可以想象⼀个丢包率达到百分之⼀的糟糕⽹络，连续两次丢包 的概率只有万分之⼀，这个概率实在是太⼩了，忽略它⽐解决它更具性价⽐。</p>
<p>因此，TIME_WAIT 和 FIN_WAIT2 状态的最⼤时⻓都是 2 MSL，由于在 Linux 系统中，MSL 的值固定 为 30 秒，所以它们都是 60 秒。</p>
<p>虽然 TIME_WAIT 状态有存在的必要，但它毕竟会消耗系统资源。如果发起连接⼀⽅的 TIME_WAIT 状 态过多，占满了所有端⼝资源，则会导致⽆法创建新连接。 </p>
<ul>
<li><p>客户端受端⼝资源限制</p>
<p>如果客户端 TIME_WAIT 过多，就会导致端⼝资源被占⽤，因为端⼝就 65536个，被占满就会导致⽆法创建新的连接；</p>
</li>
<li><p>服务端受系统资源限制</p>
<p>由于⼀个四元组表示TCP连接，理论上服务端可以建⽴很多连接，服务端 确实只监听⼀个端⼝，但是会把连接扔给处理线程，所以理论上监听的端⼝可以继续监听。但是线 程池处理不了那么多⼀直不断的连接了。所以当服务端出现⼤量 TIME_WAIT 时，系统资源被占满 时，会导致处理不过来新的连接；</p>
</li>
</ul>
<p>另外，Linux 提供了 tcp_max_tw_buckets 参数，当 TIME_WAIT 的连接数量超过该参数时，新关闭 的连接就不再经历 TIME_WAIT ⽽直接关闭：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205305424.png" alt="image-20210418205305424"></p>
<p>当服务器的并发连接增多时，相应地，同时处于 TIME_WAIT 状态的连接数量也会变多，此时就应当调 ⼤ tcp_max_tw_buckets 参数，减少不同连接间数据错乱的概率。</p>
<p>tcp_max_tw_buckets 也不是越⼤越好，毕竟内存和端⼝都是有限的。</p>
<p>有⼀种⽅式可以在建⽴新连接时，复⽤处于 TIME_WAIT 状态的连接，那就是打开 tcp_tw_reuse 参 数。但是需要注意，该参数是只⽤于客户端（建⽴连接的发起⽅），因为是在调⽤ connect() 时起作⽤ 的，⽽对于服务端（被动连接⽅）是没有⽤的。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205329777.png" alt="image-20210418205329777"></p>
<p>tcp_tw_reuse 从协议⻆度理解是安全可控的，可以复⽤处于 TIME_WAIT 的端⼝为新的连接所⽤。</p>
<p>什么是协议⻆度理解的安全可控呢？主要有两点：</p>
<ul>
<li>只适⽤于连接发起⽅，也就是 C&#x2F;S 模型中的客户端；</li>
<li>对应的 TIME_WAIT 状态的连接创建时间超过 1 秒才可以被复⽤。</li>
</ul>
<p>使⽤这个选项，还有⼀个前提，需要打开对 TCP 时间戳的⽀持（对⽅也要打开 ）：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205420700.png" alt="image-20210418205420700"></p>
<p>由于引⼊了时间戳，它能带来了些好处：</p>
<ul>
<li>我们在前⾯提到的 2MSL 问题就不复存在了，因为᯿复的数据包会因为时间戳过期被⾃然丢弃；</li>
<li>同时，它还可以防⽌序列号绕回，也是因为᯿复的数据包会由于时间戳过期被⾃然丢弃；</li>
</ul>
<p>时间戳是在 TCP 的选项字段⾥定义的，开启了时间戳功能，在 TCP 报⽂传输的时候会带上发送报⽂的 时间戳。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205502767.png" alt="image-20210418205502767"></p>
<p>我们来看看开启了 tcp_tw_reuse 功能，如果四次挥⼿中的最后⼀次 ACK 在⽹络中丢失了，会发⽣什么？</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205550656.png" alt="image-20210418205550656"></p>
<p>上图的流程：</p>
<ul>
<li>四次挥⼿中的最后⼀次 ACK 在⽹络中丢失了，服务端⼀直处于 LAST_ACK 状态；</li>
<li>客户端由于开启了 tcp_tw_reuse 功能，客户端再次发起新连接的时候，会复⽤超过 1 秒后的 time_wait 状态的连接。但客户端新发的 SYN 包会被忽略（由于时间戳），因为服务端⽐较了客户 端的上⼀个报⽂与 SYN 报⽂的时间戳，过期的报⽂就会被服务端丢弃；</li>
<li>服务端 FIN 报⽂迟迟没有收到四次挥⼿的最后⼀次 ACK，于是超时᯿发了 FIN 报⽂给客户端；</li>
<li>处于 SYN_SENT 状态的客户端，由于收到了 FIN 报⽂，则会回 RST 给服务端，于是服务端就离开 了 LAST_ACK 状态；</li>
<li>最初的客户端 SYN 报⽂超时重发了（ 1 秒钟后），此时就与服务端能正确的三次握⼿了。</li>
</ul>
<p>所以⼤家都会说开启了 tcp_tw_reuse，可以在复⽤了 time_wait 状态的 1 秒过后成功建⽴连接，这 1 秒 主要是花费在 SYN 包᯿传。</p>
<p>另外，⽼版本的 Linux 还提供了 tcp_tw_recycle 参数，但是当开启了它，就有两个坑：</p>
<ul>
<li>Linux 会加快客户端和服务端 TIME_WAIT 状态的时间，也就是它会使得 TIME_WAIT 状态会⼩于 60 秒，很容易导致数据错乱；</li>
<li>另外，Linux 会丢弃所有来⾃远端时间戳⼩于上次记录的时间戳（由同⼀个远端发送的）的任何数 据包。就是说要使⽤该选项，则必须保证数据包的时间戳是单调递增的。那么，问题在于，此处的 时间戳并不是我们通常意义上⾯的绝对时间，⽽是⼀个相对时间。很多情况下，我们是没法保证时 间戳单调递增的，⽐如使⽤了 NAT、LVS 等情况；</li>
</ul>
<p>所以，不建议设置为 1 ，在 Linux 4.12 版本后，Linux 内核直接取消了这⼀参数，建议关闭它：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205726162.png" alt="image-20210418205726162"></p>
<p>另外，我们可以在程序中设置 socket 选项，来设置调⽤ close 关闭连接⾏为。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205745092.png" alt="image-20210418205745092"></p>
<p>如果 l_onoff 为⾮ 0， 且 l_linger 值为 0，那么调⽤ close 后，会⽴该发送⼀个 RST 标志给对 端，该 TCP 连接将跳过四次挥⼿，也就跳过了 TIME_WAIT 状态，直接关闭。</p>
<p>但这为跨越 TIME_WAIT 状态提供了⼀个可能，不过是⼀个⾮常危险的⾏为，不值得提倡。</p>
<h3 id="5-2-2、被动方优化"><a href="#5-2-2、被动方优化" class="headerlink" title="5.2.2、被动方优化"></a>5.2.2、被动方优化</h3><p>当被动⽅收到 FIN 报⽂时，内核会⾃动回复 ACK，同时连接处于 CLOSE_WAIT 状态，顾名思义，它表示等待应⽤进程调⽤ close 函数关闭连接。</p>
<p>内核没有权利替代进程去关闭连接，因为如果主动⽅是通过 shutdown 关闭连接，那么它就是想在半关 闭连接上接收数据或发送数据。因此，Linux 并没有限制 CLOSE_WAIT 状态的持续时间。</p>
<p>当然，⼤多数应⽤程序并不使⽤ shutdown 函数关闭连接。所以，当你⽤ netstat 命令发现⼤量 CLOSE_WAIT 状态。就需要排查你的应⽤程序，因为可能因为应⽤程序出现了 Bug，read 函数返回 0 时，没有调⽤ close 函数。</p>
<p>处于 CLOSE_WAIT 状态时，调⽤了 close 函数，内核就会发出 FIN 报⽂关闭发送通道，同时连接进⼊ LAST_ACK 状态，等待主动⽅返回 ACK 来确认连接关闭。</p>
<p>如果迟迟收不到这个 ACK，内核就会重发 FIN 报⽂，᯿发次数仍然由 tcp_orphan_retries 参数控制，这 与主动⽅重发 FIN 报⽂的优化策略⼀致。</p>
<p>还有⼀点我们需要注意的，如果被动⽅迅速调⽤ close 函数，那么被动⽅的 ACK 和 FIN 有可能在⼀个 报⽂中发送，这样看起来，四次挥⼿会变成三次挥⼿，这只是⼀种特殊情况，不⽤在意。</p>
<h4 id="5-2-2-1、如果连接双⽅同时关闭连接，会怎么样？"><a href="#5-2-2-1、如果连接双⽅同时关闭连接，会怎么样？" class="headerlink" title="5.2.2.1、如果连接双⽅同时关闭连接，会怎么样？"></a>5.2.2.1、如果连接双⽅同时关闭连接，会怎么样？</h4><p>由于 TCP 是双全⼯的协议，所以是会出现两⽅同时关闭连接的现象，也就是同时发送了 FIN 报⽂。</p>
<p>此时，上⾯介绍的优化策略仍然适⽤。两⽅发送 FIN 报⽂时，都认为⾃⼰是主动⽅，所以都进⼊了 FIN_WAIT1 状态，FIN 报⽂的᯿发次数仍由 tcp_orphan_retries 参数控制。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418205925842.png" alt="image-20210418205925842"></p>
<p>接下来，双⽅在等待 ACK 报⽂的过程中，都等来了 FIN 报⽂。这是⼀种新情况，所以连接会进⼊⼀种 叫做 CLOSING 的新状态，它替代了 FIN_WAIT2 状态。接着，双⽅内核回复 ACK 确认对⽅发送通道 的关闭后，进⼊ TIME_WAIT 状态，等待 2MSL 的时间后，连接⾃动关闭。</p>
<h3 id="5-2-3、小结"><a href="#5-2-3、小结" class="headerlink" title="5.2.3、小结"></a>5.2.3、小结</h3><p>针对 TCP 四次挥⼿的优化，我们需要根据主动⽅和被动⽅四次挥⼿状态变化来调整系统 TCP 内核参数。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418210021774.png" alt="image-20210418210021774"></p>
<h4 id="5-2-3-1、主动方优化"><a href="#5-2-3-1、主动方优化" class="headerlink" title="5.2.3.1、主动方优化"></a>5.2.3.1、主动方优化</h4><p>主动发起 FIN 报⽂断开连接的⼀⽅，如果迟迟没收到对⽅的 ACK 回复，则会重传 FIN 报⽂，重传次数 由 tcp_orphan_retries 参数决定。</p>
<p>当主动⽅收到 ACK 报⽂后，连接就进⼊ FIN_WAIT2 状态，根据关闭的⽅式不同，优化的⽅式也不同：</p>
<ul>
<li>如果这是 close 函数关闭的连接，那么它就是孤⼉连接。如果 tcp_fin_timeout 秒内没有收到对 ⽅的 FIN 报⽂，连接就直接关闭。同时，为了应对孤⼉连接占⽤太多的资源， tcp_max_orphans 定义了最⼤孤⼉连接的数量，超过时连接就会直接释放。</li>
<li>反之是 shutdown 函数关闭的连接，则不受此参数限制；</li>
</ul>
<p>当主动⽅接收到 FIN 报⽂，并返回 ACK 后，主动⽅的连接进⼊ TIME_WAIT 状态。这⼀状态会持续 1 分钟，为了防⽌ TIME_WAIT 状态占⽤太多的资源， tcp_max_tw_buckets 定义了最⼤数量，超过时连 接也会直接释放。</p>
<p>当 TIME_WAIT 状态过多时，还可以通过设置 tcp_tw_reuse 和 tcp_timestamps 为 1 ，将 TIME_WAIT 状态的端⼝复⽤于作为客户端的新连接，注意该参数只适⽤于客户端。</p>
<h4 id="5-2-3-2、被动⽅的优化"><a href="#5-2-3-2、被动⽅的优化" class="headerlink" title="5.2.3.2、被动⽅的优化"></a>5.2.3.2、被动⽅的优化</h4><p>被动关闭的连接⽅应对⾮常简单，它在回复 ACK 后就进⼊了 CLOSE_WAIT 状态，等待进程调⽤ close 函数关闭连接。因此，出现⼤量 CLOSE_WAIT 状态的连接时，应当从应⽤程序中找问题。</p>
<p>当被动⽅发送 FIN 报⽂后，连接就进⼊ LAST_ACK 状态，在未等到 ACK 时，会在 tcp_orphan_retries 参数的控制下重发 FIN 报⽂。</p>
<h2 id="5-3、提升TCP传输数据性能"><a href="#5-3、提升TCP传输数据性能" class="headerlink" title="5.3、提升TCP传输数据性能"></a>5.3、提升TCP传输数据性能</h2><p>在前⾯介绍的是三次握⼿和四次挥⼿的优化策略，接下来主要介绍的是 TCP 传输数据时的优化策略。</p>
<p><font color='orange'>TCP 连接由内核维护，内核会为每个连接建⽴内存缓冲区：</font></p>
<ul>
<li>如果连接的内存配置过⼩，就⽆法充分使⽤⽹络带宽，TCP 传输效率就会降低；</li>
<li>如果连接的内存配置过⼤，很容易把服务器资源耗尽，这样就会导致新连接⽆法建⽴；</li>
</ul>
<p>因此，我们必须理解 Linux 下 TCP 内存的⽤途，才能正确地配置内存⼤⼩。</p>
<h3 id="5-3-1、滑动窗⼝影响传输速度"><a href="#5-3-1、滑动窗⼝影响传输速度" class="headerlink" title="5.3.1、滑动窗⼝影响传输速度"></a>5.3.1、滑动窗⼝影响传输速度</h3><p>TCP 会保证每⼀个报⽂都能够抵达对⽅，它的机制是：报⽂发出去后，必须接收到对⽅返回的确认报⽂ ACK，如果迟迟未收到，就会超时重发该报⽂，直到收到对⽅的 ACK 为⽌。</p>
<p>所以，TCP 报⽂发出去后，并不会⽴⻢从内存中删除，因为重传时还需要⽤到它。</p>
<p>由于 TCP 是内核维护的，所以报⽂存放在内核缓冲区。如果连接⾮常多，我们可以通过 free 命令观察到 buff&#x2F;cache 内存是否增⼤。</p>
<p>如果 TCP 是每发送⼀个数据，都要进⾏⼀次确认应答。当上⼀个数据包收到了应答了， 再发送下⼀ 个。这个模式就有点像我和你⾯对⾯聊天，你⼀句我⼀句，但这种⽅式的缺点就是 效率很低。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418210742380.png" alt="image-20210418210742380"></p>
<p>所以，这样的传输⽅式有⼀个缺点：<font color='orange'>数据包的往返时间越⻓，通信的效率就越低。</font></p>
<p>要解决这⼀问题不难，并⾏批量发送报⽂，再批量确认报⽂即可。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418210838615.png" alt="image-20210418210838615"></p>
<p>然⽽，这引出了另⼀个问题，发送⽅可以随⼼所欲的发送报⽂吗？当然不行，我们还得考虑接收⽅的处理能⼒。</p>
<p>当接收⽅硬件不如发送⽅，或者系统繁忙、资源紧张时，是⽆法瞬间处理这么多报⽂的。于是，这些报 ⽂只能被丢掉，使得⽹络效率⾮常低。</p>
<p>为了解决这种现象发⽣，TCP 提供⼀种机制可以让「发送⽅」根据「接收⽅」的实际接收能⼒控制发送 的数据量，这就是滑动窗⼝的由来。</p>
<p>接收⽅根据它的缓冲区，可以计算出后续能够接收多少字节的报⽂，这个数字叫做接收窗⼝。当内核接 收到报⽂时，必须⽤缓冲区存放它们，这样剩余缓冲区空间变⼩，接收窗⼝也就变⼩了；当进程调⽤ read 函数后，数据被读⼊了⽤户空间，内核缓冲区就被清空，这意味着主机可以接收更多的报⽂，接收 窗⼝就会变⼤。</p>
<p>因此，接收窗⼝并不是恒定不变的，接收⽅会把当前可接收的⼤⼩放在 TCP 报⽂头部中的窗⼝字段， 这样就可以起到窗⼝⼤⼩通知的作⽤。</p>
<p>发送⽅的窗⼝等价于接收⽅的窗⼝吗？如果不考虑拥塞控制，发送⽅的窗⼝⼤⼩「约等于」接收⽅的窗⼝⼤⼩，因为窗⼝通知报⽂在⽹络传输是存在时延的，所以是约等于的关系。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418211048586.png" alt="image-20210418211048586"></p>
<p>从上图中可以看到，窗⼝字段只有 2 个字节，因此它最多能表达 65535 字节⼤⼩的窗⼝，也就是 64KB ⼤⼩。</p>
<p>这个窗⼝⼤⼩最⼤值，在当今⾼速⽹络下，很明显是不够⽤的。所以后续有了扩充窗⼝的⽅法：在 TCP 选项字段定义了窗⼝扩⼤因⼦，⽤于扩⼤ TCP 通告窗⼝，其值⼤⼩是 2^14，这样就使 TCP 的窗⼝⼤ ⼩从 16 位扩⼤为 30 位（2^16 * 2^ 14 &#x3D; 2^30），所以此时窗⼝的最⼤值可以达到 1GB。</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418211130135.png" alt="image-20210418211130135"></p>
<p>Linux 中打开这⼀功能，需要把 <code>tcp_window_scaling</code> 配置设为 1（默认打开）：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418211148700.png" alt="image-20210418211148700"></p>
<p>要使⽤窗⼝扩⼤选项，通讯双⽅必须在各⾃的 SYN 报⽂中发送这个选项：</p>
<ul>
<li>主动建⽴连接的⼀⽅在 SYN 报⽂中发送这个选项；</li>
<li>⽽被动建⽴连接的⼀⽅只有在收到带窗⼝扩⼤选项的 SYN 报⽂之后才能发送这个选项。</li>
</ul>
<p>这样看来，只要进程能及时地调⽤ read 函数读取数据，并且接收缓冲区配置得⾜够⼤，那么接收窗⼝ 就可以⽆限地放⼤，发送⽅也就⽆限地提升发送速度。</p>
<p>这是不可能的，因为⽹络的传输能⼒是有限的，当发送⽅依据发送窗⼝，发送超过⽹络处理能⼒的报⽂ 时，路由器会直接丢弃这些报⽂。因此，缓冲区的内存并不是越⼤越好。</p>
<h3 id="5-3-2、确定最⼤传输速度"><a href="#5-3-2、确定最⼤传输速度" class="headerlink" title="5.3.2、确定最⼤传输速度"></a>5.3.2、确定最⼤传输速度</h3><p>我们知道 TCP 的传输速度受制于发送窗⼝与接收窗⼝，以及⽹络设备传输能⼒。其中，窗⼝⼤⼩由内核缓冲区⼤⼩决定。如果缓冲区与⽹络传输能⼒匹配，那么缓冲区的利⽤率就达到了最⼤化。</p>
<p>问题来了，如何计算⽹络的传输能⼒呢？</p>
<p>相信⼤家都知道⽹络是有「带宽」限制的，带宽描述的是⽹络传输能⼒，它与内核缓冲区的计量单位不同：</p>
<ul>
<li>带宽是单位时间内的流量，表达是「速度」，⽐如常⻅的带宽 100 MB&#x2F;s；</li>
<li>缓冲区单位是字节，当⽹络速度乘以时间才能得到字节数；</li>
</ul>
<p>这⾥需要说⼀个概念，就是带宽时延积，它决定⽹络中⻜⾏报⽂的⼤⼩，它的计算⽅式</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418211558531.png" alt="image-20210418211558531"></p>
<p>⽐如最⼤带宽是 100 MB&#x2F;s，⽹络时延（RTT）是 10ms 时，意味着客户端到服务端的⽹络⼀共可以存 放 100MB&#x2F;s * 0.01s &#x3D; 1MB 的字节。</p>
<p>这个 1MB 是带宽和时延的乘积，所以它就叫「带宽时延积」（缩写为 BDP，Bandwidth Delay Product）。同时，这 1MB 也表示「⻜⾏中」的 TCP 报⽂⼤⼩，它们就在⽹络线路、路由器等⽹络设 备上。如果⻜⾏报⽂超过了 1 MB，就会导致⽹络过载，容易丢包。</p>
<p>由于发送缓冲区⼤⼩决定了发送窗⼝的上限，⽽发送窗⼝⼜决定了「已发送未确认」的⻜⾏报⽂的上 限。因此，发送缓冲区不能超过「带宽时延积」。</p>
<p>发送缓冲区与带宽时延积的关系：</p>
<ul>
<li>如果发送缓冲区「超过」带宽时延积，超出的部分就没办法有效的⽹络传输，同时导致⽹络过载， 容易丢包；</li>
<li>如果发送缓冲区「⼩于」带宽时延积，就不能很好的发挥出⽹络的传输效率。</li>
</ul>
<p>所以，发送缓冲区的⼤⼩最好是往带宽时延积靠近。</p>
<h3 id="5-3-3、调整缓冲区大小"><a href="#5-3-3、调整缓冲区大小" class="headerlink" title="5.3.3、调整缓冲区大小"></a>5.3.3、调整缓冲区大小</h3><p><font color='orange'>在 Linux 中发送缓冲区和接收缓冲都可以⽤参数调节。设置完后，Linux 会根据你设置的缓冲区进⾏动态调节。</font></p>
<h4 id="5-3-3-1、调节发送缓冲区范围"><a href="#5-3-3-1、调节发送缓冲区范围" class="headerlink" title="5.3.3.1、调节发送缓冲区范围"></a>5.3.3.1、调节发送缓冲区范围</h4><p>先来看看发送缓冲区，它的范围通过 <code>tcp_wmem</code> 参数配置；</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418211755905.png" alt="image-20210418211755905"></p>
<p>上⾯三个数字单位都是字节，它们分别表示：</p>
<ul>
<li>第⼀个数值是动态范围的最⼩值，4096 byte &#x3D; 4K；</li>
<li>第⼆个数值是初始默认值，87380 byte ≈ 86K；</li>
<li>第三个数值是动态范围的最⼤值，4194304 byte &#x3D; 4096K（4M）；</li>
</ul>
<p>发送缓冲区是⾃⾏调节的，当发送⽅发送的数据被确认后，并且没有新的数据要发送，就会把发送缓冲区的内存释放掉。</p>
<h4 id="5-3-3-2、调节接收缓冲区范围"><a href="#5-3-3-2、调节接收缓冲区范围" class="headerlink" title="5.3.3.2、调节接收缓冲区范围"></a>5.3.3.2、调节接收缓冲区范围</h4><p>⽽接收缓冲区的调整就⽐较复杂⼀些，先来看看设置接收缓冲区范围的 tcp_rmem 参数：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418211857927.png" alt="image-20210418211857927"></p>
<p>上⾯三个数字单位都是字节，它们分别表示：</p>
<ul>
<li>第⼀个数值是动态范围的最⼩值，表示即使在内存压⼒下也可以保证的最⼩接收缓冲区⼤⼩，4096 byte &#x3D; 4K；</li>
<li>第⼆个数值是初始默认值，87380 byte ≈ 86K；</li>
<li>第三个数值是动态范围的最⼤值，6291456 byte &#x3D; 6144K（6M）；</li>
</ul>
<p>接收缓冲区可以根据系统空闲内存的⼤⼩来调节接收窗⼝：</p>
<ul>
<li>如果系统的空闲内存很多，就可以⾃动把缓冲区增⼤⼀些，这样传给对⽅的接收窗⼝也会变⼤，因 ⽽提升发送⽅发送的传输数据数量；</li>
<li>反之，如果系统的内存很紧张，就会减少缓冲区，这虽然会降低传输效率，可以保证更多的并发连 接正常⼯作；</li>
</ul>
<p>发送缓冲区的调节功能是⾃动开启的，⽽接收缓冲区则需要配置 <code>tcp_moderate_rcvbuf</code> 为 1 来开启调节功能：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418212006158.png" alt="image-20210418212006158"></p>
<h4 id="5-3-3-3、调节-TCP-内存范围"><a href="#5-3-3-3、调节-TCP-内存范围" class="headerlink" title="5.3.3.3、调节 TCP 内存范围"></a>5.3.3.3、调节 TCP 内存范围</h4><p>接收缓冲区调节时，怎么知道当前内存是否紧张或充分呢？这是通过 <code>tcp_mem</code> 配置完成的：</p>
<p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418212037121.png" alt="image-20210418212037121"></p>
<p>上⾯三个数字单位不是字节，⽽是「⻚⾯⼤⼩」，1 ⻚表示 4KB，它们分别表示：</p>
<ul>
<li>当 TCP 内存⼩于第 1 个值时，不需要进⾏⾃动调节；</li>
<li>在第 1 和第 2 个值之间时，内核开始调节接收缓冲区的⼤⼩；</li>
<li>⼤于第 3 个值时，内核不再为 TCP 分配新内存，此时新连接是⽆法建⽴的；</li>
</ul>
<p>⼀般情况下这些值是在系统启动时根据系统内存数量计算得到的。根据当前 <code>tcp_mem</code> 最⼤内存⻚⾯数是 177120，当内存为 (177120 * 4) &#x2F; 1024K ≈ 692M 时，系统将⽆法为新的 TCP 连接分配内存，即 TCP 连接将被拒绝。</p>
<h4 id="5-3-3-4、根据实际场景调节的策略"><a href="#5-3-3-4、根据实际场景调节的策略" class="headerlink" title="5.3.3.4、根据实际场景调节的策略"></a>5.3.3.4、根据实际场景调节的策略</h4><p>在⾼并发服务器中，为了兼顾⽹速与⼤量的并发连接，我们应当保证缓冲区的动态调整的最⼤值达到带宽时延积，⽽最⼩值保持默认的 4K 不变即可。⽽对于内存紧张的服务⽽⾔，调低默认值是提⾼并发的 有效⼿段。</p>
<p>同时，如果这是⽹络 IO 型服务器，那么，调⼤ <code>tcp_mem</code> 的上限可以让 TCP 连接使⽤更多的系统内存，这有利于提升并发能⼒。需要注意的是，<code>tcp_wmem</code> 和 <code>tcp_rmem</code> 的单位是字节，⽽ <code>tcp_mem</code> 的单位是⻚⾯⼤⼩。⽽且，千万不要在 socket 上直接设置 <code>SO_SNDBUF</code> 或者 <code>SO_RCVBUF</code>，这样会关闭缓冲区的动态调整功能。</p>
<h3 id="5-3-4、小结"><a href="#5-3-4、小结" class="headerlink" title="5.3.4、小结"></a>5.3.4、小结</h3><p><img src="/%5Cimgs%5Cjavadev%5Cimage-20210418212216740.png" alt="image-20210418212216740"></p>
<p><font color='orange'>TCP 可靠性 通过 ACK 确认报⽂实现，⼜依赖滑动窗⼝提升了发送速度也兼顾了接收⽅的处理能⼒。</font></p>
<p>可是，默认的滑动窗⼝最⼤值只有 64 KB，不满⾜当今的⾼速⽹络要求，要提升发送速度必须提升滑动窗⼝上限，在 Linux 下是通过设置 <code>tcp_window_scaling</code> 为 1 做到，此时最⼤值可⾼达 1GB。</p>
<p>滑动窗⼝定义了⽹络中⻜⾏报⽂的最⼤字节数，当它超过带宽时延积时，⽹络过载，就会发⽣丢包。⽽当它⼩于带宽时延积时，就⽆法充分利⽤⽹络带宽。因此，滑动窗⼝的设置，必须参考带宽时延积。</p>
<p>内核缓冲区决定了滑动窗⼝的上限，缓冲区可分为：发送缓冲区 <code>tcp_wmem</code> 和接收缓冲区 <code>tcp_rmem</code>。</p>
<p>Linux 会对缓冲区动态调节，我们应该把缓冲区的上限设置为带宽时延积。发送缓冲区的调节功能是⾃ 动打开的，⽽接收缓冲区需要把 <code>tcp_moderate_rcvbuf</code> 设置为 1 来开启。其中，调节的依据是 TCP 内存范围 <code>tcp_mem</code>。</p>
<p>但需要注意的是，如果程序中的 socket 设置了 <code>SO_SNDBUF</code> 和 <code>SO_RCVBUF</code>，则会关闭缓冲区的动态调整功能，所以不建议在程序中设置它们，⽽是交给内核⾃动调整⽐较好。</p>
<p>有效配置这些参数后，既能够最⼤程度地保持并发性，也能让资源充裕时连接传输速度达到最⼤值。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">豪哥</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://hshz21.gitee.io/2023/07/30/tcp-ji-chu-zhi-shi/">https://hshz21.gitee.io/2023/07/30/tcp-ji-chu-zhi-shi/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">豪哥</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">
                                    <span class="chip bg-color">网络协议</span>
                                </a>
                            
                                <a href="/tags/TCP/">
                                    <span class="chip bg-color">TCP</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wxpay.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/07/30/zong-xian-zhi-shi-zong-jie/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/19.jpg" class="responsive-img" alt="计算机系列-系统总线">
                        
                        <span class="card-title">计算机系列-系统总线</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-07-30
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="post-category">
                                    计算机
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/">
                        <span class="chip bg-color">系统总线</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/07/30/http-ji-chu-zhi-shi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/4.jpg" class="responsive-img" alt="计算机系列-HTTP基础知识">
                        
                        <span class="card-title">计算机系列-HTTP基础知识</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-07-30
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="post-category">
                                    计算机
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">
                        <span class="chip bg-color">网络协议</span>
                    </a>
                    
                    <a href="/tags/HTTP/">
                        <span class="chip bg-color">HTTP</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">豪哥</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">豪哥</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">


    <a href="mailto:3577293158@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=3577293158" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 3577293158" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
