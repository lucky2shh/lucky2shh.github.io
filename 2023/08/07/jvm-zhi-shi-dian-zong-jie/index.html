<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Java系列-JVM, 豪哥博客">
    <meta name="description" content="豪哥个人博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Java系列-JVM | 豪哥博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">豪哥博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">豪哥博客</div>
        <div class="logo-desc">
            
            豪哥个人博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/22.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Java系列-JVM</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JVM/">
                                <span class="chip bg-color">JVM</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/JVM/" class="post-category">
                                JVM
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-08-07
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-08-06
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    34.1k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="0、必知必会"><a href="#0、必知必会" class="headerlink" title="0、必知必会"></a>0、必知必会</h1><h2 id="0-1、Java类加载"><a href="#0-1、Java类加载" class="headerlink" title="0.1、Java类加载"></a>0.1、Java类加载</h2><h3 id="0-1-1、Class文件"><a href="#0-1-1、Class文件" class="headerlink" title="0.1.1、Class文件"></a>0.1.1、Class文件</h3><h4 id="0-1-1-1、简介"><a href="#0-1-1-1、简介" class="headerlink" title="0.1.1.1、简介"></a>0.1.1.1、简介</h4><p><strong>Class文件是一组以8位为基础单位的 二进制流，超过8位以上的会被按照 高位在前 分割成多个8位进行存储。</strong></p>
<p>Class文件格式采用一种类似C语言结构体的伪结构进行数据存储，其中包含两种数据类型，即 无符号数和表 。</p>
<ul>
<li><p><strong>无符号数</strong></p>
<p>无符号数属于【基本数据类型】，以u1、u2、u4、u8分别代表1字节、2字节、4字节、8字节的无符号数。它可以描述数字、索引引用、数量值、utf8编码后的字符串值。</p>
</li>
<li><p><strong>表</strong></p>
<p><em><strong>表是由 多个无符号数和其它表作为数据组成的 复合数据类型</strong></em>。所有表都以<code>_info</code>结尾，用来描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。</p>
</li>
</ul>
<h4 id="0-1-1-2、class文件结构"><a href="#0-1-1-2、class文件结构" class="headerlink" title="0.1.1.2、class文件结构"></a>0.1.1.2、class文件结构</h4><p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210428110838690.png" alt="image-20210428110838690"></p>
<p>classFile结构中，各项含义如下：</p>
<ol>
<li><font color='orange'>magic</font>：魔数</li>
<li><font color='orange'>minor_version&#x2F;major_version</font>：class文件次版本号&#x2F;主版本号</li>
<li><font color='orange'>constant_pool_count</font>：常量池计数器</li>
<li><font color='orange'>constant_pool[constant_pool_count-1]</font>：常量池</li>
<li><font color='orange'>access_flags</font>：访问标志</li>
<li><font color='orange'>this_class</font>：类索引</li>
<li><font color='orange'>super_class</font>：父类索引</li>
<li><font color='orange'>interfaces_count</font>：接口计数器</li>
<li><font color='orange'>interfaces[interfaces_count]</font>：接口表</li>
<li><font color='orange'>fields_count</font>：字段计数器</li>
<li><font color='orange'>fields[fields_count]</font>：字段表</li>
<li><font color='orange'>methods_count</font>：方法计数器</li>
<li><font color='orange'>methods[methods_count]</font>：方法表</li>
<li><font color='orange'>attributes_count</font>：属性计数器</li>
<li><font color='orange'>attributes[attributes_count]</font>：属性表</li>
</ol>
<h3 id="0-1-2、类加载过程"><a href="#0-1-2、类加载过程" class="headerlink" title="0.1.2、类加载过程"></a>0.1.2、类加载过程</h3><h4 id="0-1-2-1、概述"><a href="#0-1-2-1、概述" class="headerlink" title="0.1.2.1、概述"></a>0.1.2.1、概述</h4><p>虚拟机 把 描述类的数据 从Class文件加载到内存，并对数据进行校验、转化解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>
<p>整个生命周期包括：<em><strong>加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）</strong></em>。</p>
<p>加载分为两类：</p>
<ul>
<li><strong>显式加载</strong>：通过类加载器加载一个类。</li>
<li><strong>隐式加载</strong>：不直接使用类加载器加载类，而是虚拟机自动加载完成。</li>
</ul>
<blockquote>
<p>加载后，类的一些信息可通过工具HSDB来查看。</p>
<p>HSDB启动命令：<code>java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB</code></p>
</blockquote>
<h4 id="0-1-2-2、加载阶段"><a href="#0-1-2-2、加载阶段" class="headerlink" title="0.1.2.2、加载阶段"></a>0.1.2.2、加载阶段</h4><p>此阶段虚拟机会做三件事：</p>
<ol>
<li>通过一个<strong>类的全限定名</strong>来<strong>获取</strong>定义此<strong>类的二进制字节流</strong>；</li>
<li>将这个字节流所代表的<strong>静态存储结构转化</strong>为方法区的<strong>运行时数据结构</strong>；</li>
<li>在内存中<strong>生成</strong>一个代表该类的 <strong>java.lang.Class对象</strong>，<strong>作为</strong>方法区中<strong>该类各种数据的访问入口</strong>；</li>
</ol>
<p>获取二进制字节流可以通过Class文件、ZIP包、网络、运行时（动态代理）、JSP生成、数据库等途径获取。</p>
<p>那些二进制字节流加载完后，按指定格式存放于方法区内（Java7及以前方法区位于永久代，Java8位于Metaspace（元空间））。然后在方法区生成一个比较特殊的<code>java.lang.Class</code>对象，用来作为 访问方法区中这些类型数据的 外部接口。</p>
<p><font color='red'>注意：数组类不通过类加载器加载，而是由Java虚拟机直接创建，但数组类的元素还是要依靠类加载器进行加载。</font></p>
<h4 id="0-1-2-3、链接阶段"><a href="#0-1-2-3、链接阶段" class="headerlink" title="0.1.2.3、链接阶段"></a>0.1.2.3、链接阶段</h4><h5 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h5><p>验证的目的是确保Class文件字节流中包含的<em><strong>信息符合当前虚拟机的要求</strong></em>，并且<em><strong>不会危害虚拟机</strong></em>自身的安全。</p>
<p>验证内容如下：</p>
<ol>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ol>
<h5 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h5><p>准备阶段主要工作：在方法区中 <em><strong>为类变量分配内存、设置默认值</strong></em>。</p>
<p>类变量指的是被static修饰的变量，不包含实例变量，实例变量在对象实例化阶段分配在堆中。并且，变量的初始化值并非类中定义的值，而是该变量所属类型的默认值。</p>
<p><font color='red'>注意：变量被final修饰时，该字段属性为ConstantValue，它会在 准备阶段 初始化为指定的值。</font></p>
<h5 id="解析阶段"><a href="#解析阶段" class="headerlink" title="解析阶段"></a>解析阶段</h5><p>解析阶段主要工作：虚拟机将常量池内的 <em><strong>符号引用替换为直接引用</strong></em>。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用 进行解析。</p>
<h4 id="0-1-2-4、初始化阶段"><a href="#0-1-2-4、初始化阶段" class="headerlink" title="0.1.2.4、初始化阶段"></a>0.1.2.4、初始化阶段</h4><p>初始化阶段主要工作：<em><strong>执行类构造器的<code>clinit()</code>方法</strong></em>。</p>
<p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并而成。编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问其之前的变量，之后的变量只能赋值但不能访问。</p>
<p><font color='red'>注意：<code>&lt;clinit&gt;()</code>方法 与 实例构造器() 不同，其不需要 显式调用 父类构造器，虚拟机会保证在子类的clinit()方法执行之前，父类的clinit()方法已经执行完毕。虚拟机会保证一个类的clinit()方法在多线程下被同步加锁。</font></p>
<h3 id="0-1-3、类加载器"><a href="#0-1-3、类加载器" class="headerlink" title="0.1.3、类加载器"></a>0.1.3、类加载器</h3><h4 id="0-1-3-1、简介"><a href="#0-1-3-1、简介" class="headerlink" title="0.1.3.1、简介"></a>0.1.3.1、简介</h4><p><em><strong>通过 类的全限定名 获取该类二进制字节流的代码块叫 类加载器</strong></em>。</p>
<h4 id="0-1-3-2、类加载器分类"><a href="#0-1-3-2、类加载器分类" class="headerlink" title="0.1.3.2、类加载器分类"></a>0.1.3.2、类加载器分类</h4><p>JVM规范中规定，将派生于抽象类<code>ClassLoader</code>的类加载器都称为 自定义类加载器。</p>
<p>实际开发中，通常会将类加载器分为如下几种：</p>
<ol>
<li><p><strong>启动类加载器（Bootstrap ClassLoader）</strong></p>
<p>使用C&#x2F;C++语言实现，并不继承java.lang.ClassLoader。为安全起见，主要负责加载Java核心类库，比如：<code>%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar</code>和class等。</p>
</li>
<li><p><strong>扩展类加载器（Extensions ClassLoader）</strong></p>
<p>使用Java语言实现，派生于抽象类ClassLoader，父类是启动类加载器。</p>
<p>主要负责加载<code>%JRE_HOME%\lib\ext</code>目录下的jar包和class文件。</p>
</li>
<li><p><strong>应用程序&#x2F;系统类加载器（App ClassLoader）</strong></p>
<p>使用Java语言实现，派生于抽象类ClassLoader，父类是扩展类加载器。</p>
<p>加载 CLASSPATH 或 java.class.path 指定路径下的类库。</p>
</li>
<li><p><strong>自定义类加载器（Custom ClassLoader）</strong></p>
<p>自定义类加载器可以扩展加载源、修改类加载方式，隔离加载类、防止源码泄露。JDK1.2之前，实现自定义类加载需要继承抽象类ClassLoader并重写loadClass方法，而JDK1.2之后建议重写findClass方法来代替重写loadClass方法。</p>
<p>若无特别需求，则建议直接继承URLClassLoader类，可避免编写findClass方法及获取字节流的方式。</p>
</li>
</ol>
<p><font color="red">注意：这些类加载器之间是包含（复合）关系，而并非是继承关系。</font></p>
<h4 id="0-1-3-3、常用命令"><a href="#0-1-3-3、常用命令" class="headerlink" title="0.1.3.3、常用命令"></a>0.1.3.3、常用命令</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> -Xbootclasspath/a:. cn.shh.xxx.Test bootstrap F init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><code>Xbootclasspath</code>：表示设置bootclasspath。</li>
<li><code>/a</code>：表示将当前目录追加至bootclass之后。</li>
</ul>
<p>常用命令：</p>
<ul>
<li><code>java -Xbootclasspath:&lt;new bootclasspath&gt;</code></li>
<li><code>java -Xbootclasspath/a:&lt;追加路径&gt;</code></li>
<li><code>java -Xbootclasspath/p:&lt;追加路径&gt;</code></li>
</ul>
<h3 id="0-1-4、双亲委派模型"><a href="#0-1-4、双亲委派模型" class="headerlink" title="0.1.4、双亲委派模型"></a>0.1.4、双亲委派模型</h3><h4 id="0-1-4-1、简介"><a href="#0-1-4-1、简介" class="headerlink" title="0.1.4.1、简介"></a>0.1.4.1、简介</h4><p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20201224173439957.png" alt="image-20201224173439957"></p>
<p>上图所示，<strong>类加载器间的关系就称为 类加载器的双亲委派模型（Parents Delegation Mode）。</strong></p>
<p><strong>类加载器的 双亲委派模型 在 JDK 1.2 期间被引入。</strong>它并不是一个强制性约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。</p>
<h4 id="0-1-4-2、工作机制"><a href="#0-1-4-2、工作机制" class="headerlink" title="0.1.4.2、工作机制"></a>0.1.4.2、工作机制</h4><p><strong>双亲委派机制是指：一个类加载器收到了类加载请求时会先请求自己的父加载器去加载，如果父加载器无法加载该类，那么才会交给当前类加载器来加载。</strong></p>
<h4 id="0-1-4-3、特点"><a href="#0-1-4-3、特点" class="headerlink" title="0.1.4.3、特点"></a>0.1.4.3、特点</h4><ol>
<li><p>Java类随它的类加载器一起具备了一种带有优先级的层次关系。</p>
</li>
<li><p>保证Java程序的稳定运行。</p>
</li>
<li><p>避免类被重复加载。</p>
</li>
<li><p>保证了安全。</p>
</li>
</ol>
<h4 id="0-1-4-4、实现原理"><a href="#0-1-4-4、实现原理" class="headerlink" title="0.1.4.4、实现原理"></a>0.1.4.4、实现原理</h4><p><strong>双亲委派模型的实现代码体现在抽象类<code>java.lang.ClassLoader</code>的<code>loadClass()</code>方法中。</strong>逻辑如下：</p>
<ol>
<li>先检查一个类是否被加载过，若没有被加载，则调用父加载器的 loadClass() 方法进行加载。</li>
<li>若父加载器为空，则默认使用启动类加载器作为父加载器。</li>
<li>如果父加载器加载失败，抛出 ClassNotFoundException 异常后，再调用自己的 findClass() 方法进行加载。</li>
</ol>
<h4 id="0-1-4-5、破坏双亲模型"><a href="#0-1-4-5、破坏双亲模型" class="headerlink" title="0.1.4.5、破坏双亲模型"></a>0.1.4.5、破坏双亲模型</h4><p>到目前为止，双亲委派模型主要出现过3次 较大规模的 破坏情况：</p>
<ol>
<li>由于 JDK 1.2 才发布双亲委派模型，类加载器和抽象类 ClassLoader 则在 JDK 1.0 时代就已经存在，为了兼容已经存在的自定义类加载器实现，JDK 1.2之后添加了一个新的 protected方法 findClass() 。JDK 1.2之后已不在提倡覆盖 loadClass() 方法，而应当把自己的类加载逻辑写入 findClass() 方法中，在 loadClass() 中如果父类加载失败，则会调用自己的 findClass() 方法来完成加载。</li>
<li><strong>基础类之所以称为“基础类”，是因为它们会作为API来被用户代码调用，但是，如果基础类反过来需要调用用户代码时，该怎么办？于是线程上下文类加载器就出现了。</strong>有了线程上下文类加载器，JNDI服务可以去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为打破了双亲委派模型的层次结构来逆向使用类加载器，这实际上违背了双亲委派模型的一般性原则。</li>
<li>第三次破坏是由于 <strong>用户对程序动态性的追求而导致，动态性是指：代码热替换、模块热部署等</strong>。比如 OSGI 中的类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更复杂的网状结构。</li>
<li>Tomcat等web容器的出现。</li>
<li>OSGI、Jigsaw等模块化技术的应用。</li>
</ol>
<h4 id="0-1-4-6、重要方法"><a href="#0-1-4-6、重要方法" class="headerlink" title="0.1.4.6、重要方法"></a>0.1.4.6、重要方法</h4><ul>
<li><font color='orange'>loadClass()</font>：类加载的主要方法。双亲委派机制l的体现就是该方法。</li>
<li><font color='orange'>findClass()</font>：根据名称或位置加载.class字节码。</li>
<li><font color='orange'>definclass()</font>：把字节码转化为Class。</li>
</ul>
<p><font color='red'>注意：自定义类加载器需要破坏双亲委派原则时就重写loadClass方法。如果只想自定义类加载器不想破坏双亲委派模型，那就继承ClassLoader并重写findClass方法。</font></p>
<p><code>findClass()</code>方法是JDK1.2之后 ClassLoader 新添加的一个方法。</p>
<blockquote>
<p>JDK1.2 后不提倡覆盖loadClass()方法，而建议把自己的逻辑写到<code>findClass()</code>方法中。因为<code>loadClass()</code>方法无法完成类加载逻辑时最终还是会调用<code>findClass()</code>方法来完成加载。</p>
</blockquote>
<h4 id="0-1-4-7、JNDI-JDBC破坏双亲委派"><a href="#0-1-4-7、JNDI-JDBC破坏双亲委派" class="headerlink" title="0.1.4.7、JNDI&#x2F;JDBC破坏双亲委派"></a>0.1.4.7、JNDI&#x2F;JDBC破坏双亲委派</h4><p><strong>Java的基础类会被Bootstrap加载，且会通过API方式调用这些基础类。但是，除了API方式调用，还有一种SPI方式调用，如JDBC服务。</strong></p>
<p>创建数据库连接的方式如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/mysql"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">,</span> <span class="token string">"1234"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>java.sql.DriverManager</code>类位于rt.jar中 ，故会被根加载器加载。类加载时，会执行该类的静态方法。其中有一段关键代码是：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ServiceLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Driver</span><span class="token punctuation">></span></span> loadedDrivers <span class="token operator">=</span> <span class="token class-name">ServiceLoader</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Driver</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这段代码，会尝试加载classpath下实现了Driver接口的所有实现类。</p>
<p>那么，问题就来了。</p>
<p><strong>DriverManager会被根加载器加载，但在加载时遇到以上代码，会尝试加载Driver的所有实现类，但这些实现类基本都是第三方提供，根据双亲委派原则，第三方的类不能被根加载器加载。</strong></p>
<p>那么，怎么解决这个问题呢？</p>
<p><strong>在JDBC中引入ThreadContextClassLoader（线程上下文加载器，默认情况下是AppClassLoader）来破坏双亲委派原则。</strong></p>
<p>我们深入到<code>ServiceLoader.load</code>方法就可以看到：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">></span></span> <span class="token class-name">ServiceLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">></span></span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">></span></span> service<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">ClassLoader</span> cl <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token class-name">ServiceLoader</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span> cl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>第一行，获取当前线程的线程上下⽂类加载器 AppClassLoader，⽤于加载 classpath 下的具体实现类。</p>
<h4 id="0-1-4-8、Tomcat破坏双亲委派"><a href="#0-1-4-8、Tomcat破坏双亲委派" class="headerlink" title="0.1.4.8、Tomcat破坏双亲委派"></a>0.1.4.8、Tomcat破坏双亲委派</h4><p>Tomcat中可能会部署多个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，如果采用默认的双亲委派类加载机制，那么无法加载多个相同类。所以，Tomcat破坏双亲委派原则，提供隔离的机制，为web容器中每一个应用单独提供一个WebAppClassLoader加载器。</p>
<p><strong>Tomcat类加载机制：为了实现隔离性，优先加载 Web 应用自己定义的类，所以没有遵照双亲委派约定，每一个WebAppClassLoader负责加载自己目录下的class文件，加载不到时再交给CommonClassLoader加载，这和双亲委派刚好相反。</strong></p>
<h4 id="0-1-4-9、总结"><a href="#0-1-4-9、总结" class="headerlink" title="0.1.4.9、总结"></a>0.1.4.9、总结</h4><h5 id="父子加载器之间是继承关系吗？"><a href="#父子加载器之间是继承关系吗？" class="headerlink" title="父子加载器之间是继承关系吗？"></a>父子加载器之间是继承关系吗？</h5><p><strong>双亲委派模型中，类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是使用 组合（Composition）关系 来复用父加载器代码。</strong></p>
<p>如下为ClassLoader中父加载器的定义：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// The parent class loader for delegation</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ClassLoader</span> parent<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>Java中继承和组合的区别是什么？</p>
<ol>
<li>组合(has-a)关系可以<font color='orange'>显式获得被包含类（继承中称为父类）对象</font>，而继承(is-a)则是<font color='orange'>隐式获得父类对象，</font>被包含类和父类对应，而组合外部类和子类对应。</li>
<li>组合关系在<font color='orange'>运行期决定</font>，而继承关系在<font color='orange'>编译期决定</font>。</li>
<li>组合是组合类和被包含类之间的一种<font color='orange'>松耦合关系</font>，而继承则是父类和子类之间的一种<font color='orange'>紧耦合关系。</font></li>
<li>组合类中包含了外部类的对象，组合类<font color='orange'>可以调用外部类方法；</font>而使用继承关系时，父类的所有方法和变量都被子类<font color='orange'>无条件继承，子类不能选择。</font></li>
<li>继承可以实现<font color='orange'>类型回溯</font>，即用父类变量引用子类对象，这样便可以实现多态，而组合没有这个特性。</li>
<li>如果你确定复用另外一个类的方法永远不需要改变时，应该使用组合，因为组合只是<font color='orange'>简单复用被包含类的接口</font>，而继承除了复用父类接口外，它还<font color='orange'>可以覆盖这些接口</font>，修改父类接口的默认实现，这个特性是组合没有的。</li>
<li>组合体现的是整体和部分的思想，例如电脑类是由内存类，CPU类，硬盘类等组成，而继承则体现的是一种可回溯的父子关系，子类也是父类的一个对象。</li>
<li><font color='orange'>两者区别主要体现在类的抽象阶段</font>，在分析类之间的关系时就应该确定是采用组合还是采用继承。</li>
</ol>
</blockquote>
<h2 id="0-2、JVM运行时数据区"><a href="#0-2、JVM运行时数据区" class="headerlink" title="0.2、JVM运行时数据区"></a>0.2、JVM运行时数据区</h2><p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/2.1.1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%89%8D%E8%A8%80-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86.png"></p>
<h3 id="0-1-1、程序计数器（私有）"><a href="#0-1-1、程序计数器（私有）" class="headerlink" title="0.1.1、程序计数器（私有）"></a>0.1.1、程序计数器（私有）</h3><h4 id="0-1-1-1、简介-1"><a href="#0-1-1-1、简介-1" class="headerlink" title="0.1.1.1、简介"></a>0.1.1.1、简介</h4><p>JVM的程序计数寄存器，是物理PC寄存器的一种抽象模拟。</p>
<p><strong>程序计数器主要存储要执行的程序指令的 地址信息，确保程序正确执行。</strong></p>
<h4 id="0-1-1-2、作用"><a href="#0-1-1-2、作用" class="headerlink" title="0.1.1.2、作用"></a>0.1.1.2、作用</h4><p><strong>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码的地址。</strong>由执行引擎读取下一条指令。</p>
<h3 id="0-1-2、方法区（公有）"><a href="#0-1-2、方法区（公有）" class="headerlink" title="0.1.2、方法区（公有）"></a>0.1.2、方法区（公有）</h3><h4 id="0-1-2-1、简介"><a href="#0-1-2-1、简介" class="headerlink" title="0.1.2.1、简介"></a>0.1.2.1、简介</h4><p>方法区存储类的结构信息：<strong>运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容</strong>，还包含一些<strong>类、实例、接口初始化时用到的特殊方法</strong>。</p>
<p><font color='red'>注意事项：方法区内存不足时会导致内存溢出错误。</font></p>
<p>方法区内存溢出的场景：Spring、MyBatis。</p>
<h4 id="0-1-2-2、实现"><a href="#0-1-2-2、实现" class="headerlink" title="0.1.2.2、实现"></a>0.1.2.2、实现</h4><ul>
<li><font color='orange'>PermSpace（JDK1.7）</font><ol>
<li>JDK1.7时，方法区实现为永久代。</li>
<li>字符串常量池位于永久代中。</li>
<li>FGC不会清理。</li>
<li>-XX:PermSize默认值为20.75M，<code>-XX:MaxPermSize</code>默认值在32位下是64M，64位下是82M。</li>
</ol>
</li>
<li><font color='orange'>MetaSpace（JDK1.8）</font><ol>
<li>JDK1.8时，方法区实现为元空间，使用的是物理内存。</li>
<li>字符串常量池位于堆中。</li>
<li>会触发FGC清理。</li>
<li>windows下，<code>-XX:MetaspaceSize</code>是21M，<code>-XX:MaxMetaspaceSize</code>的值是-1，表示没有限制。</li>
</ol>
</li>
</ul>
<h4 id="0-1-2-3、方法区演变"><a href="#0-1-2-3、方法区演变" class="headerlink" title="0.1.2.3、方法区演变"></a>0.1.2.3、方法区演变</h4><p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/2.5.10-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E6%96%B9%E6%B3%95%E5%8C%BA-%E6%96%B9%E6%B3%95%E5%8C%BA%E6%BC%94%E8%BF%9B.png"></p>
<h4 id="0-1-2-4、运行时常量池"><a href="#0-1-2-4、运行时常量池" class="headerlink" title="0.1.2.4、运行时常量池"></a>0.1.2.4、运行时常量池</h4><h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>常量池是Class文件的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将会在类被加载后放到方法区的运行时常量池中。</p>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p><strong>加载 类或接口 到虚拟机后就会创建对应的运行时常量池</strong>。</p>
<p>运行时常量池是方法区的一部分。运行时常量池 是 常量池表的【运行时表示形式】，它包含多种常量，从编译期可知的 数字字面量 到必须运行且解析后才能获得的 方法或字段引用。（类似于符号表，但比符号表要更广泛。）</p>
<h3 id="0-1-3、虚拟机栈（私有）"><a href="#0-1-3、虚拟机栈（私有）" class="headerlink" title="0.1.3、虚拟机栈（私有）"></a>0.1.3、虚拟机栈（私有）</h3><h4 id="0-1-3-1、简介-1"><a href="#0-1-3-1、简介-1" class="headerlink" title="0.1.3.1、简介"></a>0.1.3.1、简介</h4><p><strong>每个线程都有自己的栈，栈中的数据都是以 栈帧 的格式存在。</strong>每个线程在执行一个方法时会在栈中对应一个栈帧。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种信息。</p>
<p><font color='red'>注意事项：虚拟机栈内存不足时会导致内存溢出错误。</font></p>
<h4 id="0-1-3-2、内部结构"><a href="#0-1-3-2、内部结构" class="headerlink" title="0.1.3.2、内部结构"></a>0.1.3.2、内部结构</h4><p>Java虚拟机中主要存储的是栈帧，而栈帧由以下几部分组成：</p>
<ul>
<li><strong>局部变量表</strong></li>
<li><strong>操作数栈</strong></li>
<li><strong>动态链接</strong></li>
<li><strong>方法出口</strong></li>
<li><strong>一些附加信息</strong></li>
</ul>
<h4 id="0-1-3-3、其它"><a href="#0-1-3-3、其它" class="headerlink" title="0.1.3.3、其它"></a>0.1.3.3、其它</h4><p>问题分析：</p>
<ul>
<li>栈内存越大越好吗？</li>
<li>垃圾回收是否设计栈内存？</li>
<li>方法中的局部变量是否是线程安全的？</li>
</ul>
<h3 id="0-1-4、本地方法栈（私有）"><a href="#0-1-4、本地方法栈（私有）" class="headerlink" title="0.1.4、本地方法栈（私有）"></a>0.1.4、本地方法栈（私有）</h3><h4 id="0-1-4-1、简介-1"><a href="#0-1-4-1、简介-1" class="headerlink" title="0.1.4.1、简介"></a>0.1.4.1、简介</h4><p><strong>本地方法栈使用C语言实现，线程私有，主要服务于本地方法的调用。</strong></p>
<p>本地方法栈中存储本地方法，执行引擎工作时会加载本地方法库。</p>
<p><font color='red'>注意事项：本地方法栈内存不足时会导致内存溢出错误。</font></p>
<h4 id="0-1-4-2、注意事项"><a href="#0-1-4-2、注意事项" class="headerlink" title="0.1.4.2、注意事项"></a>0.1.4.2、注意事项</h4><ul>
<li>可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li>
<li>直接使用本地处理器中的寄存器。</li>
<li>直接从本地内存的堆中分配任意内存。</li>
<li>并非所有JVM都支持本地方法，JVM规范并没有要求本地方法栈使用的语言、具体实现方式、数据结构等，也可以选择不实现本地方法栈。</li>
<li>Hotspot中直接将本地方法栈和虚拟机栈合二为一。</li>
</ul>
<h3 id="0-1-5、堆（公有）"><a href="#0-1-5、堆（公有）" class="headerlink" title="0.1.5、堆（公有）"></a>0.1.5、堆（公有）</h3><h4 id="0-1-5-1、简介"><a href="#0-1-5-1、简介" class="headerlink" title="0.1.5.1、简介"></a>0.1.5.1、简介</h4><p><strong>堆是各个线程公有的区域，该区域主要存储对象加载创建过程中生成的对象数据。</strong></p>
<p><font color='red'>注意事项：堆空间不足时会导致内存溢出错误。</font></p>
<h4 id="0-1-5-2、分代模型"><a href="#0-1-5-2、分代模型" class="headerlink" title="0.1.5.2、分代模型"></a>0.1.5.2、分代模型</h4><p>逻辑上将堆分为以下几个部分：</p>
<ul>
<li>年轻代<ul>
<li>Eden区</li>
<li>Surivor from区</li>
<li>Surivor to区</li>
</ul>
</li>
<li>老年代</li>
<li>永久代&#x2F;元空间（JDK7及之前是永久代，之后是元空间）</li>
</ul>
<h4 id="0-1-5-3、空间大小"><a href="#0-1-5-3、空间大小" class="headerlink" title="0.1.5.3、空间大小"></a>0.1.5.3、空间大小</h4><h5 id="堆大小"><a href="#堆大小" class="headerlink" title="堆大小"></a>堆大小</h5><p>可以通过Xms、Xmx来设置堆内存初始内存和最大内存，堆大小在JVM启动时已经设定好了。</p>
<p>默认情况下：初始内存大小为物理内存&#x2F;64，最大内存为物理内存的1&#x2F;4。</p>
<p><font color='red'>注意事项：堆内存大小超过 最大内存 限制时会抛出OOM异常。</font></p>
<h5 id="新生代老年代"><a href="#新生代老年代" class="headerlink" title="新生代老年代"></a>新生代老年代</h5><p>默认参数<code>-XX:NewRatio=2</code>表示新生代占比1，老年代占比2，新生代占整个堆内存的1&#x2F;3。同理<code>-XX:NewRatio=4</code>表示新生代占比1，老年代占比4，新生代占整个堆内存的1&#x2F;5。</p>
<p><font color='red'>注意事项：参数<code>-XX:NewRatio=2</code>的实际效果会受参数<code>-XX:UseAdaptiveSizePolicy</code>的影响，后者参数表示 开启关闭自适应内存分配策略。</font>如果想要达到指定的具体效果，需要使用参数<code>-XX:SurvivorRatio</code>来设置，该参数表示新生代中Eden区与Survivor区的比例。</p>
<p>使用参数<code>-Xmn</code>设置新生代的空间大小。</p>
<h3 id="0-1-6、直接内存"><a href="#0-1-6、直接内存" class="headerlink" title="0.1.6、直接内存"></a>0.1.6、直接内存</h3><p><strong>直接内存在堆外，不会受限于-Xmx设置的最大堆大小。</strong>但系统内存也是有限的，Java堆和直接内存的总和依然受限于操作系统能提供的最大内存。</p>
<p>直接内存有如下缺点：</p>
<ul>
<li>分配回收成本较高。</li>
<li>不受JVM内存回收管理。</li>
</ul>
<p><strong>直接内存大小可以通过参数MaxDirectMemorySize来设置，如果不指定，则默认与堆的最大值-Xmx参数值一致。</strong></p>
<h3 id="0-1-7、字符串常量池"><a href="#0-1-7、字符串常量池" class="headerlink" title="0.1.7、字符串常量池"></a>0.1.7、字符串常量池</h3><h4 id="0-1-7-1、简介"><a href="#0-1-7-1、简介" class="headerlink" title="0.1.7.1、简介"></a>0.1.7.1、简介</h4><p><strong>String Pool是一个固定大小的Hashtable，默认大小为1009。</strong>如果String Pool中字符串太多，会造成链表过长，进而导致在调用String的intern方法时性能会大幅下降。</p>
<p><strong>JDK6及以前版本，字符串常量池在方法区中，JDK7及之后版本，字符串常量池转移到堆中。</strong></p>
<h4 id="0-1-7-2、参数设置"><a href="#0-1-7-2、参数设置" class="headerlink" title="0.1.7.2、参数设置"></a>0.1.7.2、参数设置</h4><p>使用参数<code>-XX:StringTableSize</code>可设置StringTable的长度。</p>
<blockquote>
<p>JDK6中StringTable大小固定为1009。JDK7中StringTable大小默认为60013。JDK8中最小有效值为1009。</p>
</blockquote>
<h2 id="0-3、执行引擎"><a href="#0-3、执行引擎" class="headerlink" title="0.3、执行引擎"></a>0.3、执行引擎</h2><h3 id="0-3-1、即时编译器"><a href="#0-3-1、即时编译器" class="headerlink" title="0.3.1、即时编译器"></a>0.3.1、即时编译器</h3><h5 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h5><p><strong>当程序需要迅速启动和执行时，解释器先运行，然后编译器逐渐发挥作用。如果编译器优化后类发生了变化，那么可以立即通过解释器来运行。所以说解释器和编译器是互相配合来执行代码的。</strong></p>
<p>HotSpot虚拟机内置了三个即时编译器：<strong>客户端编译器（C1编译器）、服务端编译器（C2编译器）、Graal编译器（JDK 10中正式引入）。Graal编译器的目标是替换C2编译器</strong>。</p>
<p>JVM执行代码时可采用多种模式，现分为三种：</p>
<ul>
<li><p><strong>混合模式（默认方式）</strong></p>
<p>使用参数<code>-Xmixed</code>可以设置JVM运行于混合模式。</p>
</li>
<li><p><strong>解释器（Intepreter）模式</strong></p>
<p>使用参数<code>-Xint</code>可以设置JVM运行于“解释模式”。</p>
</li>
<li><p><strong>JIT（Just In-Time）模式：即时编译器</strong></p>
<p>使用参数<code>-Xcomp</code>可以设置JVM运行于“编译模式”，但要注意，当编译器无法继续工作时解释器依然会介入执行。</p>
</li>
</ul>
<p><strong>分层编译在JDK 6中被初步实现，后一直处于改进阶段，最终在JDK 7服务端模式中作为默认编译策略被开启</strong>。分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其包括：</p>
<ul>
<li>第0层：程序纯解释执行，并且解释器不开启性能监控功能（Profiling）。</li>
<li>第1层：使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启 性能监控功能。</li>
<li>第2层：使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。</li>
<li>第3层：使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。</li>
<li>第4层：使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启 用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。</li>
</ul>
<p>分层编译后，解释器、客户端编译器、服务端编译器可同时工作，在服务端编译器采用高复杂度优化算法时，客户端编译器可先采用简单优化来为之争取更多编译时间。</p>
<blockquote>
<p><font color="orange">疑问：既然编译到本地效率更高，为啥不全部编译到本地呢？</font></p>
<ol>
<li>现在的Java解释器执行效率已经很高，几乎可以和编译器相媲美。</li>
<li>类库或class很多时，采用编译到本地的方式会导致启动过程非常慢。</li>
</ol>
</blockquote>
<h5 id="热点代码"><a href="#热点代码" class="headerlink" title="热点代码"></a>热点代码</h5><p>被即时编译器编译的目标是“热点代码”，热点代码主要有两类： </p>
<ul>
<li><strong>被多次调用的方法</strong>。 </li>
<li><strong>被多次执行的循环体</strong>。</li>
</ul>
<p>某段代码是不是热点代码，是否触发即时编译需要执行“热点探测”（Hot Spot Code Detection），热点探测并不一定要知道方法具体被调用多少次，目前主流的热点探测判定方式有两种，分别是：</p>
<ul>
<li><p><strong>基于采样的热点探测</strong></p>
<p>采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。这种探测方式的好处是实现简单高效，可以很容易获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而 扰乱热点探测。</p>
</li>
<li><p><strong>基于计数器的热点探测</strong></p>
<p>采用这种方法的虚拟机会为 每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为 它是“热点方法”。这种统计方法实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。</p>
</li>
</ul>
<h5 id="调用计数器"><a href="#调用计数器" class="headerlink" title="调用计数器"></a>调用计数器</h5><p>方法被调用时会先查看是否存在该方法编译后的代码，存在则先执行编译后的代码，不存在则会将方法调用计时器值加1，然后判断方法调用计数器值与回边计数器值之和是否超过调用计数器的阈值，超过阈值会向即时编译器发送方法代码编译请求，在代码被即时编译器编译完成前会暂时先使用解释器来解释执行，当编译完成后，该方法的调用入口地址就会被自动修改为新值，后期调用该方法时就可以执行编译后的代码了。</p>
<blockquote>
<p>方法调用计数器的默认阈值在客户端模式下是1500次，在服务端模式下是10000次，这个阈值可以通过虚拟机参数<code>-XX:CompileThreshold</code>来人为设定。</p>
</blockquote>
<p>默认设置下，方法调用计数器统计的是一段时间内方法被调用的次数，该时间段内，如果方法的调用次数不足以触发即时编译器来编译，那方法调用计数器数值会减少一半，该过程被称为方法调用计数器<font color='orange'>热度衰减（Counter Decay）</font>，而这段时间称为此方法统计的<font color='orange'>半衰周期（Counter Half Life Time）</font>。</p>
<blockquote>
<p><font color='orange'>热度衰减操作在垃圾收集时进行</font>，可使用参数<code>-XX:-UseCounterDecay</code>来关闭热度衰减，让方法调用计数器统计方法调用的绝对次数。可使用参数<code>-XX:CounterHalfLifeTime</code>设置半衰周期的时间，单位秒。</p>
</blockquote>
<h5 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h5><p><strong>回边计数器会统计一个方法中循环体代码的执行次数，在字节码中遇到控制流向后跳转的指令就称为“回边（Back Edge）”，回边计数器统计的目的是为了触发栈上替换编译。</strong></p>
<p>回边计数器阈值计算分以下两种情况：</p>
<ul>
<li>客户端模式下回边计数器阈值计算公式为：方法调用计数器阈值（-XX:CompileThreshold）乘以OSR比率（-XX:OnStackReplacePercentage）除以100。其中-XX:OnStackReplacePercentage默认值为933，如果都取默认值，那客户端模式下的回边计数器的阈值为 13995。</li>
<li>服务端模式下回边计数器阈值的计算公式为：方法调用计数器阈值（-XX:CompileThreshold）乘以（OSR比率（-XX:OnStackReplacePercentage）减去解释器监控比率（-XX:InterpreterProfilePercentage）的差值）除以100。其中-XX：OnStack ReplacePercentage默认值为140，- XX:InterpreterProfilePercentage默认值为33，如果都取默认值，那服务端模式的回边计数器的阈值为10700。</li>
</ul>
<p>当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有的话，它将会优先执行已编译的代码，否则就把回边计数器的值加一，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。超过阈值时会提交一个栈上替换编译请求， 并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。</p>
<p>与方法计数器不同，回边计数器没有计算热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出时会把方法计数器的值也调整到溢出状态，这样下次再进入该方法时就会执行标准编译过程。</p>
<blockquote>
<p><font color='red'>注意：回边次数 不等于 循环次数，因为并不是所有的循环都是回边，如空循环并不算控制流向后跳转，也不会被回边计数器统计。</font></p>
</blockquote>
<h3 id="0-3-2、提前编译器"><a href="#0-3-2、提前编译器" class="headerlink" title="0.3.2、提前编译器"></a>0.3.2、提前编译器</h3><p><strong>JDK 9引入了Jaotc，可实现提前编译Class文件及模块</strong>，它可以减少程序的启动时间和到达全速性能的预热时间。该功能需要特定的物理机器和虚拟机参数，限制太多。</p>
<h3 id="0-3-3、编译器优化"><a href="#0-3-3、编译器优化" class="headerlink" title="0.3.3、编译器优化"></a>0.3.3、编译器优化</h3><h5 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h5><p><strong>内联被称为优化之母，消除方法调用成本外，也为 其它优化手段 提供了良好基础。</strong></p>
<p><strong>方法内联就是把目标方法代码“复制”到发起调用的方法之中，避免发生真实方法调用。</strong>该功能得益于即时编译器的付出。</p>
<blockquote>
<p>Java中默认的实例方法是虚方法。只有使用 invokespecial指令调用的私有方法、实例构造器、父类方法和使用invokestatic指令调用的静态方法才会在编译期进行解析。被final修饰的方法使用invokevirtual指令调用，它是非虚方法，《Java语言规范》中明确说明了这点。</p>
</blockquote>
<p>内联与 虚方法之间会产生“矛盾”，C和C++是通过使用final关键字来修饰方法解决的，但Java在虚拟机中解决这个问题。</p>
<p>Java虚拟机首先引入了一种名为类型<em><strong>继承关系分析（Class Hierarchy Analysis，CHA）</strong></em>技术，用于确定目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法 等信息。</p>
<p>编译器进行内联时会根据不同情况采取不同处理：非虚方法直接进行内联就可以；对于虚方法，会向CHA查询此方法下是否有多个目标版本可供选择，如果只有一个版本，那可以内联，这种内联称为<em><strong>守护内联（Guarded Inlining）</strong></em>。由于Java程序是动态连接的，说不准什么时候就会加载到新的类型从而改变CHA结论，因此这种内联属于<em><strong>激进预测性优化</strong></em>。假如在程序的后续执行过程中，虚拟机一直没有加载到会导致方法接收者继承关系发生变化的类，那这个内联优化的代码就可以一直使用。如果加载了导致继承关系发生变化的新类，那么就必须抛弃已编译的代码，退回到解释状态执行，或重新进行编译。</p>
<p>如果被调用的方法确实有多个版本可供选择，那即时编译器还将进行最后一次努力，使用内联缓存（Inline Cache）的方式来缩减方法调用的开销。这种状态下方法调用真正发生，比起直接查虚方法表还要快一些。</p>
<h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p>逃逸分析（Escape Analysis）与类型继承关系分析一 样，并不是直接优化代码的手段，而是<strong>为其他优化措施提供依据的分析技术</strong>。</p>
<p>逃逸分析基本原理：分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，这种称为方法逃逸；甚至还有可能被外部线程访问，这种称为线程逃逸；不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。</p>
<p><font color='red'>注意：JDK 6u23版本之后，Hotspot默认开启了逃逸分析。</font></p>
<h6 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h6><p>如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径 访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例采取不同程度的优化。比如：</p>
<ul>
<li><p><font color='orange'>栈上分配</font></p>
<p>如果确定一个对 象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存 空间就可以随栈帧出栈而销毁。栈上分配可以支持方法逃逸，但不能支持线程逃逸。</p>
</li>
<li><p><font color='orange'>标量替换</font></p>
<p>若一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据 就可以被称为标量。相对的，如果一个数据可以继续分解，那它就被称为聚合量（Aggregate），Java 中的对象就是典型的聚合量。如果把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量 恢复为原始类型来访问，这个过程就称为标量替换。</p>
<p>标量替换可以视作栈上分配的一种特例，实现更简单（不用考虑整个对象完整结构的分配），但对逃逸程度的要求更高，它不允许对象逃逸出方法范围内。</p>
</li>
<li><p><font color='orange'>同步消除</font></p>
<p>线程同步本身是一个相对耗时的过程，如果逃逸分析 能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争， 对这个变量实施的同步措施也就可以安全地消除掉。</p>
</li>
</ul>
<h6 id="功能开启"><a href="#功能开启" class="headerlink" title="功能开启"></a>功能开启</h6><ul>
<li>-XX:+DoEscapeAnalysis：开启逃逸分析。</li>
<li>-XX:+PrintEscapeAnalysis：查看逃逸分析筛选结果。</li>
</ul>
<h5 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h5><p>公共子表达式消除的含义是：<strong>如果一 个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E 的这次出现就称为公共子表达式。对于这种表达式，没有必要花时间再对它重新进行计算，可直接使用计算过的表达式结果代替E。</strong>如果这种优化仅限于程序基本块内，便可称为局部公共子表达式消除（Local Common Subexpression Elimination），如果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除（Global Common Subexpression Elimination）。</p>
<h5 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h5><p>数组边界检查消除（Array Bounds Checking Elimination）是即时编译器中的一项语言相关的经典优化技术。如果有一个数组foo[]，在Java语言中访问数组元素foo[i]的时候系统将会自动进行上下界 的范围检查，即i必须满足“i&gt;&#x3D;0&amp;&amp;i&lt;&#x3D;foo.length”的访问条件，否则将抛出一个运行时异常： java.lang.ArrayIndexOutOfBoundsException。对于虚拟机执行子系统来说，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这必定是一种性能负担。</p>
<p>无论如何，为了安全，数组边界检查肯定是要做的，但数组边界检查是不是必须在运行期间一次 不漏地进行则是可以“商量”的事情。<strong>如果对于数组的访问在编译期根据数据流分析就能确定没有越界，执行时就无须判断了。</strong>更常见的是数组访问发生在循环中，且使用循环变量来访问数组。那么在循环中就可以把整个数组的上下界检查消除掉，这可以减少很多次的条件判断操作。</p>
<h3 id="0-3-4、Graal编译器"><a href="#0-3-4、Graal编译器" class="headerlink" title="0.3.4、Graal编译器"></a>0.3.4、Graal编译器</h3><p><strong>从JDK 10起，Graal 编译器可以替换服务端编译器，成为HotSpot分层编译中最顶层的即时编译器。</strong></p>
<p>Java虚拟机编译器接口（Java-Level JVM Compiler Interface，JVMCI）（JDK 9时发布的JEP 243）使得Graal可以从HotSpot的代码中分离出来。</p>
<p>通过Java虚拟机编译器接口就可以把一个在HotSpot虚拟机外部的、用Java语言实现的即时编译器（不局限于Graal）集成到HotSpot中，响应HotSpot发出的最顶层的编译请求，并将编译后的二进制代码 部署到 HotSpot代码缓存中。此外，又可以绕开HotSpot的即时编译系统，让该编译器直接为应用的类库编译出二进制机器码，将该编译器当作一个提前编译器去使用 （如Jaotc）。</p>
<h3 id="0-3-5、总结"><a href="#0-3-5、总结" class="headerlink" title="0.3.5、总结"></a>0.3.5、总结</h3><p><strong>HotSpot VM采用 解释器与即时编译器并存 的架构。</strong>Java虚拟机运行时会采用解释器和即时编译器协调工作的方式来达到相对较好的工作状态。</p>
<h2 id="0-4、本地方法接口"><a href="#0-4、本地方法接口" class="headerlink" title="0.4、本地方法接口"></a>0.4、本地方法接口</h2><h3 id="0-4-1、本地方法"><a href="#0-4-1、本地方法" class="headerlink" title="0.4.1、本地方法"></a>0.4.1、本地方法</h3><h4 id="0-4-1-1、定义"><a href="#0-4-1-1、定义" class="headerlink" title="0.4.1.1、定义"></a>0.4.1.1、定义</h4><p><strong>被关键字native修饰的没有方法体的方法就是一个本地方法，本地方法是java调用非java代码的接口。</strong></p>
<h2 id="0-5、对象管理"><a href="#0-5、对象管理" class="headerlink" title="0.5、对象管理"></a>0.5、对象管理</h2><h3 id="0-5-1、对象创建"><a href="#0-5-1、对象创建" class="headerlink" title="0.5.1、对象创建"></a>0.5.1、对象创建</h3><p>创建对象一般遵循以下6大步骤：</p>
<ol>
<li>判断对象对应的类是否已经被加载、连接、初始化。</li>
<li>为对象分配内存。<ul>
<li>如果内存规整，通过【指针碰撞】方式来分配内存。</li>
<li>如果内存不规整，通过【空想列表】方式来分配内存。</li>
</ul>
</li>
<li>处理并发安全问题。<ul>
<li>采用CAS失败重试，区域加锁保证更新原子性。</li>
<li>每个线程预先分配一个TLAB。</li>
</ul>
</li>
<li>初始化分配到的空间。</li>
<li>设置对象的对象头。</li>
<li>执行init方法进行初始化。</li>
</ol>
<h3 id="0-5-2、对象定位"><a href="#0-5-2、对象定位" class="headerlink" title="0.5.2、对象定位"></a>0.5.2、对象定位</h3><h4 id="0-5-2-1、简介"><a href="#0-5-2-1、简介" class="headerlink" title="0.5.2.1、简介"></a>0.5.2.1、简介</h4><p>对象访问有两种方式：句柄访问和直接指针。<strong>Java中使用的是直接指针</strong>。</p>
<h4 id="0-5-2-2、句柄访问"><a href="#0-5-2-2、句柄访问" class="headerlink" title="0.5.2.2、句柄访问"></a>0.5.2.2、句柄访问</h4><p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86-1.1-%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%BD%8D-%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%9B%BE%E7%A4%BA.png"></p>
<h4 id="0-5-2-3、直接指针"><a href="#0-5-2-3、直接指针" class="headerlink" title="0.5.2.3、直接指针"></a>0.5.2.3、直接指针</h4><p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86-1.2-%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png"></p>
<h1 id="1、JVM基础"><a href="#1、JVM基础" class="headerlink" title="1、JVM基础"></a>1、JVM基础</h1><h2 id="1-1、概述"><a href="#1-1、概述" class="headerlink" title="1.1、概述"></a>1.1、概述</h2><h3 id="1-1-1、简介"><a href="#1-1-1、简介" class="headerlink" title="1.1.1、简介"></a>1.1.1、简介</h3><p><strong>JVM全称为Java Virtual Machine，意为Java虚拟机。</strong></p>
<p><strong>JVM、JRE、JDK、JAVASE、JAVAEE等的关系：JVM &lt; JRE &lt; JDK &lt; JAVASE &lt; JAVAEE。它们之间是包含与被包含的关系。</strong>详情介绍如下：</p>
<ul>
<li><strong>JVM</strong>：Java Virtual Machine，意为Java虚拟机。</li>
<li><strong>JRE</strong>：Java Runtime Environment，意为Java运行时环境。</li>
<li><strong>JDK</strong>：Java Development Kit，意为Java开发工具集。</li>
<li><strong>JAVAME</strong>：Java Micro Edition，意为Micro版，之前称J2ME。是一个技术和规范的集合，它为移动设备（包括消费类产品、嵌入式设备、高级移动设备等）提供了基于Java环境的开发与应用平台。Java ME分为两类配置，一类是面向小型移动设备的<em>CLDC</em>（Connected Limited Device Profile），一类是面向功能更强大的移动设备如智能手机和机顶盒，称为<em>CDC</em>（Connected Device Profile CDC）。Java ME有自己的类库，其中<em>CLDC</em>使用的是专用的Java虚拟机叫做J<em>VM</em>。</li>
<li><strong>JAVASE</strong>：Java Standard Edition，意为Java标准版，之前称为J2SE。JAVASE是Java技术的核心和基础，是Java ME和Java EE编程的基础。</li>
<li><strong>JAVAEE</strong>：Java Enterprise Edition，意为 Java企业版，之前也称为J2EE。Java EE 是在 Java SE 的基础上构建的，它提供Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 3.0应用程序。</li>
</ul>
<p>JVM在垃圾回收层面与C++的区别：</p>
<ul>
<li>JAVA：系统自动处理，开发效率高，执行效率低。</li>
<li>C++：手工处理，开发效率低，执行效率高。容易出现忘记回收、内存泄漏。回收多次、非法访问等问题。</li>
</ul>
<h3 id="1-1-2、优点"><a href="#1-1-2、优点" class="headerlink" title="1.1.2、优点"></a>1.1.2、优点</h3><p>JVM优点如下：</p>
<ul>
<li>一次编译，到处运行。</li>
<li>自动垃圾回收。</li>
<li>多态特性。</li>
<li>数组下标越界检查。</li>
</ul>
<h3 id="1-1-3、常见虚拟机"><a href="#1-1-3、常见虚拟机" class="headerlink" title="1.1.3、常见虚拟机"></a>1.1.3、常见虚拟机</h3><ul>
<li><p>Hotspot</p>
</li>
<li><p>JRockit（BEA）</p>
<p>JRockit专注于服务端应用，据行业基准测试显示，其是世界上最快的JVM。2008年BEA被Oracle收购，Oracle计划将整合两大优秀的虚拟机，整合方式是在Hotspot基础上加入JRockit的新特性。</p>
</li>
<li><p>J9（IBM）</p>
<p>市场定位与HotSpot相似，适用于服务器端、桌面应用、嵌入式应用等场景。2017年左右，IBM开源了J9 VM，命名为OpenJ9，交给Eclipse基金会管理。</p>
</li>
<li><p>KVM</p>
</li>
<li><p>Azul VM</p>
</li>
<li><p>Liquid VM（BEA）</p>
</li>
<li><p>Graal VM</p>
<p>2018年Oracle公开Graal VM，号称“Run Programs Faster Anywhere”，其与1995年宣称的“Write Once, Run Anywhere”遥相呼应。Graal VM是在HotSpot VM基础上增强而成的跨语言全栈虚拟机，适用于多种语言。</p>
</li>
</ul>
<h3 id="1-1-4、虚拟机退出"><a href="#1-1-4、虚拟机退出" class="headerlink" title="1.1.4、虚拟机退出"></a>1.1.4、虚拟机退出</h3><p>导致虚拟机退出的情况分以下几种：</p>
<ul>
<li>程序正常结束。</li>
<li>程序执行过程中遇到了异常或错误，进而导致虚拟机退出。</li>
<li>因操作系统出现错误导致虚拟机退出。</li>
<li>调用了Runtime类或System类的exit方法，或Runtime类的halt方法，且Java安全管理器也允许这种操作。</li>
</ul>
<h2 id="1-2、认识垃圾"><a href="#1-2、认识垃圾" class="headerlink" title="1.2、认识垃圾"></a>1.2、认识垃圾</h2><h3 id="1-2-1、垃圾定义"><a href="#1-2-1、垃圾定义" class="headerlink" title="1.2.1、垃圾定义"></a>1.2.1、垃圾定义</h3><p><strong>没有引用指向的任何对象都称为垃圾，且应该被回收。</strong></p>
<h2 id="1-3、识别垃圾"><a href="#1-3、识别垃圾" class="headerlink" title="1.3、识别垃圾"></a>1.3、识别垃圾</h2><h3 id="1-3-1、引用计数算法"><a href="#1-3-1、引用计数算法" class="headerlink" title="1.3.1、引用计数算法"></a>1.3.1、引用计数算法</h3><h4 id="1-3-1-1、简介"><a href="#1-3-1-1、简介" class="headerlink" title="1.3.1.1、简介"></a>1.3.1.1、简介</h4><p><strong>当一个对象被引用时，该对象的引用计数器数值会加1，这被称为引用计数算法。</strong></p>
<h4 id="1-3-1-2、缺点"><a href="#1-3-1-2、缺点" class="headerlink" title="1.3.1.2、缺点"></a>1.3.1.2、缺点</h4><ol>
<li><p><font color='red'>需要一个单独字段来存储计数器，增加了存储开销。</font></p>
</li>
<li><p><font color='red'>每次赋值都需要更新计数器，增加了时间开销。</font></p>
</li>
<li><p><font color='red'>不能解决“循环引用”问题。</font></p>
<p>循环引用问题指：有对象A和对象B，对象A中含有对象B的引用，对象B中含有对象A的引用。此时，对象A和对象B的引用计数器都不为0，但是在系统中却不存在任何第3个对象引用了A或B。也就是说A和B是应该被回收的垃圾对象，但由于垃圾对象间相互引用，从而使垃圾回收器无法识别，引起内存泄漏。</p>
</li>
</ol>
<h3 id="1-3-2、根可达性算法"><a href="#1-3-2、根可达性算法" class="headerlink" title="1.3.2、根可达性算法"></a>1.3.2、根可达性算法</h3><h4 id="1-3-2-1、简介"><a href="#1-3-2-1、简介" class="headerlink" title="1.3.2.1、简介"></a>1.3.2.1、简介</h4><p><strong>根搜索算法有 实现简单、执行高效 等特点，可有效解决 循环引用 问题，防止内存泄漏发生。</strong></p>
<p>根搜索算法是以 根对象集合 为起始点，按照从上至下的方式 搜索 被根对象集合所连接的目标对象是否可达，如果目标对象不可达就表明该对象己死亡，便可以在 instanceOopDesc Mark World 中将其标记为垃圾对象。在根搜索算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</p>
<h4 id="1-3-2-2、根对象"><a href="#1-3-2-2、根对象" class="headerlink" title="1.3.2.2、根对象"></a>1.3.2.2、根对象</h4><p><strong>当一个程序刚启动时需要的那些对象就称为根对象。</strong>比如：</p>
<ol>
<li>main线程栈帧中的那些对象。</li>
<li>静态变量访问到的对象。</li>
<li>常量池：一个class用到其它class的那些类的对象称为根对象。</li>
<li>JNI：调用C和C++那些方法所使用到的那些类或对象。</li>
</ol>
<p>在 Hotspot 中，根对象集合包含5个元素：</p>
<ol>
<li>Java 对象引用。</li>
<li>本地方法内的对象引用。</li>
<li>运行时常量池中的对象引用。</li>
<li>方法区中类静态属性的对象引用。</li>
<li>与一个类对应的唯一数据类型的 Class 对象。</li>
</ol>
<h4 id="1-3-2-3、总结"><a href="#1-3-2-3、总结" class="headerlink" title="1.3.2.3、总结"></a>1.3.2.3、总结</h4><p><strong>根搜索算法中的不可达对象最初处于缓刑阶段，真正死亡要经历两次标记</strong>：</p>
<ol>
<li>如果一个对象没有与GCRoot相连，那么该对象会被第一次标记并判断是否执行该对象的finaliz()方法。如果该对象没有覆盖finalize()方法或finalize()方法已经执行过了，那么无需操作，否则会将该对象放入F-Queue中，然后通过一个低优先级的finalizer线程来执行该对象的finalize()方法。</li>
<li>稍后 GC 将对 F- Queue 中的对象进行第二次标记，第二次标记之前，如果该对象与其它对象建立了引用关系，那么第二次标记时会将该对象移出即将回收的集合。如果第二次标记之前，该对象没有发生引用变化，那么它将会被真正回收。</li>
</ol>
<h2 id="1-4、垃圾回收"><a href="#1-4、垃圾回收" class="headerlink" title="1.4、垃圾回收"></a>1.4、垃圾回收</h2><h3 id="1-4-1、垃圾回收算法"><a href="#1-4-1、垃圾回收算法" class="headerlink" title="1.4.1、垃圾回收算法"></a>1.4.1、垃圾回收算法</h3><h4 id="1-4-1-1、标记清除（Mark-Sweep）"><a href="#1-4-1-1、标记清除（Mark-Sweep）" class="headerlink" title="1.4.1.1、标记清除（Mark-Sweep）"></a>1.4.1.1、标记清除（Mark-Sweep）</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p><strong>标记存活对象然后清除未被标记的垃圾对象的算法称为 标记清除算法。</strong>该算法将垃圾回收分两个阶段，标记阶段和清除阶段。</p>
<ol>
<li><p>标记阶段</p>
<p>Collector从引用根节点开始遍历，标记可以被根对象关联到的对象，这些对象都是可达对象。</p>
</li>
<li><p>清除阶段</p>
<p>Collector对堆内存从头到尾进行线性遍历，如果发现某个对象在其Header中没有被标记为可达对象，则将其回收。</p>
<p>这里的清除并非是真的清除，而是将待清除对象的地址保存在空闲地址列表中，为新对象分配内存时，可以直接覆盖使用。</p>
</li>
</ol>
<p>标记-清除算法不需要运行环境监测每一次内存分配和指针操作，而只要在“标记”阶段中跟踪每个指针变量的指向，用类似思路实现的垃圾收集器常被称为 跟踪收集器。</p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li>优点：效率较高、成本较低。</li>
<li>缺点：会产生内存碎片、执行效率低。</li>
</ul>
<h4 id="1-4-1-2、复制（Copying）"><a href="#1-4-1-2、复制（Copying）" class="headerlink" title="1.4.1.2、复制（Copying）"></a>1.4.1.2、复制（Copying）</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p><strong>将内存空间分为两块，每次只使用其中一块。垃圾回收时会将当前使用内存（假如为区域A）中的存活对象拷贝至另一空闲内存中（假如为区域B），然后清掉区域A中剩下的死亡对象并交换两个内存区域的角色，最后完成垃圾回收，这种算法称之为 复制算法。</strong></p>
<h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li>优点：<font color='orang'>只扫描一次，效率高且没有碎片；</font></li>
<li>缺点：<font color='red'>每次只使用一半内存，造成空间浪费；移动复制对象需要调整对象引用；</font></li>
</ul>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>适用于存活对象较少的情况。</p>
<h4 id="1-4-1-3、标记压缩（Mark-Compact）"><a href="#1-4-1-3、标记压缩（Mark-Compact）" class="headerlink" title="1.4.1.3、标记压缩（Mark-Compact）"></a>1.4.1.3、标记压缩（Mark-Compact）</h4><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><p>标记压缩算法思想：<strong>从根节点开始标记所有被引用对象，然后将存活对象压缩到内存一端并按顺序排放，之后清理边界外所有的空间。</strong></p>
<p>空间压缩后，内存较为规整，此种情况下可以通过 指针碰撞 算法为新对象分配空间。</p>
<h5 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li>优点：<font color='orang'>不会 产生碎片；</font></li>
<li>缺点：<font color='red'>两遍扫描，第一遍先找出有用的，第二遍才进行移动，如果是多线程还需要进行同步，效率低。</font></li>
</ul>
<h4 id="1-4-1-4、增量算法-（Incremental-Collecting"><a href="#1-4-1-4、增量算法-（Incremental-Collecting" class="headerlink" title="1.4.1.4、增量算法 （Incremental Collecting )"></a>1.4.1.4、增量算法 （Incremental Collecting )</h4><p>增量算法思想：<strong>垃圾收集线程和应用程序线程交替执行，每次垃圾收集线程只收集小片内存空间，然后切换到应用程序线程执行。依次反复，直到垃圾收集完成。</strong></p>
<p><strong>垃圾回收线程 和 应用程序线程同时执行，可以减少停顿时间，但因线程切换、上下文转换等开销会降低吞吐量。</strong></p>
<h4 id="1-4-1-5、Card-Table（卡表）"><a href="#1-4-1-5、Card-Table（卡表）" class="headerlink" title="1.4.1.5、Card Table（卡表）"></a>1.4.1.5、Card Table（卡表）</h4><p>官方解释：A kind of remembered set that records where oops have changed in a generation.</p>
<p><strong>Card Table 是一种数组结构，底层由BitMap实现，每个位置代表一个Card，其大小为1byte。</strong>1byte有八位，通过约定每一位的含义就可区分不同的使用场景。</p>
<p>卡表作用：<strong>将老年代空间分成多个大小相同的块（一般为 <code>128~512bytes</code> ），叫做卡片（Card）。对象放在不同的card中，如果老年代的某个Card中的对象引用了年轻代中的对象，写屏障逻辑就会将之标记为Dirty，下次扫描时只需扫描Dirty Card即可。</strong></p>
<h3 id="1-4-2、垃圾回收触发机制"><a href="#1-4-2、垃圾回收触发机制" class="headerlink" title="1.4.2、垃圾回收触发机制"></a>1.4.2、垃圾回收触发机制</h3><h4 id="1-4-2-1、年轻代GC"><a href="#1-4-2-1、年轻代GC" class="headerlink" title="1.4.2.1、年轻代GC"></a>1.4.2.1、年轻代GC</h4><ul>
<li>年轻代空间不足时会触发Minor GC，Survivor区满并不会触发GC。</li>
<li>Minor GC会引发STW，暂停其它用户线程，当垃圾线程执行完毕后用户线程才会恢复。</li>
</ul>
<h4 id="1-4-2-2、老年代GC"><a href="#1-4-2-2、老年代GC" class="headerlink" title="1.4.2.2、老年代GC"></a>1.4.2.2、老年代GC</h4><ul>
<li>出现了Major GC前通常会先执行一次Minor GC（非绝对，Parallel Scavenge收集器可以直接执行Major GC。）。</li>
<li>Major GC 速度一般比Minor GC慢10倍以上。</li>
<li>Major GC后内存依然不足，那么就报OOM。</li>
</ul>
<h4 id="1-4-2-3、FUll-GC"><a href="#1-4-2-3、FUll-GC" class="headerlink" title="1.4.2.3、FUll GC"></a>1.4.2.3、FUll GC</h4><p>触发FGC的情况有如下几种：</p>
<ul>
<li>老年代空间不足。</li>
<li>方法区空间不足。</li>
<li>通过Minor GC后进入老年代对象的平均大小大于老年代可用空间。</li>
<li>由Eden区、Survivor from区向Survivor to区复制对象时，对象大小大于to区可用内存，则把该对象放进老年代，且老年代可用内存小于该对象大小。</li>
<li>调用System.gc()方法时，通知系统执行Full GC，但不保证一定执行。</li>
</ul>
<h2 id="1-5、堆内存逻辑分区模型"><a href="#1-5、堆内存逻辑分区模型" class="headerlink" title="1.5、堆内存逻辑分区模型"></a>1.5、堆内存逻辑分区模型</h2><ul>
<li>除了Epsilon、ZGC、Shenandoah之外，其它GC都使用逻辑分代模型。</li>
<li>G1是逻辑分代，物理不分代。</li>
<li>除此之外，不仅逻辑分代，物理也分代。</li>
</ul>
<h2 id="1-6、新老年代划分"><a href="#1-6、新老年代划分" class="headerlink" title="1.6、新老年代划分"></a>1.6、新老年代划分</h2><h3 id="1-6-1、新生代"><a href="#1-6-1、新生代" class="headerlink" title="1.6.1、新生代"></a>1.6.1、新生代</h3><ul>
<li><font color='orange'>eden（伊甸）</font>：默认比例为8，存放刚new出来的对象。</li>
<li><font color='orange'>survivor from</font>：默认比例为1，回收一次后要存储对象的区域。</li>
<li><font color='orange'>survivor to</font>：默认比例为1，回收一次后要存储对象的区域。</li>
</ul>
<h3 id="1-6-2、老年代"><a href="#1-6-2、老年代" class="headerlink" title="1.6.2、老年代"></a>1.6.2、老年代</h3><ul>
<li><font color='orange'>tenured（终身）</font>：默认与新生代的比例为2:1，存放大对象和生命力较强的对象。</li>
</ul>
<h2 id="1-7、对象生命周期"><a href="#1-7、对象生命周期" class="headerlink" title="1.7、对象生命周期"></a>1.7、对象生命周期</h2><h3 id="1-7-1、生命周期"><a href="#1-7-1、生命周期" class="headerlink" title="1.7.1、生命周期"></a>1.7.1、生命周期</h3><p><strong>对象产生后会优先栈上分配；如果不能分配，就判断其大小，如果太大直接放进老年代，如果不大，就在TLAB中分配；如果还是分配不下，就直接在eden区分配。</strong></p>
<p>eden区经过一次垃圾回收之后，未被回收的对象会进入surivor from区，eden区和surivor from区再经过一次回收后，未被回收的对象会被移动到survivor to区（注意：移动完成后from区和to区交换角色，即 from变to，to变from，为的是下次再回收后来存储alive对象），以此反复执行，直到年龄达到阈值时就进入老年代。</p>
<p><font color='red'>注意：from &lt;—&gt; to区中对象间的移动超过阈值就会进入老年代，这个阈值可通过如下参数进行设置：</font></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-XX:MaxTenuringThreshold</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>栈上分配前提条件：</p>
<ul>
<li><font color='orange'>线程私有小对象。</font></li>
<li><font color='orange'>无逃逸</font>：在某一段代码中使用，代码外无法使用。</li>
<li><font color='orange'>支持标量替换</font>：用普通的类型代替对象（若仅仅使用一个对象中的1至2个属性，那么就无需先拿到对象再获取对应属性，而是直接使用这两个属性代替这个对象）。</li>
<li><font color='orange'>无需调整。</font></li>
</ul>
<h3 id="1-7-2、TLAB"><a href="#1-7-2、TLAB" class="headerlink" title="1.7.2、TLAB"></a>1.7.2、TLAB</h3><h4 id="1-7-2-1、简介"><a href="#1-7-2-1、简介" class="headerlink" title="1.7.2.1、简介"></a>1.7.2.1、简介</h4><p><strong>TLAB意为 线程本地分配缓冲区，TLAB是堆内存eden区中划分出的一块线程专用空间。</strong>线程初始化时，虚拟机会为每一个线程分配一块TLAB空间，该空间线程独有。如果要分配内存，优先在该空间上分配，这样就避免了竞争，大大提高内存分配效率和线程安全。</p>
<p><font color='red'>注意：TLAB的独占只限于“内存分配”这个动作，而对于TLAB的读取、内存回收等操作依然属于线程共享。</font></p>
<h4 id="1-7-2-2、TLAB问题"><a href="#1-7-2-2、TLAB问题" class="headerlink" title="1.7.2.2、TLAB问题"></a>1.7.2.2、TLAB问题</h4><p>假如一个线程的TLAB空间大小为100KB，已经使用80KB，当再分配一个30KB的对象时，就无法在TLAB中分配，遇到此种情况，有两种处理方案：</p>
<ol>
<li><font color='orange'>直接在堆内存中分配对象。</font></li>
<li><font color='orange'>废弃当前TLAB，重新申请TLAB并在其中为对象分配内存。</font></li>
</ol>
<p>为解决这两个问题，虚拟机设定了一个参数<code>refill_waste</code>，称为【最大浪费空间】。当请求分配的内存大于该参数值，则在堆内存中分配对象，当小于该值时则废弃当前TLAB并重新申请TLAB，然后在其中进行对象分配。</p>
<h4 id="1-7-2-3、TLAB相关参数"><a href="#1-7-2-3、TLAB相关参数" class="headerlink" title="1.7.2.3、TLAB相关参数"></a>1.7.2.3、TLAB相关参数</h4><ul>
<li><font color='orange'>手动指定tlab大小</font>：-XX：TLABSize</li>
<li><font color='orange'>tlab功能开启&#x2F;关闭</font>：XX:+&#x2F;-UseTLAB</li>
<li><font color='orange'>tlab占eden空间百分比</font>：-XX:TLABWasteTargetPercent</li>
<li><font color='orange'>禁用tlab运行时动态自动调整大小功能</font>：-XX:-ResizeTLAB</li>
<li><font color='orange'>tlab的refill_waste值</font>：-XX：TLABRefillWasteFraction（默认大小64，表示使用约为1&#x2F;64空间大小作为refill_waste）</li>
<li><font color='orange'>观察tlab使用情况</font>：-XX+PringTLAB</li>
</ul>
<h3 id="1-7-3、何时进入老年代"><a href="#1-7-3、何时进入老年代" class="headerlink" title="1.7.3、何时进入老年代"></a>1.7.3、何时进入老年代</h3><h4 id="1-7-3-1、参数指定"><a href="#1-7-3-1、参数指定" class="headerlink" title="1.7.3.1、参数指定"></a>1.7.3.1、参数指定</h4><p><font color='orange'>年龄达到参数<code>-XX:MaxTenuringThreshold</code> 设置的值，如果不指定，默认参考如下：</font></p>
<ul>
<li>Parallel Scavenge：15</li>
<li>CMS：6</li>
<li>G1：15</li>
</ul>
<h4 id="1-7-3-2、动态年龄"><a href="#1-7-3-2、动态年龄" class="headerlink" title="1.7.3.2、动态年龄"></a>1.7.3.2、动态年龄</h4><ul>
<li>from -&gt; to后超过to内存总量50%。form + eden区的存活对象全部移到to区后，若此时to区中相同年龄对象的内存大小总和占用to区内存总量的一半时，则将这些年龄相同的对象和超过该年龄的对象直接放入老年代。所以说也不一定非得到了15岁&#x2F;6岁才行。</li>
<li>把年龄最大的直接放入老年代。</li>
</ul>
<h2 id="1-8、垃圾收集器"><a href="#1-8、垃圾收集器" class="headerlink" title="1.8、垃圾收集器"></a>1.8、垃圾收集器</h2><h3 id="1-8-1、Serial（JDK1-3）"><a href="#1-8-1、Serial（JDK1-3）" class="headerlink" title="1.8.1、Serial（JDK1.3）"></a>1.8.1、Serial（JDK1.3）</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><strong>JDK1.3.1引入Serial GC，适用于 存储器小，CPU少的环境。</strong></p>
<p>Serial 收集器工作于<strong>年轻代</strong>，采用<strong>复制算法</strong>、串行回收和“ Stop-the-World ”机制的方式执行内存回收。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li><font color='orange'>-XX:+UseSerialGC</font>：年轻代、老年代分别使用Serial、Serial Old收集器。</li>
</ul>
<h3 id="1-8-2、Serial-Old"><a href="#1-8-2、Serial-Old" class="headerlink" title="1.8.2、Serial Old"></a>1.8.2、Serial Old</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>Serial Old收集器工作于<strong>老年代</strong>，采用 单线程 <strong>标记压缩算法</strong>。</p>
<blockquote>
<p>Serial Old是运行在Client模式下默认的老年代垃圾回收器。Serial Old在Server模式下主要有两个用途：与新生代的Parallel Scavenge配合使用；作为老年代CMS收集器的后备方案。</p>
</blockquote>
<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul>
<li><font color='orange'>-XX:+UseSerialGC</font>：年轻代、老年代分别使用Serial、Serial Old收集器。</li>
</ul>
<h3 id="1-8-3、Parallel-Scavenge（JDK1-4）"><a href="#1-8-3、Parallel-Scavenge（JDK1-4）" class="headerlink" title="1.8.3、Parallel Scavenge（JDK1.4）"></a>1.8.3、Parallel Scavenge（JDK1.4）</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p><strong>JDK1.4.2引入Parallel GC，JDK6中成为默认垃圾回收器。</strong></p>
<p>Parallel Scavenge收集器工作在<strong>年轻代</strong>，采用<strong>复制算法</strong>，关注吞吐量。与并行收集器一样都是多线程、独占式的收集器。</p>
<p>自适应调节策略是Parallel Scavenge与ParNew的一个重要区别。</p>
<blockquote>
<p>如果没有优化，JDK1.8默认使用Parallel Scavenge和Parallel Old，简称PS+PO。</p>
</blockquote>
<h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><ul>
<li><font color='orange'>-XX:+UseParallelGC </font>：年轻代使用并行回收收集器，老年代使用串行收集器。</li>
<li><font color='orange'>-XX:+UseParallelOldGC</font>：年轻代和老年代都使用井行垃圾回收器。</li>
<li>-XX:ParallelGCThreads：年轻代并行收集器的线程数量。默认，当CPU数量小于8时线程数量等于CPU数量。当CPU数量大于8时，线程数量值为：3+[5*cpu数量&#x2F;8]。</li>
<li><font color='orange'>-XX MaxGCPauseMills</font>：最大垃圾收集停顿时间（单位毫秒），它的值是一个大于0的整数。</li>
<li><font color='orange'>-XX:+GCTimeRatio</font>：垃圾收集时间占总时间的比例。取值范围为0~100，默认值为99，也就是垃圾回收时间占用不超过1%。与参数<code>-XX MaxGCPauseMills</code>有一定矛盾性。</li>
<li>-XX:+UseAdaptiveSizePolicy：开启自适应调节策略。在这种模式下，年轻代的大小、 Eden的比例、晋升老年代的对象年龄等参数会被自动调整，己达到在堆大小、吞吐量和停顿时间之间的平衡点。仅指定虚拟机的最大堆、目标的吞吐量（ GCTimeRatio ）和停顿时间（ MaxGCPauseMills) , 让虚拟机自己完成调优工作。</li>
</ul>
<h3 id="1-8-4、Parallel-Old"><a href="#1-8-4、Parallel-Old" class="headerlink" title="1.8.4、Parallel Old"></a>1.8.4、Parallel Old</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p><strong>Parallel Old收集器工作于老年代，它既是多线程并发收集器，也是关注吞吐量的收集器。它采用标记压缩算法，基于并行回收和“Stop-the-World”机制，JDK 1.6 之后开始启用。</strong></p>
<h4 id="如何开启？"><a href="#如何开启？" class="headerlink" title="如何开启？"></a>如何开启？</h4><ul>
<li><font color='orange'>-XX:+UseParallelOldGC</font>：年轻代和老年代中都使用并行回收收集器；</li>
<li><font color='orange'>-XX :ParallelGCThreads</font>：垃圾回收时的线程数量；</li>
</ul>
<h3 id="1-8-5、ParNew"><a href="#1-8-5、ParNew" class="headerlink" title="1.8.5、ParNew"></a>1.8.5、ParNew</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><p><strong>ParNew收集器是Serial收集器的多线程版本。</strong></p>
<p>ParNew收集器工作于<strong>年轻代</strong>，采用<strong>复制算法</strong>和<strong>Stop-the-World机制</strong>，并采用井行回收的方式执行内存回收。</p>
<blockquote>
<p>ParNew是大多数JVM运行在Server模式下新生代的默认垃圾回收器。</p>
<p>目前来说，ParNew只能与CMS配合工作。</p>
</blockquote>
<h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>优点<ol>
<li><font color='orange'>单CPU环境下， ParNew 收集器不见得比 Serial 收集器更高效；</font></li>
<li><font color='orange'>ParNew收集器可充分利用多CPU、多核心等物理硬件优势，可以更快速地完成垃圾收集，提升程序吞吐量；</font></li>
</ol>
</li>
<li>缺点</li>
</ul>
<h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><ul>
<li>-XX:+UseParNewGC：使用 ParNew 收集器；</li>
<li>-XX:ParallelGCThreads：并发线程数量，默认与CPU数量相同。</li>
</ul>
<h4 id="ParNew-vs-Paraller-Scavenge"><a href="#ParNew-vs-Paraller-Scavenge" class="headerlink" title="ParNew vs Paraller Scavenge"></a>ParNew vs Paraller Scavenge</h4><ol>
<li>PN响应时间优先，可配合CMS。</li>
<li>PS吞吐量优先。</li>
</ol>
<p>ParNew是Parallel Scavenge的变种。</p>
<h3 id="1-8-6、CMS（JDK1-4）"><a href="#1-8-6、CMS（JDK1-4）" class="headerlink" title="1.8.6、CMS（JDK1.4）"></a>1.8.6、CMS（JDK1.4）</h3><h4 id="1-8-6-1、简介"><a href="#1-8-6-1、简介" class="headerlink" title="1.8.6.1、简介"></a>1.8.6.1、简介</h4><p>CMS 是 concurrent mark sweep的首字母，意为并发标记回收。工作线程和垃圾回收线程可同时工作。CMS 天生井发、低延迟。CMS采用<strong>标记清除算法</strong>和<strong>STW机制</strong>。</p>
<p><font color='red'>注意：HotSpot 中， 除了 CMS收集器外的任何老年代垃圾收集器都会执行Full GC，只有G1收集器较为特殊。</font></p>
<blockquote>
<p>JDK 1.4.2引入CMS，JDK 14中删除了CMS。</p>
</blockquote>
<h4 id="1-8-6-2、回收过程"><a href="#1-8-6-2、回收过程" class="headerlink" title="1.8.6.2、回收过程"></a>1.8.6.2、回收过程</h4><ol>
<li><p><font color='orange'>初始标记</font>：有STW；单线程；</p>
</li>
<li><p><font color='orange'>并发标记</font>：工作线程和回收线程同时工作；多线程；会产生漏标问题。</p>
<p>最耗时的阶段，且并发执行、不产生STW、响应较好，如何做到？它会从根对象往下找，寻找过程中可能出现 垃圾被引用后又变成不是垃圾的情况。如果该情况发生在并发标记阶段，此时就会进入重新标记阶段，标记上一阶段标记后又发生变化的那些对象，因为变化不多，故重新标记也有STW，不过时间不长，故它可以控制暂停时间。</p>
</li>
<li><p><font color='orange'>重新标记</font>：STW；多线程；</p>
<p>对 起死回生对象、漏标对象 进行重新标记。</p>
</li>
<li><p><font color='orange'>并发清理</font>：会产生浮动垃圾（新垃圾）</p>
<p>回收垃圾对象过程中产生的新垃圾称为浮动垃圾。</p>
</li>
</ol>
<h4 id="1-8-6-3、优缺点"><a href="#1-8-6-3、优缺点" class="headerlink" title="1.8.6.3、优缺点"></a>1.8.6.3、优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>CMS优点：<strong>并发收集、低延迟</strong>。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>CMS存在如下缺点：</p>
<ul>
<li><p><strong>会产生内存碎片</strong></p>
<p>并发清除后，存在内存碎片，可用空间不足，无法分配大对象，不得不提前触发FULL GC。</p>
</li>
<li><p><strong>对CPU资源较敏感</strong></p>
<p>并发执行过程占用了一部分的资源导致程序一定程度上变慢，总吞吐量会降低。</p>
</li>
<li><p><strong>无法处理浮动垃圾</strong></p>
<p>程序线程与垃圾收集线程同时运行，并发标记阶段可能出现一些新的垃圾对象，而这些新的垃圾对象无法在这一时刻被及时处理，只能留给下一次GC来处理。</p>
</li>
</ul>
<p><font color='red'>CMS无法处理时会采用 单线程Serial Old收集器 进行标记压缩，速度会非常慢，应避免该情况发生。</font></p>
<h4 id="1-8-6-4、参数"><a href="#1-8-6-4、参数" class="headerlink" title="1.8.6.4、参数"></a>1.8.6.4、参数</h4><ul>
<li><strong>-XX:+UseConcMarkSweepGC</strong>：使用 CMS 收集器。开启该参数时会自动开启参数-XX:+UserParNewGC，最终的组合就是年轻代使用ParNew，老年代使用CMS和Serial Old。</li>
<li><strong>-XX:CMSInitiatingOccupanyFraction</strong>：堆内存使用率阈值，达到该阈值会触发垃圾回收。JDK5及之前版本默认值为68，即堆内存使用率达到68%时触发一次垃圾回收。JDK6及之后版本默认值为92。</li>
<li><strong>-XX:+UseCMSInitiatingOccupancyOnly</strong>： 只使用设定的回收阈值(-XX:CMSInitiatingOccupanyFraction值)。如果不开启该功能，则JVM仅在第一次使用设定值，后续会自动调整；</li>
<li><strong>-XX:+UseCMSCompactAtFullCollection</strong>：执行完Full GC后是否对内存进行压缩，压缩可避免内存碎片但停顿时间会更长。</li>
<li><strong>-XX:CMSFullGCsBeforeCompaction</strong>：执行多少次Full GC后对内存进行压缩。</li>
<li><strong>-XX:ParallelCMSThreads</strong>：CMS线程数量。默认线程数量为**(ParallelGCThreads + 3) &#x2F; 4**，</li>
</ul>
<h4 id="1-8-6-6、扩展"><a href="#1-8-6-6、扩展" class="headerlink" title="1.8.6.6、扩展"></a>1.8.6.6、扩展</h4><h5 id="Card-Table"><a href="#Card-Table" class="headerlink" title="Card Table"></a>Card Table</h5><p>Card Table是一种用于辅助处理跨代垃圾回收的数据结构。它的作用是跟踪对象引用在堆内存中的位置变化，以便准确的标记和回收垃圾对象。</p>
<p>Java堆内存通常被划分为多个连续的内存块，称之为卡片（Card）。每个卡片的大小通常为512字节或更小。Java堆中的每个对象引用都被映射到一个或多个卡片上。</p>
<p>Card Table通过位图（Bitmap）来表示堆内存的卡片状态。这个位图的每个位对应一个卡片，用于标记卡片上的引用是否发生变化。位图通常被分为两个部分，一个称为“dirty card”位图，用于标记引用变为非空；另一个称为“clean card”位图，用于标记引用变为空。</p>
<p>对象引用发生变化时，对应的卡片状态会发生改变。GC进行垃圾回收时会先扫描“dirty card”位图，找到与该位图相关的对象并对之进行检查，确保其准确性。</p>
<p>Card Table提供了一种增量标记的方式，即只对发生变化的卡片进行标记和处理，减少垃圾回收停顿时间，提供吞吐量。</p>
<p>Card Table只是垃圾回收机制的一部分，它与其它组件合作来实现高效垃圾回收。Card Table的实现会因不同的垃圾回收器而有所差异。</p>
<h5 id="Rememvered-Set"><a href="#Rememvered-Set" class="headerlink" title="Rememvered Set"></a>Rememvered Set</h5><p>Remembered Set是一种用于<strong>跟踪堆内存中对象应用的数据结构。与Card Table一起工作，帮助其准确地标记和回收垃圾对象</strong>。</p>
<p>Remembered Set的主要作用是<em><strong>记录老年代中对象对年轻代中对象的引用关系</strong></em>。</p>
<p>Remembered Set使用一种特殊的数据结构，通常是一个位图，或其它类似位图的结构。位图的每个位对应一个引用，用于标记引用是否存在。当对象引用发生变化时，对响应的位进行标记或清除。</p>
<p>Card Table会标记发生变化的卡片，而 Remembered Set会根据这些卡片信息来确定哪些引用需要被记录下来。</p>
<p>垃圾回收器执行垃圾回收时会先扫描Remembered Set中标记的引用，垃圾回收器会根据这些引用关系进行标记和处理，确保引用链的完整性和准确性。</p>
<h5 id="CMS中的使用"><a href="#CMS中的使用" class="headerlink" title="CMS中的使用"></a>CMS中的使用</h5><p>Card Table 在 CMS GC 中也有使用，使用一块区域用来记录老年代中的每个 Card 指向新生代的引用（<code>points-out</code> 结构），YGC执行时会将该区域的对象作为 GC roots，而不需要扫描整个老年代。</p>
<p>并发标记时，如果某个对象的引用发生了变化，那么标记该对象所在的 Card 为 Dirty Card（通过 write-barrier）。在重新标记时，只需要重新扫描 Dirty Cards 即可，同时【清除 Dirty 标记】。</p>
<h3 id="1-8-7、G1（JDK7）"><a href="#1-8-7、G1（JDK7）" class="headerlink" title="1.8.7、G1（JDK7）"></a>1.8.7、G1（JDK7）</h3><h4 id="1-8-7-1、简介"><a href="#1-8-7-1、简介" class="headerlink" title="1.8.7.1、简介"></a>1.8.7.1、简介</h4><p><em><strong>JDK 1.7u4中引入G1，JDK9中G1成为默认垃圾收集器，JDK12中增强了G1</strong></em>。</p>
<p><strong>G1是一款服务器式垃圾回收器，适用于 大内存多处理器 的服务器。可以尽可能满足设定的垃圾回收暂定目标，同时提高吞吐量。</strong></p>
<p>如果你的应用程序符合以下几点，那么使用G1将变得非常合适：</p>
<ul>
<li>超过50%的堆内存被实时数据占用。</li>
<li>对象分配率和晋升率有很大差异。</li>
</ul>
<p>G1有如下特点：</p>
<ol>
<li><strong>并发收集；</strong></li>
<li><strong>压缩空闲空间不会延长GC暂停时间</strong>；</li>
<li><strong>更易预测的GC暂停时间</strong>；</li>
<li><strong>适用于 低吞吐量 场景</strong>；</li>
</ol>
<h4 id="1-8-7-2、Region"><a href="#1-8-7-2、Region" class="headerlink" title="1.8.7.2、Region"></a>1.8.7.2、Region</h4><p><strong>G1 会把整个 Java 堆划分为不超过2048个大小独立的Region，每个 Region 大小要满足2的N次幂，范围在1MB-32MB 之间</strong>。Region的大小在 JVM 生命周期内不会被改变。</p>
<p>每一个Region在逻辑上属于某一个分代，该分代分为四种：</p>
<ol>
<li><strong>Eden区存放新对象</strong>；</li>
<li><strong>Survivor区放存活对象</strong>；</li>
<li><strong>old区存放老对象</strong>；</li>
<li><strong>Humongoous区存放大对象</strong>；（G1中通常会将H区作为老年代的一部分来看待。）</li>
</ol>
<blockquote>
<p>G1内存区域不是固定的E或O。G1新老年代比例动态变化无需显式指定，因为G1有预测停顿时间的基准。G1会跟踪每一次STW，据此动态设置各个Regin的大小。</p>
<p>一个对象大小超过了1个Region的一半则称该对象为大对象。如果一个H区无法容纳一个大对象，那么会使用连续的H区来存储这个大对象。为了能找到连续的H区，有时不得不执行Full GC。G1不会复制巨型对象，巨型对象没有被引用时会在YGC阶段被回收。</p>
</blockquote>
<h4 id="1-8-7-3、重要概念"><a href="#1-8-7-3、重要概念" class="headerlink" title="1.8.7.3、重要概念"></a>1.8.7.3、重要概念</h4><h5 id="RSet"><a href="#RSet" class="headerlink" title="RSet"></a>RSet</h5><p><em><strong>RSet是Remembered Set的缩写，意为记录集合。G1中的每个Region都有一个RSet，它是一个hash表（表中存储card table），记录了其它Region中的对象对本Region中对象的引用</strong></em>。</p>
<p>***RSet大小和Region数量有直接关系，一般来说 RSet 的大小占整个 Java 堆空间的1%~20%***。</p>
<blockquote>
<p>每次引用类型数据写操作时，会产生一个写屏障来中断当前操作。然后检查要写入的引用指向的对象与当前引用类型是否在不同的Regin中，如果确实在不同的Region，那么通过CardTable把相关引用信息记录到引用所指对象所在的Regin的RSet中。</p>
</blockquote>
<p><em><strong>G1中RSet使用的是point-in机制，而CMS使用的是point-out机制</strong></em>。</p>
<blockquote>
<p>point-in是指：哪些分区引用了当前分区中的对象，则仅仅将这些对象当做根来扫描就避免了无效的扫描。</p>
</blockquote>
<p>对于G1来说，当引用发生变化时赋值器会对引用做处理，引用较多时赋值器开销会很大，为解决开销大问题，G1 中又引入了卡表（Card Table）。</p>
<blockquote>
<p>当 Region 被引用较多时，RSet 占用空间会上升，因此为RSet 的存储划分了三种粒度：</p>
<ul>
<li><font color='orange'>稀疏表（Sparse）</font>：直接通过哈希表来存储，key 是 region index，value 是 card 数组（记录 card index）。</li>
<li><font color='orange'>细粒度（Fine）</font>：当一个 region 的 card 数量超过阈值时，退化为一个 bitmap，每一位对应一个card（index）。如果bit为0表示该bit对应的内存分段中没有引用，为1表示有引用。</li>
<li><font color='orange'>粗粒度（Coarse）</font>：当引用 region 数量超过阈值时，退化为只记录 regin 引用，由 bitmap 存储，每一位对应一个 region（index）。</li>
</ul>
<p>因为某些Region中的对象可能会被其它许多对象引用，为避免保存太多数据，故会以更大粒度保存引用，这种方式会减少RS数据，但会增加扫描和标记开销，因为需要扫描所有bit为1的内存分段中的对象以确定具体是来自哪个对象的引用。 </p>
</blockquote>
<h5 id="Card-Table-1"><a href="#Card-Table-1" class="headerlink" title="Card Table"></a>Card Table</h5><p>Card Table会将一个分区在逻辑上划分为多个固定大小的连续区域，每个区域称之为卡。卡通常较小，介于128到512字节之间，堆中每 512byte 映射 card table 1 byte。Card Table通常为字节数组，数组的索引（即数组下标）会用来标识每个卡的空间地址。当一个卡被引用时，该卡对应数组索引下的值会被标记为0，即标记为脏被引用，RSet会将该下标记录下来。<strong>RSet一般是一个Hash Table，Key是其它Region的起始地址，Value是一个集合，集合中存储的是Card Table的Index。</strong></p>
<blockquote>
<p>JVM会对程序中的每一个引用赋值语句进行记录和处理，把引用关系更新到RS中。RS更新并非实时性，RS处理需要线程同步，开销会很大，所以为了性能需要，G1维护了一个Dirty Card Queue。对于引用赋值语句，JVM会在之前和之后执行特殊操作以在dirty card queue中加入一个保存了对象引用信息的card。YGC时G1会对Dirty Card Queue中所有的card进行处理并更新RS，以保证RS实时准确的反映引用关系。</p>
</blockquote>
<h5 id="CSet"><a href="#CSet" class="headerlink" title="CSet"></a>CSet</h5><p><strong>CSet意为回收集合，记录了需要回收的内存区域。</strong></p>
<p><strong>一个CSet 中包含多少 Region 取决于有多少空间可以被释放、G1停顿目标时间这两个因素。</strong>G1只关注是否有存活对象，如果没有，则无论你属于老年代，还是年轻代，你都会被回收井放入可用 Region 队列，下一次被分配到哪里是无法确定的。</p>
<p>CSet 包含了大量Region ，每个Region中有一个RSet。</p>
<h5 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h5><p><font color='orange'>TLAB是Thread Local Allocation Buffer的首字母，意为 线程本地分配缓冲。</font></p>
<p>堆内存是线程共享的，多个线程分配内存时需要加锁同步。为了避免加锁，提高性能，每一个线程会被分配一个私有TLAB。TLAB中的内存来自于G1年轻代中的内存分段。当对象是Humongous对象，TLAB也能装下的时候，对象会被优先分配在线程的TLAB中。因为TLAB属于线程，不需要加锁，效率高。</p>
<h5 id="PLAB"><a href="#PLAB" class="headerlink" title="PLAB"></a>PLAB</h5><p><font color='orange'>PLAB是Promotion Local Allocation Buffer的首字母，意为晋升本地分配缓冲。</font></p>
<p>G1是多线程并发回收，为避免多线程将对象向同一个内存分段拷贝，那么复制过程也需加锁。为避免加锁，G1的每个线程都关联一个PLAB，这样就不需要进行加锁了。</p>
<p>多线程环境下最好使用<code>-XX:-ResizePLAB</code>来关闭PLAB大小的自动调整功能，避免大量线程通信导致的性能下降。</p>
<h5 id="SATB"><a href="#SATB" class="headerlink" title="SATB"></a>SATB</h5><p><font color='orange'>SATB是Snapshot At The Beginning的首字母，意为开始时快照。</font></p>
<h4 id="1-8-7-4、GC回收过程"><a href="#1-8-7-4、GC回收过程" class="headerlink" title="1.8.7.4、GC回收过程"></a>1.8.7.4、GC回收过程</h4><p>G1垃圾回收过程图示如下：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-1.1-G1-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.png"></p>
<h5 id="YGC阶段（标记复制-STW）"><a href="#YGC阶段（标记复制-STW）" class="headerlink" title="YGC阶段（标记复制 &#x2F; STW）"></a>YGC阶段（标记复制 &#x2F; STW）</h5><p>对象被创建后首先放到Eden区，<strong>当所有Eden区都满了，G1会启动一次年轻代垃圾回收</strong>：首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），将要被回收的内存放到回收集中，然后执行回收操作。</p>
<p><font color='red'>注意</font>：YGC只会回收Eden区和Survivor区。回收集是指需要被回收的内存分段的集合，年轻代回收集 包含年轻代Eden区和Survivor区所有的内存分段。</p>
<p>年轻代回收过程如下：</p>
<ol>
<li><font color='orange'>根扫描</font>：根指的是静态变量指向的对象，正在执行的方法链条上的局部变量等。根引用和RSet记录的外部引用将作为扫描存活对象的入口。</li>
<li><font color='orange'>更新RS</font>：处理Dirty Card队列，更新RS。（RS可以反映老年代中的对象对年轻代对象的引用）</li>
<li><font color='orange'>处理RS</font>：识别老年代对象对Eden区中对象的引用，被指向的Eden区对象都被认为是存活对象。</li>
<li><font color='orange'>对象拷贝</font>：将Eden中的存活对象复制到survivor中，Survivor中存活对象年龄未达阈值则将年龄加1，达到阈值则复制到老年代中。如果Survivor空间不足，Eden中部分数据会直接晋升至老年代。</li>
<li><font color='orange'>处理引用</font>：处理软引用，弱引用，虚引用、Final等引用。最终Eden中空间为空，GC停止，目标内存中对象连续，没有内存碎片，所以复制过程可以达到整理内存的效果。</li>
</ol>
<h5 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h5><p><strong>年轻代回收后或 houmongous对象 分配后会检测当前堆内存使用情况，当堆内存（包括老年代和新生代）使用率达到参数<code>-XX:InitiatingHeapOccupancyPercent</code>（默认是45%）设置的百分比时会触发老年代回收。</strong></p>
<p><strong>老年代回收包含标记老年代内对象是否存活的过程，标记过程和应用程序并发运行（不需要Stop-The-World）</strong>，所以应用程序会改变指针指向，进而导致对象丢失。<strong>G1处理对象丢失的方法是使用 开始时快照技术（SATB，Snapshot At The Begging）</strong>，这种技术会造成某些垃圾对象也被当做是存活对象，所以G1会使得占用的内存比实际需要的内存大。</p>
<p>并发标记过程如下：</p>
<ol>
<li><p><font color='orange'>初始标记（STW）</font><br>标记从根节点直接可达的对象。该阶段存在STW，且会触发一次YGC。</p>
</li>
<li><p><font color='orange'>根区域扫描</font><br>扫描Survivor区直接可达的老年代对象，并标记被引用的对象。该过程必须在YGC之前完成。</p>
</li>
<li><p><font color='orange'>并发标记</font><br>在整个堆中进行并发标记（可与应用程序并发执行），该过程可能被YGC中断。并发标记阶段，若区域中的对象都是垃圾，那么这个区域会被立即回收。同时，会计算每个区域对象的活性（区域中存活对象的比例）。</p>
</li>
<li><p><font color='orange'>再次标记（STW）</font><br>由于并发标记阶段是GC和应用程序同时执行，可能存在漏标情况，所以需要执行STW式的再次标记。G1中采用了SATB（开始时快照技术）算法。</p>
</li>
<li><p><font color='orange'>独占清除（STW）</font><br>计算各个区域存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。该阶段不会做垃圾收集。</p>
</li>
<li><p><font color='orange'>并发清理</font></p>
<p>识别并清理完全空闲的区域。</p>
</li>
</ol>
<h5 id="混合回收（Mixed-GC）"><a href="#混合回收（Mixed-GC）" class="headerlink" title="混合回收（Mixed GC）"></a>混合回收（Mixed GC）</h5><p><strong>越来越多的对象晋升到老年代Regin后，为避免堆内存被耗尽，会触发一次混合回收（Mixed GC）。</strong>该算法并非是Old GC，除了回收整个年轻代Regin，还会回收一部分老年代Regin。选择收集不同的老年代Regin（并发标记阶段中的独占清理阶段已经排序过了），可以一定程度上控制垃圾回收的消耗时间。</p>
<p><strong>并发标记结束以后，老年代中百分百为垃圾的内存被回收了，部分为垃圾的内存也计算了出来。</strong></p>
<ul>
<li><font color='orange'>-XX:G1MixedGCCountTarget</font>：该参数表示 老年代内存分段会分多少次来回收，默认8次。</li>
<li><font color='orange'>-XX:G1MixedGCLiveThresholdPercent</font>：表示垃圾占内存分段比例要达到该参数值设定的百分比时才会被回收，默认为65%。垃圾占内存分段比例越高的，越优先被回收。老年代、Eden、Survivor from区中要被回收的内存分段合起来称为Collection Set，也即 回收集合。混合回收回收集（Collection Set）包括八分之一的老年代内存分段、Eden区内存分段、Survivor区内存分段，下次mixed GC 的evacuation阶段会把他们都一并清理。混合回收的算法和年轻代完全一样，只是回收集多了老年代的内存分段。混合回收并不一定要进行8次。具体执行逻辑与参数-XX:G1HeapWastePercent有关，详情如下。</li>
<li><font color='orange'>-XX:G1HeapWastePercent</font>：默认为10%，表示允许浪费整个堆内存10%的空间。也就是说 若垃圾占堆内存的比例低于10%，就不再执行混合回收，因为性价比很低。</li>
</ul>
<p><font color='red'>注意：Mixed GC 并不是 Full GC。G1 GC回收足够数量的老年代区域 (通过多次混合回收) 后，G1将恢复到年轻代回收、全局并发标记、混合回收，以此逻辑循环执行。</font></p>
<h5 id="FGC"><a href="#FGC" class="headerlink" title="FGC"></a>FGC</h5><p>G1初衷是避免Full GC出现，但如果上述方式不能正常工作时会停止应用程序，使用单线程Serial收集器来完成垃圾清理工作，性能会非常差。</p>
<p>导致Full GC的原因有两个：</p>
<ul>
<li><em><strong>Evacuation时没有足够的to-space来存放晋升对象</strong></em>。</li>
<li><em><strong>并发处理过程完成之前空间耗尽</strong></em>。</li>
</ul>
<h4 id="1-8-7-5、三色标记算法"><a href="#1-8-7-5、三色标记算法" class="headerlink" title="1.8.7.5、三色标记算法"></a>1.8.7.5、三色标记算法</h4><p>并发标记使用的是三色标记算法。它是描述追踪式回收器的一种有效方法，利用它可以推演回收器的正确性。 三色标记会将对象分成三种类型：</p>
<ul>
<li><strong>黑色</strong>：根对象，或者该对象与它的子对象都被扫描过。</li>
<li><strong>灰色</strong>：对象本身已被扫描过，但该对象的子对象还没有扫描。</li>
<li><strong>白色</strong>：未扫描过的对象，扫描完所有对象之后，最终为白色的就是不可达对象，即为垃圾对象。</li>
</ul>
<h4 id="1-8-7-8、G1优化"><a href="#1-8-7-8、G1优化" class="headerlink" title="1.8.7.8、G1优化"></a>1.8.7.8、G1优化</h4><p>优化和注意事项分析如下：</p>
<ul>
<li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小。固定年轻代大小会覆盖暂停时间目标。</li>
<li>评估G1 GC吞吐量时，暂停时间目标不需要太严格，否则会直接影响吞吐量。</li>
</ul>
<h4 id="1-8-7-9、参数"><a href="#1-8-7-9、参数" class="headerlink" title="1.8.7.9、参数"></a>1.8.7.9、参数</h4><ul>
<li>-XX:+UseG1GC：使用G1垃圾回收器。</li>
<li>-XX:G1HeapRegionSize：每个Region的大小。值是2的幂，范围1m~32m之间。目标是根据最小Java堆大小划分处约2048个区域，默认是堆内存的1&#x2F;2000。</li>
<li>-XX:MaxGCPauseMillis：最大GC停顿时间指标。默认200ms。</li>
<li>-XX:ParallelGCThread：STW工作线程的数量，最多8个。</li>
<li>-XX:ConcGCThreads：并发标记的线程数量。建议该值为并行垃圾回收线程数量(ParallelGCThreads)的1&#x2F;4左右。</li>
<li>-XX:InitiatingHeapOccupancyPercent：触发并发GC周期的堆占用率阈值。默认是45。</li>
</ul>
<h3 id="1-8-8、ZGC-（JDK11）"><a href="#1-8-8、ZGC-（JDK11）" class="headerlink" title="1.8.8、ZGC （JDK11）"></a>1.8.8、ZGC （JDK11）</h3><h4 id="1-8-8-1、简介"><a href="#1-8-8-1、简介" class="headerlink" title="1.8.8.1、简介"></a>1.8.8.1、简介</h4><p><strong>ZGC是JDK11中 新加入的 具有实验性质的低延迟垃圾收集器，目前仅支持Linux&#x2F;x86-64。ZGC收集器是一款基于Region内存布局，（暂时）不设分代，使用读屏障、染色指针和内存多重映射等技术来实现可并发的标记整理算法，首要目标是实现低延迟。</strong></p>
<blockquote>
<p>JDK11中引入ZGC，JDK13中增强ZGC。</p>
</blockquote>
<h4 id="1-8-8-2、内存布局"><a href="#1-8-8-2、内存布局" class="headerlink" title="1.8.8.2、内存布局"></a>1.8.8.2、内存布局</h4><p>与Shenandoah和G1一样，ZGC也采取基于Region的堆内存布局，但是ZGC的Region具有动态性（动态的创建和销毁，以及动态的区域容量大小）。</p>
<p>ZGC的Region可以分为三类：</p>
<ul>
<li><font color='orange'>小型Region</font>：容量固定为2MB，用于放置小于256KB的小对象。</li>
<li><font color='orange'>中型Region</font>：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。</li>
<li><font color='orange'>大型Region</font>：容量不固定，可以动态变化，但必须为2MB的整数倍，用于存放4MB或以上的大对象。并且每个大型Region只会存放一个对象。</li>
</ul>
<h4 id="1-8-8-3、染色指针"><a href="#1-8-8-3、染色指针" class="headerlink" title="1.8.8.3、染色指针"></a>1.8.8.3、染色指针</h4><h5 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h5><p>HotSpot的垃圾收集器，有几种不同的标记实现方案。</p>
<ul>
<li>把标记直接记录在对象头上（Serial 收集器）。</li>
<li>把标记记录在于对象相互独立的数据结构上（G1、Shenandoah使用了一种相当于堆内存的1&#x2F;64大小的BitMap结构来记录标记信息）。</li>
<li>ZGC染色指针直接把标记信息记录到引用对象的指针上。</li>
</ul>
<p>染色指针是一种直接<em><strong>将少量额外信息存储在指针上的技术</strong></em>。目前Linux下64位指针的高18位不能用来寻址，但剩余的46位指针所能支持的4TB内存仍然可以满足需要。</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/ZGC%E9%A2%9C%E8%89%B2%E6%8C%87%E9%92%8801.png"></p>
<p>ZGC将使用剩下46位的高4位来存储四个标志信息：</p>
<ol>
<li><font color='orange'>Finalizable</font>：是否只能通过finalize()方法才能被访问到。</li>
<li><font color='orange'>Remapped</font>：是否进入了重分配集。</li>
<li><font color='orange'>Marked0</font>：通过这些标志虚拟机就可以直接从指针中看到引用对象的三色标记状态。</li>
<li><font color='orange'>Marked1</font>：同3。</li>
</ol>
<p><font color='red'>注意：由于这些标志位占用4位，故剩余42位空间（4TB），所以ZGC能够管理的内存不能超过4TB。</font></p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>染色指针可以使得一旦某个Region的存活对象被移走之后，该Region会立即被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。</li>
<li>染色指针可以减少在垃圾收集过程中内存屏障的使用数量。因为读、写内存屏障的主要目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。</li>
<li>染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</li>
</ul>
<h4 id="1-8-8-4、读屏障"><a href="#1-8-8-4、读屏障" class="headerlink" title="1.8.8.4、读屏障"></a>1.8.8.4、读屏障</h4><p><em><strong>当从堆中加载对象时，就会使用读屏障（Load Barrier）</strong></em>。读屏障的主要作用就是<em><strong>检查指针上的三色标记位，根据标记位判断出对象是否被移动过，如果没有则可以直接访问，如果移动过就需要进行“自愈”</strong></em>。自愈会使对象访问变慢，但“自愈”完成后访问就不会变慢了。</p>
<blockquote>
<p>当读取处于重分配集的对象时，会被读屏障拦截，通过 转发表记录 将访问转发到新复制对象上，并同时修正更新该引用的值，使其直接指向新对象。ZGC将这种行为叫做指针的“自愈能力”。</p>
</blockquote>
<h4 id="1-8-8-5、内存多重映射"><a href="#1-8-8-5、内存多重映射" class="headerlink" title="1.8.8.5、内存多重映射"></a>1.8.8.5、内存多重映射</h4><h5 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h5><p>Linux&#x2F;x86-64平台上ZGC使用了多重映射（Multi-Mapping）将多个不同的虚拟内存地址映射到同一物理内存地址上，这是一种多对一映射，意味着ZGC在虚拟内存中看到的地址空间要比实际的堆内存容量更大。把染色指针中的标志位看作是地址的分段符，那只要将这些不同的地址段都映射到同一物理内存空间，经过多重映射转换后，就可以使用染色指针进行正常寻址。</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/ZGC%E5%86%85%E5%AD%98%E5%A4%9A%E9%87%8D%E6%98%A0%E5%B0%8401.png"></p>
<h4 id="1-8-8-6、ZGC工作过程"><a href="#1-8-8-6、ZGC工作过程" class="headerlink" title="1.8.8.6、ZGC工作过程"></a>1.8.8.6、ZGC工作过程</h4><p>ZGC工作过程大致可划分为以下四个阶段。四个阶段都可以并发执行，仅是两个阶段中间会存在短暂的小阶段停顿。</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/ZGC%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B01" alt="ZGC运行过程"></p>
<ol>
<li><font color='orange'>并发标记（Concurrent Mark）</font>：与G1、Shenandoah一样，并发标记是遍历对象图做可达性分析的阶段，前后也要经过类似于G1、Shenandoah的初始标记、最终标记的短暂停顿，而且这些停顿阶段所做的事情在目标上也是类似的。</li>
<li><font color='orange'>并发预备重分配（ Concurrent Prepare for Relocate）</font>：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。</li>
<li><font color='orange'>并发重分配（Concurrent Relocate）</font>：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table）,记录从旧对象到新对象的转向关系。</li>
<li><font color='orange'>并发重映射（Concurrent Remap）</font>：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，ZGC的并发映射并不是以一个必须要“迫切”去完成的任务。ZGC很巧妙地把并发重映射阶段要做的工作，合并到下一次垃圾收集循环中的并发标记阶段里去完成，反正他们都是要遍历所有对象的，这样合并节省了一次遍历的开销。</li>
</ol>
<h4 id="1-8-8-7、ZGC优缺点"><a href="#1-8-8-7、ZGC优缺点" class="headerlink" title="1.8.8.7、ZGC优缺点"></a>1.8.8.7、ZGC优缺点</h4><h5 id="优点（高吞吐量、低延迟）"><a href="#优点（高吞吐量、低延迟）" class="headerlink" title="优点（高吞吐量、低延迟）"></a>优点（高吞吐量、低延迟）</h5><p>ZGC是支持<code>NUMA-Aware</code>的内存分配。MUMA（Non-Uniform Memory Access，非统一内存访问架构）是一种多处理器或多核处理器计算机所设计的内存架构。</p>
<p>现在多CPU插槽的服务器都是Numa架构，比如两颗CPU插槽(24核)，64G内存的服务器，那一颗CPU 12个核，访问从属于它的32G本地内存，要比访问另外32G远端内存要快得多。</p>
<p>ZGC默认支持NUMA架构，在创建对象时，根据当前线程在哪个CPU执行，优先在靠近这个CPU的内存进行分配，这样可以显著的提高性能，在SPEC JBB 2005 基准测试里获得40%的提升。</p>
<h5 id="缺点（浮动垃圾）"><a href="#缺点（浮动垃圾）" class="headerlink" title="缺点（浮动垃圾）"></a>缺点（浮动垃圾）</h5><p>当ZGC准备要对一个很大的堆做一次完整的并发收集，则全过程要持续十分钟以上，由于应用的对象分配速率很高，将创造大量的新对象，这些新对象很难进入当次收集的标记范围，通常就只能全部作为存活对象来看待（尽管其中绝大部分对象都是朝生夕灭），这就产生了大量的浮动垃圾。</p>
<p>目前唯一的办法就是尽可能地去增加堆容量大小，获取更多喘息的时间。但若要从根本上解决，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后针对这个区域进行更频繁、更快的收集。</p>
<h3 id="1-8-9、Epsilon（JDK11）"><a href="#1-8-9、Epsilon（JDK11）" class="headerlink" title="1.8.9、Epsilon（JDK11）"></a>1.8.9、Epsilon（JDK11）</h3><h4 id="1-8-9-1、简介"><a href="#1-8-9-1、简介" class="headerlink" title="1.8.9.1、简介"></a>1.8.9.1、简介</h4><p>JDK 11中的JEP 318添加了一个名为Epsilon的垃圾回收器实现。Epsilon（A No-Op Garbage Collector）的特点是只负责分配内存，而不做任何垃圾回收操作。当堆内存空闲空间不足时会自动触发与<code>OutOfMemoryError</code>相关的处理。</p>
<blockquote>
<p>JDK11引入Epsilon。</p>
</blockquote>
<h4 id="1-8-9-2、目标"><a href="#1-8-9-2、目标" class="headerlink" title="1.8.9.2、目标"></a>1.8.9.2、目标</h4><p>设计的目的是提供一个完全消极的GC实现，执行有限内存分配，最大限度降低内存占用量和内存吞吐时的延迟时间。一个好的实现是隔离代码变化，不影响其他GC，最小限度的改变其他的JVM代码。</p>
<h4 id="1-8-9-3、使用场景"><a href="#1-8-9-3、使用场景" class="headerlink" title="1.8.9.3、使用场景"></a>1.8.9.3、使用场景</h4><ul>
<li><font color='orange'>Performance testing</font>：什么都不执行的GC非常适合用于差异性分析。no-op GC可以用于过滤掉GC诱发的新能损耗，比如GC线程的调度，GC屏障的消耗，GC周期的不合适触发，内存位置变化等。此外有些延迟者不是由于GC引起的，比如scheduling hiccups, compiler transition hiccups，所以去除GC引发的延迟有助于统计这些延迟。</li>
<li><font color='orange'>Memory pressure testing</font>：在测试java代码时，确定分配内存的阈值有助于设置内存压力常量值。这时no-op就很有用，它可以简单地接受一个分配的内存分配上限，当内存超限时就失败。例如：测试需要分配小于1G的内存，就使用-Xmx1g参数来配置no-op GC，然后当内存耗尽的时候就直接crash。</li>
<li><font color='orange'>VM interface testing</font>：以VM开发视角，有一个简单的GC实现，有助于理解VM-GC的最小接口实现。它也用于证明VM-GC接口的健全性。</li>
<li><font color='orange'>Extremely short lived jobs</font>： 一个短声明周期的工作可能会依赖快速退出来释放资源，这个时候接收GC周期来清理heap其实是在浪费时间，因为heap会在退出时清理。并且GC周期可能会占用一会时间，因为它依赖heap上的数据量。</li>
<li><font color='orange'>Last-drop latency improvements</font>：对那些极端延迟敏感的应用，开发者十分清楚内存占用，或者是几乎没有垃圾回收的应用，此时耗时较长的GC周期将会是一件坏事。</li>
<li><font color='orange'>Last-drop throughput improvements</font>：即便对那些无需内存分配的工作，选择一个GC意味着选择了一系列的GC屏障，所有的OpenJDK GC都是分代的，所以他们至少会有一个写屏障。避免这些屏障可以带来一点点的吞吐量提升。</li>
</ul>
<h4 id="1-8-9-4、相关描述"><a href="#1-8-9-4、相关描述" class="headerlink" title="1.8.9.4、相关描述"></a>1.8.9.4、相关描述</h4><p>通过参数<code>-XX:+UseEpsilonGC</code>可以开启Epsilon GC。</p>
<p>Epsilon GC通过在分配内存的单个连续块中实现线性分配来工作。这样就可以在GC中轻松实现无锁TLAB（线程本地分配缓冲区）发行代码，然后可以重用现有VM代码处理的无锁TLAB内部分配。发出TLAB还有助于使驻留内存占用的进程受实际分配的内存限制。大量&#x2F;超出TLAB的分配由同一代码处理，因为在此方案中分配TLAB与分配大对象之间几乎没有区别。</p>
<p>Epsilon使用的障碍集完全为空&#x2F;无操作，因为GC不执行任何GC循环，因此不关心对象图，对象标记，对象复制等。引入一种新的障碍集实现是可能是此实现中最具破坏性的JVM更改。</p>
<p>由于Epsilon的运行时接口的唯一重要部分是发布TLAB的时间，因此其延迟很大程度上取决于所发布的TLAB的大小。对于任意大的TLAB和任意大的堆，延迟开销可以由任意低的正值（因此称为名称）来描述。（替代起源故事：“ epsilon”通常表示“空符号”，与该GC的禁止操作性保持一致）。</p>
<p>Java堆耗尽就不可能进行分配，也不能进行内存回收。此时有几种选择：</p>
<ul>
<li>抛出一条带有描述性信息的<code>OutOfMemoryError</code>异常消息。</li>
<li>执行堆转储（启用<code>-XX:+HeapDumpOnOutOfMemoryError</code>）</li>
<li>关闭JVM，并有选择地执行外部操作（通常操作<code>-XX:OnOutOfMemoryError=...</code>），例如，启动调试器或向外部监视系统通知该失败。</li>
</ul>
<h3 id="1-8-10、Shenandoah"><a href="#1-8-10、Shenandoah" class="headerlink" title="1.8.10、Shenandoah"></a>1.8.10、Shenandoah</h3><p>待补充。</p>
<h3 id="1-8-11、总结"><a href="#1-8-11、总结" class="headerlink" title="1.8.11、总结"></a>1.8.11、总结</h3><h4 id="1-8-11-1、垃圾收集器对比"><a href="#1-8-11-1、垃圾收集器对比" class="headerlink" title="1.8.11.1、垃圾收集器对比"></a>1.8.11.1、垃圾收集器对比</h4><p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-1.2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93.png"></p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210315120311771.png" alt="image-20210315120311771"></p>
<h4 id="1-8-11-2、ZGC-vs-Shenandoah"><a href="#1-8-11-2、ZGC-vs-Shenandoah" class="headerlink" title="1.8.11.2、ZGC vs Shenandoah"></a>1.8.11.2、ZGC vs Shenandoah</h4><p>前者用的是三色标记，后者用的是染色指针。</p>
<h4 id="1-8-11-3、三色标记-颜色指针"><a href="#1-8-11-3、三色标记-颜色指针" class="headerlink" title="1.8.11.3、三色标记 &#x2F; 颜色指针"></a>1.8.11.3、三色标记 &#x2F; 颜色指针</h4><ul>
<li><p><strong>三色标记</strong></p>
<p>把对象分为三个颜色，不同的颜色代表是否被标记过，还是标记了一半，还是没有标记。</p>
</li>
<li><p><strong>染色指针</strong></p>
<p>染色指针是一种直接将少量额外信息存储到指针上的技术。目前Linux下64位指针的高18位不能用来寻址，但剩余的46位指针所能支持的4TB内存仍然可以满足需要。故，拿出剩下的46位中高4位来记录不同的状态信息。</p>
</li>
</ul>
<h4 id="1-8-11-4、Remark阶段的算法"><a href="#1-8-11-4、Remark阶段的算法" class="headerlink" title="1.8.11.4、Remark阶段的算法"></a>1.8.11.4、Remark阶段的算法</h4><p>CMS和G1中用的是同一个算法，该算法叫三色标记：</p>
<ol>
<li><strong>黑</strong>：自己和所引用的对象都标记完了。</li>
<li><strong>灰</strong>：自己标记完了，但所引用的其它对象还没有标记。</li>
<li><strong>白</strong>：自己和引用的对象都还没有标记。</li>
</ol>
<h2 id="1-9、漏标问题"><a href="#1-9、漏标问题" class="headerlink" title="1.9、漏标问题"></a>1.9、漏标问题</h2><h3 id="1-9-1、认识漏标"><a href="#1-9-1、认识漏标" class="headerlink" title="1.9.1、认识漏标"></a>1.9.1、认识漏标</h3><p>CMS和G1的核心就是并发标记的线程和工作线程同时进行，而该阶段会产生“漏标”问题。</p>
<p>问题：<strong>GC标记阶段中如果删除了所有灰色到白色的引用，且黑色指向了白色，则此时若不对黑色对象的子对象进行重新扫描，就会出现漏标现象，会把白色对象当作垃圾被回收</strong>。</p>
<h3 id="1-9-2、解决漏标"><a href="#1-9-2、解决漏标" class="headerlink" title="1.9.2、解决漏标"></a>1.9.2、解决漏标</h3><p><strong>（1）增量更新（Increment Update）</strong></p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210314213906184.png" alt="image-20210314213906184"></p>
<p>如上图所示，若A指向D时，跟踪这个引用，并把A标记为灰色，这样下次扫描的时就会重新扫描A的子对象D，这就叫做增量更新。</p>
<p>特点：<em><strong>当产生新标记后，关注引用的增加，CMS采用 增量更新+写屏障 解决了漏标问题</strong></em>。</p>
<p><strong>（2）SATB（snapshot at the beginning）</strong></p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210314214048813.png" alt="image-20210314214048813"></p>
<p>如上图所示，刚开始做一个快照，当B和D之间的引用消失时要把这个引用推到GC的堆栈，保证D能够被扫描到。如果某一个引用消失了，我会把白色对象放到GC的堆栈中，下次扫描时直接扫描白色对象即可，这样白色就不会漏标了。</p>
<p>SATB有三个工作步骤：</p>
<ol>
<li>在开始标记时生成一个快照图，用来标记存活对象。</li>
<li>在并发标记时所有被改变的对象将会被加入到队列（在write barrier里把所有旧的引用所指向的对象都变成非白的）。</li>
<li>可能存在游离垃圾，将在下次被收集。</li>
</ol>
<p>特点：<em><strong>当引用被删除后，关注引用的删除，G1用 SATB+写屏障 解决了漏标问题</strong></em>。</p>
<blockquote>
<p>SATB 算法通过创建一个对象图的方式完成堆内存逻辑上的快照，即将堆内存里所有需要回收的对象全部呈现在它的这张对象图上，这个标记过程在并行标记阶段完成 。</p>
<p>SATB 算法维护的标记内容在数据结构上也分为两块， 一块是已经完成的标记，另一块是即将进行的标记。</p>
</blockquote>
<h3 id="1-9-3、总结"><a href="#1-9-3、总结" class="headerlink" title="1.9.3、总结"></a>1.9.3、总结</h3><p>灰色指向白色的引用消失时，如果没有黑色指向白色，则该引用会直接被push到堆栈，下次扫描时拿到这个引用，由于RSet的存在，不需要扫描整个堆去查找指向白色的引用，效率比较高。SATB配合RSet浑然天成。</p>
<blockquote>
<p>G1为什么使用SATB，而不使用incremental update？因为变成灰色后还要重新扫描，效率太低了。</p>
</blockquote>
<h1 id="2、JVM参数"><a href="#2、JVM参数" class="headerlink" title="2、JVM参数"></a>2、JVM参数</h1><h2 id="2-1、简介"><a href="#2-1、简介" class="headerlink" title="2.1、简介"></a>2.1、简介</h2><h3 id="2-1-1、参数分类"><a href="#2-1-1、参数分类" class="headerlink" title="2.1.1、参数分类"></a>2.1.1、参数分类</h3><ul>
<li><p><strong>-开头</strong>：标准类型，所有HotSpot都支持。</p>
</li>
<li><p><strong>-X开头</strong>：非标准类型，特定版本才支持。</p>
</li>
<li><p><strong>-XX开头</strong>：不稳定，下个版本可能取消。</p>
<ol>
<li><p><strong>Boolean类型参数</strong></p>
<p>-XX:+&#x2F;- 某个属性值（+表示开启，-表示关闭）。</p>
</li>
<li><p><strong>K-V类型参数</strong></p>
<p>-XX: key（属性）&#x3D; value（属性值）</p>
</li>
<li><p><strong>jinfo查看当前运行时配置项</strong></p>
<p>jinfo -flag 配置项 进程号</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>如何解释-Xms和-Xmx参数属于-XX参数？</p>
<p>-Xms &#x3D; -XX:InitialHeapSize  &#x2F;   -Xmx &#x3D; -XX:MaxHeapSize</p>
</blockquote>
<h3 id="2-1-2、查看参数值"><a href="#2-1-2、查看参数值" class="headerlink" title="2.1.2、查看参数值"></a>2.1.2、查看参数值</h3><h4 id="查看方式"><a href="#查看方式" class="headerlink" title="查看方式"></a>查看方式</h4><ol>
<li><p>查看java进程相关参数</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jinfo <span class="token parameter variable">-flag</span> 参数项 进程号
jinfo <span class="token parameter variable">-flags</span> 进程号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>查看默认值和最终值</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> <span class="token parameter variable">-XX:+PrintFlagsInitial</span>   <span class="token comment"># 查看jvm未更改的默认参数</span>
<span class="token function">java</span> <span class="token parameter variable">-XX:+PrintFlagsFinal</span>     <span class="token comment"># 查看jvm已经更改过的参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>也可以在运行java命令的同时加入打印jvm参数，如：<code>java -XX:+PrintFlagsFinal UpdateJVMParamDemo</code></p>
<p><font color="red">注意：<code>:=</code>表示jvm启动时修改过的参数。<code>=</code>表示jvm没有更改过的默认参数。</font></p>
</li>
<li><p>打印命令行参数</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> <span class="token parameter variable">-XX:+PrintCommandLineFlags</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>查看可以被修改的参数</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> <span class="token parameter variable">-XX:+PrintFlagsFinal</span> <span class="token parameter variable">-version</span> <span class="token operator">|</span> <span class="token function">grep</span> manageable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<h2 id="2-2、系统优化参数"><a href="#2-2、系统优化参数" class="headerlink" title="2.2、系统优化参数"></a>2.2、系统优化参数</h2><ul>
<li><strong>-XX:-UseCompressedOops</strong>：禁用压缩指针。默认启用，当 Java 堆内存小于 32 GB 时将使用压缩指针。启用此选项后，对象引用表示为 32 位偏移量而不是 64 位指针。此选项仅适用于 64 位 JVM。当 Java 堆内存大于 32GB 时，也可以使用压缩指针。查看<code>-XX:ObjectAlignmentInBytes</code>选项。 </li>
<li><strong>-XX:+Inline</strong>：启用方法内联。默认开启。要禁用方法内联，请指定<code>-XX:-Inline</code>。</li>
<li><strong>-XX:InlineSmallCode&#x3D;大小</strong>：设置触发内联功能的已编译方法的代码大小（以字节为单位）。只有已编译代码小于指定大小时才会被内联。默认最大代码大小设置为 1000 字节：-XX:InlineSmallCode&#x3D;1000。</li>
<li><strong>-XX:MaxInlineSize&#x3D;大小</strong>：设置要内联的方法的最大字节码大小（以字节为单位）。默认最大字节码大小为 35 个字节：<code>-XX:MaxInlineSize=35</code>。</li>
<li><strong>-XX:MaxTrivialSize&#x3D;大小</strong>：设置要内联的普通方法的最大字节码大小（以字节为单位）。默认普通方法的最大字节码大小为 6 个字节：<code>-XX:MaxTrivialSize=6</code>。</li>
<li><strong>-XX:+PrintInlining</strong>：启用内联决策打印，可以查看哪些方法正在被内联。默认禁用且不打印内联信息。参数<code>-XX:+PrintInlining</code>必须与参数<code>-XX:+UnlockDiagnosticVMOptions</code>一起使用。</li>
<li><strong>-XX:+OptimizeStringConcat</strong>：启用<code>String</code>连接优化。默认启用。要禁用<code>String</code>串联优化，请指定<code>-XX:-OptimizeStringConcat</code>。只有 Java HotSpot Server VM 支持此选项。</li>
<li><strong>-XX:+UseStringDeduplication</strong>：启用字符串重复数据删除。默认禁用。要想启用该功能就必须启用G1 垃圾收集器。</li>
</ul>
<h2 id="2-3、类加载参数"><a href="#2-3、类加载参数" class="headerlink" title="2.3、类加载参数"></a>2.3、类加载参数</h2><ul>
<li><p><strong>-XX:+TraceClassLoading</strong>：启用类加载跟踪。</p>
</li>
<li><p><strong>-XX:+TraceClassLoadingPreorder</strong>：启用按引用顺序跟踪所有加载类。默认禁用且不跟踪。</p>
</li>
<li><p><strong>-XX:+TraceClassUnloading</strong>：启用类卸载跟踪。默认禁用且不跟踪。</p>
</li>
<li><p><strong>-XX:CICompilerCount&#x3D;线程</strong>：设置用于编译的编译器线程数。默认线程数为 2，客户端线程数为 1，如果使用分层编译，它会扩展到内核数。</p>
</li>
<li><p><strong>-XX:CodeCacheMinimumFreeSpace&#x3D;大小</strong>：编译所需最小空间（以字节为单位）。当剩余空间小于最小可用空间时将停止编译。默认空间大小为 500 KB。</p>
</li>
<li><p><strong>-XX:CompileOnly&#x3D;方法</strong>：设置限制编译的方法列表（以逗号分隔）。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-XX:CompileOnly</span><span class="token operator">=</span>java/lang/String.length,java/util/List.size<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>-XX:CompileThreshold&#x3D;调用</strong>：设置 编译前解释方法次数。默认情况下，在服务器 JVM 中，JIT 编译器执行 10,000 次解释方法调用来收集信息以进行高效编译。对于客户端 JVM，默认为 1,500 次调用。启用分层编译时将忽略此选项；见选项<code>-XX:+TieredCompilation</code>。</p>
</li>
<li><p><strong>-XX:+BackgroundCompilation</strong>：启用后台编译。默认启用。要禁用后台编译，请指定<code>-XX:-BackgroundCompilation</code>（这等效于指定<code>-Xbatch</code>）。</p>
</li>
<li><p><strong>-XX:MaxNodeLimit&#x3D;节点</strong>：设置单个方法编译期间要使用的最大节点数。默认情况下，最大节点数设置为 65,000：<code>-XX:MaxNodeLimit=65000</code>。</p>
</li>
<li><p><strong>-XX:+PrintCompilation</strong>：通过在每次编译方法时将消息打印到控制台来启用来自 JVM 的详细诊断输出。这可以查看实际编译了哪些方法。默认禁用该功能且不打印诊断输出。同时可以通过指定参数<code>-XX:+LogCompilation</code>将编译活动记录到文件中。</p>
</li>
<li><p><strong>-XX:ReservedCodeCacheSize&#x3D;大小</strong>：设置 JIT 编译代码的最大代码缓存大小（以字节为单位）。默认最大代码缓存为 240 MB；如果指定参数<code>-XX:-TieredCompilation</code>禁用了分层编译，则默认大小为 48 MB。该参数最大限制为 2 GB，否则报错。最大代码缓存不应小于初始代码缓存；见选项<code>-XX:InitialCodeCacheSize</code>。此选项等效于<code>-Xmaxjitcodesize</code>。</p>
</li>
<li><p><strong>-XX:-TieredCompilation</strong>：禁用分层编译。默认启用。只有 Java HotSpot Server VM 支持此选项。</p>
</li>
</ul>
<h2 id="2-4、运行时数据区参数"><a href="#2-4、运行时数据区参数" class="headerlink" title="2.4、运行时数据区参数"></a>2.4、运行时数据区参数</h2><h3 id="2-4-1、堆（Heap）"><a href="#2-4-1、堆（Heap）" class="headerlink" title="2.4.1、堆（Heap）"></a>2.4.1、堆（Heap）</h3><h4 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h4><ul>
<li><strong>-Xms &#x2F; -XX:InitialHeapSize&#x3D;大小</strong>：堆内存最小值和初始大小。此值必须是 1024 的倍数且大于 1 MB。</li>
<li><strong>-Xmx &#x2F; -XX:MaxHeapSize&#x3D;大小</strong>：堆内存最大值（以字节为单位）。此值必须是 1024 的倍数且大于 2 MB。通常将<code>-Xms</code>并<code>-Xmx</code>设为相同值。</li>
<li><strong>-XX:+AggressiveHeap</strong>：启用 Java 堆优化。根据计算机配置（RAM 和 CPU）自动设置合适的参数值。默认禁用。</li>
<li><strong>-XX:NewRatio&#x3D;比率</strong>：设置年轻代和年老代大小比例。默认为 2。</li>
<li><strong>-XX:+UseAdaptiveSizePolicy</strong>：启用自适应大小调整。默认启用。要禁用请指定参数<code>-XX:-UseAdaptiveSizePolicy</code>和 设置内存分配池的大小（请参阅<code>-XX:SurvivorRatio</code>选项）。</li>
<li><strong>-XX:InitialRAMPercentage&#x3D;percent</strong>：将 JVM 用于 Java 堆的初始内存量设置为 -XX:MaxRAM 选项中所述确定的最大内存量的百分比。默认值为 1.5625%。</li>
<li><strong>-XX:MaxRAMPercentage&#x3D;百分比</strong>：Java 堆的最大内存量，设置为 -XX:MaxRAM 选项中所述确定的最大内存量的百分比。默认值为 25%。</li>
</ul>
<h4 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h4><ul>
<li><strong>-XX:NewSize</strong>：年轻代初始大小。</li>
<li><strong>-XX:MaxNewSize</strong>：年轻代最大内存大小。</li>
<li><strong>-Xmn</strong>：年轻代 初始大小 和 最大大小。官方建议 年轻代大小 应在 整堆大小的一半 到 四分之一之间。</li>
<li><strong>-XX:SurvivorRatio</strong>：新生代中 Eden区 与 Survivor区 的占用比例，默认为8，意为eden区大小占年轻代的8&#x2F;10，而survivor from区和to区各占1&#x2F;10；</li>
<li><strong>-XX:+UseTLAB</strong>：在年轻代中使用TLAB。默认启用。要禁用 TLAB，请指定<code>-XX:-UseTLAB</code>。</li>
<li><strong>-XX:TLABSize&#x3D;大小</strong>：TLAB 初始大小（以字节为单位）。参数值为 0 时表示自动选择初始大小。</li>
<li><strong>-XX:TargetSurvivorRatio&#x3D;百分比</strong>：设置YGC后，幸存区使用占比。默认为 50%。</li>
</ul>
<h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><h3 id="2-4-2、方法区（MethodArea）"><a href="#2-4-2、方法区（MethodArea）" class="headerlink" title="2.4.2、方法区（MethodArea）"></a>2.4.2、方法区（MethodArea）</h3><h4 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h4><ul>
<li><code>-XX:PermSize=256m</code>：设置永久代初始大小。</li>
<li><code>-XX:MaxPermSize=256m</code>：设置永久代最大容量。</li>
</ul>
<h4 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h4><ul>
<li><strong>-XX:MaxMetaspaceSize&#x3D;大小</strong>：设置 类元数据 最大本机内存量。默认大小不受限制。应用程序的元数据量取决于应用程序本身、其他正在运行的应用程序以及系统上可用的内存量。</li>
<li><strong>-XX:MetaspaceSize&#x3D;size</strong>：设置 类元数据空间大小，该空间将在第一次超出时触发垃圾回收。根据使用的元数据量增加或减少垃圾收集的阈值。默认大小取决于平台。</li>
<li><code>-XX:+UseCompressedOops</code>：压缩对象指针。</li>
<li><code>-XX:+UseCompressedClassPointers</code>：压缩类型指针。</li>
<li><code>-XX:CompressedClassSpaceSize</code>：设置Klass Metaspace的大小，默认1G。</li>
</ul>
<h3 id="2-4-3、操作数栈（OperandStack）"><a href="#2-4-3、操作数栈（OperandStack）" class="headerlink" title="2.4.3、操作数栈（OperandStack）"></a>2.4.3、操作数栈（OperandStack）</h3><ul>
<li><strong>-Xss</strong>：设置 线程堆栈大小（以字节为单位）等价于<code>-XX:ThreadStackSize=大小</code>。默认值取决于平台。</li>
<li><strong>-XX:+DoEscapeAnalysis</strong>：启用逃逸分析。默认启用。要禁用请指定<code>-XX:-DoEscapeAnalysis</code>。只有 Java HotSpot Server VM 支持此选项。</li>
</ul>
<h3 id="2-4-4、本地方法栈（LocalMethodStack）"><a href="#2-4-4、本地方法栈（LocalMethodStack）" class="headerlink" title="2.4.4、本地方法栈（LocalMethodStack）"></a>2.4.4、本地方法栈（LocalMethodStack）</h3><h3 id="2-4-5、程序计数器（ProgramRegister）"><a href="#2-4-5、程序计数器（ProgramRegister）" class="headerlink" title="2.4.5、程序计数器（ProgramRegister）"></a>2.4.5、程序计数器（ProgramRegister）</h3><h3 id="2-4-6、直接内存（DirectMemory）"><a href="#2-4-6、直接内存（DirectMemory）" class="headerlink" title="2.4.6、直接内存（DirectMemory）"></a>2.4.6、直接内存（DirectMemory）</h3><ul>
<li><strong>-XX:MaxDirectMemorySize&#x3D;大小</strong>：设置新 I&#x2F;O（<code>java.nio</code>包）直接缓冲区分配的最大值（以字节为单位）。默认大小为 0，表示 JVM 会自动选择 NIO 直接缓冲区大小。</li>
</ul>
<h3 id="2-4-7、其它"><a href="#2-4-7、其它" class="headerlink" title="2.4.7、其它"></a>2.4.7、其它</h3><ul>
<li><strong>-XX:ObjectAlignmentInBytes&#x3D;对齐</strong>：设置 Java 对象的内存对齐（以字节为单位）。默认为 8 个字节。指定的值应该是 2 的幂，并且必须在 8 到 256（含）范围内。</li>
<li><strong>-XX:+PrintCommandLineFlags</strong>：允许 打印出现在命令行上的符合人体工程学的选定 JVM 标志。</li>
<li><strong>-XX:InitialCodeCacheSize&#x3D;大小</strong>：设置 初始代码缓存大小（以字节为单位）。默认为 500 KB。初始代码缓存大小应不小于系统的最小内存页大小。</li>
</ul>
<h2 id="2-5、垃圾回收参数"><a href="#2-5、垃圾回收参数" class="headerlink" title="2.5、垃圾回收参数"></a>2.5、垃圾回收参数</h2><h3 id="2-5-1、基本参数"><a href="#2-5-1、基本参数" class="headerlink" title="2.5.1、基本参数"></a>2.5.1、基本参数</h3><ul>
<li><p><strong>-Xnoclassgc</strong>：禁用垃圾回收 (GC)。</p>
</li>
<li><p><strong>-XX:ErrorFile&#x3D;文件名</strong>：发生错误时 将 错误数据 写入指定文件。文件默认在当前目录且并命名为 hs_err_pid pid.log，其中 pid 是导致错误的进程标识符。</p>
</li>
<li><p><strong>-XX:+HeapDumpOnOutOfMemoryError</strong>：OOM引发异常时将错误信息导出到指定文件。可使用参数<code>-XX:HeapDumpPath</code>设置文件路径和名称。默认禁用。</p>
</li>
<li><p><strong>-XX:HeapDumpPath&#x3D;路径</strong>：设置该<code>-XX:+HeapDumpOnOutOfMemoryError</code>选项时，设置用于写入堆分析器 (HPROF) 提供的堆转储的路径和文件名。默认情况下，该文件在当前工作目录中创建，并命名为<code>java_pid</code><em>pid</em><code>.hprof</code>，其中 pid 是导致错误的进程标识符。以下示例设置默认文件（<code>%p</code>代表当前进程标识符）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-XX:HeapDumpPath</span><span class="token operator">=</span>./java_pid%p.hprof
<span class="token comment"># 以下示例显示如何将堆转储文件设置为/var/log/java/java_heapdump.hprof：</span>
<span class="token parameter variable">-XX:HeapDumpPath</span><span class="token operator">=</span>/var/log/java/java_heapdump.hprof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>-XX:ActiveProcessorCount&#x3D; x</strong>：覆盖 VM 用于计算其用于各种操作（例如垃圾收集和 ForkJoinPool）的线程池大小的 CPU 数量。</p>
</li>
<li><p><strong>-XX:MaxHeapFreeRatio&#x3D;百分比</strong>：设置 GC后堆最大空闲空间占比（0 到 100）。如果GC后空闲空间占比大于该参数值，则将堆缩小。默认为 70%。</p>
</li>
<li><p><strong>-XX:MinHeapFreeRatio&#x3D;百分比</strong>：设置 GC后堆最小空闲空间占比（0 到 100）。如果GC后空闲空间占比小于该参数值，则将堆扩大。默认为 40%。</p>
</li>
<li><p><strong>-XX:MaxTenuringThreshold&#x3D;阈值</strong>：对象晋升至老年代的最大年龄阈值为 15。并行（吞吐量）收集器默认为 15，CMS 收集器默认为 6。</p>
</li>
<li><p><strong>-XX:MinRAMPercentage&#x3D;百分比</strong>：将 JVM 可用于 Java 堆的最大内存量设置为如<code>-XX:MaxRAM</code>小堆选项中所述确定的最大内存量的百分比。小堆大约 125 MB。默认值为 50%。</p>
</li>
<li><p><strong>-XX:+ScavengeBeforeFullGC</strong>：FGC前先执行一次YGC，默认启用。Oracle 建议您不要禁用它。</p>
</li>
<li><p><strong>-XX:StringDeduplicationAgeThreshold&#x3D;阈值</strong>：<code>String</code>达到指定年龄的对象被视为重复数据删除的候选对象。一个对象的年龄是衡量它在垃圾收集中幸存下来的次数。这有时被称为任期；</p>
</li>
<li><p><strong>-XX:+UseGCOverheadLimit</strong>：允许使用限制 JVM 在<code>OutOfMemoryError</code>抛出异常之前花费在 GC 上的时间比例的策略。默认情况下启用此选项，<code>OutOfMemoryError</code>如果总时间的 98% 以上用于垃圾收集并且堆的回收少于 2%，则并行 GC 将抛出异常。当堆很小时，此功能可用于防止应用程序长时间运行而几乎没有或没有进展。要禁用此选项请指定<code>-XX:-UseGCOverheadLimit</code>。</p>
</li>
<li><p><strong>-XX:+UseNUMA</strong>：通过增加应用程序对低延迟内存的使用，在具有非统一内存架构 (NUMA) 的机器上实现应用程序的性能优化。默认情况下，此选项处于禁用状态，并且不会对 NUMA 进行优化。该选项仅在使用并行垃圾收集器 ( <code>-XX:+UseParallelGC</code>)时可用。</p>
</li>
<li><p><font color='orange'>-XX:PreTenureSizeThreshold</font>：设置大对象大小；</p>
</li>
<li><p><font color='orange'>-XX:MaxTenuringThreshold</font>：表示对象晋升到老年代的年龄阈值；（默认值15，CMS为6，G1为15。）</p>
<p><font color='red'>注意，年龄小于该阈值时也可能会晋升，但晋升时对象的年龄永远不会超过该阈值。因为还有对象动态晋升机制的存在，动态晋升是指：当survivor区中所有相同大小对象的大小总和超过survivor区一半时，就需要将这些相同大小的对象和大于该大小的对象全部晋升到老年代中，使得survivor区中有空闲空间来供程序正常运行来用，否则没有空闲空间，程序将会出现问题。</font></p>
</li>
</ul>
<h3 id="2-5-2、垃圾收集器参数"><a href="#2-5-2、垃圾收集器参数" class="headerlink" title="2.5.2、垃圾收集器参数"></a>2.5.2、垃圾收集器参数</h3><h4 id="基本参数-1"><a href="#基本参数-1" class="headerlink" title="基本参数"></a>基本参数</h4><ul>
<li><strong>-XX:ConcGCThreads&#x3D;线程</strong>：设置并发GC 线程数。默认值取决于 JVM 可用的 CPU 数量。</li>
<li><strong>-XX:+DisableExplicitGC</strong>：禁用代码块 System.gc()。</li>
<li><strong>-XX:InitiatingHeapOccupancyPercent&#x3D;百分比</strong>：设置启动并发 GC 周期的堆占用百分比（0 到 100）。它被垃圾收集器使用，它们根据整个堆的占用率触发并发 GC 周期，而不仅仅是其中一代（例如，G1 垃圾收集器）。默认初始值为 45%。值 0 表示不间断 GC 循环。</li>
<li><strong>-XX:MaxGCPauseMillis&#x3D;时间</strong>：设置 GC 最大暂停时间（以毫秒为单位）。默认 没有最大暂停时间值。</li>
</ul>
<h4 id="Serial-Old常用参数"><a href="#Serial-Old常用参数" class="headerlink" title="Serial Old常用参数"></a>Serial Old常用参数</h4><ul>
<li><strong>-XX:+UseSerialGC</strong>：启用串行垃圾收集器。适用于小型的简单的应用程序。默认禁用，并根据机器配置和 JVM 类型自动选择收集器。</li>
</ul>
<h4 id="Parallel常用参数"><a href="#Parallel常用参数" class="headerlink" title="Parallel常用参数"></a>Parallel常用参数</h4><ul>
<li><p><strong>-XX:+UseParallelGC</strong>：使用并行清理垃圾收集器（也称为吞吐量收集器）。默认禁用，并根据机器配置和 JVM 类型自动选择收集器。如果启用该选项，则默认同时启用<code>-XX:+UseParallelOldGC</code>，除非明确禁用它。</p>
</li>
<li><p><strong>-XX:+UseParallelOldGC</strong>：启用并行垃圾收集器。默认禁用。启用它会自动启用参数<code>-XX:+UseParallelGC</code>。</p>
</li>
<li><p><strong>-XX:+ParallelGCThreads&#x3D;n</strong>：设置用于年轻代和年老代并行垃圾回收的线程数。默认值取决于 JVM 可用的 CPU 数量。同样适用于CMS。*</p>
<p>按照逻辑处理器的数量来设置n值。n 的值应该与逻辑处理器的数量相同，最多为 8。如果逻辑处理器不止八个，则将 n 的值设置为逻辑处理器数量的 5&#x2F;8 左右。这适用于大多数情况，除非是较大的 SPARC 系统，其中 n 值可以是逻辑处理器数的 5&#x2F;16 左右。</p>
</li>
<li><p><strong>-XX:+UseAdaptiveSizePolicy</strong>：表示自动选择各区大小比例。</p>
</li>
<li><p><strong>-XX:InitialSurvivorRatio&#x3D;比率</strong>：设置吞吐量垃圾收集器使用的初始幸存者空间比率（由<code>-XX:+UseParallelGC</code>和&#x2F;或 -<code>XX:+UseParallelOldGC</code>选项启用）。默认吞吐量垃圾收集器使用<code>-XX:+UseParallelGC</code>和<code>-XX:+UseParallelOldGC</code>选项启用自适应大小调整，并根据应用程序行为调整幸存者空间大小，从初始值开始。如果禁用了自适应大小调整（使用该<code>-XX:-UseAdaptiveSizePolicy</code>选项），<code>-XX:SurvivorRatio</code>则应使用该选项为整个应用程序执行设置幸存者空间的大小。</p>
<p>根据年轻代的大小（Y）和初始幸存者空间比率（R），可以使用以下公式计算幸存者空间的初始大小（S）：</p>
<pre class="line-numbers language-none"><code class="language-none">S&#x3D;Y&#x2F;(R+2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>-XX:+ParallelRefProcEnabled</strong>：启用并行引用处理。默认禁用状态。</p>
</li>
<li><p><code>-XX:MaxGCPauseMillis</code>：设置垃圾收集器最大停顿时间。</p>
</li>
<li><p><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例。</p>
</li>
</ul>
<h4 id="ParNew参数"><a href="#ParNew参数" class="headerlink" title="ParNew参数"></a>ParNew参数</h4><ul>
<li><strong>-XX:+UseParNewGC</strong>：年轻代中使用 并行线程 进行收集。默认禁用。设置参数<code>-XX:+UseConcMarkSweepGC</code>会自动启用。使用<code>-XX:+UseParNewGC</code>不带选项<code>-XX:+UseConcMarkSweepGC</code>的选择是在JDK 8弃用。</li>
</ul>
<h4 id="CMS常用参数"><a href="#CMS常用参数" class="headerlink" title="CMS常用参数"></a>CMS常用参数</h4><ul>
<li><p><font color='orange'>-XX:+UseConcMarkSweepGC</font>：为老年代启用 CMS 垃圾收集器。Oracle 建议您在吞吐量 ( <code>-XX:+UseParallelGC</code>) 垃圾收集器无法满足应用程序延迟要求时使用 CMS 垃圾收集器。G1 垃圾收集器 ( <code>-XX:+UseG1GC</code>) 是另一种选择。</p>
<p>默认情况下，此选项处于禁用状态，并根据机器的配置和 JVM 的类型自动选择收集器。当启用该选项时，<code>-XX:+UseParNewGC</code>选项将自动设置，你不应该禁用它，因为下面的选项组合已经在JDK 8被弃用：<code>-XX:+UseConcMarkSweepGC -XX:-UseParNewGC</code>。</p>
</li>
<li><p><font color='orange'>-XX:ParallelCMSThreads</font>：CMS线程数量。</p>
</li>
<li><p><font color='orange'>-XX:CMSInitiatingOccupancyFraction</font>：老年代内存使用率达到多少时执行CMS收集（低版本的 JDK 默认值为 68%, JDK6 及以上版本默认值为 92%），这里的内存回收范围仅限于老年代，而非整个堆空间，因此通过该选项便可以有效降低 Full GC 执行次数。如果频繁发生SerialOld卡顿，应该调小，（频繁CMS回收）。默认值设置为 -1。任何负值（包括默认值）都意味着<code>-XX:CMSTriggerRatio</code>用于定义初始占用率的值。</p>
</li>
<li><p><font color='orange'>-XX:+UseCMSCompactAtFullCollection</font>：执行FGC后是否进行压缩整理。</p>
</li>
<li><p><font color='orange'>-XX:CMSFullGCsBeforeCompaction</font>：执行FGC多少次后进行压缩整理。</p>
</li>
<li><p><font color='orange'>-XX:+CMSClassUnloadingEnabled</font>：表示对永久代进行垃圾回收；</p>
<p>CMS收集器默认不会对永久代进行垃圾回收，如需回收设置该参数即可。在早期JVM版本中，要求设置额外的标志-XX:+CMSPermGenSweepingEnabled。注意，即使没有设置这个标志，一旦永久代耗尽空间也会尝试进行垃圾回收，但是收集不会是并行的，而再一次进行Full GC。</p>
</li>
<li><p><font color='orange'>-XX:CMSInitiatingPermOccupancyFraction</font>：达到什么比例时进行Perm回收。</p>
</li>
<li><p><font color='orange'>GCTimeRatio</font>：设置GC时间占用程序运行时间的百分比。</p>
</li>
<li><p><font color='orange'>-XX:MaxGCPauseMillis</font>：停顿时间，是一个建议时间，GC会尝试用各种手段达到这个时间，比如减小年轻代。</p>
</li>
<li><p><strong>-XX:+CMSClassUnloadingEnabled</strong>：在使用并发标记清除 (CMS) 垃圾收集器时启用类卸载。默认启用。要禁用 CMS 垃圾收集器的类卸载，请指定<code>-XX:-CMSClassUnloadingEnabled</code>。</p>
</li>
<li><p><strong>-XX:+CMSScavengeBeforeRemark</strong>：在 CMS 注释步骤之前启用清理尝试。默认禁用。</p>
</li>
<li><p><strong>-XX:CMSTriggerRatio&#x3D;百分比</strong>：设置在<code>-XX:MinHeapFreeRatio</code>CMS 收集周期开始之前分配的指定值的百分比（0 到 100）。默认值设置为 80%。</p>
</li>
<li><p><strong>-XX:+ExplicitGCInvokesConcurrent</strong>：通过使用<code>System.gc()</code>请求启用并发 GC 的调用。默认禁用，只能与<code>-XX:+UseConcMarkSweepGC</code>选项一起启用。</p>
</li>
<li><p><strong>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</strong>：通过在并发 GC 周期中使用 System.gc() 请求和卸载类来启用并发 GC 的调用。默认禁用，只能与 -XX:+UseConcMarkSweepGC 选项一起启用。</p>
</li>
<li><p><strong>-XX:+UseCMSInitiatingOccupancyOnly</strong>：允许使用占用值作为启动 CMS 收集器的唯一标准。默认禁用，可以使用其他条件。</p>
</li>
</ul>
<h4 id="G1常用参数"><a href="#G1常用参数" class="headerlink" title="G1常用参数"></a>G1常用参数</h4><ul>
<li><p><font color='orange'>-XX:+UseG1GC</font>：表示 使用G1收集器；</p>
</li>
<li><p><font color='orange'>-XX:MaxGCPauseMillis</font>：每次GC的停顿目标时间，默认值 200ms。G1会尝试调整Young区的个数来达到该值；</p>
</li>
<li><p>-<font color='orange'>XX:GCPauseIntervalMillis</font>：GC间隔时间；</p>
</li>
<li><p><font color='orange'>-XX:G1HeapRegionSize&#x3D;n</font>：分区大小，建议逐渐增大该值1、2、4、8、16、32。随着size增加，垃圾存活时间会更长，GC间隔会更长，但每次GC时间也会更长，ZGC做了改进（动态区块大小）；</p>
</li>
<li><p><font color='orange'>-XX:G1HeapWastePercent</font>：默认值5%，表示在全局并发标记结束后能够统计出所有可被回收的垃圾占Heap的比例值，如果超过5%，就会触发之后的多轮Mixed GC，mixed gc会同时回收年轻代+老年代，而这个参数可以指定mixed gc触发的时机；</p>
<p>注意：该参数与 <code>InitiatingHeapOccupancyPercent</code> 结合使用可以实现提前回收老年代，让老年代提前释放空间。</p>
</li>
<li><p><font color='orange'>-XX:InitiatingHeapOccupancyPercent&#x3D;45</font>：默认45%，表示在堆使用率达到该参数设定值时，就会触发 混合回收；</p>
</li>
<li><p><font color='orange'>-XX:G1NewSizePercent</font>：新生代最小比例，默认为5%。</p>
</li>
<li><p><font color='orange'>-XX:G1MaxNewSizePercent</font>：新生代最大比例，默认为60%；</p>
</li>
<li><p><font color='orange'>-XX:G1MixedGCCountTarget</font>：默认值8，表示最后的混合回收阶段会执行8次，一次只回收掉一部分Region，然后系统继续运行，过了一小段时间后，会再次进行混合回收，就这样重复8次；</p>
</li>
<li><p><font color='orange'>-XX:G1MixedGCLiveThresholdPercent</font>：默认值85%，表示 一个Region中的存活对象若大于Region大小的85%，那就无需回收这个Region，否则得不偿失；</p>
</li>
<li><p><font color='orange'>-XX:GCTimeRatio</font>：圾回收时间占程序运行时间的百分比；</p>
</li>
<li><p><font color='orange'>-XX:ConcGCThreads&#x3D;n</font>：设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1&#x2F;4 左右；</p>
</li>
<li><p><strong>-XX:G1HeapRegionSize&#x3D;大小</strong>：使用G1收集器时 Java 堆细分的区域大小。该值介于 1 MB 和 32 MB 之间。默认区域大小是根据堆大小来定。</p>
</li>
<li><p><strong>-XX:+G1PrintHeapRegions</strong>：启用打印有关哪些区域已分配以及哪些由 G1 收集器回收的信息。默认情况下，此选项处于禁用状态。</p>
</li>
<li><p><strong>-XX:G1ReservePercent&#x3D;百分比</strong>：设置保留为虚假上限的堆的百分比（0 到 50），以减少 G1 收集器升级失败的可能性。默认情况下，此选项设置为 10%。</p>
</li>
<li><p><strong>-XX:+UseStringDeduplication</strong>：启用字符串重复数据删除。默认禁用。要使用此选项，您必须启用G1垃圾收集器。</p>
</li>
</ul>
<h4 id="常见垃圾回收器参数"><a href="#常见垃圾回收器参数" class="headerlink" title="常见垃圾回收器参数"></a>常见垃圾回收器参数</h4><ul>
<li><p>设置串行收集器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-XX:+UseSerialGC</span>      <span class="token operator">=</span> Serial New<span class="token punctuation">(</span>DefNew<span class="token punctuation">)</span> + Serial Old<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>设置并行收集器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-XX:+UseParallelGC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>同时还需要设置以下参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-XX:ParallelGCThreads</span><span class="token operator">=</span>n     <span class="token comment"># 设置并行收集器工作时使用的CPU数量。</span>
<span class="token parameter variable">-XX:MaxGCPauseMillis</span><span class="token operator">=</span>n      <span class="token comment"># 设置并行收集器最大停顿时间。</span>
<span class="token parameter variable">-XX:GCTimeRatio</span><span class="token operator">=</span>n           <span class="token comment"># 设置垃圾回收时间占程序运行时间的百分比。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>设置老年代并行收集器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-XX:+UseParallelOldGC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>设置并发收集器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-XX:+UseConcMarkSweeqGC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>同时还需要设置以下参数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-XX:+CMSIncrementalMode</span>     <span class="token comment"># 设置为增量模式，适用于单CPU情况。</span>
<span class="token parameter variable">-XX:ParallelGCThreads</span><span class="token operator">=</span>n     <span class="token comment"># 设置年轻代收集为并行收集时，并行GC线程的数量，一般最好和CPU核心数量一样。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
<p>其它参数如下：</p>
<ul>
<li><p><font color='orange'>-XX:+UseParNewGC &#x3D; ParNew + SerialOld</font></p>
</li>
<li><p><font color='orange'>-XX:+UseConc(current)MarkSweepGC &#x3D; ParNew + CMS + SerialOld</font></p>
</li>
<li><p><font color='orange'>-XX:+UseParallelGC &#x3D; Parallel Scavenge + Parallel Old</font></p>
</li>
<li><p><font color='orange'>-XX:+UseG1GC &#x3D; G1</font></p>
</li>
<li><p>查看Linux下默认GC的方法，而Windows中会打印UseParallelGC</p>
<ol>
<li><font color='orange'>java -XX:+PrintCommandLineFlags - version</font></li>
<li>通过GC日志分辨。</li>
</ol>
</li>
<li><p>Linux下1.8版本默认垃圾收集器是啥？</p>
<ol>
<li>1.8.0_181 默认看不出，Copy MarkCompact</li>
<li>1.8.0_222 默认PS + PO</li>
</ol>
</li>
</ul>
<h3 id="2-5-3、GC日志参数"><a href="#2-5-3、GC日志参数" class="headerlink" title="2.5.3、GC日志参数"></a>2.5.3、GC日志参数</h3><h4 id="基本参数-2"><a href="#基本参数-2" class="headerlink" title="基本参数"></a>基本参数</h4><ul>
<li><strong>-XX:LogFile&#x3D;路径</strong>：设置写入日志数据的路径和文件名。默认该文件创建在当前工作目录中，并命名为<code>hotspot.log</code>.</li>
</ul>
<h4 id="日志打印参数"><a href="#日志打印参数" class="headerlink" title="日志打印参数"></a>日志打印参数</h4><ul>
<li><strong>-XX:+PrintGC</strong>：每次 GC 时打印消息。默认禁用。</li>
<li><strong>-XX:+PrintGCDetails</strong>：每次 GC 时打印详细消息。默认禁用。</li>
<li><strong>-XX:+PrintGCTimeStamps</strong>：每次 GC 时打印时间戳。默认禁用。</li>
<li><strong>-XX:+PrintGCTaskTimeStamps</strong>：为每个单独的 GC 工作线程任务启用时间戳打印。默认禁用。</li>
<li><strong>-XX:+PrintGCCauses</strong></li>
<li><strong>-XX:+PrintGCApplicationConcurrentTime</strong>：启用打印自上次暂停（例如，GC 暂停）以来经过的时间。默认禁用。</li>
<li><strong>-XX:+PrintGCApplicationStoppedTime</strong>：启用打印暂停（例如，GC 暂停）持续的时间。默认禁用。</li>
<li><strong>-XX:+PrintGCDateStamps</strong>：每次 GC 时打印日期戳。默认禁用。</li>
<li><strong>-XX:+PrintStringDeduplicationStatistics</strong>：打印详细重复数据，删除统计信息。默认禁用。查看<code>-XX:+UseStringDeduplication</code>选项。</li>
<li><strong>-XX:+PrintTenuringDistribution</strong>：启用任期年龄信息的打印。</li>
<li><strong>-XX:SoftRefLRUPolicyMSPerMB&#x3D;时间</strong>：软引用对象在上次被引用后在堆上保持活动的时间量（以毫秒为单位）。默认值是堆中每空闲兆字节的生命周期一秒。</li>
<li><strong>-XX:PrintHeapAtGC</strong>：GC执行前后打印出堆的信息；</li>
<li><strong>-Xloggc:filename</strong>：日志文件保存路径；</li>
</ul>
<p><font color="red">注意：total &#x3D; eden区 + 1个survivor区。</font></p>
<h4 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h4><ol>
<li><p>方式一</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log <span class="token parameter variable">-XX:+UseGCLogFileRotation</span> <span class="token parameter variable">-XX:NumberOfGCLogFiles</span><span class="token operator">=</span><span class="token number">5</span> <span class="token parameter variable">-XX:GCLogFileSize</span><span class="token operator">=</span>20M <span class="token parameter variable">-XX:+PrintGCDetails</span> <span class="token parameter variable">-XX:+PrintGCGateStamps</span> <span class="token parameter variable">-XX:+PrintGCCause</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>方式二</p>
<p>或者每天产生一个。</p>
</li>
</ol>
<h2 id="2-6、Java锁参数"><a href="#2-6、Java锁参数" class="headerlink" title="2.6、Java锁参数"></a>2.6、Java锁参数</h2><ul>
<li><strong>-XX:-UseBiasedLocking</strong>：禁用偏向锁。</li>
</ul>
<h2 id="2-7、JVM参数总结"><a href="#2-7、JVM参数总结" class="headerlink" title="2.7、JVM参数总结"></a>2.7、JVM参数总结</h2><h3 id="2-7-1、GC常用参数"><a href="#2-7-1、GC常用参数" class="headerlink" title="2.7.1、GC常用参数"></a>2.7.1、GC常用参数</h3><ul>
<li><font color='orange'>-Xms &#x2F; -Xmx &#x2F; -Xmn &#x2F; -Xss</font>：最小堆 &#x2F; 最大堆 &#x2F; 年轻代 &#x2F; 栈空间。</li>
<li><font color='orange'>-XX:NewSize</font>：JVM启动时分配的新生代内存大小。</li>
<li><font color='orange'>-XX:OldSize</font>：JVM启动时分配的老年代内存大小。</li>
<li><font color='orange'>-XX:PermSize 和 -XX:MaxPermSize</font>：JVM 永久代（方法区，JDK7之前）大小。</li>
<li><font color='orange'>-XX SurvivorRatio</font>：Eden空间和另外两个Survivor空间的比例，默认比例是<code>8:1</code>。</li>
<li><font color='orange'>-XX:+UseTLAB</font>：使用TLAB，默认打开。</li>
<li><font color='orange'>-XX:+PrintTLAB</font>：打印TLAB使用情况。</li>
<li><font color='orange'>-XX:TLABSize</font>：设置TLAB大小。</li>
<li><font color='orange'>-XX:+DisableExplictGC</font>：System.gc()不管用 ，FGC。</li>
<li><font color='orange'>-XX:+PrintGC</font>：</li>
<li><font color='orange'>-XX:+PrintGCDetails</font>：</li>
<li><font color='orange'>-XX:+PrintHeapAtGC</font>：</li>
<li><font color='orange'>-XX:+PrintGCTimeStamps</font>：</li>
<li><font color='orange'>-XX:+PrintGCApplicationConcurrentTime (低)</font>：打印应用程序时间。</li>
<li><font color='orange'>-XX:+PrintGCApplicationStoppedTime（低）</font>：打印暂停时长。</li>
<li><font color='orange'>-XX:+PrintReferenceGC（重要性低）</font>：记录回收了多少种不同引用类型的引用。</li>
<li><font color='orange'>-verbose:class</font>：类加载详细过程。</li>
<li><font color='orange'>-XX:+PrintVMOptions</font>：</li>
<li><font color='orange'>-XX:+PrintFlagsFinal  -XX:+PrintFlagsInitial</font>：必须会用。</li>
<li><font color='orange'>-Xloggc:opt&#x2F;log&#x2F;gc.log</font>：将生成的gc日志保存于指定的文件中。</li>
<li><font color='orange'>-XX:MaxTenuringThreshold</font>：升代年龄，最大值15。</li>
<li><font color='orange'>-XX:PreBlockSpin</font>：锁自旋次数参数（默认即可，不建议设置）。</li>
<li><font color='orange'>-XX:CompileThreshold</font>：热点代码检测参数、逃逸分析、标量替换（默认即可，不建议设置）。</li>
</ul>
<h3 id="2-7-2、堆内存常用配置"><a href="#2-7-2、堆内存常用配置" class="headerlink" title="2.7.2、堆内存常用配置"></a>2.7.2、堆内存常用配置</h3><h4 id="类型1"><a href="#类型1" class="headerlink" title="类型1"></a>类型1</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> <span class="token parameter variable">-Xmx3550m</span> <span class="token parameter variable">-Xms3550m</span> <span class="token parameter variable">-Xmn2g</span> <span class="token parameter variable">-Xss128k</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><p><font color='orange'>-Xmx3550m</font>：设置JVM最大可用内存为3550M。</p>
</li>
<li><p><font color='orange'>-Xms3550m</font>：设置JVM内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p>
</li>
<li><p><font color='orange'>-Xmn2g</font>：设置年轻代大小为2G。整个JVM内存大小&#x3D;年轻代大小+老年代大小+持久代大小。持久代大小一般固定为64m，所以增大年轻代后，将会减小老年代大小。</p>
<p><font color='red'>注意：此值对系统性能影响较大，Sun官方推荐配置为整个堆的3&#x2F;8。</font></p>
</li>
<li><p><font color='orange'>-Xss128k</font>：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p>
</li>
</ul>
<h4 id="类型2"><a href="#类型2" class="headerlink" title="类型2"></a>类型2</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> <span class="token parameter variable">-Xmx3550m</span> <span class="token parameter variable">-Xms3550m</span> <span class="token parameter variable">-Xss128k</span> <span class="token parameter variable">-XX:NewRatio</span><span class="token operator">=</span><span class="token number">4</span> <span class="token parameter variable">-XX:SurvivorRatio</span><span class="token operator">=</span><span class="token number">4</span> <span class="token parameter variable">-XX:MaxPermSize</span><span class="token operator">=</span>16m <span class="token parameter variable">-XX:MaxTenuringThreshold</span><span class="token operator">=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><font color='orange'>-XX:NewRatio&#x3D;4</font>：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4表示年轻代与年老代所占比值为<code>1:4</code>，年轻代占整个堆栈的1&#x2F;5。</li>
<li><font color='orange'>-XX:SurvivorRatio&#x3D;4</font>：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为<code>2:4</code>，一个Survivor区占整个年轻代的1&#x2F;6。</li>
<li><font color='orange'>-XX:MaxPermSize&#x3D;16m</font>：设置持久代大小为16m。</li>
<li><font color='orange'>-XX:MaxTenuringThreshold&#x3D;0</font>：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代即被回收的机会。</li>
</ul>
<h3 id="2-8-3、回收器常用配置"><a href="#2-8-3、回收器常用配置" class="headerlink" title="2.8.3、回收器常用配置"></a>2.8.3、回收器常用配置</h3><h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 方案1</span>
<span class="token function">java</span> <span class="token parameter variable">-Xmx3800m</span> <span class="token parameter variable">-Xms3800m</span> <span class="token parameter variable">-Xmn2g</span> <span class="token parameter variable">-Xss128k</span> <span class="token parameter variable">-XX:+UseParallelGC</span> <span class="token parameter variable">-XX:ParallelGCThreads</span><span class="token operator">=</span><span class="token number">20</span>
<span class="token comment"># 方案2</span>
<span class="token function">java</span> <span class="token parameter variable">-Xmx3550m</span> <span class="token parameter variable">-Xms3550m</span> <span class="token parameter variable">-Xmn2g</span> <span class="token parameter variable">-Xss128k</span> <span class="token parameter variable">-XX:+UseParallelGC</span> <span class="token parameter variable">-XX:ParallelGCThreads</span><span class="token operator">=</span><span class="token number">20</span> <span class="token parameter variable">-XX:+UseParallelOldGC</span>
<span class="token comment"># 方案3</span>
<span class="token function">java</span> <span class="token parameter variable">-Xmx3550m</span> <span class="token parameter variable">-Xms3550m</span> <span class="token parameter variable">-Xmn2g</span> <span class="token parameter variable">-Xss128k</span> <span class="token parameter variable">-XX:+UseParallelGC</span> <span class="token parameter variable">-XX:MaxGCPauseMillis</span><span class="token operator">=</span><span class="token number">100</span>
<span class="token comment"># 方案4</span>
<span class="token function">java</span> <span class="token parameter variable">-Xmx3550m</span> <span class="token parameter variable">-Xms3550m</span> <span class="token parameter variable">-Xmn2g</span> <span class="token parameter variable">-Xss128k</span> <span class="token parameter variable">-XX:+UseParallelGC</span> <span class="token parameter variable">-XX:MaxGCPauseMillis</span><span class="token operator">=</span><span class="token number">100</span> <span class="token parameter variable">-XX:+UseAdaptiveSizePolicy</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 方案1</span>
<span class="token function">java</span> <span class="token parameter variable">-Xmx3550m</span> <span class="token parameter variable">-Xms3550m</span> <span class="token parameter variable">-Xmn2g</span> <span class="token parameter variable">-Xss128k</span> <span class="token parameter variable">-XX:ParallelGCThreads</span><span class="token operator">=</span><span class="token number">20</span> <span class="token parameter variable">-XX:+UseConcMarkSweepGC</span> <span class="token parameter variable">-XX:+UseParNewGC</span>
<span class="token comment"># 方案2</span>
<span class="token function">java</span> <span class="token parameter variable">-Xmx3550m</span> <span class="token parameter variable">-Xms3550m</span> <span class="token parameter variable">-Xmn2g</span> <span class="token parameter variable">-Xss128k</span> <span class="token parameter variable">-XX:+UseConcMarkSweepGC</span> <span class="token parameter variable">-XX:CMSFullGCsBeforeCompaction</span><span class="token operator">=</span><span class="token number">5</span> <span class="token parameter variable">-XX:+UseCMSCompactAtFullCollection</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="3、JVM调优"><a href="#3、JVM调优" class="headerlink" title="3、JVM调优"></a>3、JVM调优</h1><h2 id="3-1、前言"><a href="#3-1、前言" class="headerlink" title="3.1、前言"></a>3.1、前言</h2><h3 id="3-1-1、内存泄漏和内存溢出"><a href="#3-1-1、内存泄漏和内存溢出" class="headerlink" title="3.1.1、内存泄漏和内存溢出"></a>3.1.1、内存泄漏和内存溢出</h3><ul>
<li><strong>内存泄漏（Memory Leak）：程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积的话后果会很严重。</strong></li>
<li><strong>内存溢出（Out Of Memory）：程序在申请内存时，没有足够的内存空间供其使用，会出现Out Of Memory。</strong></li>
</ul>
<h3 id="3-1-2、QPS和TPS"><a href="#3-1-2、QPS和TPS" class="headerlink" title="3.1.2、QPS和TPS"></a>3.1.2、QPS和TPS</h3><ul>
<li><p><strong>QPS</strong>：全称——Queries Per Second，意思是<em><strong>每秒查询率</strong></em>，是一台服务器每秒能够响应的查询次数（数据库中的每秒执行查询sql的次数），显然，这个不够全面，不能描述增删改，所以，不建议用qps来作为系统性能指标。</p>
</li>
<li><p><strong>TPS</strong>：全称——Transactions Per Second，意思是<em><strong>每秒事务数</strong></em>，具体事务的定义，都是人为的，可以一个接口、多个接口、一个业务流程等等。一个事务是指事务内第一个请求发送到接收到最后一个请求的响应的过程，以此来计算使用的时间和完成的事务个数。</p>
<p>以单接口定义的事务为例，每个事务包括了如下3个过程：</p>
<ol>
<li>向服务器发请求。</li>
<li>服务器自己的内部处理（包含应用服务器、数据库服务器等）。</li>
<li>服务器返回结果给客户端。</li>
</ol>
<p>如果每秒能够完成N次这三个过程，那么TPS就是N；</p>
<p>如果多个接口定义为一个事务，且1、2、3过程执行一轮为一次，那么1秒能执行多少次，TPS就是多少。</p>
</li>
</ul>
<h3 id="3-1-3、吞吐量和响应时间"><a href="#3-1-3、吞吐量和响应时间" class="headerlink" title="3.1.3、吞吐量和响应时间"></a>3.1.3、吞吐量和响应时间</h3><ul>
<li><strong>吞吐量</strong>：用户代码时间 &#x2F; (用户代码执行时间 + 垃圾回收时间)。</li>
<li><strong>响应时间</strong>：服务器接收到请求到返回结果给客户端这么一个过程所耗费的时间。STW时间越短，响应时间越好。</li>
</ul>
<h2 id="3-2、如何调优"><a href="#3-2、如何调优" class="headerlink" title="3.2、如何调优"></a>3.2、如何调优</h2><p>想要调优，首先要有一个目标，你的目标是追求 <em><strong>响应时间 or 吞吐量？</strong></em></p>
<ul>
<li>追求吞吐量，对于 科学计算、数据挖掘等场景，选择垃圾回收器组合：PS+PO。</li>
<li>追求响应时间，比如：网站、带界面的程序、对外提供API等，选择ParNew、CMS、G1。</li>
</ul>
<h2 id="3-3、调优分类"><a href="#3-3、调优分类" class="headerlink" title="3.3、调优分类"></a>3.3、调优分类</h2><p>GC调优分为三类：</p>
<ol>
<li>根据需求进行JVM规划和预调优。</li>
<li>优化JVM运行环境（慢、卡顿）。</li>
<li>解决JVM运行过程中出现的各种问题，比如说OOM。</li>
</ol>
<h2 id="3-4、调优思路"><a href="#3-4、调优思路" class="headerlink" title="3.4、调优思路"></a>3.4、调优思路</h2><h3 id="3-4-1、思路"><a href="#3-4-1、思路" class="headerlink" title="3.4.1、思路"></a>3.4.1、思路</h3><p>调优，从业务场景开始，没有业务场景的调优就是耍流氓。同时还要遵循无监控，不调优的规则</p>
<p>常见的调优思路如下：</p>
<ol>
<li><p>熟悉业务场景（选择垃圾收集器，垃圾收集器只有合适的，没有最好的）。</p>
<ul>
<li>响应时间：停顿时间，（推荐：CMS &#x2F; G1 &#x2F; ZGC）</li>
<li>吞吐量：代码时间 &#x2F; (代码时间 + GC时间)，（推荐：PS）</li>
</ul>
</li>
<li><p>选择回收器组合。</p>
</li>
<li><p>计算内存需求。</p>
</li>
<li><p>选定CPU（越高越好，按预算来）。</p>
</li>
<li><p>设定年代大小，升级年龄。</p>
</li>
<li><p>设定日志参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log 
<span class="token parameter variable">-XX:+UseGCLogFileRotation</span> 
<span class="token parameter variable">-XX:NumberOfGCLogFiles</span><span class="token operator">=</span><span class="token number">5</span> 
<span class="token parameter variable">-XX:GCLogFilesSize</span><span class="token operator">=</span>20m 
<span class="token parameter variable">-XX:+PrintGcDetails</span> 
<span class="token parameter variable">-XX:+PrintGCDateStamps</span> 
<span class="token parameter variable">-XX:PrintGCCause</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意：一般记录日志时，会形成日志文件。如果只有一个日志文件，肯定不行，需要根据实际情况来定。</p>
</li>
</ol>
<h3 id="3-4-2、常用命令"><a href="#3-4-2、常用命令" class="headerlink" title="3.4.2、常用命令"></a>3.4.2、常用命令</h3><ol>
<li>java -XX:+PrintFlagsInitial：打印默认参数值；</li>
<li>java -XX:+PrintFlagsFinal：打印最终参数值；</li>
<li>java -XX:+PrintFlagsFinal | grep xxx：找到对应的参数；</li>
<li>java -XX:+PrintFlagsFinal -version | grep GC；</li>
</ol>
<h2 id="3-5、调优工具"><a href="#3-5、调优工具" class="headerlink" title="3.5、调优工具"></a>3.5、调优工具</h2><h3 id="3-5-1、Arthas"><a href="#3-5-1、Arthas" class="headerlink" title="3.5.1、Arthas"></a>3.5.1、Arthas</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>1、dump到指定文件（使用jhat进行分析）</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">heapdump</span> <span class="token value attr-value">/tmp/dump.hprof</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>2、仅dump live对象</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">heapdump</span> <span class="token value attr-value">--live /tmp/dump.hprof</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>3、展示当前进程信息</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">dashboard<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>4、打印线程ID的栈信息</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">thread</span> <span class="token value attr-value">id </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>5、可以方便查看死锁</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">thread</span> <span class="token value attr-value">-b id</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>6、反编译</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">jad</span> <span class="token value attr-value">*.class    如：jad HelloGC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>反编译需要注意以下问题：</p>
<ol>
<li><font color='red'>动态代理生成类问题；</font></li>
<li><font color='red'>第三方类；（观察代码）</font></li>
<li><font color='red'>版本问题；（确定自己最新提交的版本是不是被使用）</font></li>
</ol>
<p><font color='red'>注意：配合热替换使用，但要注意热替换的限制问题。</font></p>
<p>7、热替换</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redefine /opt/XXX.class<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>实现步骤：</p>
<ol>
<li>运行测试类A；（A中有方法m，m中打印数字1。）</li>
<li>现需要修改类A中方法m的逻辑，让其打印数字2；</li>
<li>在不停掉1步骤中类A情的况下，直接修改类A中方法m的逻辑（打印2），然后重新编译（javac A.java）；</li>
<li>执行arthas命令：<code>redefine /opt/A.class</code>，即可实现热替换；（命令中的A.class是修改后的最新版本）</li>
</ol>
<p>限制条件有：</p>
<ol>
<li>只能修改方法实现；（方法已经运行）</li>
<li>不能改方法名；</li>
<li>不能改属性；</li>
</ol>
<h3 id="3-5-2、VisualVM"><a href="#3-5-2、VisualVM" class="headerlink" title="3.5.2、VisualVM"></a>3.5.2、VisualVM</h3><h3 id="3-5-3、Profiler"><a href="#3-5-3、Profiler" class="headerlink" title="3.5.3、Profiler"></a>3.5.3、Profiler</h3><h3 id="3-5-4、GCEasy"><a href="#3-5-4、GCEasy" class="headerlink" title="3.5.4、GCEasy"></a>3.5.4、GCEasy</h3><h3 id="3-5-5、GCViewer"><a href="#3-5-5、GCViewer" class="headerlink" title="3.5.5、GCViewer"></a>3.5.5、GCViewer</h3><h2 id="3-6、调优案例"><a href="#3-6、调优案例" class="headerlink" title="3.6、调优案例"></a>3.6、调优案例</h2><h3 id="3-6-1、案例一"><a href="#3-6-1、案例一" class="headerlink" title="3.6.1、案例一"></a>3.6.1、案例一</h3><h4 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigDecimal</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Date</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ScheduledThreadPoolExecutor</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ThreadPoolExecutor</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FullGC_Problem01</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CardInfo</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">BigDecimal</span> bigDecimal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"ZhangSan"</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>
        <span class="token class-name">Date</span> birthdate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ScheduledThreadPoolExecutor</span> executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>DiscardOldestPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>
        executor<span class="token punctuation">.</span><span class="token function">setMaximumPoolSize</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token function">modelFit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">modelFit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CardInfo</span><span class="token punctuation">></span></span> taskList <span class="token operator">=</span> <span class="token function">getAllCardInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        taskList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>info <span class="token operator">-></span> <span class="token punctuation">&#123;</span>
            executor<span class="token punctuation">.</span><span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>
                info<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CardInfo</span><span class="token punctuation">></span></span> <span class="token function">getAllCardInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CardInfo</span><span class="token punctuation">></span></span> taskList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token class-name">CardInfo</span> ci <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CardInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            taskList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> taskList<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h4><p><strong>1）运行测试程序</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> <span class="token parameter variable">-Xms200m</span> <span class="token parameter variable">-Xmx200m</span> <span class="token parameter variable">-XX:+PrintGC</span> <span class="token parameter variable">-XX:+HeapDumpOnOutOfMemoryError</span> FullGC_Problem01<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>2）查看CPU占用，拿到占比较高的进程ID。</strong></p>
<p>通过命令 top 查找耗费CPU最高的进程PID，比如3568。</p>
<p><strong>3）找到CPU占用最高的线程ID，查看线程运行情况。</strong></p>
<ol>
<li>通过命令<code>top -Hp 3568</code>查找当前进程中耗费CPU最高的线程PID，比如1374；</li>
<li>通过命令<code>printf &quot;%x\n&quot; 1374</code>可以把线程PID转为16进制，得到 55e；</li>
<li>通过命令<code>jstack 3568 | grep -20 55e</code>查找当前线程阻塞的位置；</li>
</ol>
<p><strong>4）查看线程运行情况</strong>：执行<code>jinfo pid</code>命令。</p>
<p><strong>5）观察GC执行情况。</strong></p>
<p>通过命令<code>jstat -gc PID</code> 观察gc动态情况，阅读GC日志发现频繁GC，arthas观察，jconsole，jvisualVM，Jprofiler（最好用）。</p>
<p>通过命令<code>jstat -gc 4655 500</code>实现每500毫秒打印一次GC情况。</p>
<blockquote>
<p>注意：图形界面监控一般适用于测试阶段，线上系统监控一般使用命令行调式工具——cmdline、Arthas。</p>
</blockquote>
<p><strong>6）查看对象创建的数量。</strong></p>
<p>通过命令<code>jmap - histo pid | head -20</code>查看对象创建数量排名前20的对象信息。</p>
<p><strong>7）导出dump信息文件。</strong></p>
<p>通过命令<code>jmap -dump:format=b,file=D:\test\heap.hprof 6956</code>将当前堆栈信息导出到一个文件中。</p>
<blockquote>
<p>线上系统，内存特别大，jmap执行期间会对进程产生很大影响，甚至卡顿（电商不适合）</p>
<ol>
<li>设定参数HeapDump，OOM的时会自动产生堆转储文件（不是很专业，因为多有监控，内存增长就会报警。</li>
<li>多服务器备份（高可用），停掉这台服务器对其他服务器不影响。</li>
<li>在线定位(一般小点儿公司用不到)。</li>
<li>在测试环境中压测（产生类似内存增长问题，在堆还不是很大的时候进行转储）。</li>
</ol>
</blockquote>
<p><strong>8）重新运行测试程序。</strong></p>
<p><code>java -Xms20M -Xmx20M -XX:+UseParallelGC -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/opt/test_jvm/gc_out/ FullGC_Problem01</code></p>
<p><strong>9）分析dump文件。</strong></p>
<p>使用<code>MAT、jhat、jvisualvm</code>工具来分析dump文件。</p>
<p>执行命令<code>jhat -J-Xmx512M xxx.hprof</code>后会在7000端口开启一个服务，通过浏览器可以访问该服务并对其执行相关操作，比如可以使用OQL查找特定问题对象。</p>
<p><strong>10）找出代码问题。</strong></p>
<h2 id="3-7、GC日志详解"><a href="#3-7、GC日志详解" class="headerlink" title="3.7、GC日志详解"></a>3.7、GC日志详解</h2><h3 id="3-7-1、准备"><a href="#3-7-1、准备" class="headerlink" title="3.7.1、准备"></a>3.7.1、准备</h3><p>测试代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">LinkedList</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloGC</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HellGC."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试一：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 命令</span>
<span class="token function">java</span> <span class="token parameter variable">-XX:+PrintCommandLineFlags</span> HelloGC

<span class="token comment"># 输出</span>
<span class="token parameter variable">-XX:InitialHeapSize</span><span class="token operator">=</span><span class="token number">29592512</span> <span class="token parameter variable">-XX:MaxHeapSize</span><span class="token operator">=</span><span class="token number">473480192</span> <span class="token parameter variable">-XX:+PrintCommandLineFlags</span> <span class="token parameter variable">-XX:+UseCompressedClassPointers</span> <span class="token parameter variable">-XX:+UseCompressedOops</span> 
HelloGC
Exception <span class="token keyword">in</span> thread <span class="token string">"main"</span> java.lang.OutOfMemoryError: Java heap space at HelloGC.main<span class="token punctuation">(</span>HelloGC.java:9<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试二：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 命令</span>
<span class="token function">java</span> <span class="token parameter variable">-Xmn10M</span> <span class="token parameter variable">-Xms40M</span> <span class="token parameter variable">-Xmx60M</span> <span class="token parameter variable">-XX:+PrintCommandLineFlags</span> <span class="token parameter variable">-XX:+PrintGC</span> HelloGC PrintGCDetails PrintGCTimeStamps PrintGCCauses

<span class="token comment"># 输出</span>
<span class="token parameter variable">-XX:InitialHeapSize</span><span class="token operator">=</span><span class="token number">41943040</span> <span class="token parameter variable">-XX:MaxHeapSize</span><span class="token operator">=</span><span class="token number">62914560</span> <span class="token parameter variable">-XX:MaxNewSize</span><span class="token operator">=</span><span class="token number">10485760</span> <span class="token parameter variable">-XX:NewSize</span><span class="token operator">=</span><span class="token number">10485760</span> <span class="token parameter variable">-XX:+PrintCommandLineFlags</span> <span class="token parameter variable">-XX:+PrintGC</span> <span class="token parameter variable">-XX:+UseCompressedClassPointers</span> <span class="token parameter variable">-XX:+UseCompressedOops</span> 
HelloGC
<span class="token punctuation">[</span>GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  7675K-<span class="token operator">></span>7426K<span class="token punctuation">(</span>39936K<span class="token punctuation">)</span>, <span class="token number">0.0065081</span> secs<span class="token punctuation">]</span>
<span class="token punctuation">[</span>GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  14756K-<span class="token operator">></span>14594K<span class="token punctuation">(</span>39936K<span class="token punctuation">)</span>, <span class="token number">0.0066781</span> secs<span class="token punctuation">]</span>
<span class="token punctuation">[</span>GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  21916K-<span class="token operator">></span>21762K<span class="token punctuation">(</span>39936K<span class="token punctuation">)</span>, <span class="token number">0.0082077</span> secs<span class="token punctuation">]</span>
<span class="token punctuation">[</span>GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  29086K-<span class="token operator">></span>28931K<span class="token punctuation">(</span>39936K<span class="token punctuation">)</span>, <span class="token number">0.0062089</span> secs<span class="token punctuation">]</span>
<span class="token punctuation">[</span>GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  36256K-<span class="token operator">></span>36099K<span class="token punctuation">(</span>45076K<span class="token punctuation">)</span>, <span class="token number">0.0077737</span> secs<span class="token punctuation">]</span>
<span class="token punctuation">[</span>Full GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  36099K-<span class="token operator">></span>36098K<span class="token punctuation">(</span>45076K<span class="token punctuation">)</span>, <span class="token number">0.0023287</span> secs<span class="token punctuation">]</span>
<span class="token punctuation">[</span>GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  43424K-<span class="token operator">></span>43266K<span class="token punctuation">(</span>60416K<span class="token punctuation">)</span>, <span class="token number">0.0068826</span> secs<span class="token punctuation">]</span>
<span class="token punctuation">[</span>GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  50592K-<span class="token operator">></span>50434K<span class="token punctuation">(</span>60416K<span class="token punctuation">)</span>, <span class="token number">0.0075865</span> secs<span class="token punctuation">]</span>
<span class="token punctuation">[</span>Full GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  57761K-<span class="token operator">></span>57603K<span class="token punctuation">(</span>60416K<span class="token punctuation">)</span>, <span class="token number">0.0027358</span> secs<span class="token punctuation">]</span>
<span class="token punctuation">[</span>Full GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span>  57603K-<span class="token operator">></span>57591K<span class="token punctuation">(</span>60416K<span class="token punctuation">)</span>, <span class="token number">0.0022941</span> secs<span class="token punctuation">]</span>
Exception <span class="token keyword">in</span> thread <span class="token string">"main"</span> java.lang.OutOfMemoryError: Java heap space at HelloGC.main<span class="token punctuation">(</span>HelloGC.java:9<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试三：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 命令</span>
<span class="token function">java</span> <span class="token parameter variable">-XX:+UseConcMarkSweepGC</span> <span class="token parameter variable">-XX:+PrintCommandLineFlags</span> HelloGC

 <span class="token comment"># 输出</span>
<span class="token parameter variable">-XX:InitialHeapSize</span><span class="token operator">=</span><span class="token number">29592512</span> <span class="token parameter variable">-XX:MaxHeapSize</span><span class="token operator">=</span><span class="token number">473480192</span> <span class="token parameter variable">-XX:MaxNewSize</span><span class="token operator">=</span><span class="token number">87244800</span> <span class="token parameter variable">-XX:MaxTenuringThreshold</span><span class="token operator">=</span><span class="token number">6</span> <span class="token parameter variable">-XX:OldPLABSize</span><span class="token operator">=</span><span class="token number">16</span> <span class="token parameter variable">-XX:+PrintCommandLineFlags</span> <span class="token parameter variable">-XX:+UseCompressedClassPointers</span> <span class="token parameter variable">-XX:+UseCompressedOops</span> <span class="token parameter variable">-XX:+UseConcMarkSweepGC</span> <span class="token parameter variable">-XX:+UseParNewGC</span> 
HelloGC
Exception <span class="token keyword">in</span> thread <span class="token string">"main"</span> java.lang.OutOfMemoryError: Java heap space at HelloGC.main<span class="token punctuation">(</span>HelloGC.java:9<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-7-2、示例日志1"><a href="#3-7-2、示例日志1" class="headerlink" title="3.7.2、示例日志1"></a>3.7.2、示例日志1</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">[</span><span class="token constant">GC</span> <span class="token punctuation">(</span><span class="token class-name">Allocation</span> <span class="token class-name">Failure</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token class-name">DefNew</span> <span class="token punctuation">(</span>promotion failed<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">123228</span>K<span class="token operator">-></span><span class="token function">138592K</span><span class="token punctuation">(</span><span class="token number">138816</span>K<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0698705</span> secs<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">Tenured</span><span class="token operator">:</span> <span class="token number">308488</span>K<span class="token operator">-></span><span class="token function">308488K</span><span class="token punctuation">(</span><span class="token number">308608</span>K<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0097199</span> secs<span class="token punctuation">]</span> <span class="token number">360036</span>K<span class="token operator">-></span><span class="token function">359693K</span><span class="token punctuation">(</span><span class="token number">447424</span>K<span class="token punctuation">)</span><span class="token punctuation">,</span> 
<span class="token punctuation">[</span><span class="token class-name">Metaspace</span><span class="token operator">:</span> <span class="token number">2500</span>K<span class="token operator">-></span><span class="token function">2500K</span><span class="token punctuation">(</span><span class="token number">1056768</span>K<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0.0796660</span> secs<span class="token punctuation">]</span> 
<span class="token punctuation">[</span><span class="token class-name">Times</span><span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.02</span> sys<span class="token operator">=</span><span class="token number">0.06</span><span class="token punctuation">,</span> real<span class="token operator">=</span><span class="token number">0.07</span> secs<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li>GC：指YGC。</li>
<li>(Allocation Failure)：GC原因。</li>
<li>DefNew：产生的年代，这里是年轻代；后面的：123228K-&gt;138592K(138816K), 0.0698705 secs，其从左到右分别代表：回收前年轻代大小-&gt;回收后年轻代大小(整个年轻代的大小)，回收所消耗的时间；</li>
<li>[Tenured: 308488K-&gt;308488K(308608K), 0.0097199 secs]：从左到右分别代表：回收前堆大小-&gt;回收后堆大小(整个堆的大小)，回收消耗的时间。</li>
<li>[Metaspace: 2500K-&gt;2500K(1056768K)], 0.0796660 secs]：从左到右分别代表：回收前元空间大小-&gt;回收后大小(整个元空间的大小)，回收消耗的时间。</li>
<li>[Times: user&#x3D;0.02 sys&#x3D;0.06, real&#x3D;0.07 secs]：从左到右分别代表：用户态消耗的时间、内核态消耗的时间，整个过程实际消耗多长时间。</li>
</ul>
<h3 id="3-7-3、示例日志2"><a href="#3-7-3、示例日志2" class="headerlink" title="3.7.3、示例日志2"></a>3.7.3、示例日志2</h3><p>一旦内存溢出，就会把整个堆 heap dump出来：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Heap</span>
 def <span class="token keyword">new</span> generation   total <span class="token number">138816</span>K<span class="token punctuation">,</span> used <span class="token number">138753</span>K <span class="token punctuation">[</span><span class="token number">0x00000000e3c00000</span><span class="token punctuation">,</span> <span class="token number">0x00000000ed2a0000</span><span class="token punctuation">,</span> <span class="token number">0x00000000ed2a0000</span><span class="token punctuation">)</span>
  eden space <span class="token number">123392</span>K<span class="token punctuation">,</span> <span class="token number">100</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000e3c00000</span><span class="token punctuation">,</span> <span class="token number">0x00000000eb480000</span><span class="token punctuation">,</span> <span class="token number">0x00000000eb480000</span><span class="token punctuation">)</span>
  from space <span class="token number">15424</span>K<span class="token punctuation">,</span>  <span class="token number">99</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ec390000</span><span class="token punctuation">,</span> <span class="token number">0x00000000ed290478</span><span class="token punctuation">,</span> <span class="token number">0x00000000ed2a0000</span><span class="token punctuation">)</span>
  <span class="token keyword">to</span>   <span class="token namespace">space</span> <span class="token number">15424</span>K<span class="token punctuation">,</span>   <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000eb480000</span><span class="token punctuation">,</span> <span class="token number">0x00000000eb480000</span><span class="token punctuation">,</span> <span class="token number">0x00000000ec390000</span><span class="token punctuation">)</span>
 tenured generation   total <span class="token number">308608</span>K<span class="token punctuation">,</span> used <span class="token number">308477</span>K <span class="token punctuation">[</span><span class="token number">0x00000000ed2a0000</span><span class="token punctuation">,</span> <span class="token number">0x0000000100000000</span><span class="token punctuation">,</span> <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>
   the space <span class="token number">308608</span>K<span class="token punctuation">,</span>  <span class="token number">99</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ed2a0000</span><span class="token punctuation">,</span> <span class="token number">0x00000000fffdf618</span><span class="token punctuation">,</span> <span class="token number">0x00000000fffdf800</span><span class="token punctuation">,</span> <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>
 <span class="token class-name">Metaspace</span>       used <span class="token number">2531</span>K<span class="token punctuation">,</span> capacity <span class="token number">4486</span>K<span class="token punctuation">,</span> committed <span class="token number">4864</span>K<span class="token punctuation">,</span> reserved <span class="token number">1056768</span>K
  <span class="token keyword">class</span> space    used <span class="token number">272</span>K<span class="token punctuation">,</span> capacity <span class="token number">386</span>K<span class="token punctuation">,</span> committed <span class="token number">512</span>K<span class="token punctuation">,</span> reserved <span class="token number">1048576</span>K<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p><font color='orange'>Metaspace  used 2531K, capacity 4486K, committed 4864K, reserved 1056768K</font></p>
<p>2531K表示已使用；4486K表示总容量；4864K表示虚拟内存占用；1056768K表示虚拟内存保留容量。</p>
</li>
<li><p><font color='orange'>total &#x3D; eden + 一个survivor</font></p>
</li>
<li><p><font color='orange'>年轻代大小加起来不相等？因为：除了new的对象、整个年轻代外还有其他信息。观察日志主要看的是变化。</font></p>
</li>
</ul>
<h2 id="3-8、OOM问题案例"><a href="#3-8、OOM问题案例" class="headerlink" title="3.8、OOM问题案例"></a>3.8、OOM问题案例</h2><h3 id="3-8-1、常见"><a href="#3-8-1、常见" class="headerlink" title="3.8.1、常见"></a>3.8.1、常见</h3><ol>
<li><p>线程池使用不当导致OOM。</p>
</li>
<li><p>tomcat http-head-size过大导致OOM问题。</p>
<p>原因分析：由于Http11OutPutBuffer对象大且多才造成OOM问题。</p>
</li>
<li><p>如果一个系统的内存使用不超10%，但观察GC日志发现FGC频繁发生，原因是什么？</p>
<p>原因分析：主动调用了<code>System.gc();</code></p>
</li>
</ol>
<h3 id="3-8-2、少见"><a href="#3-8-2、少见" class="headerlink" title="3.8.2、少见"></a>3.8.2、少见</h3><ol>
<li><p><strong>栈溢出问题（知道即可）</strong></p>
<p>原因分析：-Xss设定太小造成。</p>
</li>
<li><p><strong>lambda表达式导致方法区溢出问题（知道即可）</strong></p>
<p>测试前限制其方法区大小，便于快速重现问题。设置参数：</p>
<p><code>-XX:MaxMetaspaceSize=9M -XX:+PrintGCDeTAILS</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LambdaGC</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token class-name">I</span> i <span class="token operator">=</span> <span class="token class-name">C</span><span class="token operator">::</span><span class="token function">n</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">interface</span> <span class="token class-name">I</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">n</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>直接内存溢出问题（少见，知道即可）</p>
<p>《深入理解虚拟机》P59，使用Unsafe分配直接内存，或使用NIO问题。</p>
</li>
<li><p>重写finalize引发频繁GC</p>
<p>小米云，HBase同步系统，系统通过nginx访问超时报警，最后排查结果：C++程序员重写finalize而引发的频繁GC问题。</p>
</li>
<li><p>Disruptor链长且大，对象也大且消费完不主动释放就会出现溢出问题。</p>
</li>
</ol>
<h2 id="3-9、垃圾回收器调优"><a href="#3-9、垃圾回收器调优" class="headerlink" title="3.9、垃圾回收器调优"></a>3.9、垃圾回收器调优</h2><h3 id="3-9-1、G1调优"><a href="#3-9-1、G1调优" class="headerlink" title="3.9.1、G1调优"></a>3.9.1、G1调优</h3><p>触发FGC的情况如下：</p>
<ul>
<li><p><strong>并发模式失败</strong></p>
<p>G1启动标记周期，但在Mix GC之前，老年代就被填满，此时G1会放弃标记周期。这种情形下，需要增加堆大小，或者调整周期（例如增加线程数-XX:ConcGCThreads等）。</p>
</li>
<li><p><strong>晋升失败或疏散失败</strong></p>
<p><strong>G1 GC时如果没有足够的内存供存活对象或晋升对象使用时会触发Full GC。可以在日志中看到（to-space exhausted）或者（to-space overflow）。</strong>解决该问题的方式如下：</p>
<ol>
<li>增加参数<code>-XX:G1ReservePercent</code>的值（并相应增加总的堆大小），为“目标空间”增加预留内存。</li>
<li>减少参数<code>-XX:InitiatingHeapOccupancyPercent</code>的值，提前启动标记周期。</li>
<li>增加参数<code>-XX:ConcGCThreads</code>的值，增加并行标记线程的数目。</li>
</ol>
</li>
<li><p><strong>巨型对象分配失败</strong></p>
<p>当巨型对象找不到空闲空间分配时会触发Full GC来释放空间。这种情况下，应该避免分配大量的巨型对象，增加内存或者增大<code>-XX:G1HeapRegionSize</code>，使巨型对象不再是巨型对象。</p>
</li>
</ul>
<h2 id="3-10、场景分析优化"><a href="#3-10、场景分析优化" class="headerlink" title="3.10、场景分析优化"></a>3.10、场景分析优化</h2><h3 id="3-10-1、卡慢场景"><a href="#3-10-1、卡慢场景" class="headerlink" title="3.10.1、卡慢场景"></a>3.10.1、卡慢场景</h3><p><strong>场景1</strong>：原服务器32位、1.5G内存堆，用户反馈慢。优化升级为64位、16G内存堆后，反馈更慢，反而不如从前。</p>
<p><strong>1）原网站为啥慢？</strong></p>
<p>多用户访问数据，故大量数据加载至内存，从而造成内存不足、频繁GC、STW长、响应时间慢等问题。</p>
<p><strong>2）为什么会卡顿？</strong></p>
<p>内存越大，FGC时间就会越长。</p>
<p><strong>3）如何应对？</strong></p>
<p>PS 更改为 PN + CMS 或者 G1。</p>
<h3 id="3-10-2、CPU消耗高问题"><a href="#3-10-2、CPU消耗高问题" class="headerlink" title="3.10.2、CPU消耗高问题"></a>3.10.2、CPU消耗高问题</h3><p>场景1：系统CPU经常100%，如何调优？</p>
<p>解决方案参考如下：</p>
<ol>
<li>找出消耗CPU较高的进程；可使用 top 命令查看。</li>
<li>该进程中哪个线程消耗CPU较高；可使用 top -Hp 命令查看。</li>
<li>导出该线程的堆栈；可使用 jstack 命令实现。</li>
<li>查找哪个方法（栈帧）的导致的问题。</li>
<li>工作线程占比高 | 垃圾回收线程占比高。</li>
</ol>
<h3 id="3-10-3、内存消耗高问题"><a href="#3-10-3、内存消耗高问题" class="headerlink" title="3.10.3、内存消耗高问题"></a>3.10.3、内存消耗高问题</h3><p>场景1：系统内存飙高，如何定位及应对？</p>
<p>参考解决方案如下：</p>
<ol>
<li>堆栈比较多，导出堆信息；可使用 jmap 命令实现。</li>
<li>通过工具分析，分析工具有：jhat、jvisualvm、mat、jprofiler等。</li>
</ol>
<h3 id="3-10-4、如何监控JVM"><a href="#3-10-4、如何监控JVM" class="headerlink" title="3.10.4、如何监控JVM"></a>3.10.4、如何监控JVM</h3><p>工具：jstat、jvisualvm、jprofiler、arthas、top。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">豪哥</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://hshz21.gitee.io/2023/08/07/jvm-zhi-shi-dian-zong-jie/">https://hshz21.gitee.io/2023/08/07/jvm-zhi-shi-dian-zong-jie/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">豪哥</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/JVM/">
                                    <span class="chip bg-color">JVM</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wxpay.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/08/07/duo-xian-cheng-yu-gao-bing-fa-zhi-shi-zong-jie/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="Java系列-多线程与高并发">
                        
                        <span class="card-title">Java系列-多线程与高并发</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-08-07
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%B9%B6%E5%8F%91/" class="post-category">
                                    并发
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%B9%B6%E5%8F%91/">
                        <span class="chip bg-color">并发</span>
                    </a>
                    
                    <a href="/tags/%E7%BA%BF%E7%A8%8B/">
                        <span class="chip bg-color">线程</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/08/07/asm-zhi-shi-dian-zong-jie/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/4.jpg" class="responsive-img" alt="Java系列-ASM">
                        
                        <span class="card-title">Java系列-ASM</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-08-07
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/ASM/" class="post-category">
                                    ASM
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/ASM/">
                        <span class="chip bg-color">ASM</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">豪哥</a>
            |&nbsp;Powered by&nbsp;<a href="https://github.com/lucky2shh" target="_blank">豪哥</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">


    <a href="mailto:3577293158@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=3577293158" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 3577293158" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
