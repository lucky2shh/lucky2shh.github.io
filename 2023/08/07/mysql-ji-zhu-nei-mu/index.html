<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="MySQL系列-MySQL基础应用, 豪哥博客">
    <meta name="description" content="豪哥个人博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>MySQL系列-MySQL基础应用 | 豪哥博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">豪哥博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">豪哥博客</div>
        <div class="logo-desc">
            
            豪哥个人博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/21.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">MySQL系列-MySQL基础应用</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/MySQL/">
                                <span class="chip bg-color">MySQL</span>
                            </a>
                        
                            <a href="/tags/MySQL%E5%9F%BA%E7%A1%80/">
                                <span class="chip bg-color">MySQL基础</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/MySQL/" class="post-category">
                                MySQL
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-08-07
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-08-06
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    44.2k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="1、MySQL基础"><a href="#1、MySQL基础" class="headerlink" title="1、MySQL基础"></a>1、MySQL基础</h1><h2 id="1-1、MySQL体系结构"><a href="#1-1、MySQL体系结构" class="headerlink" title="1.1、MySQL体系结构"></a>1.1、MySQL体系结构</h2><p>MySQL体系结构如下：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20220410152916029.png" alt="image-20220410152916029"></p>
<p><strong>MySQL在系统角度就是一个进程。实例与数据库的关系相互对应</strong>。</p>
<blockquote>
<p>Oracle的Windows版也是单进程多线程架构。</p>
</blockquote>
<p>MySQL由以下几部分组成：</p>
<ol>
<li>连接池</li>
<li>管理服务和工具组件</li>
<li>SQL接口组件</li>
<li>查询分析组件</li>
<li>优化组件</li>
<li>缓冲组件</li>
<li>插件式存储引擎</li>
<li>物理文件</li>
</ol>
<blockquote>
<p><font color='red'>注意：存储引擎基于表，而非基于数据库。</font></p>
</blockquote>
<h2 id="1-2、字符集"><a href="#1-2、字符集" class="headerlink" title="1.2、字符集"></a>1.2、字符集</h2><h3 id="1-2-1、字符集级别"><a href="#1-2-1、字符集级别" class="headerlink" title="1.2.1、字符集级别"></a>1.2.1、字符集级别</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>MySQL有4个级别的字符集和比较规则：</p>
<ul>
<li>服务器级别</li>
<li>数据库级别</li>
<li>表级别</li>
<li>列级别</li>
</ul>
<p>命令<code>show variables like &#39;character%&#39;;</code>可打印当前数据库生效的各种字符集信息：</p>
<ul>
<li><strong>character_set_client</strong>：服务器解码请求时使用的字符集。</li>
<li><strong>character_set_connection</strong>：服务器把请求字符串从character_set_client转为 character_set_connection。</li>
<li><strong>character_set_database</strong>：数据库的字符集。</li>
<li><strong>character_set_filesystem</strong>：文件系统字符集。</li>
<li><strong>character_set_results</strong>：服务器向客户端返回数据时使用的字符集。</li>
<li><strong>character_set_server</strong>：服务器级别的字符集。</li>
<li><strong>character_set_system</strong>：系统字符集。</li>
<li><strong>character_sets_dir</strong>：字符集设置路径。</li>
</ul>
<h4 id="服务器级别"><a href="#服务器级别" class="headerlink" title="服务器级别"></a>服务器级别</h4><p>参数<code>character_set_server</code>用来设置 服务器字符集。可在服务器运行中通过set语句来修改，也可直接在配置文件中配置。配置文件配置示例如下：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">[server]
<span class="token key attr-name">character_set_server</span><span class="token punctuation">=</span><span class="token value attr-value">gbk 			# 默认字符集</span>
<span class="token key attr-name">collation_server</span><span class="token punctuation">=</span><span class="token value attr-value">gbk_chinese_ci    	 # 默认比较规则</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="数据库级别"><a href="#数据库级别" class="headerlink" title="数据库级别"></a>数据库级别</h4><p>参数<code>character_set_database</code>用来设置 数据库字符集。</p>
<p>创建和修改数据库的时候可以指定该数据库的字符集和比较规则，具体语法如下：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE DATABASE 数据库名 [[DEFAULT] CHARACTER SET 字符集名称] [[DEFAULT] COLLATE 比较规则名称];
ALTER DATABASE 数据库名 [[DEFAULT] CHARACTER SET 字符集名称]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="表级别"><a href="#表级别" class="headerlink" title="表级别"></a>表级别</h4><p>在创建和修改表时可以设置表的字符集和比较规则，语法如下：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE 表名 (列的信息) [[DEFAULT] CHARACTER SET 字符集名称] [COLLATE 比较规则名称]]
ALTER TABLE 表名 [[DEFAULT] CHARACTER SET 字符集名称] [COLLATE 比较规则名称]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果创建和修改表时没有指明字符集和比较规则，将使用该表所在数据库的字符集和比较规则。</p>
<h4 id="列级别"><a href="#列级别" class="headerlink" title="列级别"></a>列级别</h4><p>对于存储字符串的列，同一个表中的不同的列也可以有不同的字符集和比较规则。我们在创建和修改列 定义的时候可以指定该列的字符集和比较规则，语法如下：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE 表名(
	列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],
	其他列...
);

ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果在创建和修改的语句中没有指明字符集和比较规则，将使用该列所在表的字符集 和比较规则作为该列的字符集和比较规则。</p>
<p><font color='red'>注意：在转换列字符集时要注意，转换前，列中存储的数据不能用转换后的字符集来表示时会发生错误。</font></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>字符集和比较规则的关系如下： </p>
<ul>
<li>如果 创建或修改列时 没有显式指定字符集和比较规则，则该列 <strong>使用表的字符集和比较规则</strong>。</li>
<li>如果 创建表时 没有显式指定字符集和比较规则，则该表 <strong>使用数据库的字符集和比较规则</strong>。</li>
<li>如果 创建数据库时 没有显式指定字符集和比较规则，则该数据库 <strong>使用服务器的字符集和比较规则</strong>。</li>
</ul>
<p>utf8 字符集有两种：</p>
<ul>
<li><strong>utf8mb3</strong>：阉割过的 utf8 字符集，只使用1～3个字节表示字符。</li>
<li><strong>utf8mb4</strong>：正宗的 utf8 字符集，使用1～4个字节表示字符。</li>
</ul>
<h3 id="1-2-2、请求响应字符集"><a href="#1-2-2、请求响应字符集" class="headerlink" title="1.2.2、请求响应字符集"></a>1.2.2、请求响应字符集</h3><p>请求响应字符集主要有如下 3 种：</p>
<ul>
<li><strong>character_set_client</strong>：服务器 解码请求时 使用的字符集。</li>
<li><strong>character_set_connection</strong>：服务器 处理请求时 会把请求字符串从character_set_client 转为 character_set_connection。</li>
<li><strong>character_set_results</strong>：服务器 返回数据给客户端时 使用的字符集。</li>
</ul>
<h3 id="1-2-3、比较规则"><a href="#1-2-3、比较规则" class="headerlink" title="1.2.3、比较规则"></a>1.2.3、比较规则</h3><p>MySQL支持多种字符集，对应的也有很多种比较规则。</p>
<p><strong>比较规则的后缀表示是否区分语言中的重音、大小写</strong>。具体如下：</p>
<table>
<thead>
<tr>
<th align="center">比较规则后缀</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">_ai</td>
<td align="center">不区分重音</td>
</tr>
<tr>
<td align="center">_as</td>
<td align="center">区分重音</td>
</tr>
<tr>
<td align="center">_ci</td>
<td align="center">不区分大小写</td>
</tr>
<tr>
<td align="center">_cs</td>
<td align="center">区分大小写</td>
</tr>
<tr>
<td align="center">_bin</td>
<td align="center">以二进制方式比较</td>
</tr>
</tbody></table>
<h3 id="1-2-4、字符集设置"><a href="#1-2-4、字符集设置" class="headerlink" title="1.2.4、字符集设置"></a>1.2.4、字符集设置</h3><p><strong>MySQL 5.7 默认的客户端和服务器都用了 latin1 ，不支持中文</strong>。</p>
<p><strong>MySQL 8.0 前默认字符集为<code>latin1</code>，utf8字符集指向<code>utf8mb3</code>。MySQL 8.0及之后默认编码为<code>utf8mb4***</code>。</strong></p>
<h4 id="查看字符集"><a href="#查看字符集" class="headerlink" title="查看字符集"></a>查看字符集</h4><ol>
<li>使用 SHOW CREATE TABLE 语句；</li>
<li>使用 DESCRIBE 语句；</li>
<li>使用 INFORMATION_SCHEMA 数据库；</li>
<li>使用 SHOW TABLE STATUS 语句；</li>
<li>使用 SHOW FULL COLUMNS 语句；</li>
<li>使用 SHOW VARIABLES 语句；</li>
</ol>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 查看数据库连接情况
show processlist;
# 查看数据库中可用的字符集
show character set;
# 查看数据库表的字符集
show create table tbl_user1;
# 查看字符集（latin1）的校对规则
SHOW COLLATION LIKE &#39;latin1%&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="修改字符集"><a href="#修改字符集" class="headerlink" title="修改字符集"></a>修改字符集</h4><p>1、修改字符集</p>
<p>编辑 my.cnf 文件，添加配置如下内容：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 在MySQL5.7或之前的版本中，在文件最后加上中文字符集配置</span>
<span class="token key attr-name">character_set_server</span><span class="token punctuation">=</span><span class="token value attr-value">utf8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>2、修改 已创建数据库 的字符集：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">alter database dbtest1 character set &#39;utf8&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>3、修改 已创建表 的字符集：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">alter table t_emp convert to character set &#39;utf8&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><font color='red'>注意：原有数据如果基于非’utf8’编码存储，那么原有数据编码不会发生改变。若需修改原有数据的字符集编码，那么只能将 原有数据 导出或删除后 重新插入来实现修改效果。</font></p>
<p>4、、重启MySQL服务。</p>
<p>字符集修改后不会对原库、原表产生修改，参数修改只对新建的数据库生效。</p>
<h2 id="1-3、数据类型"><a href="#1-3、数据类型" class="headerlink" title="1.3、数据类型"></a>1.3、数据类型</h2><h3 id="1-3-1、数据分类"><a href="#1-3-1、数据分类" class="headerlink" title="1.3.1、数据分类"></a>1.3.1、数据分类</h3><p>MySQL支持多种数据类型，整体可分为如下几种：</p>
<ul>
<li><strong>数值类型</strong><ul>
<li>整数类型（精确值）：TINYINT、SMALLINT、MEDIUMINT、INT、INTEGER、BIGINT；</li>
<li>浮点类型（近似值）：FLOAT、DOUBLE；</li>
<li>定点类型（精确值）：DECIMAL、NUMERIC；</li>
<li>位值类型：BIT；</li>
</ul>
</li>
<li><strong>字符串类型</strong>：<ul>
<li>CHAR 和 VARCHAR 类型</li>
<li>BINARY 和 VARBINARY 类型</li>
<li>BLOB 和 TEXT 类型</li>
<li>ENUM 类型</li>
<li>SET 类型</li>
</ul>
</li>
<li><strong>日期和时间类型</strong>：YEAR、DATE、TIME、TIMESTAMP、DATETIME；</li>
<li><strong>空间类型</strong></li>
<li><strong>JSON类型</strong></li>
</ul>
<p>数据类型也有属性，<strong>常见属性如：NULL、NOT NULL、DEFAULT、PRIMARY KEY、AUTO_INCREMENT、USSIGNED（无符号，非负）、CHARACTER SET name</strong>；</p>
<h3 id="1-3-2、数值类型"><a href="#1-3-2、数值类型" class="headerlink" title="1.3.2、数值类型"></a>1.3.2、数值类型</h3><p>数值类型有TINYINT、SMALLINT、MEDIUMINT、INT或INTEGER、BIGINT、FLOAT、DOUBLE、DECIMAL等类型。具体对比如下：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">范围（有符号）</th>
<th align="left">大小</th>
<th align="left">范围（无符号）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TINYINT</td>
<td align="left">(-128，127)</td>
<td align="left">1 Bytes</td>
<td align="left">(0，255)</td>
</tr>
<tr>
<td align="left">SMALLINT</td>
<td align="left">(-32 768，32 767)</td>
<td align="left">2 Bytes</td>
<td align="left">(0，65 535)</td>
</tr>
<tr>
<td align="left">MEDIUMINT</td>
<td align="left">(-8 388 608，8 388 607)</td>
<td align="left">3 Bytes</td>
<td align="left">(0，16 777 215)</td>
</tr>
<tr>
<td align="left">INT或INTEGER</td>
<td align="left">(-2 147 483 648，2 147 483 647)</td>
<td align="left">4 Bytes</td>
<td align="left">(0，4 294 967 295)</td>
</tr>
<tr>
<td align="left">BIGINT</td>
<td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td>
<td align="left">8 Bytes</td>
<td align="left">(0，18 446 744 073 709 551 615)</td>
</tr>
<tr>
<td align="left">FLOAT</td>
<td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td align="left">4 Bytes</td>
<td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
</tr>
<tr>
<td align="left">DOUBLE</td>
<td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td align="left">8 Bytes</td>
<td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
</tr>
<tr>
<td align="left">DECIMAL</td>
<td align="left">依赖于M和D的值</td>
<td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2，否则为D+2</td>
<td align="left">依赖于M和D的值</td>
</tr>
</tbody></table>
<h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p><strong><code>INT(5) ZEROFILL</code>中的 5 表示显示宽度，当数字不够5位时用数字0来补齐，当数字超过5位时，不会受宽度5限制的影响，是多少位就显示多少位</strong>。ZEROFILL表示不够位数时使用0来填充，要注意，ZEROFILL修饰字段时会自动加上UNSIGNED修饰，这样字段值就只能为正数了。</p>
<h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><p><strong>MySQL存储浮点数的格式为：符号、尾数、阶码。无论有没有符号，浮点数都会存储表示符号的部分。所以，无符号取值范围就是无符号取值范围中大于等于0的那部分</strong>。</p>
<p>MySQL中<strong>单精度值使用4字节，双精度值使用 8字节</strong>。</p>
<ul>
<li>MySQL允许使用非标准语法：FLOAT(M, D)、DOUBLE(M, D)，其中M称为精度（整数位+小数位），D称为标度（小数位）。精度与标度取值范围：D &lt;&#x3D; M &lt;&#x3D;255，0 &lt;&#x3D;D &lt;&#x3D; 30。</li>
<li>FLOAT 和 DOUBLE 不指定(M,D)时，默认按实际精度来显示。</li>
<li><strong>浮点类型可以加UNSIGNED，但不会改变数值范围</strong>。</li>
<li>无论设置精度与否，MySQL处理规则如下：<ul>
<li>以 二进制 形式存储，因小数对应的二进制有时不能准确表示，会进行四舍五入，导致不精准。</li>
<li>整数部分超过设定精度时直接报错。</li>
<li>小数部分超过设定精度时 执行 四舍五入：<ul>
<li>四舍五入后，整数部分没有超过范围，则只是警告，但能删除五入后多余的小数。</li>
<li>四舍入五后，整数部分超过范围，则MySQL报错拒绝处理。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="定点类型"><a href="#定点类型" class="headerlink" title="定点类型"></a>定点类型</h4><p><strong>MySQL中定点类型只有 DECIMAL。MySQL中的定点数基于 字符串 形式存储，这决定了它是精确的</strong>。</p>
<p><code>DECIMAL(M, D) DESC NUMERIC</code>占用 M+2 个字节，M称为精度，D称为标度，有效范围由 M 和 D 决定。精度与标度取值范围：0 &lt;&#x3D; M &lt;&#x3D; 65，0 &lt;&#x3D; D &lt;&#x3D; 30，最大取值范围与DOUBLE类型一样。</p>
<p><strong>DECIMAL不指定精度和标度时默认为DECIMAL(10, 0)，当数据精度超过阈值范围时会执行四舍五入</strong>。</p>
<h4 id="位值类型"><a href="#位值类型" class="headerlink" title="位值类型"></a>位值类型</h4><p><strong><code>BIT(M)</code>中M表示长度，长度范围：1 &lt;&#x3D; M &lt;&#x3D; 64，占用<code>(M+7)/8</code>个字节</strong>。</p>
<p><strong>BIT类型没有指定M时，默认为<code>BIT(1)</code>，表示只能存储1位的二进制值，M表示二进制数字的位数</strong>。</p>
<h3 id="1-3-3、字符串类型"><a href="#1-3-3、字符串类型" class="headerlink" title="1.3.3、字符串类型"></a>1.3.3、字符串类型</h3><p>字符串类型有CHAR、VARCHAR、TINYBLOB、TINYTEXT、BLOB、TEXT、MEDIUMBLOB、MEDIUMTEXT、LONGBLOB、LONGTEXT等类型。具体对比如下：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">长度</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CHAR</td>
<td align="center">0-255</td>
<td align="left">定长字符串</td>
</tr>
<tr>
<td align="center">VARCHAR</td>
<td align="center">0-65535</td>
<td align="left">变长字符串</td>
</tr>
<tr>
<td align="center">TINYBLOB</td>
<td align="center">0-255</td>
<td align="left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td align="center">TINYTEXT</td>
<td align="center">0-255</td>
<td align="left">短文本字符串</td>
</tr>
<tr>
<td align="center">BLOB</td>
<td align="center">0-65 535（64K）</td>
<td align="left">二进制形式的长文本数据</td>
</tr>
<tr>
<td align="center">TEXT</td>
<td align="center">0-65 535（64K）</td>
<td align="left">长文本数据</td>
</tr>
<tr>
<td align="center">MEDIUMBLOB</td>
<td align="center">0-16 777 215（16M）</td>
<td align="left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td align="center">MEDIUMTEXT</td>
<td align="center">0-16 777 215（16M）</td>
<td align="left">中等长度文本数据</td>
</tr>
<tr>
<td align="center">LONGBLOB</td>
<td align="center">0-4 294 967 295（4G）</td>
<td align="left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td align="center">LONGTEXT</td>
<td align="center">0-4 294 967 295（4G）</td>
<td align="left">极大文本数据</td>
</tr>
<tr>
<td align="center">ENUM</td>
<td align="center">0 - 65535</td>
<td align="left">1或2个字节</td>
</tr>
<tr>
<td align="center">SET</td>
<td align="center">0 - 64</td>
<td align="left">1、2、3、4或8个字节</td>
</tr>
</tbody></table>
<h4 id="CHAR与VARCHAR类型"><a href="#CHAR与VARCHAR类型" class="headerlink" title="CHAR与VARCHAR类型"></a>CHAR与VARCHAR类型</h4><ul>
<li>CHAR类型<ul>
<li><strong>需要预先定义字符长度，不指定时默认长度为1个字符。若设定了长度，则该长度表示所占字节数。</strong></li>
<li>字段值实际长度小于设定长度时，会在字段值右边以空格来填充至设定长度。MySQL检索CHAR类型字段值时，会去掉字段值尾部空格。</li>
</ul>
</li>
<li>VARCHAR类型<ul>
<li><strong>定义字段为VARCHAR类型时，必须指定长度，否则报错</strong>。</li>
<li>MySQL 4.0 前，varchar(20) 表示 20个字节，可以存储 6 个 UTF-8编码的汉字（每个汉字占3字节）。MySQL 5.0 后，varchar(20) 表示 20个字符。</li>
<li>检索VARCHAR类型字段值时，会保留数据末尾空格。VARCHAR类型字段占用空间大小为字符串实际长度+1。</li>
</ul>
</li>
</ul>
<h4 id="TEXT类型"><a href="#TEXT类型" class="headerlink" title="TEXT类型"></a>TEXT类型</h4><p><strong>因为实际长度不确定，MySQL不允许TEXT类型的字段做主键</strong>。</p>
<h4 id="BLOB类型"><a href="#BLOB类型" class="headerlink" title="BLOB类型"></a>BLOB类型</h4><p><strong>BLOB是一个二进制大对象，可以容纳可变数量的数据。主要用来存储图片、音频、视频等</strong>。</p>
<p>生产中不会使用BLOB类型来存储大对象数据，通常会将 图片、音频、视频等文件存储到服务器磁盘上，并将它们的访问路径存储到MySQL中。</p>
<p>TEXT和BLOB类型使用注意事项如下：</p>
<ol>
<li><strong>执行大量删除或修改会导致数据表存在很大的空洞（碎片），为提高性能，建议定期使用OPTIMIZE TABLE功能对表进行碎片整理</strong>。</li>
<li>虽然MySQL为检索大文本提供了前缀索引，但还是要减少对大型BLOB或TEXT值的模糊检索。</li>
<li>如果需要使用BLOB或TEXT数据类型，那么建议将TEXT列和BLOB列分离到一个单独的表中。</li>
</ol>
<h3 id="1-3-4、时间类型"><a href="#1-3-4、时间类型" class="headerlink" title="1.3.4、时间类型"></a>1.3.4、时间类型</h3><p>时间类型有YEAR、DATA、TIME、TIMESTAMP、DATETIME等类型。具体对比如下：</p>
<table>
<thead>
<tr>
<th align="left">bytes</th>
<th align="left">类型</th>
<th align="left">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">YEAR</td>
<td align="left">1901 ~ 2155</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">DATE</td>
<td align="left">1000-01-01 ~ 9999-12-31</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">TIME</td>
<td align="left">‘-838:59:59’ ~ ‘838:59:59’</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">TIMESTAMP</td>
<td align="left">1970-01-01 00:00:00 ~ 2038-01-19 03:14:07。结束时间：北京时间2038-1-19_11:14:07，格林尼治时间2038-01-19_03:14:07</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">DATETIME</td>
<td align="left">1000-01-01 00:00:00&#x2F;9999-12-31 23:59:59</td>
</tr>
</tbody></table>
<h4 id="DATETIME类型"><a href="#DATETIME类型" class="headerlink" title="DATETIME类型"></a>DATETIME类型</h4><p><strong>DATETIME类型占用8字节，在所有日期和时间类型中占用空间最大</strong>。</p>
<p>向DATETIME类型的字段插入数据时，需要满足一定的格式条件：</p>
<ul>
<li>推荐使用<code>YYYY-mm-DD HH:MM:SS</code>格式来插入。</li>
<li>可以使用<code>CURRENT_TIMESTAMP()</code> 、<code>NOW()</code>函数的返回值来作为字段值进行插入。</li>
</ul>
<h4 id="TIMESTAMP类型"><a href="#TIMESTAMP类型" class="headerlink" title="TIMESTAMP类型"></a>TIMESTAMP类型</h4><p><strong>TIMESTAMP类型占用4字节存储空间。显示格式与DATETIME类型一样</strong>。</p>
<p>TIMESTAMP类型字段中存储数据时 <strong>需要对当前时间所在的时区进行转换，查询时再将时区转换回当前时区</strong>。使用TIMESTAMP存储的同一时间，在不同时区环境下会显示不同时间。</p>
<p>向TIMESTAMP类型的字段插入数据的格式可以使用<code>YY-MM-DD HH:MM:SS</code>。</p>
<blockquote>
<p>若无特殊需求，生产中推荐使用DATETIME类型来存储时间。DATETIME数据类型包含了完整的日期和时间，取值范围很大，使用较方便。</p>
</blockquote>
<h3 id="1-3-5、数据类型总结"><a href="#1-3-5、数据类型总结" class="headerlink" title="1.3.5、数据类型总结"></a>1.3.5、数据类型总结</h3><p>定义字段数据类型时，参考建议如下：</p>
<ul>
<li>定义数据类型时，<strong>确定是整数就用INT，确定是小数就用DECIMAL(M, D)，如果是日期类型就用DATETIME</strong>。</li>
<li><strong>如果存储的字符串长度几乎相等，推荐使用CHAR定长字符串类型</strong>。</li>
<li><strong>VARCHAR是可变长字符串，不预先分配空间，建议长度不要超过5000。如果长度超过5000，建议定义字段类型为TEXT，且将之单独放于一张表中</strong>，然后使用主键来关联原表，避免影响其它字段索引效率。</li>
</ul>
<p>字节与字符关系如下：</p>
<ul>
<li>ASCII 码中，一个英文字母（不分大小写）为一个字节，一个中文汉字为两个字节。</li>
<li>UTF-8 编码中，一个英文字为一个字节，一个中文为三个字节。</li>
<li>Unicode 编码中，一个英文为一个字节，一个中文为两个字节。</li>
<li>符号：英文标点为一个字节，中文标点为两个字节。例如：英文句号 <strong>.</strong> 占1个字节的大小，中文句号 <strong>。</strong>占2个字节的大小。</li>
<li>UTF-16 编码中，一个英文字母字符或一个汉字字符存储都需要 2 个字节（Unicode 扩展区的一些汉字存储需要 4 个字节）。</li>
<li>UTF-32 编码中，世界上任何字符的存储都需要 4 个字节。</li>
</ul>
<h2 id="1-4、存储引擎"><a href="#1-4、存储引擎" class="headerlink" title="1.4、存储引擎"></a>1.4、存储引擎</h2><h3 id="引擎分类"><a href="#引擎分类" class="headerlink" title="引擎分类"></a>引擎分类</h3><ul>
<li><strong>InnoDB</strong>：<ul>
<li>支持行锁、表锁、外键、事务。</li>
<li>5.5.8及之后版本，默认采用InnoDB引擎 。</li>
<li>InnoDB是MySQL的默认事务型引擎 。</li>
<li>InnoDB是处理巨大数据量的最大性能设计 。</li>
<li>InnoDB写处理效率差一些。</li>
<li>InnoDB不仅缓存索引还要缓存真实数据， 对内存要求较高 ，而且内存大小对性能有决定性影响；MyISAM只缓存索引，不缓存真实数据；</li>
</ul>
</li>
<li><strong>MyISAM</strong><ul>
<li>不支持行锁、外键、事务，崩溃后无法安全恢复 。</li>
<li>5.5版本前是默认存储引擎。</li>
<li>适用于只读或多读场景。</li>
</ul>
</li>
<li><strong>Memory</strong>：将数据存储在内存中，速度快，但不会持久化，适合缓存、临时表场景。</li>
<li>Blackhole：不会存储数据，但会将接收到的数据记录在二进制日志中，适合数据同步、备份等场景</li>
<li><strong>Federated</strong>：将不同mysql服务器中的表关联起来，使其逻辑上看起来像是一张表，实现MySQL服务器之间的数据共享。</li>
<li><strong>NDB</strong>：支持分布式数据库，适合海量数据存储和高可用场景。</li>
<li><strong>Archive</strong>：将数据以压缩格式存储在文件中，适合存储历史数据或不经常使用的数据。</li>
<li><strong>CSV</strong>：将数据以CSV格式存储在文件中，适合存储大量数据且不需要索引的场景。</li>
</ul>
<h3 id="引擎比较"><a href="#引擎比较" class="headerlink" title="引擎比较"></a>引擎比较</h3><ul>
<li><strong>InnoDB</strong>：支持行锁、外键、事务、非锁定读，5.5.8版本开始被设定为默认引擎。<ul>
<li>MySQL 5.7：字符集+排序规则等信息保存在<strong>db.opt</strong>文件中。<ul>
<li>独立表空间：**.frm**文件（表结构） &#x2F; <strong>.ibd</strong>文件（索引+数据）。</li>
<li>系统表空间：<strong>ibdata1</strong>，默认12M。</li>
</ul>
</li>
<li>MySQL 8<ul>
<li>独立表空间：**.ibd**文件（字符集+排序规则+表结构+表数据）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>MyISAM</strong>：不支持事务，支持表锁，支持全文索引，5.5.8版本之前为默认引擎（除了windows版）。<ul>
<li>MySQL 5.7：字符集+排序规则等信息保存在<strong>db.opt</strong>文件中。<ul>
<li>独立表空间：**.frm**文件（表结构） &#x2F; <strong>.MYD</strong>文件（数据）&#x2F; <strong>.MYI</strong>（索引）</li>
<li>系统表空间：<strong>ibdata1</strong>中，默认12M</li>
</ul>
</li>
<li>MySQL 8<ul>
<li>独立表空间：**.xxx.sdi**（表结构，相当于5.7中的frm） &#x2F; <strong>.MYD</strong>（数据）&#x2F;	<strong>.MYI</strong>（索引）</li>
</ul>
</li>
</ul>
</li>
<li><strong>Memory</strong>：数据存放于内存，适合存储临时数据、数据仓库维度表，使用哈希索引。</li>
</ul>
<h3 id="系统存储引擎管理"><a href="#系统存储引擎管理" class="headerlink" title="系统存储引擎管理"></a>系统存储引擎管理</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 查看
show engines;
show engines \G;

# 设置
show variables like &#39;%storage_engine%&#39;;
SELECT @@default_storage_engine;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>也可以 修改配置文件 来实现相同效果：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">default-storage-engine</span><span class="token punctuation">=</span><span class="token value attr-value">MyISAM</span>
<span class="token comment"># 重启服务</span>
<span class="token key attr-name">systemctl</span> <span class="token value attr-value">restart mysqld.service</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="表存储引擎管理"><a href="#表存储引擎管理" class="headerlink" title="表存储引擎管理"></a>表存储引擎管理</h3><p>创建表时执行：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE 表名(
	建表语句;
) ENGINE &#x3D; 存储引擎名称;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>修改表的存储引擎：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE 表名 ENGINE &#x3D; 存储引擎名称;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="1-5、SQL运行"><a href="#1-5、SQL运行" class="headerlink" title="1.5、SQL运行"></a>1.5、SQL运行</h2><h3 id="1-5-1、执行流程"><a href="#1-5-1、执行流程" class="headerlink" title="1.5.1、执行流程"></a>1.5.1、执行流程</h3><p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20220410153114801.png" alt="image-20220410153114801"></p>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>如果发现了要加工执行的 SQL 语句已经存在于查询缓存中，则会直接将结果返回给客户端；如果没有，则继续走SQL解析、处理等流程。</p>
<p>只要表结构或数据被修改（INSERT 、 UPDATE 、 DELETE 、 TRUNCATE TABLE 、 ALTER TABLE 、 DROP TABLE 或 DROP DATABASE），则该表涉及的所有高速缓存都将失效并清空！对于更新压力大的数据库来说，查询缓存的命中率会非常低。</p>
<p><strong>因为查询缓存效率不高，所以 MySQL8.0 后废弃了查询缓存</strong>。</p>
<h4 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h4><p><strong>在解析器中对SQL语句 执行 语法分析、语义分析</strong>。</p>
<p>分析器<em><strong>先做“ 词法分析 ”</strong></em>。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。 </p>
<p>然后<em><strong>再做“ 语法分析 ”</strong></em>。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输 入的这个 SQL 语句是否 满足 MySQL 语法 。</p>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p><strong>在优化器中会确定 SQL 执行路径，比如是否使用索引</strong>。</p>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p><strong>执行前会先判断用户是否具备权限</strong> 。如果没有，会返回权限错误。如果具备权限，会执行SQL并返回结果。</p>
<p>MySQL8.0 前，如果设置了查询缓存，则会将查询结果缓存起来。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>SQL执行流程：<strong>SQL语句 - 查询缓存 - 解析器 - 优化器 - 执行器</strong>。</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20220410153913664.png" alt="image-20220410153913664"></p>
<p>oracle执行流程：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20220410154843126.png" alt="image-20220410154843126"></p>
<h3 id="1-5-2、MySQL8执行信息"><a href="#1-5-2、MySQL8执行信息" class="headerlink" title="1.5.2、MySQL8执行信息"></a>1.5.2、MySQL8执行信息</h3><ol>
<li><p>确认profiling 是否开启</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select @@profiling;
show variables like &#39;profiling&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>多次执行相同SQL查询</p>
</li>
<li><p>查看profiles</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show profiles; # 显示最近的几次查询<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>查看profile</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show profile;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<h3 id="1-5-3、MySQL5-7执行信息"><a href="#1-5-3、MySQL5-7执行信息" class="headerlink" title="1.5.3、MySQL5.7执行信息"></a>1.5.3、MySQL5.7执行信息</h3><ol>
<li><p>配置文件中开启查询缓存</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">query_cache_type&#x3D;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>重启MySQL服务</p>
</li>
<li><p>开启查询执行计划</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">set profiling&#x3D;1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>执行语句</p>
</li>
<li><p>查看profiles</p>
</li>
<li><p>查看profile</p>
</li>
</ol>
<h3 id="1-5-4、SQL语法顺序"><a href="#1-5-4、SQL语法顺序" class="headerlink" title="1.5.4、SQL语法顺序"></a>1.5.4、SQL语法顺序</h3><p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20220410154740134.png" alt="image-20220410154740134"></p>
<h2 id="1-6、增删改查"><a href="#1-6、增删改查" class="headerlink" title="1.6、增删改查"></a>1.6、增删改查</h2><h3 id="1-6-1、增"><a href="#1-6-1、增" class="headerlink" title="1.6.1、增"></a>1.6.1、增</h3><h3 id="1-6-4、查"><a href="#1-6-4、查" class="headerlink" title="1.6.4、查"></a>1.6.4、查</h3><h4 id="1-6-4-1、子查询"><a href="#1-6-4-1、子查询" class="headerlink" title="1.6.4.1、子查询"></a>1.6.4.1、子查询</h4><h5 id="子查询分类"><a href="#子查询分类" class="headerlink" title="子查询分类"></a>子查询分类</h5><ul>
<li>根据内查询返回结果的条目数量来说，分为 单行子查询 和 多行子查询。</li>
<li>根据内查询是否被执行多次来说，分为：相关子查询 和 不相关子查询。</li>
</ul>
<h3 id="1-6-3、改"><a href="#1-6-3、改" class="headerlink" title="1.6.3、改"></a>1.6.3、改</h3><h3 id="1-6-2、删"><a href="#1-6-2、删" class="headerlink" title="1.6.2、删"></a>1.6.2、删</h3><h1 id="2、InnoDB存储引擎"><a href="#2、InnoDB存储引擎" class="headerlink" title="2、InnoDB存储引擎"></a>2、InnoDB存储引擎</h1><h2 id="2-1、InnoDB体系架构"><a href="#2-1、InnoDB体系架构" class="headerlink" title="2.1、InnoDB体系架构"></a>2.1、InnoDB体系架构</h2><h3 id="2-1-1、后台线程"><a href="#2-1-1、后台线程" class="headerlink" title="2.1.1、后台线程"></a>2.1.1、后台线程</h3><ol>
<li><p><strong>Master Thread</strong></p>
<p>将缓冲池中的数据异步刷新到磁盘，包括脏页刷新、合并插入缓冲、undo页回收。</p>
</li>
<li><p><strong>IO Thread</strong></p>
<p>InnoDB中用了大量AIO来处理IO请求，而IO Thread负责这些请求的回调处理。</p>
</li>
<li><p><strong>Purge Thread</strong></p>
<p>事务提交后，undo log可能还会需要，故最终是否回收undo页由<code>puurge thread</code>决定。</p>
<p>InnoDB 1.1前，purge操作在Master Thread中完成。1.1版本开始基于单独线程来完成。可在配置文件配置参数<code>innodb_purge_threads=1;</code> 来开启独立purge thread。</p>
</li>
<li><p><strong>Page Cleaner Thread</strong></p>
<p>InnoDB 1.2.x版本引入，将之前版本中的 脏页刷新 升级为 独立线程来完成，目的是减轻Master Thread工作、用户查询线程的阻塞。</p>
</li>
</ol>
<p>	</p>
<h3 id="2-1-2、内存"><a href="#2-1-2、内存" class="headerlink" title="2.1.2、内存"></a>2.1.2、内存</h3><h4 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h4><p>InnoDB引擎基于磁盘存储，其中的记录以页为单位来管理，故称之为基于磁盘的数据库系统。由于CPU和磁盘IO速度的巨大差异，故使用【缓冲池】来提高性能。</p>
<p><strong>数据库读取页时会先从磁盘读取，然后放入缓冲池</strong>，该过程称为将页“FIX”在缓冲池中。下次再读取时先判断缓冲池中是否存在，存在则称为“命中”，直接读取该页，否则就从磁盘读取。</p>
<p><strong>修改数据库页时，先修改缓冲池中的页，然后再通过<code>CheckPoint</code>机制刷新至磁盘（并非每次修改页就刷新），这也是为了提高数据库整体性能</strong>。</p>
<p>缓冲池中页的种类有：索引页、数据页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等。</p>
<p><strong>从InnoDB 1.0.x版本开始，允许有多个缓冲池实例，每个页可通过哈希映射到不同的缓冲池实例中</strong>。其可以通过参数<code>innodb_buffer_pool_instances</code>进行配置，默认为1。查看缓冲状态可以通过命令：<code>SHOW ENGINE INNODB STATUS</code>来实现，MySQL5.6开始，可通过表<code>INNODB_BUFFER_POOL_STATUS</code>来观察。</p>
<h4 id="LRU-List、Free-List、Flush-List"><a href="#LRU-List、Free-List、Flush-List" class="headerlink" title="LRU List、Free List、Flush List"></a>LRU List、Free List、Flush List</h4><p><strong>数据库缓冲池基于LRU（最近最少使用）算法来管理</strong>。频繁使用的数据会放在LRU列表前端，最少使用的放在列表末端，当缓冲池空闲容量不足以缓冲新数据时，会抛弃释放掉列表末端的页。</p>
<p><strong>InnoDB缓冲池中页的大小为16KB，要注意的是这里的LRU算法是在原算法基础上做了优化</strong>。LRU列表中加入了midpoint位置（默认列表5&#x2F;8位置），新读取的页放在midpoint位置，该算法在InnoDB下称为“midpoint insertion strategy”。midpoint位置可通过参数<code>innodb_old_blocks_pct</code>来设置，M以SQL8默认值为 37。</p>
<p>为何不将新读取的页放在LRU列表前端呢？因为某些SQL操作会使得缓冲池中的页被刷新出去。为解决该问题，引入一个参数<code>innodb_old_blocks_time</code>来管理LRU列表，该参数表示读取页到mid位置后需要多久才会被加入到LRU列表前端（频繁使用，热端）。</p>
<p><strong>数据库刚启动时，LRU列表是空的，此时页都被放在Free列表中。当要从缓冲池中分页时，先从Free列表中查找是否有可用页，若有则将该页复制一份放至LRU列表并将原页删除</strong>。页从LRU列表的old部分加入到new部分时，称之为“page made young”。因为参数”innodb_old_blocks_time”原因导致页没有从old部分加入到new部分的操作称为“page not made young”。可以通过命令<code>SHOW ENGINE INNODB STATUS</code>来观察LRU列表和Free列表的情况。</p>
<p><strong>InnoDB1.0.x 开始支持【页压缩】功能，可将16K的页压缩至1、2、4、8KB，对于非16KB的页会通过unzip_LRU列表来管理</strong>。LRU中的页包括unzip_LRU列表中的页，unzip_LRU列表是通过伙伴算法为不同大小的页进行内存分配，分配内存时只能按照1、2、4、8KB的大小空间进行申请并存储。</p>
<p><strong>LRU列表中的页被修改后称为“脏页”，脏页需要通过CHECKPOINT机制刷新到磁盘</strong>。Flush列表是脏页列表，注意脏页既存在于LRU列表中，也存在于Flush列表中，LRU列表用于管理页的可用性，Flush列表用于将页刷新至磁盘，二者互不影响。</p>
<h4 id="重做日志缓冲"><a href="#重做日志缓冲" class="headerlink" title="重做日志缓冲"></a>重做日志缓冲</h4><p><strong>InnoDB的内存除了缓冲池，还有重做日志缓冲。先将重做日志放至重做日志缓冲中，再按一定规则刷新至磁盘上的重做日志文件中</strong>。重做日志文件无需太大，只需满足每秒产生的日志数量即可。该值由参数<code>innodb_log_buffer_size</code>控制，MySQL5.7.33和MySQL 8中默认16M。</p>
<p>重做日志缓冲刷新到磁盘的三种情况：</p>
<ol>
<li>Master Thread <em><strong>每秒</strong></em> 将重做日志刷新至磁盘重做日志文件中。</li>
<li>每个<em><strong>事务提交时</strong></em>会将重做日志缓冲 刷新至 重做日志文件。</li>
<li>重做日志<em><strong>缓冲池空闲容量小于1&#x2F;2时</strong></em>，会刷新至重做日志文件。</li>
</ol>
<h4 id="额外内存池"><a href="#额外内存池" class="headerlink" title="额外内存池"></a>额外内存池</h4><p><strong>InnoDB通过内存堆方式来管理内存</strong>。在对一些数据结构本身进行内存分配时需要从额外内存池中申请，该内存不够时会从缓冲池中进行申请。分配了缓冲池，但每个缓冲池中的帧缓冲还有对应的缓冲控制对象，这些对象记录了LRU、锁、等待等信息，而这个对象也需要从额外内存池中申请，故应尽量增大该内存池容量。</p>
<h2 id="2-2、Checkpoint技术"><a href="#2-2、Checkpoint技术" class="headerlink" title="2.2、Checkpoint技术"></a>2.2、Checkpoint技术</h2><p><strong>缓冲池的存在是为了 协调 CPU速度和磁盘速度的鸿沟</strong>。</p>
<p>页中记录被修改后，该页就被称为脏页。脏页需要从缓冲池被刷新到磁盘，磁盘刷新过程存在诸多问题，为解决这些问题，提出了<code>Write Ahead Log</code>策略，即事务提交时先写重做日志，再修改页。</p>
<p>InnoDB是通过LSN（Log Sequence Number）来标记版本。LSN通过8字节大小的数字来表示，单位为字节。每个页都有LSN，重做日志也有LSN，CheckPoint也有LSN。</p>
<h3 id="2-2-1、Checkpoint功能"><a href="#2-2-1、Checkpoint功能" class="headerlink" title="2.2.1、Checkpoint功能"></a>2.2.1、Checkpoint功能</h3><ol>
<li><p><strong>缩短数据库的恢复时间</strong></p>
<p>数据库宕机时，无需重做所有日志，因为checkpoint之前的页都已经刷新到磁盘，故只需对cp之后的重做日志进行恢复即可。</p>
</li>
<li><p><strong>缓冲池不够用时，刷新脏页到磁盘</strong></p>
<p>缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若该页是脏页，那么需要强制执行Checkpoint，将脏页刷新到磁盘。</p>
</li>
<li><p><strong>重做日志不可用时，刷新脏页</strong></p>
<p>重做日志是可以循环使用，而非无限增大。重做日志可以被重用的前提是该日志中内容已经刷新到磁盘，若此时重做日志还没有刷新到磁盘，那么就需要强制产生cp，将缓冲池的页至少刷新到当前重做日志的位置。</p>
</li>
</ol>
<h3 id="2-2-2、Checkpoint分类"><a href="#2-2-2、Checkpoint分类" class="headerlink" title="2.2.2、Checkpoint分类"></a>2.2.2、Checkpoint分类</h3><ol>
<li><p><strong>Sharp Checkpoint</strong></p>
<p><strong>数据库关闭时将所有脏页刷新到磁盘，这是默认方式，即参数 innodb_fast_shutdown&#x3D;1</strong>。使用该check point会降低数据库的可用性，故InnoDB内部使用Fuzzy Checkpoint来刷新部分脏页，而非全部脏页。</p>
</li>
<li><p><strong>Fuzzy Checkpoint</strong></p>
<p>InnoDB中可能发生的FCP情况：</p>
<ol>
<li><p><strong>Master Thread CheckPoint</strong></p>
<p>以每秒或者每十秒的速度从缓冲池脏页列表（Flush列表）中刷新一定比例的脏页到磁盘中，该过程异步。</p>
</li>
<li><p><strong>FLUSH_LRU_LIST CheckPoint</strong></p>
<p>InnoDB要保证LRU列表中至少有100个空闲页可供使用，如果低于100个空闲页会清除LRU列表尾端的页，但如果尾端的页又是脏页那么就需要强制执行CheckPoint。</p>
<p>从MySQL5.6开始，这个检查机制被放在单独的Page Cleaner线程中进行，可通过参数<code>innodb_lru_scan_depth</code>控制LRU列表中可用页的数量，默认值为1024。</p>
</li>
<li><p><strong>Async&#x2F;Sync Flush CheckPoint</strong></p>
<p>重做日志不可用时要强制刷新部分脏页到磁盘，此时脏页是从脏页列表（Flush列表）中选取的。若已经写入到重做日志的LSN标记为 redo_lsn，已经刷新到磁盘最新页的LSN标记为checkpoint_lsn，则：</p>
<p><code>checkpoint_age = redo_lsn - checkpoint_lsn</code>，再定义如下变量：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">async_water_mark</span> <span class="token punctuation">=</span> <span class="token value attr-value">75% * total_redo_log_file_size</span>
<span class="token key attr-name">sync_water_mark</span> <span class="token punctuation">=</span> <span class="token value attr-value">90% * total_redo_log_file_size</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>若每个重做日志文件大小为1G，且定义了两个重做日志，则重做日志总大小为2G，那么async_water_mark&#x3D;1.5G，sync_water_mark&#x3D;1.8G，则：</p>
<ol>
<li>当checkpoint_age &lt; async_water_mark时，不需要刷新任何脏页至磁盘；</li>
<li>当async_water_mark &lt; checkpoint_age &lt; sync_water_mark时触发 Async Flush，从Flush列表刷新足够的脏页至磁盘，使得刷新后满足 checkpoint_age &lt; async_water_mark；</li>
<li>checkpoint_age &gt; sync_water_mark的情况很难发生，除非重做日志文件太小，且进行类似 LOAD DATE的BULK INSERT 操作。此时触发Sync Flush操作，从Flush列表刷新足够的脏页至磁盘，使得刷新后满足 checkpoint_age &lt; async_water_mark；</li>
</ol>
</li>
</ol>
</li>
<li><p>脏页太多导致 CheckPoint</p>
<p><strong>脏页数量太多，导致 InnoDB强制进行 CheckPoint，其目的是为了保证缓冲池中有足够可用的页</strong>。其可由参数<code>innodb_max_dirty_pages_pct</code>控制，该值表示当缓冲池中脏页数量占据总量的百分比，当达到这个值时，就执行Checkpoint操作。InnoDB 1.0.x之前，默认值为90，之后版本都为75。</p>
</li>
</ol>
<h2 id="2-3、InnoDB关键特性"><a href="#2-3、InnoDB关键特性" class="headerlink" title="2.3、InnoDB关键特性"></a>2.3、InnoDB关键特性</h2><h3 id="2-3-1、插入缓冲"><a href="#2-3-1、插入缓冲" class="headerlink" title="2.3.1、插入缓冲"></a>2.3.1、插入缓冲</h3><h4 id="Insert-Buffer"><a href="#Insert-Buffer" class="headerlink" title="Insert Buffer"></a>Insert Buffer</h4><p>插入缓冲区是InnoDB引擎的一项优化技术。当使用辅助索引插入新记录时，会先将新记录写入插入缓冲区而并非直接写入磁盘。</p>
<p>插入缓冲区可以减少随机磁盘写入的数量，提高插入性能。在特定情况下，会将插入缓冲区中的数据刷新到对应的辅助索引页中。</p>
<p>使用 插入缓冲 需要满足两个条件：</p>
<ol>
<li><p><strong>索引是辅助索引</strong>；</p>
</li>
<li><p><strong>索引不是唯一的</strong>；</p>
<p>因为使用唯一索引会导致在插入缓冲时会查找索引页来判断插入记录的唯一性，查找会导致离散读取，Insert Buffer也将失去意义。</p>
</li>
</ol>
<p>Insert Bufffer存在一个问题：写密集环境下，插入缓冲会占用大量缓冲池内存，默认最大可占用1&#x2F;2的缓冲池。</p>
<h4 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h4><p><strong>InnoDB 1.0.x 开始引入 Change Buffer，可视为 Insert Buffer 升级版</strong>。InnoDB可以对DML操作都进行缓冲，它们分别是：Insert Buffer、Delete Buffer、Purge Buffer。</p>
<p>Update操作可分为两个过程：</p>
<ol>
<li><strong>将记录标记为删除</strong>；</li>
<li><strong>真正将记录删除</strong>；</li>
</ol>
<p><strong>Delete Buffer对应Update操作的第一个过程，Purge Buffer对应Update操作的第二个过程</strong>。</p>
<p>InnoDB提供参数<code>innodb_change_buffering</code>来开启各种Buffer选项，该参数可选值有：inserts、deletes、purges、changes、all、none。其中inserts、deletes、purges表示三种情况。changes表示inserts和deletes，all表示所有，none表示都不启用。该参数默认值为all。</p>
<p>InnoDB 1.2.x开始可通过参数<code>innodb_change_buffer_max_size</code>来控制Change Buffer最大可用内存比例。默认25，表示最多可以使用1&#x2F;4大小的缓冲池内存，该参数最大有效值为50。</p>
<h4 id="Insert-Buffer内部实现"><a href="#Insert-Buffer内部实现" class="headerlink" title="Insert Buffer内部实现"></a>Insert Buffer内部实现</h4><p><strong>Innsert Buffer数据结构是一颗B+树，由 叶节点 和 非叶节点 组成。MySQL 4.1前每张表有一颗 Insert Buffer B+树，后续版本，全局只有一颗 Insert  Buffer B+树，负责对所有表的辅助索引进行 Insert Buffer</strong>。该B+树存放于共享表空间中，默认就在<code>ibdate1</code>中。因此通过独立表空间ibd文件恢复表中数据时往往会导致Check TABLE失败，所以通过ibd恢复后，还需通过REPAIR TABLE操作来重建表上所有的辅助索引。</p>
<h4 id="Merge-Insert-Buffer"><a href="#Merge-Insert-Buffer" class="headerlink" title="Merge Insert Buffer"></a>Merge Insert Buffer</h4><p>Merge Insert Buffer操作发生于以下几种情况：</p>
<ol>
<li>辅助索引页 被读取至 缓冲池 中；</li>
<li>Insert Buffer Bitmap页 追踪到该辅助索引页 已无可用空间时；</li>
<li>Master Thread；</li>
</ol>
<h3 id="2-3-2、两次写"><a href="#2-3-2、两次写" class="headerlink" title="2.3.2、两次写"></a>2.3.2、两次写</h3><p>InnoDB引擎下，数据存储在页中，页通常大小为16KB。当进行数据写入操作时，通常先将数据写入到内存中的缓冲区中，然后再异步将缓冲区的数据刷新到磁盘上的文件中。数据在被刷新到磁盘前，发生了系统崩溃或其它异常情况，那么可能导致数据写入不完整或被损坏。</p>
<p>为了保证数据的完整性和持久性，InnoDB引擎引入了“两次写”技术。两次写的原理是：<strong>当进行数据写入操作时，先将数据写入到一个 double write buffer 的缓冲区中，该缓冲区大小与页大小相同（通常16KB）。然后将该缓冲区中的数据同时写到磁盘上的两个不同位置，这样即使其中一个出现异常导致不可用，那么另一个作为备份也可以继续使用</strong>。</p>
<p>在系统崩溃或重新启动后，InnoDB需要进行数据恢复，以确保数据的一致性和完整性。恢复过程中，首先检查数据文件中的页和 double write buffer 中的数据是否一致。如果某个页上的数据不完整，InnoDB可以从另一个备份中获取正确数据，从而恢复其数据，保证其完整一致。</p>
<p>其实，两次写说的是——利用 重做日志 来恢复数据前，用户需要一个页的副本，当写入失效发生时，先通过副本还原该页，再进行重做，这就是两次写。</p>
<p>两次写由两部分组成，一部分是内存中doublewrite buffer，大小为2m；另一个是物理磁盘上共享表空间中连续的128个页，即2个区，大小同样为2m。</p>
<p>缓冲池脏页刷新过程：</p>
<ol>
<li>通过<code>memcpy</code>函数 先将脏页 复制到 内存中的<code>double write buffer</code>。</li>
<li>dwb分两次，每次1m顺序写入共享表空间的物理磁盘上，严格来说是先到 PageCache 中。</li>
<li>马上调用 fsync 函数同步到磁盘，避免缓冲写带来的问题。</li>
</ol>
<h3 id="2-3-3、自适应哈希索引"><a href="#2-3-3、自适应哈希索引" class="headerlink" title="2.3.3、自适应哈希索引"></a>2.3.3、自适应哈希索引</h3><p><strong>该索引查找时间复杂度一般为O(1)。InnoDB引擎会监控对表上各索引页的查询，如果发现建立哈希索引会有速度提升，那么会自动建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI），这个判断并创建的过程用户无法干预</strong>。</p>
<p>AHI 通过缓冲池的 B+ 树页构造而来，因此建立速度非常快，且不需要对整张表构建哈希索引。InnoDB引擎会根据访问的频率和模式自动建立哈希索引。</p>
<p>AHI要求：对页的连续访问模式必须是一样的；以该模式访问了100次。<font color='orange'>页通过该模式被访问了N次，其中N &#x3D; (页中记录数量&#x2F;16)。</font></p>
<blockquote>
<p>访问模式是指：查询条件一样，若交替执行两种查询，且次数也达到了100次，那么也不会构建AHI。</p>
</blockquote>
<p>自适应哈希索引存在如下特点：</p>
<ul>
<li>InnoDB引擎自动创建，无需手动干预。</li>
<li>一个索引键被频繁访问时，会将该键会对应的物理位置添加到哈希索引中，加速其查询。</li>
<li>不会占用磁盘空间，只在内存中维护。</li>
</ul>
<h3 id="2-3-4、异步IO"><a href="#2-3-4、异步IO" class="headerlink" title="2.3.4、异步IO"></a>2.3.4、异步IO</h3><p>MySQL中，<strong>InnoDB引擎使用了异步IO来进行IO操作，进一步提升了读写效率</strong>。</p>
<p>mysql 5.5之前，异步IO默认关闭，需要手动开启。从mysql 5.5开始，异步IO默认开启，可通过配置文件进行调整。</p>
<h4 id="AIO优点"><a href="#AIO优点" class="headerlink" title="AIO优点"></a>AIO优点</h4><ol>
<li>发出一个IO请求后，可以再次发送另一个IO请求，当全部发送完毕，等待IO请求完成即可。</li>
<li>可以进行IO Merge操作，即将多个IO合并为一个IO，这提高了IOPS的性能。</li>
</ol>
<h3 id="2-3-5、刷新邻接页"><a href="#2-3-5、刷新邻接页" class="headerlink" title="2.3.5、刷新邻接页"></a>2.3.5、刷新邻接页</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><strong>当刷新一个脏页时，InnoDB引擎会检测该页所在区的所有页，如果这些页中也有脏页那么会将它们一起刷新</strong>。</p>
<blockquote>
<p>InnoDB1.2.x提供了参数 <code>innodb_flush_neighbors</code>来控制是否开启该特性。对于机械硬盘建议开启，对于有较高IOPS的固态硬盘建议关闭。</p>
</blockquote>
<h2 id="2-4、启动、关闭与恢复"><a href="#2-4、启动、关闭与恢复" class="headerlink" title="2.4、启动、关闭与恢复"></a>2.4、启动、关闭与恢复</h2><p>服务关闭时，参数<code>innodb_fast_shutdown</code>影响着InnoDB的行为，该参数可取值为0、1、2，默认为1。</p>
<ul>
<li>0：数据库关闭时，InnoDB需要<strong>完成所有的<code>full purge</code>和<code>merge insert buffer</code><strong>，该过程时间很长，可能长达几个小时，</strong>并将所有脏页刷新到磁盘</strong>。（InnoDB升级时，必须将该参数置为0，然后再关闭数据库。）</li>
<li>1：参数默认值，不需要完成<code>full purge</code>和<code>merge insert buffer</code>操作，但<strong>缓冲池中的脏页会刷新到磁盘</strong>。</li>
<li>2：不完成<code>full purge</code>和<code>merge insert buffer</code>操作，也不将缓冲池中的脏页刷新至磁盘，而是<strong>将日志都写入日志文件</strong>。下次数据库启动时，会进行恢复操作。</li>
</ul>
<p><strong>参数<code>innodb_force_recovery</code>影响整个InnoDB引擎恢复的情况</strong>。该参数值有7个：0~6，分别代表不同意思：</p>
<ul>
<li>0：需要恢复时会执行所有的恢复操作；当不能进行有效恢复且发生错误时，会把错误写入错误日志中。</li>
<li>1：忽略检查到的corrupt页；</li>
<li>2：阻止Master Thread线程运行，如MT需要进行full purge操作，而这会导致崩溃。</li>
<li>3：不进行事务的回滚操作；</li>
<li>4：不进行插入缓冲的合并操作；</li>
<li>5：不查看撤销日志，InnoDB引擎会将未提交的事务视为已提交；</li>
<li>6：不进行前滚操作；</li>
</ul>
<h1 id="3、文件"><a href="#3、文件" class="headerlink" title="3、文件"></a>3、文件</h1><p>构成MySQL数据库和InnoDB引擎表的各种类型文件有：</p>
<ol>
<li><p><strong>参数文件</strong></p>
<p>告诉MySQL启动时从哪里去获取数据库文件，并指定某些初始化参数。</p>
</li>
<li><p><strong>日志文件</strong></p>
<p>记录MySQL对某种条件做出响应时写入的文件，如错误日志文件、二进制日志文件、慢查询日志、查询日志文件等。</p>
</li>
<li><p><strong>socket文件</strong></p>
<p>当用 UNIX域套接字方式进行连接时需要的文件。</p>
</li>
<li><p><strong>pid文件</strong></p>
<p>MySQL实例的进程ID文件。</p>
</li>
<li><p><strong>MySQL表结构文件</strong></p>
<p>存放MySQL表结构定义文件。</p>
</li>
<li><p><strong>存储引擎文件</strong></p>
<p>每个存储引擎都会有自己的文件来保存各种数据。存储引擎记录了记录和索引数据。</p>
</li>
</ol>
<h2 id="3-1、参数文件"><a href="#3-1、参数文件" class="headerlink" title="3.1、参数文件"></a>3.1、参数文件</h2><p><strong>当MySQL启动时，数据库会先读取一个配置参数文件来做相关的初始化操作</strong>。</p>
<p>Oracle实例启动时 找不到参数文件 会无法启动装载，而MySQL实例启动时可以不需要参数文件，此时所有的参数使用的是默认值。</p>
<p>mysql结构中记录了访问该实例的权限，如果找不到该架构，则实例无法启动成功。</p>
<h3 id="3-1-1、参数定义"><a href="#3-1-1、参数定义" class="headerlink" title="3.1.1、参数定义"></a>3.1.1、参数定义</h3><p>简单说，可以把数据库参数看成一个键&#x2F;值对。</p>
<h3 id="3-1-2、参数类型"><a href="#3-1-2、参数类型" class="headerlink" title="3.1.2、参数类型"></a>3.1.2、参数类型</h3><p>参数可分为两类：</p>
<ol>
<li><p><strong>动态参数</strong></p>
<p>可以在实例运行中进行修改。更改可通过 SET命令 实现，SET语法如下：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">set</span> 
<span class="token key attr-name">|</span> <span class="token value attr-value">[global | session] system_var_name=expr</span>
<span class="token key attr-name">|</span> <span class="token value attr-value">[@@global. | @@session. | @@] system_var_name=expr</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>静态参数</strong></p>
<p>整个实例生命周期内都不得进行更改。</p>
</li>
</ol>
<h2 id="3-2、日志文件"><a href="#3-2、日志文件" class="headerlink" title="3.2、日志文件"></a>3.2、日志文件</h2><p>常见日志文件有：</p>
<ol>
<li><strong>错误日志</strong></li>
<li><strong>查询日志</strong></li>
<li><strong>慢查询日志</strong></li>
<li><strong>二进制日志</strong></li>
<li><strong>中继日志（MySQL8）</strong></li>
<li><strong>数据定义语句日志（MySQL8）</strong></li>
</ol>
<h3 id="3-2-1、错误日志"><a href="#3-2-1、错误日志" class="headerlink" title="3.2.1、错误日志"></a>3.2.1、错误日志</h3><p>错误日志记录了MySQL服务器在启动、运行、关闭过程中的所有错误信息。</p>
<h3 id="3-2-2、查询日志"><a href="#3-2-2、查询日志" class="headerlink" title="3.2.2、查询日志"></a>3.2.2、查询日志</h3><p>查询日志记录了MySQL服务器收到的所有查询请求，默认文件名为：<code>主机名.log</code>。<strong>开启查询日志会对性能产生影响，因此通常只在调试时开启</strong>。</p>
<h3 id="3-2-3、慢查询日志"><a href="#3-2-3、慢查询日志" class="headerlink" title="3.2.3、慢查询日志"></a>3.2.3、慢查询日志</h3><p>慢查询日志记录了执行时间超过设定阈值的查询请求。这个阈值可以通过参数<code>long_query_time</code>来设置，默认为10秒。</p>
<p>有两点需要注意：</p>
<ol>
<li><strong>阈值设置后，只会记录查询耗时超过该阈值的 SQL，等于的不会被记录</strong>。</li>
<li><strong>MySQL 5.1开始，该参数以 微妙 为单位记录SQL语句运行时间</strong>。</li>
</ol>
<p>相关参数：</p>
<ol>
<li><strong>log_queries_not_using_indexes</strong>：可选值为OFF&#x2F;ON，ON代表当前SQL没有使用索引时也会被记录到慢查询日志，OFF则相反。</li>
<li><strong>log_throttle_queries_not_using_indexes</strong>：MySQL 5.6.5 开始支持，表示每分钟可以记录未使用索引的慢SQL数量，默认值为0。</li>
</ol>
<p><font color='red'>注意：MySQL 5.1 开始可以将慢查询日志放入一个表中，该表在mysql架构下，名为slow_log。</font></p>
<h3 id="3-2-4、二进制日志"><a href="#3-2-4、二进制日志" class="headerlink" title="3.2.4、二进制日志"></a>3.2.4、二进制日志</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><strong>二进制日志记录了MySQL数据库的所有修改操作，但不包括 SELECT、SHOW 该类操作</strong>。若操作本身并没有导致数据库发生变化，那么该操作可能也会写入到二进制日志（比如年龄为25，修改后依然是25，则也会被写入到日志）。</p>
<p>MySQL创建二进制日志文件时，先创建一个以“filename”为名称、以“.index”为后缀的文件，再创建一 个以“filename”为名称、以“.000001”为后缀的文件。</p>
<p>MySQL服务 重新启动一次 ，以“.000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的 个数与MySQL服务启动次数相同；如果日志长度超过了参数<code>max_binlog_size</code>值（默认是1GB），就会创建一个新日志文件。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>二进制日志主要作用：</p>
<ol>
<li><p><strong>恢复</strong></p>
<p>某些数据的恢复需要二进制日志。</p>
</li>
<li><p><strong>复制</strong></p>
<p>其原理和恢复类似，通过复制和执行二进制日志可以使一台远程的MySQL数据库（一般为slave或standby）与一台MySQL数据库（一般为master或primary）进行实时同步。</p>
</li>
<li><p><strong>审计</strong></p>
<p>可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入的攻击行为。</p>
</li>
</ol>
<h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><h5 id="binlog-cache"><a href="#binlog-cache" class="headerlink" title="binlog cache"></a>binlog cache</h5><p><strong>事务执行过程中，先把日志写到<code>binlog cache</code> ，事务提交时再把<code>binlog cache</code>中的数据写入<code>binlog</code>文件</strong>。因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大也要确保一 次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p>
<h5 id="write-fsync"><a href="#write-fsync" class="headerlink" title="write&#x2F;fsync"></a>write&#x2F;fsync</h5><p>write 和 fsync 的执行时间由参数<code>sync_binlog</code>控制，默认0。参数值为0表示每次提交事务仅仅执行write，后面则由系统自行判断何时执行fsync。虽然性能得到了提升，但机器宕机会导致丢失 page cache 中的 binglog。</p>
<p><strong>建议将参数值设置为 1 ，表示每次提交事务都会执行fsync</strong>。 此外还可以设置为N（N&gt;1），表示每次提交事务都执行write，但累积N个事务后才执行fsync。</p>
<p><strong>将<code>sync_binlog</code>设置为一个较大值可提升性能。但如果机器宕机，也会丢失最近N个事务的binlog日志</strong>。</p>
<h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><p>执行更新语句的过程中会记录 redo log 与 bin log 两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以 redo log 与 bin log 写入时机不一样。</p>
<p><strong>redo log 与 binlog 逻辑不一致会出现问题，为解决该问题使用了两阶段提交方案</strong>。</p>
<p>两阶段提交图示如下：</p>
<img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/binlog%E4%B8%8Eredo%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%9B%BE%E7%A4%BA1.png" style="zoom:80%;" />

<p>使用两阶段提交后，写入<code>binlog</code>时发生异常不会损失太大，因为有事务回滚存在。<code>redo log</code>设置<code>commit</code>阶段发生异常时并不会回滚事务，因为虽然<code>redo log</code>是处于<code>prepare</code>阶段，但能通过事务id找到对应的<code>binlog</code>日志，所以MySQL认为是完整的，就会提交事务恢复数据。</p>
<p>具体处理流程参考下图：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/binlog%E4%B8%8Eredo%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E4%B8%ADredo%E6%8F%90%E4%BA%A4%E9%98%B6%E6%AE%B5%E5%87%BA%E9%94%99%E6%97%B6%E4%B8%8D%E4%BC%9A%E5%9B%9E%E6%BB%9A.png"></p>
<h4 id="开启日志"><a href="#开启日志" class="headerlink" title="开启日志"></a>开启日志</h4><p><strong>MySQL 8 之前默认没有启用二进制日志文件，MySQL 8 中默认启用了二进制文件</strong>。</p>
<p><strong>开启二进制日志会降低性能，但可以使用复制、point-in-time恢复功能</strong>。</p>
<h5 id="永久性设置"><a href="#永久性设置" class="headerlink" title="永久性设置"></a>永久性设置</h5><p>若要永久性开启二进制日志功能，可以在 my.cnf 或 my.ini 文件中配置如下参数：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">log-bin</span><span class="token punctuation">=</span><span class="token value attr-value">shh-binlog</span>
<span class="token key attr-name">binlog_expire_logs_seconds</span><span class="token punctuation">=</span><span class="token value attr-value">600</span>
<span class="token key attr-name">max_binlog_size</span><span class="token punctuation">=</span><span class="token value attr-value">100M</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>设置参数 log-bin&#x3D;name 可以启动二进制日志，如果不指定name，则默认为主机名，后缀名为二进制日志序列号，路径一般是数据库所在目录</strong>（datadir）。</p>
<p>binlog.index 为二进制索引文件，用来存储产生的二进制序号，通常不建议手工修改该文件。</p>
<h5 id="二进制日志设置"><a href="#二进制日志设置" class="headerlink" title="二进制日志设置"></a>二进制日志设置</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># global 级别</span>
mysql<span class="token operator">></span> <span class="token builtin class-name">set</span> global <span class="token assign-left variable">sql_log_bin</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
ERROR <span class="token number">1228</span> <span class="token punctuation">(</span>HY000<span class="token punctuation">)</span>: Variable <span class="token string">'sql_log_bin'</span> is a <span class="token environment constant">SESSION</span> variable and can`t be used
with SET GLOBAL

<span class="token comment"># session级别</span>
mysql<span class="token operator">></span> SET <span class="token assign-left variable">sql_log_bin</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
Query OK, <span class="token number">0</span> rows affected <span class="token punctuation">(</span><span class="token number">0.01</span> 秒<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><p>二进制日志常用参数有：</p>
<ol>
<li><p><strong>max_binlog_size</strong></p>
<p>单个二进制日志文件的最大值，超过该值则会生成新的文件，后缀名+1，并记录到<code>.index</code>文件。从MySQL 5.0开始，<em><strong>默认值为1073 741 824，即1G</strong></em>（之前的版本默认1.1G）。</p>
</li>
<li><p><strong>binlog_cache_size</strong></p>
<p>当使用支持事务的表存储引擎时，所有未提交的二进制日志会被记录到一个缓存中，等事务提交时直接将缓冲中的二进制日志写入到二进制文件，该缓冲的大小由参数<code>binlog_cache_size</code>决定，<em><strong>默认大小为 32K（MySQL5.7版本）</strong></em>。</p>
<p>该参数是基于会话的，当开始一个事务时就会自动分配一个大小为该参数指定值的缓存，故设置该值时要小心。当一个事务的记录大于该参数指定的值，会把缓冲中的日志写入到一个临时文件中，因此该值也不能设置的太小。那如何选择呢？可以通过命令<code>SHOW GLOBAL STATUS</code>命令查看 &#96;&#96;binlog_cache_use<code>(使用缓冲写二进制的次数)、</code>binlog_cache_disk_use&#96;（使用临时文件写二进制的次数）的状态，通过其状态来判断设置为多少合适。</p>
</li>
<li><p><strong>sync_binlog</strong></p>
<p>二进制日志并非每次写完缓存就同步到磁盘，那么具体写入缓冲几次后再同步到磁盘由该参数<code>sync_binlog</code>决定，参数值为1表示采用同步写写二进制日志。该参数默认值为0。如果使用InnoDB进行复制，且想得到最大的高可用性，<em><strong>建议将该值设置为0</strong></em>。</p>
</li>
<li><p><strong>binlog-do-db</strong></p>
<p>表示需要写入或忽略写入哪些库的日志，默认为空，表示需要同步所有库的日志到二进制日志。</p>
</li>
<li><p><strong>binlog-ignore-db</strong></p>
<p>表示需要写入或忽略写入哪些库的日志，默认为空，表示需要同步所有库的日志到二进制日志。</p>
</li>
<li><p><strong>log-slave-update</strong></p>
<p>如果当前数据库是复制中的slave角色，则它不会把从master取得的二进制日志写入到自己的二进制日志中去。如果需要写入，则要设置该参数即<code>log-slave-update</code>。如果需要搭建master -&gt; slave -&gt; slave架构的复制，则必须设置该参数。</p>
</li>
<li><p><strong>binlog_format</strong>（动态参数）</p>
<p>它会影响记录二进制日志的格式。MySQL 5.1版本前没有这个参数，所有二进制文件的格式都是基于SQL语句级别的，主服务器运行rand、uuid等函数，又或者使用触发器等操作，其会导致主从服务器上表中数据的不一致。另一个影响是，会发现InnoDB引擎的默认事务隔离级别是REPEATABLE READ。如果使用 READ COMMITTED事务隔离级别，会出现丢失更新的现象，从而导致主从数据库上的数据不一致。</p>
<p>MySQL 5.1 开始引入<code>binlog_format</code>参数，该参数可选值有：</p>
<ol>
<li><p><strong>STATEMENT</strong></p>
<p>该格式和之前的MySQL版本一样，记录的是逻辑SQL语句。</p>
</li>
<li><p><strong>ROW</strong></p>
<p>记录表的行更改情况。基于ROW格式的复制类似于Oracle的Standby，同时解决了STATEMENT格式下复制的问题。MySQL 5.1开始，如果设置了该格式，可以将InnoDB的事务隔离级别设置为 READ COMMITTED，以获得更好的并发性。（查看隔离级别命令：<code>select @@global.transaction_isolation,@@transaction_isolation;</code>）</p>
</li>
<li><p><strong>MIXED</strong></p>
<p>默认采用STATEMENT格式进行二进制日志文件的记录，但在一些情况下会使用ROW格式，这些情况有：</p>
<ol>
<li>表存储引擎为NDB，此时对表的DML操作都会以ROW格式记录。</li>
<li>使用了UUID()、USER()、CURRENT_USER()、FOUND_ROWS()、ROW_COUNT()等不确定函数。</li>
<li>使用了INSERT DELAY语句。</li>
<li>使用了用户自定义函数（UDF）。</li>
<li>使用了临时表（temporary table）。</li>
</ol>
</li>
</ol>
<p>此外，<code>binlog_format</code>参数还存在对存储引擎的限制：</p>
<ul>
<li>STATEMENT格式：除了NDB引擎，其它都支持。</li>
<li>ROW格式：除了Blockhole引擎，其它都支持。</li>
</ul>
</li>
</ol>
<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p>1、查看当前的二进制日志文件列表及大小：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW BINARY LOGS;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>2、将行事件以 伪SQL形式 表现出来：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 会显示binlog格式的语句</span>
mysqlbinlog <span class="token parameter variable">-v</span> <span class="token string">"/var/lib/mysql/binlog/atguigu-bin.000002"</span>
<span class="token comment"># 不会显示binlog格式的语句</span>
mysqlbinlog <span class="token parameter variable">-v</span> --base64-output<span class="token operator">=</span>DECODE-ROWS <span class="token string">"/var/lib/mysql/binlog/atguigu-bin.000002"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>3、其它命令</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 格式：show binlog events [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count];</span>
show binlog events <span class="token keyword">in</span> <span class="token string">'atguigu-bin.000002'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>二进制日志有 3 种格式：ROW（默认）、Statement、Mixed。</p>
<p>查看二进制日志格式命令：<code>show variables like &#39;binlog_format&#39;;</code>。</p>
<h4 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h4><p>mysql binlog 恢复数据的语法如下：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysqlbinlog [option] filename | mysql –uuser -ppass;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>使用mysqlbinlog命令读取filename中的内容，然后使用mysql命令将这些内容恢复到数据库中</strong>。</p>
<p>命令解析：</p>
<ul>
<li>filename：日志文件名。</li>
<li>option：可选项，可选值中有两对重要的参数：<ul>
<li>–start-date 和 –stop-date ：可以指定恢复数据库的起始时间点和结束时间点。</li>
<li>–start-position和–stop-position ：可以指定恢复数据的开始位置和结束位置。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如atguigu-bin.000001必 须在atguigu-bin.000002之前恢复。</p>
</blockquote>
<h4 id="删除日志"><a href="#删除日志" class="headerlink" title="删除日志"></a>删除日志</h4><p><strong>MySQL二进制文件可以通过配置自动删除，也可以手动删除二进制文件</strong>。</p>
<p><strong>PURGE MASTER LOGS 只删除指定部分的二进制日志文件， RESET MASTER 删除所有的二进制日志文件</strong>。</p>
<p>PURGE MASTER LOGS语法如下：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">PURGE &#123;MASTER | BINARY&#125; LOGS TO &#39;指定日志文件名&#39;
PURGE &#123;MASTER | BINARY&#125; LOGS BEFORE &#39;指定日期&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="3-2-5、中继日志"><a href="#3-2-5、中继日志" class="headerlink" title="3.2.5、中继日志"></a>3.2.5、中继日志</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p><strong>MySQL 8 中引入中继日志，用于主从服务架构</strong>。</p>
<p>从服务器使用中继日志存放主服务器二进制日志内容，然后读取中继日志来同步主服务器上的操作。</p>
<p>文件格式是<code>从服务器名-relay-bin.序号</code>。中继日志索引文件格式：<code>从服务器名-relaybin.index</code>，用来定位当前正在使用的中继日志。</p>
<h4 id="查看日志-1"><a href="#查看日志-1" class="headerlink" title="查看日志"></a>查看日志</h4><p>中继日志与二进制日志的格式相同，可以用 mysqlbinlog 工具进行查看。</p>
<h4 id="同步数据"><a href="#同步数据" class="headerlink" title="同步数据"></a>同步数据</h4><p>中继日志记录了从服务器名，从服务器名与新服务器名不同会导致无法从中继日志中读取数据来恢复从服务器数据，故只要保证从服务器名与新服务器名相同即可实现数据恢复。 </p>
<h3 id="3-2-6、数据定义语句日志"><a href="#3-2-6、数据定义语句日志" class="headerlink" title="3.2.6、数据定义语句日志"></a>3.2.6、数据定义语句日志</h3><p><strong>MySQL 8 中引入数据定义语句日志，用来记录数据定义语句执行的元数据操作</strong>。</p>
<h2 id="3-3、套接字"><a href="#3-3、套接字" class="headerlink" title="3.3、套接字"></a>3.3、套接字</h2><p>UNIX系统下本地连接MySQL可采用UNIX域套接字方式，只需要一个套接字文件。套接字文件可由参数socket控制，一般在<code>/tmp</code>目录下，名为 mysql.sock。</p>
<h2 id="3-4、PID文件"><a href="#3-4、PID文件" class="headerlink" title="3.4、PID文件"></a>3.4、PID文件</h2><p>MySQL实例启动时，会将自己的进程ID写入一个文件中——该文件即为PID文件。该文件可由参数pid_file控制，默认存放在数据库目录下，文件名为：主机名.pid。</p>
<h2 id="3-5、表结构定义文件"><a href="#3-5、表结构定义文件" class="headerlink" title="3.5、表结构定义文件"></a>3.5、表结构定义文件</h2><p>因为MySQL插件式存储引擎体系架构的关系，MySQL数据库是根据表进行的，每个表都有对应的文件。无论表采用何种存储引擎，都有一个以frm为后缀名的文件，这个文件记录了该表的表结构定义。</p>
<p>frm还用来存储视图的定义，如果创建一个v_a视图，那么会对应产生一个v_a.frm文件，用来记录视图定义，该文件是文本文件，可直接查看。</p>
<h2 id="3-6、InnoDB存储引擎文件"><a href="#3-6、InnoDB存储引擎文件" class="headerlink" title="3.6、InnoDB存储引擎文件"></a>3.6、InnoDB存储引擎文件</h2><p>每个表存储引擎都有自己独有的文件，这些文件包括【重做日志文件】、【表空间文件】。</p>
<h3 id="3-6-1、表空间文件"><a href="#3-6-1、表空间文件" class="headerlink" title="3.6.1、表空间文件"></a>3.6.1、表空间文件</h3><p><strong>InnoDB将存储的数据按表空间进行存放，默认有一个初始大小为12M，名为 ibdata1的文件，该文件就是默认表空间文件，可通过参数<code>innodb_data_file_path</code>进行配置</strong>。</p>
<p>可配置将多个文件组成一个表空间，同时指定文件属性，命令示例如下：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">innodb_data_file_path</span> <span class="token punctuation">=</span> <span class="token value attr-value">/db/ibdata1:2000M;/dir2/db/ibdata2:2000M:autoextend</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果指定的两个文件位于不同的磁盘上，磁盘的负载可能被平均，进而提高数据库的整体性能。同时，两个文件都有指定大小为2000M，如果用完这2000M，则该文件可以【自动增长（autoextend）】。</p>
<p>参数<code>innodb_data_file_path</code>会导致所有InnoDB表的数据都会记录到该共享表空间中。若设置参数<code>innodb_file_per_table</code>的值为ON，则用户可以基于InnoDB每个表生成一个独立表空间，独立表空间命名规则为：表名.ibd。</p>
<h3 id="3-6-2、重做日志文件"><a href="#3-6-2、重做日志文件" class="headerlink" title="3.6.2、重做日志文件"></a>3.6.2、重做日志文件</h3><h4 id="重做日志简介"><a href="#重做日志简介" class="headerlink" title="重做日志简介"></a>重做日志简介</h4><p><strong>默认情况下，InnoDB引擎数据目录下会有两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件。官方称之为InnoDB引擎日志文件，不过更准确的定义应该是重做日志文件</strong>。重做日志文件对于InnoDB引擎极其重要，它记录了InnoDB的事务日志。</p>
<h4 id="重做日志文件组"><a href="#重做日志文件组" class="headerlink" title="重做日志文件组"></a>重做日志文件组</h4><p><strong>每个InnoDB至少有1个重做日志文件组，每个文件组至少有2个重做日志文件，比如默认的 ib_logfile0 和 ib_logfile1</strong>。为提高可靠性，可以设置多个镜像日志组，将不同的文件组放在不同的磁盘上，以此提高重做日志的高可用性。日志组中的两个文件大小一致，并以循环写入的方式运行，即 先写文件1，写满后会切换到文件2，文件2写满后再切换到文件1。</p>
<h4 id="重做日志相关参数"><a href="#重做日志相关参数" class="headerlink" title="重做日志相关参数"></a>重做日志相关参数</h4><p>下列参数影响着重做日志文件的属性：</p>
<ol>
<li><p><strong>innodb_log_file_size</strong></p>
<p>每个重做日志文件的大小，MySQL 8.0.22下默认48M（MySQL5.7.33相同）。InnoDB 1.2.X之前，文件总大小不得大于等于4G，而1.2.x将其限制扩大为512G。</p>
</li>
<li><p><strong>innodb_log_files_in_group</strong></p>
<p>文件组中文件的数量，默认为2。</p>
</li>
<li><p><strong>innodb_mirrored_log_groups</strong></p>
<p>日志镜像文件组的数量，默认为1。如果磁盘本身已经做了高可用方案，如磁盘阵列，则可不开启该功能。</p>
</li>
<li><p><strong>innodb_log_group_home_dir</strong></p>
<p>文件组所在路径默认为 &#x2F; ，表示MySQL数据库的数据目录。</p>
</li>
</ol>
<p>重做日志文件的大小设置会对InnoDB引擎的性能有很大影响：</p>
<ul>
<li>如果很大，恢复时会需要很长时间；</li>
<li>如果很小，可能导致一个事务的日志需要多次切换重做日志文件；此外会导致频繁发生 async checkpoint，出现性能抖动。</li>
</ul>
<p>重做日志文件还有一个capacity变量，该值代表最后的检查点不能超过这个阈值，如果超过则必须将缓冲池中脏页列表（Flush List）中的部分脏页写回磁盘，此时会导致用户线程的阻塞。</p>
<h4 id="redo-log和bin-log的区别"><a href="#redo-log和bin-log的区别" class="headerlink" title="redo log和bin log的区别"></a>redo log和bin log的区别</h4><ol>
<li><p><strong>记录范围</strong></p>
<p>二进制日志会记录所有与MySQL数据库有关的日志记录，包括InnoDB、MyISAM、Heap等引擎的日志；</p>
<p>重做日志只记录InnoDB引擎本身的事务日志。</p>
</li>
<li><p><strong>记录内容</strong></p>
<p>无论二进制日志记录格式是STATEMENT，ROW，或是MIXED，记录的都是一个事务的具体操作内容，即该日志是逻辑日志。</p>
<p>重做日志记录的是每个页更改的物理情况。</p>
</li>
<li><p><strong>写入时间</strong></p>
<p>二进制日志在事务提交前进行提交，即只写磁盘一次，不论此时该事务有多么大。</p>
<p>事务进行过程中，会不断有重做日志条目被写入到重做日志文件中。</p>
</li>
</ol>
<h4 id="重做日志条目结构"><a href="#重做日志条目结构" class="headerlink" title="重做日志条目结构"></a>重做日志条目结构</h4><p>InnoDB引擎中，不同的操作会有不同的重做日志格式，截止InnoDB 1.2.x版本为止，总共定义了51种重做日志类型。虽然类型多种多样，但有着基本的格式。重做日志条目结构由四部分组成：</p>
<ol>
<li><p><strong>redo_log_type</strong></p>
<p>占用1字节，表示重做日志的类型。</p>
</li>
<li><p><strong>space</strong></p>
<p>表示表空间的ID，但采用压缩方式，因此占用空间可能小于4字节。</p>
</li>
<li><p><strong>page_no</strong></p>
<p>表示页的偏移量，同样采用压缩方式。</p>
</li>
<li><p><strong>redo_log_body</strong></p>
<p>表示每个重做日志的数据部分，恢复时需要调用相应的函数进行解析。</p>
</li>
</ol>
<h4 id="重做日志缓冲写入"><a href="#重做日志缓冲写入" class="headerlink" title="重做日志缓冲写入"></a>重做日志缓冲写入</h4><p><strong>缓冲是以 512 字节大小的块为单位进行写入，512字节是一个扇区的大小。因为扇区是磁盘写入最小单位，写入必定成功，故写入过程不需要 double write</strong>。</p>
<p>Master Thread每秒会将重做日志缓冲写入磁盘的日志文件中，无论事务是否提交。另一个触发写磁盘的过程由参数<code>innodb_flush_log_at_trx_commit</code>控制，表示事务提交时重做日志的刷新方式，该参数可选值有：</p>
<ul>
<li>0：事务提交时，并不将事务的重做日志写入磁盘，而是等待主线程每秒刷新。</li>
<li>1：事务提交时，将重做日志缓冲同步写入磁盘，即伴有fsync调用。</li>
<li>2：事务提交时，重做日志异步写入缓存，即写入文件系统缓存中（非磁盘）。</li>
</ul>
<p>因此为了保证事务ACID中的持久性，<strong>建议将该参数值设置为1</strong>。</p>
<h1 id="4、表"><a href="#4、表" class="headerlink" title="4、表"></a>4、表</h1><h2 id="4-1、索引组织表"><a href="#4-1、索引组织表" class="headerlink" title="4.1、索引组织表"></a>4.1、索引组织表</h2><p><strong>InnoDB引擎中表是根据主键顺序组织存放，该种组织方式的表被称为索引组织表</strong>。InnoDB引擎中的每张表都有主键，如果创建表时没有主动创建主键，则InnoDB会按如下方式创建一个主键：</p>
<ol>
<li>判断表中是否存在非空的唯一索引（Unique NOT NULL），若有，则该列即为主键。</li>
<li>若不符合1中的条件，则自动创建一个6字节row_id列作为主键。</li>
</ol>
<p>若表中有多个非空唯一索引，则会选择第一个非空唯一索引作为主键。主键的选择根据的是定义索引的顺序，而不是建表时列的顺序。</p>
<h2 id="4-2、InnoDB逻辑存储结构"><a href="#4-2、InnoDB逻辑存储结构" class="headerlink" title="4.2、InnoDB逻辑存储结构"></a>4.2、InnoDB逻辑存储结构</h2><p>所有数据逻辑存放在表空间。表空间又由段、区、页组成。InnnoDB逻辑存储结构大致如图所示（page页有时也被称为块block）：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200814123555813.png" alt="image-20200814123555813"></p>
<h3 id="4-2-1、表空间"><a href="#4-2-1、表空间" class="headerlink" title="4.2.1、表空间"></a>4.2.1、表空间</h3><p><strong>表空间存放所有数据，如果开启参数<code>innodb_file_per_table</code>，则每张表的数据将会被单独放到一个表空间内</strong>。</p>
<p><font color='red'>注意：每张表的表空间中存放的只是数据、索引和插入缓冲Bitmap页，其它的数据（undo信息、插入缓冲索引页、系统事务信息、二次写缓冲等）还是会存放到原来的共享表空间中。</font></p>
<p>自动提交关闭环境下，执行update操作但不执行commit&#x2F;rollback，会产生大量undo操作语句，从而导致共享表空间增大。执行rollback后，其共享表空间容量也不会缩减到原来的大小。但是会自动判断这些undo信息是否还需要，如果不需要，则会将其标记为可用空间，供下次undo使用。</p>
<h3 id="4-2-2、段"><a href="#4-2-2、段" class="headerlink" title="4.2.2、段"></a>4.2.2、段</h3><p><strong>表空间由段组成，常见的段有：数据段、索引段、回滚段等</strong>。因为InnoDB引擎表是索引组织的，因此数据即索引，索引即数据。那么数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。</p>
<h3 id="4-2-3、区"><a href="#4-2-3、区" class="headerlink" title="4.2.3、区"></a>4.2.3、区</h3><p><strong>区由连续页组成，每个区大小固定为1M</strong>。为保证区中页的连续性，<strong>InnoDB引擎一次从磁盘申请4~5个区。默认情况下，InnoDB引擎页的大小为16K，即一个区共有64个页</strong>。</p>
<p>InnoDB 1.0.x 引入压缩页，<strong>每个页大小可通过参数 <code>KEY_BLOCK_SIZE</code>设置为2k、4k、8k，因此每个区的页数量就会是512、256、128</strong>。</p>
<p>InnoDB 1.2.x 开始通过<strong>参数<code>innodb_page_size</code>可以将页默认大小设置为4k、8k，但页中的数据不会被压缩。此时页的数量同样为256、128，总之页大小不管怎么变，区大小总是为1M</strong>。</p>
<p>每个段开始时，会先用32个页大小的碎片页来存放数据，用完之后再申请64个页。这样做的目的对于一些小表来说，或者undo这种段，可以在申请时申请较少的空间，节省磁盘开销。</p>
<h3 id="4-2-4、页"><a href="#4-2-4、页" class="headerlink" title="4.2.4、页"></a>4.2.4、页</h3><p>页是InnoDB进行磁盘管理的最小单位<strong>InnoDB引擎中每个页默认大小为16K，从InnoDB 1.2.x开始，可通过参数<code>innodb_page_size</code>来设置页的大小为4k、8k、16k</strong>。若设置完成，所有表中页的大小就是该值，不可再次对其进行更改，除非通过 mysqldump导入和导出操作来生成新库。</p>
<p>InnoDB引擎中，常见的页类型有：</p>
<ol>
<li>数据页</li>
<li>undo页</li>
<li>系统页</li>
<li>事务数据页</li>
<li>插入缓冲位图页</li>
<li>插入缓冲空闲列表页</li>
<li>未压缩的二进制大对象页</li>
<li>压缩的二进制大对象页</li>
</ol>
<h3 id="4-2-5、行"><a href="#4-2-5、行" class="headerlink" title="4.2.5、行"></a>4.2.5、行</h3><p>InnoDB引擎是面向列的。每个页存放的行记录最多为(16K &#x2F; 2-200)行记录，即7992行记录。</p>
<p>MySQL infobright存储引擎会按照列来存储数据，这对于数据仓库下的分析类SQL语句的执行及数据压缩非常有帮助。类似的数据库还有Sybase IQ、Google Big Table。面向列的数据库是数据库发展的一个方向。</p>
<h2 id="4-3、InnoDB行记录格式"><a href="#4-3、InnoDB行记录格式" class="headerlink" title="4.3、InnoDB行记录格式"></a>4.3、InnoDB行记录格式</h2><p>InnoDB引擎下，记录是以行的形式存储，这意味着页中保存着一行行的数据。InnoDB  1.0.x前，InnoDB提供 Compact 和 Redundant（为兼容之前版本而保留） 两种格式来存放行记录数据。MySQL 5.1版本中，默认设为Compact行格式。用户可以通过命令 <code>show table status like &#39;table_name&#39;</code>来查看当前表使用的行格式。</p>
<h3 id="4-3-1、Compact行记录格式"><a href="#4-3-1、Compact行记录格式" class="headerlink" title="4.3.1、Compact行记录格式"></a>4.3.1、Compact行记录格式</h3><p>该行记录格式在MySQL5.0中引入，目标是高效存储数据，简单说，<em><strong>一个页中存放的行数据越多，其性能就越高</strong></em>。</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20201212184714449.png" alt="image-20201212184714449"></p>
<ol>
<li><p><strong>变长字段长度列表</strong></p>
<p>其是一个非NULL变长字段长度列表，且按照列的顺序逆序存放，其长度为：</p>
<ol>
<li>若列的长度小于255字节，yong1字节表示。</li>
<li>若大于255个字节，用2个字节表示。</li>
</ol>
</li>
<li><p><strong>NULL标志位</strong></p>
</li>
</ol>
<p>   表示该行数据中是否有NULL值，有则用1表示，占1字节。</p>
<ol start="3">
<li><strong>记录头信息</strong></li>
</ol>
<p>   固定占用5字节（40位），每位含义见表：</p>
<p>   <img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20201212185453950.png" alt="image-20201212185453950"></p>
<ol start="4">
<li><strong>列数据</strong></li>
</ol>
<p>   需要注意，NULL除了占有NULL标志位外，不占该部分空间。每行除了用户定义的列外，还有两个列，事务ID列（6字节） 和 回滚指针列（7字节），若InnoDB表没有定义主键，每行还会增加一个6字节的rowid列。</p>
<h3 id="4-3-2、Redundant行记录格式"><a href="#4-3-2、Redundant行记录格式" class="headerlink" title="4.3.2、Redundant行记录格式"></a>4.3.2、Redundant行记录格式</h3><p>该记录格式是MySQL5.0之前InnoDB引擎的行记录存储方式，5.0支持该格式是为了兼容之前版本的页格式。该记录采用如下图所示的方式存储：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20201212190244966.png" alt="image-20201212190244966"></p>
<ol>
<li><p><strong>字段长度偏移列表</strong>：与 Compact 一样。</p>
</li>
<li><p><strong>记录头信息</strong>：占6字节（48位），每位含义见表：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20201212190633971.png" alt="image-20201212190633971"></p>
</li>
<li><p><strong>列数据</strong>：实际存储的列数据。</p>
</li>
</ol>
<h3 id="4-3-3、行溢出数据"><a href="#4-3-3、行溢出数据" class="headerlink" title="4.3.3、行溢出数据"></a>4.3.3、行溢出数据</h3><p>InnoDB引擎可以将一条记录中的某些数据存储在数据页面之外。一般认为BLOB、LOB这类大对象类型数据会存储在数据页面之外，但也可以不存储在外面。且即便是VARCHAR列数据类型，也有可能存储在页面之外。</p>
<p>普遍认为，MySQL的VARCHAR类型可以存储65535字节，但实际上创建VARCHAR长度为65535的表时，会报错。因为还有别的开销，实际测试VARCHAR类型可以创建的最大长度为65532。</p>
<blockquote>
<p>这里要注意，如果没有将SQL_MODE设为严格模式，或许创建VARCHAR长度为65535的表时会成功，但会抛出一个warning，这个warning提示了这次可以创建成功是因为自动将VARCHAR类型转换成了TEXT类型。</p>
</blockquote>
<p>成功创建VARCHAR长度为65535的表时的字符类型是latin1，如果换成 GBK 或 UTF-8，则在创建时会再次报错。由此可以得出：VARCHAR(N)中的N指的是字符长度，而官方指定的65535说的是字节。</p>
<p><font color='red'>注意：官方定义的65535长度是指VARCHAR列的长度总和，如果列的长度总和超过这个长度，依然无法创建。</font></p>
<p>一般情况下，InnoDB引擎的数据存放在B树节点中。但当发生行溢出时，数据会存放至Uncompress BLOB类型页中。</p>
<h3 id="4-3-4、Compressed和Dynamic行记录格式"><a href="#4-3-4、Compressed和Dynamic行记录格式" class="headerlink" title="4.3.4、Compressed和Dynamic行记录格式"></a>4.3.4、Compressed和Dynamic行记录格式</h3><p><strong>InnoDB 1.0.x开始引入新的文件格式 Barracuda，该格式下有两种新的行记录格式：Compressed 和 Dynamic 行记录格式。以前支持的 Compact 和 Redundant 格式称之为 Antelope 文件格式</strong>。</p>
<p>两种新的行记录格式对于存放在BLOB中的数据采用了完全行溢出的方式。Compressed行记录格式的另一个功能是，存储在其中的行数据会以 zlib 算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度类型的数据能进行有效存储。</p>
<h3 id="4-3-5、CHAR行结构存储"><a href="#4-3-5、CHAR行结构存储" class="headerlink" title="4.3.5、CHAR行结构存储"></a>4.3.5、CHAR行结构存储</h3><p>MySQL 4.1开始，CHAR(N)中的N指 字符长度，而不是字节长度。在不同字符集下，CHAR类型列内部存储的可能不是定长数据。</p>
<h2 id="4-4、InnoDB数据页结构"><a href="#4-4、InnoDB数据页结构" class="headerlink" title="4.4、InnoDB数据页结构"></a>4.4、InnoDB数据页结构</h2><p>InnoDB数据页由7个部分组成：</p>
<ol>
<li><p><font color='orange'>File Header</font></p>
<p>固定38字节。记录页的头信息。</p>
</li>
<li><p><font color='orange'>Page Header</font></p>
<p>固定56字节。记录数据页的状态信息，由14个部分组成。</p>
</li>
<li><p><font color='orange'>Infimun 和 Supremum Records</font></p>
<p>InnoDB引擎中，每个数据页有两个虚拟的行记录，用来限定记录的边界。Infimum记录是比该页中任何主键值都要小的值，Supremum记录的是比任何大的值都要大的值。这两个值在页创建时被建立，且不会被删除。在Compact行格式和Redundant行记录格式下，两者占用的字节数各不相同。</p>
</li>
<li><p><font color='orange'>User Records</font></p>
<p>动态大小，实际存储行记录的内容。</p>
</li>
<li><p><font color='orange'>Free Space</font></p>
<p>动态大小，指的是空闲空间，是个链表数据结构。在一条记录被删除后，该空间会被加入到空闲链表中。</p>
</li>
<li><p><font color='orange'>Page Directory</font></p>
<p>动态大小，存放了记录的相对位置（页相对位置，而不是偏移量），有时候这些记录指针被称为Slots（槽）或目录槽。InnoDB的槽中可能包含多个记录。伪记录Infimum的n_owned值总是1，记录Supremum的n_owned的取值范围为[1, 8]，其它用户记录n_owned的取值范围为[4, 8]。当记录被插入或删除时需要对槽进行分裂或平衡操作。</p>
<p>Slots中记录按照索引键值顺序存放，这样可以利用二叉查找迅速找到记录的指针。</p>
<p>要牢记，B+树索引本身并不能找到具体的一条记录，能找到的只是该记录所在的页。数据库把页载入到内存，然后通过Page Directory在进行二叉查找。</p>
</li>
<li><p><font color='orange'>File Trailer</font></p>
<p>固定8字节。该部分是为了检测页是否完整地写入磁盘。File Trailer只有一个FIL_PAGE_END_LSN部分，占用8字节，前4字节代表该页的checksum值，后4字节和File Header中的FIL_PAGE_LSN一样。将这两个值与File Header中的FIL_PAGE_SPACE_OR_CHKSUM 和 FIL_PAGE_LSN值进行比较，看是否一致，以此确保页的完整性。</p>
<p>默认InnoDB引擎每次从磁盘读取一个页就会检查其完整性，检查有一定的开销，可通过参数<code>innodb_checksums</code>来开启或关闭这个检查功能。</p>
<p>MySQL 5.6.6开始新增参数 <code>innodb_checksum_algorithm</code>，该参数用来控制检测checksum函数的算法，默认crc32，可选值有：innodb、crc32、none、strict_innodb、strict_crc32、strict_none。</p>
</li>
</ol>
<p><font color='orange'>7个部分的大小总和就是Page Size的值，3和4合称为行记录。</font></p>
<h2 id="4-5、Named-File-Formats机制"><a href="#4-5、Named-File-Formats机制" class="headerlink" title="4.5、Named File Formats机制"></a>4.5、Named File Formats机制</h2><p><strong>从InnoDB 1.0.x开始，InnoDB通过Named File Formats机制来解决不同版本页结构兼容性问题</strong>。</p>
<p>未来版本的InnoDB引擎还将引入新文件格式，此文件格式的名称取自动物名字。</p>
<p>参数<code>innodb_file_format</code>用来指定文件格式。参数<code>innodb_file_format_check</code>表示是否开启检测当前InnoDB引擎文件格式的支持度，默认为ON。</p>
<h2 id="4-6、约束"><a href="#4-6、约束" class="headerlink" title="4.6、约束"></a>4.6、约束</h2><h3 id="4-6-1、数据完整性"><a href="#4-6-1、数据完整性" class="headerlink" title="4.6.1、数据完整性"></a>4.6.1、数据完整性</h3><p>域完整性可以通过以下方式来保证：</p>
<ol>
<li><strong>选择合适的数据类型确保一个数据值满足特定条件</strong>。</li>
<li><strong>外键约束</strong>。</li>
<li><strong>编写触发器</strong>。</li>
<li><strong>还可考虑使用DEFAULT约束作为强制域完整性的一个方面</strong>。</li>
</ol>
<p>InnoDB引擎提供了以下几种约束：</p>
<ol>
<li>Primary Key（主键约束）</li>
<li>Unique Key（唯一性约束）</li>
<li>Foreign Key（外键约束）</li>
<li>Default（默认约束）</li>
<li>Not Null（非空约束）</li>
</ol>
<h3 id="4-6-2、约束创建"><a href="#4-6-2、约束创建" class="headerlink" title="4.6.2、约束创建"></a>4.6.2、约束创建</h3><p>约束创建有两种方式：</p>
<ol>
<li>表建立时就进行约束定义。</li>
<li>利用ALTER TABLE命令创建约束。</li>
</ol>
<h3 id="4-6-3、约束和索引的区别"><a href="#4-6-3、约束和索引的区别" class="headerlink" title="4.6.3、约束和索引的区别"></a>4.6.3、约束和索引的区别</h3><p>约束和索引的概念不同，约束是一个逻辑概念，用来保证数据完整性，而索引是一个数据结构，既有逻辑概念，也代表着物理存储的方式。</p>
<h3 id="4-6-4、错误数据约束"><a href="#4-6-4、错误数据约束" class="headerlink" title="4.6.4、错误数据约束"></a>4.6.4、错误数据约束</h3><p>可通过参数<code>sql_mode</code>来严格审核输入的参数，该参数的可选值有很多，具体参考官方文档。</p>
<h3 id="4-6-5、ENUM-和-SET约束"><a href="#4-6-5、ENUM-和-SET约束" class="headerlink" title="4.6.5、ENUM 和 SET约束"></a>4.6.5、ENUM 和 SET约束</h3><p>MySQL不支持传统的CHECK约束，但通过ENUM和SET可以解决部分这样的需求。有时还需要配合参数 <code>sql_mode</code>。</p>
<h3 id="4-6-6、触发器约束"><a href="#4-6-6、触发器约束" class="headerlink" title="4.6.6、触发器约束"></a>4.6.6、触发器约束</h3><p>最多可以为一个表创建6个触发器，即INSERT、UPDATE、DELETE的BEFORE和AFTER各定义一个。</p>
<h3 id="4-6-7、外键约束"><a href="#4-6-7、外键约束" class="headerlink" title="4.6.7、外键约束"></a>4.6.7、外键约束</h3><p>外键用来保证参照完整性。MyISAM引擎不支持外键，而InnoDB引擎完全支持。</p>
<p><font color='orange'>一般来说，被引用表称为父表，引用表称为子表。外键定义时的 ON DELETE 和 ON UPDATE 表示在对父表执行 DELETE 和 UPDATE 操作时，子表应被如何对待，可选操作有：</font></p>
<ol>
<li><p><strong>CASCADE</strong></p>
<p>父表被怎么操作，子表就被怎么操作。</p>
</li>
<li><p><strong>SET NULL</strong></p>
<p>父表被操作时，子表中相对应的数据被更新为NULL值（列必须允许NULL值）。</p>
</li>
<li><p><strong>NO ACTION</strong></p>
<p>父表被操作时，抛出错误，不允许这类操作发生。</p>
</li>
<li><p><strong>RESTRICT</strong></p>
<p>父表被操作时，抛出错误，不允许这类操作发生。</p>
</li>
</ol>
<p><font color='red'>注意：如果定义外键时没有指定ON DELETE 或 ON UPDATE，那么默认是RESTRICT。</font></p>
<h2 id="4-7、视图"><a href="#4-7、视图" class="headerlink" title="4.7、视图"></a>4.7、视图</h2><p><strong>MySQL 5.0开始支持视图。视图是一个虚表，它由一个SQL查询来定义，可做表使用，且视图中的数据没有实际的物理存储</strong>。</p>
<h3 id="4-7-1、视图作用"><a href="#4-7-1、视图作用" class="headerlink" title="4.7.1、视图作用"></a>4.7.1、视图作用</h3><p><strong>视图充当了一个安全层</strong>。</p>
<p>要查询视图的一些元数据，可以访问<code>information_schema</code>架构下的VIEWS表，该表有视图的详细信息。查看命令如下：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> infomation_schema<span class="token punctuation">.</span>VIEWS 
<span class="token keyword">where</span> table_schema <span class="token operator">=</span> <span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span> \G<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="4-7-2、物化视图"><a href="#4-7-2、物化视图" class="headerlink" title="4.7.2、物化视图"></a>4.7.2、物化视图</h3><p>物化视图 指：将视图多对应的数据插入到一张实表中。物化视图可以提高一些复杂统计类查询的性能。</p>
<p>物化视图刷新 指：当基表发生DML操作后，物化视图会在某一时刻以某种方式进行同步。同步的方式有两种：</p>
<ol>
<li><p><strong>ON DEMAND</strong>：用户需要时进行刷新。</p>
</li>
<li><p><strong>ON COMMIT</strong>：基表的DML操作提交的同时进行刷新。</p>
</li>
</ol>
<p>刷新方法有四种：</p>
<ol>
<li><p><strong>FAST</strong>：只刷新自上次刷新后执行的修改。</p>
</li>
<li><p><strong>COMPLETE</strong>：对整个物化视图进行完全刷新。</p>
</li>
<li><p><strong>FORCE</strong>：刷新时判断是否可以快速刷新，如果可以，采用FAST方式，否则采用COMPLETE的方式。</p>
</li>
<li><p><strong>NEVER</strong>：不进行任何刷新。</p>
</li>
</ol>
<p><font color='red'>注意：MySQL本身不支持物化视图，但可以通过【定时把数据导入到一张表】来实现。</font></p>
<h2 id="4-8、分区表"><a href="#4-8、分区表" class="headerlink" title="4.8、分区表"></a>4.8、分区表</h2><h3 id="4-8-1、简介"><a href="#4-8-1、简介" class="headerlink" title="4.8.1、简介"></a>4.8.1、简介</h3><p><strong>MySQL 5.1 开始支持分区，分区指：将一个表或索引分解为多个更小、更可管理的部分</strong>。</p>
<p>局部分区索引指：一个分区中既存放数据又存放索引。全局分区指：数据存放在各个分区中，数据的索引放在一个对象中。</p>
<p><font color='red'>注意：MySQL仅支持水平分区，并不支持垂直分区。MySQL仅支持局部分区，还不支持全局分区。</font></p>
<p>当前数据库是否开启了分区功能，可通过如下命令查看</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'%partition%'</span> \G<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>当前MySQL支持的分区类型有：</p>
<ol>
<li><strong>RANGE分区</strong></li>
<li><strong>LIST分区</strong></li>
<li><strong>HASH分区</strong></li>
<li><strong>KEY分区</strong></li>
</ol>
<p><font color='red'>注意：不论创建哪一种分区，如果表中存在主键或唯一索引，分区列必须是唯一索引的组成部分。</font></p>
<h3 id="4-8-2、子分区"><a href="#4-8-2、子分区" class="headerlink" title="4.8.2、子分区"></a>4.8.2、子分区</h3><p><strong>子分区是在分区的基础上再进行分区，子分区也被称为复合分区。MySQL允许在RANGE 和 LIST 分区上再进行 HASH 和 KEY 的子分区</strong>。</p>
<p>子分区建立注意事项如下：</p>
<ol>
<li>每个子分区的数量必须相同。</li>
<li>要在一个分区表的任何分区上使用SUBPARTITION 来明确定义任何子分区，就必须定义所有的子分区。</li>
<li>每个 SUBPARTITION 子句必须包括子分区的一个名字。</li>
<li>子分区的名字必须唯一。</li>
</ol>
<h3 id="4-8-3、分区中的NULL值"><a href="#4-8-3、分区中的NULL值" class="headerlink" title="4.8.3、分区中的NULL值"></a>4.8.3、分区中的NULL值</h3><p><strong>MySQL允许对NULL值做分区，且总是认为NULL值小于任何一个非NULL值，这和处理NULL值的ORDER BY操作一样。不同的分区类型对于NULL值的处理也不相同</strong>。</p>
<p><strong>对于NULL值，RANGE分区会放在分区最左边，LIST分区就必须显式指出哪个区中放入NULL值，否则会报错。HASH 和 KEY 对于NULL值的记录会返回0</strong>。</p>
<h3 id="4-8-4、分区和性能"><a href="#4-8-4、分区和性能" class="headerlink" title="4.8.4、分区和性能"></a>4.8.4、分区和性能</h3><p>数据库的应用分为两类：</p>
<ol>
<li><p><strong>OLTP（在线事务处理）</strong></p>
<p>不适合分区，因为该类应用通常获取的数据一般在表数据的10%左右。</p>
</li>
<li><p><strong>OLAP（在线分析处理）</strong></p>
<p>对于该类应用，分区可以提高查询的性能，因为该应用大多数需要扫描一张大表。</p>
</li>
</ol>
<h3 id="4-8-5、在表和分区间交换数据"><a href="#4-8-5、在表和分区间交换数据" class="headerlink" title="4.8.5、在表和分区间交换数据"></a>4.8.5、在表和分区间交换数据</h3><p>MySQL 5.6开始支持 ALTER TABLE … EXCHANGE PARTITION 语法，该语句允许分区或子分区中的数据与另一个非分区的表中的数据进行交换。</p>
<p>要使用这个语句，需满足下列条件：</p>
<ol>
<li>要交换的表需要和分区表有着相同的表结构，但表不能含有分区。</li>
<li>在非分区表中的数据必须在交换的分区定义内。</li>
<li>被交换的表中不能还有外键，或者其它表含有对该表的外键引用。</li>
<li>用户除了需要 ALTER、INSERT 和 CREATE权限外，还需要 DROP 的权限。此外，有两个小细节要注意：<ol>
<li>使用该语句时，不会触发交换表和被交换表上的触发器。</li>
<li>AUTO_INCREMENT列将被重置。</li>
</ol>
</li>
</ol>
<h1 id="5、索引"><a href="#5、索引" class="headerlink" title="5、索引"></a>5、索引</h1><h2 id="5-1、索引简介"><a href="#5-1、索引简介" class="headerlink" title="5.1、索引简介"></a>5.1、索引简介</h2><h3 id="5-1-1、索引分类"><a href="#5-1-1、索引分类" class="headerlink" title="5.1.1、索引分类"></a>5.1.1、索引分类</h3><ul>
<li>基于功能划分，可分为 4 种：普通、唯一、主键、全文。</li>
<li>基于物理划分，可分为 2 种：聚簇索引、非聚簇索引（二级索引 &#x2F; 辅助索引）。</li>
<li>基于字段数量划分，可分为 2 种：单列索引、多列（联合）索引</li>
</ul>
<blockquote>
<p>所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。其它个别存储引擎支持更多的索引数量和更大的索引长度。</p>
</blockquote>
<h3 id="5-1-2、索引优缺点"><a href="#5-1-2、索引优缺点" class="headerlink" title="5.1.2、索引优缺点"></a>5.1.2、索引优缺点</h3><p>选择使用索引时，需要综合考虑索引的优缺点。</p>
<ul>
<li>优点<ul>
<li>降低数据库IO成本。</li>
<li>保证每行数据唯一性。</li>
<li>加速表之间的连接。</li>
<li>减少查询过程中的分组和排序时间。</li>
</ul>
</li>
<li>缺点<ul>
<li>创建和维护耗费时间。</li>
<li>索引存储需要占用较大磁盘空间。若有大量索引，则索引文件可能比数据文件更快到达最大文件尺寸。</li>
<li>降低了表的更新速度。</li>
</ul>
</li>
</ul>
<blockquote>
<p>索引可以提高查询速度，但同时也会降低插入速度。为应对此问题，提出一条合理性建议：先删除索引，再插入数据，然后再建立索引。</p>
</blockquote>
<h2 id="5-2、索引实现"><a href="#5-2、索引实现" class="headerlink" title="5.2、索引实现"></a>5.2、索引实现</h2><p>InnoDB引擎支持的索引如下：</p>
<ol>
<li>聚簇索引与非聚簇索引。</li>
<li>全文索引。</li>
<li>自适应哈希索引（不能人为干预创建）。</li>
</ol>
<p>MyISAM引擎支持的索引如下：</p>
<ul>
<li>非聚簇索引</li>
<li>普通索引</li>
</ul>
<h2 id="5-3、B-树索引"><a href="#5-3、B-树索引" class="headerlink" title="5.3、B+树索引"></a>5.3、B+树索引</h2><h3 id="5-3-1、B-树结构"><a href="#5-3-1、B-树结构" class="headerlink" title="5.3.1、B+树结构"></a>5.3.1、B+树结构</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>B+树由B树和索引顺序访问方法演化而来。</p>
<p>B+树中的B代表平衡（balance），B+树是从平衡二叉树演化而来，但B+树不是一个二叉树。</p>
<h4 id="B-树插入"><a href="#B-树插入" class="headerlink" title="B+树插入"></a>B+树插入</h4><p>B+树的插入必须保证插入后叶子节点中的记录依然有序，同时需要考虑插入到B+树的三种情况：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20201213123240100.png" alt="image-20201213123240100"></p>
<h4 id="B-树删除"><a href="#B-树删除" class="headerlink" title="B+树删除"></a>B+树删除</h4><p>B+树使用填充因子来控制树的删除变化，50%是填充因子可设置的最小值。B+树删除操作必须保证删除后叶子节点中的记录依然有序，与插入一样，删除同样需要考虑三种情况：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20201213123536278.png" alt="image-20201213123536278"></p>
<p>B+树有一个特点是高扇出性，因此B+树的高度一般在2<del>4层，也就是说需要2</del>4次IO。机械硬盘每秒至少100次IO，2<del>4次IO意味着查询时间只需0.02</del>0.04秒。</p>
<p>InnoDB引擎将B+树分为聚集索引和辅助索引。两者的区别是，叶子节点存放的是否是一整行的数据。</p>
<blockquote>
<p>B+树中的B不是二叉 ，而是代表平衡（balance），因为B+树是从最早的平衡二叉树演化而来，但B+树不是一个二叉树。</p>
<p>B+树索引不能找到一个给定键值的具体数据，B+树索引能找到的只是被查找数据所在的页，然后数据库需要把页读到内存中进行再次查找，最后找到需要的数据。</p>
</blockquote>
<h3 id="5-3-2、B-树索引分裂"><a href="#5-3-2、B-树索引分裂" class="headerlink" title="5.3.2、B+树索引分裂"></a>5.3.2、B+树索引分裂</h3><p>B+树索引页的分裂并不会经常性从页的中间记录开始，这样可能会导致页空间的浪费。</p>
<p>InnoDB引擎的<code>Page header</code>由以下几部分用来保存插入顺序信息：</p>
<ol>
<li><strong>PAGE_LAST_INSERT</strong></li>
<li><strong>PAGE_DIRECTION</strong></li>
<li><strong>PAGE_N_DIRECTION</strong></li>
</ol>
<p>通过这些信息可以判断是向左分裂还是向右分裂，同时决定将分裂点记录为哪一个。</p>
<ul>
<li>若插入是随机的，则取中间记录为分裂点记录。</li>
<li>若向同一方向插入的记录数量为5，且目前已经定位到的记录之后还有3条记录，则分裂点记录是定位的记录后的第三条记录。否则分裂点的记录就是待插入的记录的第一条记录。</li>
</ul>
<h3 id="5-3-3、B-树索引分类"><a href="#5-3-3、B-树索引分类" class="headerlink" title="5.3.3、B+树索引分类"></a>5.3.3、B+树索引分类</h3><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引 是根据表中主键 构造的B+树，叶子节点中存放的就是表数据，也将聚簇索引的叶子节点称为数据页，每个数据页通过一个双向链表来进行链接。由于实际的数据页只能按照一颗B+树来进行排序，因此一张表只能拥有一个聚簇索引。</p>
<p>聚簇索引不仅包含索引的键值，还包含所有表数据。聚集索引中的记录根据键值顺序存放，这个顺序指逻辑顺序。</p>
<h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>辅助索引 又称为 二级索引 或 非聚簇索引。其结构也为B+树。辅助索引的叶子节点并不保存表的全部数据，叶子节点除了包含键值外，每个叶子节点的索引行中还包含了一个书签，这个书签就是相应行数据的聚集索引键。</p>
<p><font color='orange'>辅助索引叶子节点保存的是&lt;键值, (记录)地址&gt;。</font>记录地址可以存在两种形式：</p>
<ol>
<li>记录的物理地址，页号：槽号：偏移量。（MyISAM引擎B+树存储方式）</li>
<li>记录的主键值。（InnoDB引擎下的存储方式）InnoDB引擎是索引组织表，所有记录都放在聚集索引中，辅助索引中记录地址存放的是主键的键值。</li>
</ol>
<p><strong>InnoDB引擎下，辅助索引叶子节点存放的是主键，因此查找完整记录需要通过 聚簇索引 再次查询，一般称这种查询方式为 书签查找回表</strong>。</p>
<p><strong>辅助索引的非叶子节点存放的记录格式为&lt;键值，主键值，地址&gt;。辅助索引节点的记录不保存隐藏列<code>trx_id</code>和<code>roll_ptr</code>，这是辅助索引和聚集索引不相同的另一方面</strong>。</p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>可以为多个列建立索引，比方说我们想让B+树按照 c2和c3列 的大小进行排序，这个包含两层含义：</p>
<ul>
<li>先把各个记录和页按照c2列进行排序。 </li>
<li>在记录的c2列相同的情况下，采用c3列进行排序。</li>
</ul>
<p><strong>以 c2 和 c3 列的大小为排序规则建立的 B+ 树称为 联合索引，本质上也是一个二级索引</strong>。</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><h5 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h5><p><strong>仅通过二级索引且无需回表就可拿到需要查询的数据，这种索引称为覆盖索引</strong>。</p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li>优点<ul>
<li>避免了索引的二次查询。</li>
<li>可以把随机IO变成顺序IO。</li>
</ul>
</li>
<li>缺点<ul>
<li>索引字段维护需要代价，故在建立冗余字段提升效率时需要权衡考虑。</li>
</ul>
</li>
</ul>
<h3 id="5-3-4、B-树索引管理"><a href="#5-3-4、B-树索引管理" class="headerlink" title="5.3.4、B+树索引管理"></a>5.3.4、B+树索引管理</h3><h4 id="索引创建与删除"><a href="#索引创建与删除" class="headerlink" title="索引创建与删除"></a>索引创建与删除</h4><p><strong>索引的创建和删除有两种方式：一种是 ALTER TABLE，另一种是 CREATE &#x2F; DROP INDEX</strong>。</p>
<p><code>SHOW INDEX</code>命令返回的结果中有一个<code>Cardinality</code>值非常关键，优化器会根据这个值来判断是否使用这个索引。但这个值的更新不是实时的，因为实时更新代价会很大。如果需要更新该值，可以使用 <code>ANALYZE TABLE TABLE_NAME</code> 命令来实现。</p>
<h3 id="5-3-5、B-树索引使用"><a href="#5-3-5、B-树索引使用" class="headerlink" title="5.3.5、B+树索引使用"></a>5.3.5、B+树索引使用</h3><h4 id="联合索引-1"><a href="#联合索引-1" class="headerlink" title="联合索引"></a>联合索引</h4><h5 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h5><p><strong>联合索引指的是为表上多个列建立索引</strong>。联合索引的创建方法与单个索引的创建方法一样，不同的是有多个索引列。</p>
<p>例如，创建一张表 t，并且idx_a_b是联合索引，联合的列为（a, b）：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> t<span class="token punctuation">(</span>
  a <span class="token keyword">int</span><span class="token punctuation">,</span>
  b <span class="token keyword">int</span><span class="token punctuation">,</span>
  <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">key</span> idx_a_b <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">innodb</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>联合索引也是一颗B+树，不同的是联合索引的键值数量不是 1，而是大于等于 2</strong>。</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210102183237223.png" alt="image-20210102183237223"></p>
<p>上图是多个键值的B+树，其实和单个键值的B+树没有什么不同，键值都是有序的，通过叶子节点可以逻辑上顺序的读到所有数据，就如图说，即 (1, 1)、(1, 2)、(2, 1)、(2, 4)、(3, 1)、(3, 2)。数据按 (a, b) 的顺序进行存放。</p>
<p>因此，对于select * from t where a&#x3D;xxx and  b&#x3D;xxx，是可以使用联合索引 (a, b) 的，对于单个 a 列的查询也是可以使用这个联合索引的，但对于单个 b 列的查询，却不能使用这个索引。我们可以发现叶子节点上的 b 值为1、2、1、4、1、2，显然不是有序的，因此对于单个 b 列的查询是使用不到这个联合索引的。</p>
<p><strong>联合索引的第二好处是已经对第二个键值进行了排序处理，这样就避免了某种情况下的排序要求</strong>。</p>
<p>对于联合索引 (a, b)，下列 SQL 可以使用到这个索引：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> a <span class="token operator">=</span> xxx <span class="token keyword">order</span> <span class="token keyword">by</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>对于联合索引 (a, b, c)，下列 SQL 可以使用到这个索引：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> a <span class="token operator">=</span> xxx <span class="token keyword">order</span> <span class="token keyword">by</span> b<span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> a <span class="token operator">=</span> xxx <span class="token operator">and</span> b <span class="token operator">=</span> xxx <span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>但对于下列 SQL，通过联合索引不能直接得到结果，还需要执行一次额外的排序操作：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> a <span class="token operator">=</span> xxx <span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li><font color='orange'>对于两个列的查询可以使用联合索引，单个列的查询也可以使用联合索引。</font></li>
<li><font color='orange'>已经对第二个键值进行了排序处理。</font></li>
</ol>
<h4 id="覆盖索引-1"><a href="#覆盖索引-1" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p><strong>InnoDB引擎支持覆盖索引（covering index），即从辅助索引中就可以得到查询结果，而不需要回表查询。辅助索引不包含整行全部记录，故大小要小于聚集索引，可以减少大量IO操作</strong>。</p>
<p>创建一个测试表 buy_log：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> buy_log<span class="token punctuation">(</span>
  userid <span class="token keyword">int</span> <span class="token keyword">unsigned</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">,</span>
  buy_date <span class="token keyword">date</span><span class="token punctuation">,</span>
  <span class="token keyword">key</span> <span class="token punctuation">(</span>userid<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">key</span> <span class="token punctuation">(</span>userid<span class="token punctuation">,</span> buy_date<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">innodb</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>InnoDB辅助索引由于包含了主键信息，因此其叶子节点存放的数据为 (primary key, primary key2, …, key1, key2, …)。</p>
<p>覆盖索引也可适用于统计问题，如下列 SQL ：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> buy_log<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>对于如上查询，如果表中有辅助索引的话，InnoDB引擎不会选择通过聚集索引来统计，因为选择辅助索引可以减少IO操作。</p>
<p>通常情况下，诸如 (a, b) 的联合索引，一般是不可以选择列 b 中所谓的查询条件。但如果是对于统计操作，且是覆盖索引的，则优化器会选择这个索引。如下列 SQL：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> buy_log 
<span class="token keyword">where</span> buy_date <span class="token operator">>=</span> <span class="token string">'2011-01-01'</span> adn buy_date <span class="token operator">&lt;</span> <span class="token string">'2011-02-01'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><font color='orange'>表 buy_log 有 (userid, buy_date) 联合索引，只对 b 列进行条件查询，一般不走联合索引，但这个 SQL 是统计操作，且可使用到覆盖索引信息，因此优化器会选择该联合索引。</font></p>
<h4 id="索引提示"><a href="#索引提示" class="headerlink" title="索引提示"></a>索引提示</h4><p><strong>MySQL支持索引提示（INDEX HINT），显式告诉优化器使用哪个索引</strong>。需要用到索引提示的情况如下：</p>
<ol>
<li>MySQL优化器错误地选择了某个索引。</li>
<li>某SQL语句可以选择的索引比较多，此时优化器选择索引的时间开销可能比SQL语句本身都要大。</li>
</ol>
<p>显式指定索引来执行查询，可以通过以下关键字实现：</p>
<ul>
<li>USE：为MySQL提供参考的索引列表，让MySQL不再考虑使用其他可用索引。</li>
<li>FORCE：强制使用一个特定的索引。</li>
<li>IGNORE：忽略一个或多个索引。</li>
</ul>
<p>使用示例如下：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 告诉MySQL 使用 指定索引</span>
<span class="token keyword">select</span> emp_no<span class="token punctuation">,</span>salary <span class="token keyword">from</span> salaries 
<span class="token keyword">use</span> <span class="token keyword">index</span><span class="token punctuation">(</span>s_f_t<span class="token punctuation">)</span> 
<span class="token keyword">where</span> emp_no<span class="token operator">&lt;</span><span class="token number">11010</span> <span class="token operator">and</span> salary<span class="token operator">&lt;</span><span class="token number">60000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 告诉MySQL 强制使用 指定索引</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>yrd_pay_flow<span class="token punctuation">`</span></span> 
<span class="token keyword">force</span> <span class="token keyword">index</span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>idx_trxn_date<span class="token punctuation">`</span></span><span class="token punctuation">)</span>
<span class="token keyword">WHERE</span>  trxn_date <span class="token operator">></span> <span class="token string">'2017-08-12 59:59:59'</span>  <span class="token operator">AND</span> trxn_date <span class="token operator">&lt;</span> <span class="token string">'2016-06-23 00:00:00'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-3-6、B-树索引优化"><a href="#5-3-6、B-树索引优化" class="headerlink" title="5.3.6、B+树索引优化"></a>5.3.6、B+树索引优化</h3><h4 id="Multi-Range-Read"><a href="#Multi-Range-Read" class="headerlink" title="Multi-Range Read"></a>Multi-Range Read</h4><h5 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h5><p><strong>MySQL 5.6开始支持Multi-Range Read优化。目的是减少磁盘的随机访问，将 随机访问 转为 顺序数据访问</strong>。</p>
<p>MRR优化是基于B+树的一种查询优化，可以同时使用多个范围查询条件，避免了多次进行索引查找的问题，提高了查询效率。</p>
<p>MRR优化优点如下：</p>
<ol>
<li>MRR可以顺序访问数据。通过辅助索引查找到主键后进行排序，然后再通过排序后的主键到聚簇索引中查找。</li>
<li>减少 缓冲池中 页替换次数。</li>
<li>批量处理 键值查询操作。</li>
</ol>
<p>对于InnoDB 和 MyISAM引擎的范围查询和JOIN，MRR工作方式如下：</p>
<ol>
<li>将依据 辅助索引键值 查询得到的 数据存放到缓存中，这时，缓存中的数据是根据辅助索引键值排序的。</li>
<li>将缓存中的键值根据 RowID 进行排序。</li>
<li>根据RowID的排序顺序来访问实际的数据文件。</li>
</ol>
<p><font color='red'>注意：如果 InnoDB 和 MyISAM 的缓冲池不足以存放一张表的所有数据，那么频繁离散读取会导致缓存中的页被 替换出缓冲池，然后又不断被 读进缓冲池。若按照主键顺序进行访问，则可以将此重复行为降到最低。</font></p>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>例如对于如下SQL：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t 
<span class="token keyword">where</span> key_part1 <span class="token operator">>=</span> <span class="token number">1000</span> <span class="token operator">and</span> key_part1 <span class="token operator">&lt;</span> <span class="token number">2000</span> <span class="token operator">and</span> key_part2 <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>表 t 有 (key_part1, key_part2)联合索引，因此索引根据 key_part1、key_part2 的位置关系进行排序。若没有 MRR 优化，此时查询类型为 Range，SQL优化器会先将 key_part1 大于 1000 且小于 2000 的数据都取出，即使 key_part2 不等于 1000。待取出行数据后再根据 key_part2 的条件进行过滤。这会导致无用数据被取出。</p>
<p>若启用了 MRR 优化，优化器会先将查询条件进行拆分，然后再进行数据查询。对于上面那个 SQL，优化器会先将查询条件拆分为 (1000, 1000)、(1001, 1000)、(1002, 1000)、…、(1999, 1000)，最后再根据这些拆分出的条件进行数据查询。</p>
<h5 id="如何启用"><a href="#如何启用" class="headerlink" title="如何启用"></a>如何启用</h5><p>是否启用 MRR 优化可以通过参数 <code>optimizer_switch</code>中的标记来控制。当 mrr 为 on 时，表示启用 MRR 优化。<code>mrr_cost_based</code> 标记表示是否通过 cost based 的方式来选择是否启用 mrr。若将 mrr 设为 on，mrr_cost_based 设为 off，则表示总是启用 MRR 优化。如下命令可以将 MRR 优化设为一直开启状态：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">set</span> @<span class="token variable">@optimizer_switch</span><span class="token operator">=</span><span class="token string">'mrr=on,mrr_cost_based=off'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><font color='orange'>参数 <code>read_rnd_buffer_size</code>用来控制 键值缓冲区大小，默认值为256KB。当大于该值时，则执行器对已经缓存的数据将通过 RowID 进行排序并取得行数据。</font></p>
<h4 id="ICP"><a href="#ICP" class="headerlink" title="ICP"></a>ICP</h4><h5 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h5><p>ICP是 Index Condition Pushdown 的首字母，意为索引下推。</p>
<p><font color='orange'>MySQL 5.6开始支持一种基于索引进行查询的优化。不支持该优化时，会先通过索引查找记录，然后根据 WHERE 进行过滤。开启该优化后，会在基于索引查找记录的同时就判断是否可以进行Where过滤，也就是将WHERE过滤放到了存储引擎层。对于某些查询，该方式可大大减少上层SQL层对记录的索取，进而提高数据库的整体性能。</font></p>
<p>ICP优化支持range、ref、eq_ref、ref_or_null类型的查询，且支持MyISAM和InnoDB引擎。当优化器选择 ICP 优化时，可以在执行计划的列 Extra 看到 Using index condition提示。</p>
<p>若支持ICP优化，则会在通过索引取出记录时就进行WHERE过滤，然后再回表查询。当然Where过滤的条件是该索引可以覆盖的范围。</p>
<h5 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h5><p>假设某张表有联合索引 (zip_code, last_name, first_name)，且查询 SQL 如下：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">slect <span class="token operator">*</span> <span class="token keyword">from</span> people
<span class="token keyword">where</span> zipcode <span class="token operator">=</span> <span class="token string">'95054'</span> 
<span class="token operator">and</span> lastname <span class="token operator">like</span> <span class="token string">'%etrunia%'</span> 
<span class="token operator">and</span> address <span class="token operator">like</span> <span class="token string">'Main Street'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于上述 SQL，可以通过索引定位 zipcode 等于 95054 的记录，但是索引对于 where 的后两个过滤条件没有任何帮助。若不支持 ICP 优化，则数据需要先通过索引取出所有 zipcode 等于 95054 的记录，然后再过滤 where 之后的两个条件。若支持 ICP 优化，则在索引取出时，就会进行 where 条件过滤，然后再去获取记录。这将极大提高查询的效率。当然，where 可以过滤的条件是要该索引可以覆盖到的范围。</p>
<h5 id="如何启用-1"><a href="#如何启用-1" class="headerlink" title="如何启用"></a>如何启用</h5><p><strong>ICP优化默认情况下是开启状态</strong>，当然也可通过下列命令开启或关闭：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">set</span> @<span class="token variable">@optimizer_switch</span><span class="token operator">=</span><span class="token string">'index_condition_pushdown=on'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>ICP 优化可以将查询效率在原有MySQL 5.5版本技术上提高 23%左右。而再同时开启 MRR 优化，性能还能有 400% 的提升。</p>
<h4 id="Fast-Index-Creation"><a href="#Fast-Index-Creation" class="headerlink" title="Fast Index Creation"></a>Fast Index Creation</h4><p><strong>InnoDB引擎从 1.0.x 开始支持一种称为 Fast Index Creation（快速索引创建）的索引创建方式——简称FIC</strong>。</p>
<p>InnoDB引擎会<strong>对创建辅助索引的表加上一个S锁。创建过程中无需重建表</strong>，因此速度较之前提高很多，且数据库可用性也得到提高。</p>
<p>删除辅助索引更简单，InnoDB引擎只需更新内部视图，并将辅助索引的空间标为可用，同时删除MySQL内部视图上对该表的索引定义即可。</p>
<blockquote>
<p>注意，临时表的创建路径是通过参数 <code>tmpdir</code>进行设置，用户必须保证tmpdir有足够的空间可以存放临时表，否则会导致创建索引失败。</p>
<p>FIC方式只限定于辅助索引，对于主键的创建和删除同样需要重建一张表。</p>
</blockquote>
<h4 id="Online-Schema-Change"><a href="#Online-Schema-Change" class="headerlink" title="Online Schema Change"></a>Online Schema Change</h4><p><font color='orange'>Online Schema Change（简称OSC）最早由FaceBook实现的一种在线 DDL 的方式，并广泛应用于 Facebook 的MySQL数据库。所谓在线是指：事务创建过程中，允许执行读写事务，该种方式极大提高了MySQL并发能力。</font></p>
<p><font color='red'>注意：Facebook采用 PHP 脚本来实现 OSC，而并非是修改 InnoDB源码来实现。</font></p>
<h4 id="Online-DDL"><a href="#Online-DDL" class="headerlink" title="Online DDL"></a>Online DDL</h4><p>FIC可以避免InnoDB创建临时表，但索引创建时会阻塞表上的DML操作。OSC虽然解决了上述的部分问题，但还是有很大局限性。<font color='orange'>MySQL 5.6开始支持 Online DDL（在线数据定义）操作，其允许辅助索引创建的同时，还允许其它诸如：insert、update、delete等操作，极大提高了MySQL性能和可用性。</font></p>
<p>不仅是辅助索引，以下几类DDL操作都可以通过”在线“方式进行操作：</p>
<ol>
<li><strong>辅助索引的创建与删除</strong></li>
<li><strong>改变自增长值</strong></li>
<li><strong>添加或删除外键约束</strong></li>
<li><strong>列的重命名</strong></li>
</ol>
<p>通过新的 ALTER TABLE 语法，可以选择索引的创建方式：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> table_name
<span class="token operator">|</span> <span class="token keyword">add</span> <span class="token punctuation">(</span><span class="token keyword">index</span> <span class="token operator">|</span> <span class="token keyword">key</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>index_name<span class="token punctuation">]</span>
<span class="token punctuation">[</span>index_type<span class="token punctuation">]</span> <span class="token punctuation">(</span>index_col_name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>index_option<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">ALGORITHM</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">DEFAULT</span> <span class="token operator">|</span> INPLACE <span class="token operator">|</span> COPY<span class="token punctuation">)</span>
<span class="token keyword">LOCK</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">DEFAULT</span> <span class="token operator">|</span> NONE <span class="token operator">|</span> SHARED <span class="token operator">|</span> EXCLUSIVE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><font color='orange'>ALGORITHM指定了创建或删除索引的算法</font>，可选值有：</p>
<ol>
<li><p><strong>DEFAULT</strong></p>
<p>根据参数 old_alter_table（默认为OFF，采用INPLACE） 来判断是通过 INPLACE 还是 COPY。</p>
</li>
<li><p><strong>INPLACE</strong></p>
<p>不需要创建临时表。</p>
</li>
<li><p><strong>COPY</strong></p>
<p>创建临时表方式。</p>
</li>
</ol>
<p>LOCK表示索引创建或删除时为表添加锁的情况，可选值有：</p>
<ol>
<li><p><strong>NONE</strong></p>
<p>不对目标表添加任何锁，可提高最大并发度。</p>
</li>
<li><p><strong>SHARE</strong></p>
<p>对目标表加一个S锁。如果存储引擎不支持该模式，则会报错。</p>
</li>
<li><p><strong>EXCLUSIVE</strong></p>
<p>对目标表加一个X锁。</p>
</li>
<li><p><strong>DEFFAULT</strong></p>
<p>会先判断当前操作是否可以使用NONE模式，若不能，则判断是否可以使用SHARE模式，最后判断是否可以使用EXCLUSIVE模式。</p>
</li>
</ol>
<p><font color='orange'>InnoDB实现Online DDL的原理是：在执行创建或者删除的同时，先将这些操作放入缓存中。待完成索引创建后再将之应用到表上，以此达到数据一致性。这个缓存大小由参数 <code>innodb_online_alter_log_max_size</code> 控制，默认大小为128M。如果存放的内容大小超过这个值，会抛出错误。</font></p>
<blockquote>
<p>索引创建过程中，SQL优化器不会选择正在创建中的索引。</p>
</blockquote>
<h3 id="5-3-7、B-树优缺点"><a href="#5-3-7、B-树优缺点" class="headerlink" title="5.3.7、B+树优缺点"></a>5.3.7、B+树优缺点</h3><ul>
<li>优点<ul>
<li>数据访问效率块。</li>
<li>聚簇索引对于【顺序查找】与【范围查找】速度很快。</li>
<li>因叶子节点数据排列有序，范围查询时可大大减少IO操作。</li>
</ul>
</li>
<li>缺点<ul>
<li>插入速度严重依赖插入顺序。（尽量保证主键升序。）</li>
<li>更新主键代价很高。（更新会导致节点分裂与合并）</li>
<li>二级索引访问需要两次索引查找。</li>
</ul>
</li>
</ul>
<h3 id="5-3-8、总结"><a href="#5-3-8、总结" class="headerlink" title="5.3.8、总结"></a>5.3.8、总结</h3><p>B+树注意事项：</p>
<ol>
<li>根页面位置万年不动。</li>
<li>内节点中目录项记录的唯一性。</li>
<li>一个页面最少存储2条记录。</li>
</ol>
<p>B+树限制：</p>
<ul>
<li>只有InnoDB支持聚簇索引，MyISAM不支持聚簇索引。</li>
<li>一个表只能有一个聚簇索引，该索引一般都是表的主键。</li>
<li>没有主键，InnoDB会选择【非空唯一索引】来代替，若唯一索引也没有，会创建隐藏列唯一【rowId】作为聚簇索引。</li>
<li>InnoDB表的主键尽量使用有序ID，而不建议设计无序字段作为主键。</li>
</ul>
<h2 id="5-5、Cardinality值"><a href="#5-5、Cardinality值" class="headerlink" title="5.5、Cardinality值"></a>5.5、Cardinality值</h2><h3 id="5-5-1、什么是Cardinality"><a href="#5-5-1、什么是Cardinality" class="headerlink" title="5.5.1、什么是Cardinality"></a>5.5.1、什么是Cardinality</h3><p><strong>Cardinality值非常关键，表示索引中不重复记录的数量预估值。</strong>实际中 <code>Cardinality / n_rows_in_table</code> 应尽可能接近1，如果非常小，就不适合创建这个索引。故在访问高选择性属性的字段并从表中取出很少一部分数据时，对这个字段添加B+树索引 会变得 非常必要。</p>
<h3 id="5-5-2、InnoDB中Cardinality统计"><a href="#5-5-2、InnoDB中Cardinality统计" class="headerlink" title="5.5.2、InnoDB中Cardinality统计"></a>5.5.2、InnoDB中Cardinality统计</h3><p>InnoDB更新Cardinality信息的策略为：</p>
<ol>
<li><font color='orange'>表中 1&#x2F;16 的数据已发生过变化。</font></li>
<li><font color='orange'>stat_modified_counter &gt; 2 000 000 000。（stat_modified_counter代表行数据变化的次数）</font></li>
</ol>
<p><strong>InnoDB引擎对Cardinality信息的统计和更新是通过 采样方法 实现。</strong>默认InnoDB对8个叶子节点进行采样。采样过程如下：</p>
<ol>
<li>取得B+树索引中叶子节点的数量，记为A。</li>
<li>随机取得B+树索引中的8个叶子节点。统计每个页不同记录的个数，记为P1、P2、….P8。</li>
<li>根据采样信息给出Cardinality预估值：Cardinality &#x3D; (P1 + P2 + …. +P8) * A &#x2F; 8。</li>
</ol>
<h2 id="5-6、哈希算法"><a href="#5-6、哈希算法" class="headerlink" title="5.6、哈希算法"></a>5.6、哈希算法</h2><p>哈希算法的时间复杂度为O(1)，且不只存在于索引中，每个数据库应用中都存在该数据结构。</p>
<h3 id="5-6-1、哈希表"><a href="#5-6-1、哈希表" class="headerlink" title="5.6.1、哈希表"></a>5.6.1、哈希表</h3><p><strong>哈希表 又叫 散列表，由 直接寻址表 改进而来。</strong></p>
<h4 id="直接寻址表"><a href="#直接寻址表" class="headerlink" title="直接寻址表"></a>直接寻址表</h4><p>假设 某应用 要用到 一个动态集合，其中每个元素都有一个取自全域 U &#x3D; {0, 1, …, m-1} 的关键字。同时假设没有具有相同关键字的元素。用一个数组（直接寻址表）T[0 … m-1] 表示动态集合，其中每个位置（或称槽或称桶）对应全域 U 中的一个关键字。如下图所示，槽 K 指向集合中的一个关键字为 K 的元素，如果集合中没有关键字为 K 的元素，则 T[K] &#x3D; null。</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210103220241478.png" alt="image-20210103220241478"></p>
<p>直接寻址表有以下操作：</p>
<ol>
<li>INSERT：插入一个元素。</li>
<li>DELETE：删除一个元素。</li>
<li>SEARCH：查找一个元素。</li>
</ol>
<p>这里要注意，要是集合U的元素键值并不唯一，即keyikeyi和keyjkeyj(i≠j)(i≠j)有可能相等，那么采用链表的形式将相同键值的元素串成一串，全都挂在A[keyi]A[keyi]的后面，比如键值1重复：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210103214822207.png" alt="image-20210103214822207"></p>
<p>直接寻址技术有一个问题：如果域 U 很大，在一台典型计算机的可用容量的限制下，要在机器中存储大小为 U 的一张表 T 就有点不实际，甚至不可能。如果实际要存储的关键字集合 K   相对于 U 来说很小，那么分配给 T 的大部分空间都要浪费掉。因为这个问题，哈希表出现了。</p>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表也有一个小问题：<strong>两个关键字可能映射到同一个槽上。这种情况称为 碰撞，解决方法是 链表法</strong>。</p>
<p>在链表法中，把散列到同一槽中的所有元素都放在一个链表中。槽 j 中有一个指针，它指向所有散列到 j 的元素构成的链表的头。如果不存在这样的元素，则 j 中为 null。</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210103221109942.png" alt="image-20210103221109942"></p>
<p>映射到哪一个槽是通过哈希函数计算的，这个哈希函数基于 除法散列 方式实现。即 通过取 K 除以 M 的余数，将关键字 K 映射到 M 个槽的某一个中去。</p>
<h3 id="5-6-2、InnoDB实现"><a href="#5-6-2、InnoDB实现" class="headerlink" title="5.6.2、InnoDB实现"></a>5.6.2、InnoDB实现</h3><p><strong>InnoDB引擎使用哈希算法来对字典进行查找，其碰撞会采用链表方式解决，哈希函数采用除法散列方式。对于缓冲池页的哈希表来说，缓冲池中的page页都有一个chain指针，它指向相同哈希值的页。而对于除法散列，m的取值略大于2倍的缓冲池页数量的质数。</strong></p>
<p>对于参数 <code>innodb_buffer_pool_size</code>的大小为 10M，则共有640个 16K 的页。对于缓冲池页内存的哈希表来说，需要分配 640 x 2 &#x3D; 1280 个槽，但是由于 1280 不是一个质数，需要取 比之大的一个质数，应该是 1399，所以启动时会分配一个具有 1399 个槽的哈希表，用来哈希 查询缓冲池中的页。</p>
<p>InnoDB缓冲池的页如何查找呢？InnoDB表空间都有一个space_id，用户要查询的应该是某个表空间的某个连续的 16K 的页，即偏移量 offset。InnoDB将space_id左移20位，然后加上这个space_id 和 offset，即关键字 K &#x3D; space_id &lt;&lt; 20 + space_id + offset，然后通过触发散列到各个槽中。</p>
<h3 id="5-6-3、自适应哈希索引"><a href="#5-6-3、自适应哈希索引" class="headerlink" title="5.6.3、自适应哈希索引"></a>5.6.3、自适应哈希索引</h3><p><strong>自适应哈希索引基于哈希表实现，数据库会根据特殊情况自动创建并使用，不能人为干预</strong>。</p>
<p>自适应哈希索引 对于 字典类型的查找非常快，但对于范围查找就无能为力了。通过命令 SHOW ENGINE INNODB STATUS 可以看到当前自适应哈希索引的使用状况。</p>
<p><strong>可通过参数 <code>innodb_adaptive_hash_index</code> 来禁用或启用自适应哈希索引这个特性，默认开启</strong>。</p>
<h2 id="5-7、全文检索"><a href="#5-7、全文检索" class="headerlink" title="5.7、全文检索"></a>5.7、全文检索</h2><p>InnoDB引擎从1.2.x开始支持全文检索。</p>
<p>全文检索功能是指在文本数据中进行全文检索的功能。在mysql中，全文检索是通过创建全文索引来实现的。全文索引是一种特殊的索引，用于加速文本数据的搜索。</p>
<p>使用全文检索时需要注意以下几点：</p>
<ul>
<li>只有innodb和myisam支持全文检索。</li>
<li>全文检索只适用于char、varchar、text类型。</li>
<li>全文检索默认不区分大小写，但可以通过配置来修改。</li>
<li>全文检索可以使用 in boolean mode指定布尔模式进行搜索，也可以使用in natural language mode指定自然语言模型来进行搜索。</li>
</ul>
<h3 id="5-7-1、倒排索引"><a href="#5-7-1、倒排索引" class="headerlink" title="5.7.1、倒排索引"></a>5.7.1、倒排索引</h3><p><strong>全文检索基于 倒排索引 实现，倒排索引在辅助表中存储了单词与单词在一个或多个文档中所在位置之间的映射。这通常利用关联数组实现，其有两种表现形式</strong>：</p>
<ol>
<li>inverted file index。其表现形式为<code>&#123;单词, 单词所在文档的ID&#125;</code></li>
<li>full inverted index。其变现形式为<code>&#123;单词, (单词所在文档的ID， 在具体文档中的位置)&#125;</code></li>
</ol>
<h3 id="5-7-2、InnoDB全文检索"><a href="#5-7-2、InnoDB全文检索" class="headerlink" title="5.7.2、InnoDB全文检索"></a>5.7.2、InnoDB全文检索</h3><p><strong>InnoDB引擎采用【full inverted index】方式。InnoDB引擎中，将（DocumentID, Position）视为一个“ilist”，因此在全文检索表中有两个列，word字段 和 ilist字段，且word字段上设有索引。此外由于InnoDB引擎在ilist字段中存放了Position信息，故可以进行Proximity Search，而MyISAM不支持该特性。</strong></p>
<p>倒排索引需要将word存放到 Auxiliary Table（辅助表）中，它是持久表，存放于磁盘上。此外还有一个重要概念 FTS Index Cache（全文检索索引缓存），用来提高全文检索的性能。</p>
<p>FTS Index Cache是一个红黑树结构，根据（word, ilist）进行排序。InnoDB引擎会批量对 Auxiliary Table进行更新，而不是每次插入后就更新。当对全文检索进行查询时，AT首先会将FTS Index Cache中对应的word字段合并到AT中，然年再进行查询。</p>
<p><strong>可通过参数<code>innodb_ft_aux_table</code>来观察倒排索引的 Auxiliary Table。</strong></p>
<p><strong>参数<code>innodb_ft_cache_size</code>用来控制FTS Index Cache的大小，默认为32M。 存满后会将其中的（word, ilist）分词信息同步到磁盘的AT中。</strong></p>
<p>要想InnoDB支持全文检索，必须有一个列与word进行映射，这个列命名为 FTS_DOC_ID，其类型必须是 BIGINT UNSIGNED NOT NULL，且InnoDB引擎会自动在该列上加入一个命名为FTS_DOC_ID_INDEX 的 Unique Index。</p>
<p>InnnoDB全文检索存在以下控制：</p>
<ol>
<li>每张表只能有一个全文检索索引。</li>
<li>有多列组合而成的全文检索的索引列必须使用相同的字符集与排序规则。</li>
<li>不支持没有单词界定符的语言，如中文、日语、韩语等。</li>
</ol>
<h3 id="5-7-3、全文检索实现"><a href="#5-7-3、全文检索实现" class="headerlink" title="5.7.3、全文检索实现"></a>5.7.3、全文检索实现</h3><p>MySQL通过 MATCH() … AGAINST() 语法支持全文检索的查询，MATCH指需要被查询的列，AGAINST指定了使用何种方法进行查询。可查询模式如下 ：</p>
<ol>
<li><p><font color='orange'>Natural Language</font></p>
<p>全文检索通过MATCH函数进行查询，默认采用 Natural Language模式，表示查询带有指定word的文档。</p>
</li>
<li><p><font color='orange'>Boolean</font></p>
<p>使用 IN BOOLEAN MODE修饰符进行全文检索，使用该修饰符时，查询字符串的前后字符会有特殊的含义。+ 和 - 代表这个单词必须出现，或一定不出现。</p>
</li>
<li><p><font color='orange'>Query Expansion</font></p>
<p>全文检索的扩展查询，该种查询通常在查询的关键词太短，用户需要implied knowledge（隐含知识）时进行。</p>
<p>通过在查询短语中添加 WITH QUERY EXPANSION 或 IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION 可以开启 blind query expansion（又称为automatic relevance feedback）。该查询分为两个阶段：</p>
<ol>
<li>第一阶段：根据搜索的单词进行全文索引查询。</li>
<li>第二阶段：根据第一阶段产生的分词再进行以此全文检索的查询。</li>
</ol>
</li>
</ol>
<h2 id="5-8、索引总结"><a href="#5-8、索引总结" class="headerlink" title="5.8、索引总结"></a>5.8、索引总结</h2><h3 id="5-8-1、索引代价"><a href="#5-8-1、索引代价" class="headerlink" title="5.8.1、索引代价"></a>5.8.1、索引代价</h3><ul>
<li><p><strong>空间代价</strong></p>
<p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p>
</li>
<li><p><strong>时间代价</strong></p>
<p>每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。B+树 每层节点都是按照索引列的值 从小到大的顺序排序 组成了 双向链表 。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序 而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需 要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p>
</li>
</ul>
<h3 id="5-8-2、适合建立索引的场景"><a href="#5-8-2、适合建立索引的场景" class="headerlink" title="5.8.2、适合建立索引的场景"></a>5.8.2、适合建立索引的场景</h3><ol>
<li>字段的数值有唯一性的限制。</li>
<li>频繁作为 WHERE 查询条件的字段。</li>
<li>经常 GROUP BY 和 ORDER BY 的列。</li>
<li>UPDATE、DELETE 的 WHERE 条件列。</li>
<li>DISTINCT 字段需要创建索引。</li>
<li>多表 JOIN 连接操作时，创建索引注意事项。<ol>
<li>连接表的数量尽量不要超过 3 张 。</li>
<li>对 WHERE 条件创建索引 。</li>
<li>用于连接的字段创建索引 。</li>
</ol>
</li>
<li>使用列的类型小的创建索引</li>
<li>使用字符串前缀创建索引。</li>
<li>区分度高(散列性高)的列适合作为索引。</li>
<li>使用最频繁的列放到联合索引的左侧。</li>
<li>多个字段都要创建索引的情况下，联合索引优于单值索引</li>
</ol>
<h3 id="5-8-3、B树与B-树的区别"><a href="#5-8-3、B树与B-树的区别" class="headerlink" title="5.8.3、B树与B+树的区别"></a>5.8.3、B树与B+树的区别</h3><ol>
<li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数 +1。 索引 &#x2F; 存储引擎 MyISAM InnoDB Memory R-Tree索引 支持 支持 不支持</li>
<li>非叶子节点的关键字也会存在于子节点中，且在子节点中是所有关键字的最大（或最小）。</li>
<li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， 非 叶子节点既保存索引，也保存数据记录 。</li>
<li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字从小到大顺序链接。</li>
</ol>
<h3 id="5-8-4、索引限制"><a href="#5-8-4、索引限制" class="headerlink" title="5.8.4、索引限制"></a>5.8.4、索引限制</h3><p>64位系统，版本5.0后，mysql 单表可支持16个索引，最大索引长度256字节。</p>
<ul>
<li>InnoDB: 最多1017列，最多64个二级索引，单个索引最多包含16列，索引最大长度767字节(其实行格式为REDUNDANT，COMPACT最高为767字节，但行格式为DYNAMIC，COMPRESSED最高可达为3072字节)，行大小最大65536字节。</li>
<li>MyISAM: 最多4096列，最多64个二级索引，单个索引最多包含16列，索引最大长度1000字节，行大小最大65536字节。</li>
</ul>
<h3 id="5-8-5、Explain关键字"><a href="#5-8-5、Explain关键字" class="headerlink" title="5.8.5、Explain关键字"></a>5.8.5、Explain关键字</h3><h4 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h4><p><strong>通过 慢查询日志 可定位查询较慢的SQL，通过explain命令查看该SQL的执行计划</strong>。</p>
<p>expain命令执行结果有12列，按顺序分别是<code>id、select_type、table、PARTITIONS、type、possible_keys、key、key_len、ref、rows、FILTERED、Extra</code>。每项定义如下：</p>
<ol>
<li>id：查询标识符，同一条查询语句id相同。</li>
<li>select_type：查询类型。</li>
<li>table：查询的表名。</li>
<li>partitions：查询的分区表名。</li>
<li>type：查询类型。</li>
<li>possible_keys：可能使用的索引。</li>
<li>key：实际使用的索引。</li>
<li>key_len：索引字段的长度。</li>
<li>ref：索引如何被使用。</li>
<li>rows：扫描行数。</li>
<li>filtered：表数据过滤百分比。</li>
<li>Extra：执行情况的描述和说明。</li>
</ol>
<h4 id="详解12列"><a href="#详解12列" class="headerlink" title="详解12列"></a>详解12列</h4><ul>
<li><p><font color='orange'>ID</font></p>
<p>SELECT识别符。这是SELECT的查询序列号。SQL从大到小的执行：</p>
<ol>
<li><p>id相同时，执行顺序由上至下。</p>
</li>
<li><p>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行。</p>
</li>
<li><p>id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行。</p>
</li>
</ol>
</li>
<li><p><font color='orange'>SELECT_TYPE</font></p>
<p>查询中每个select子句的类型，可选值有：</p>
<ol>
<li>SIMPLE（简单SELECT，不使用UNION或子查询等）。</li>
<li>PRIMARY（子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY）。</li>
<li>UNION（UNION中的第二个或后面的SELECT语句）。</li>
<li>DEPENDENT UNION（UNION中的第二个或后面的SELECT语句，取决于外面的查询）。</li>
<li>UNION RESULT（UNION的结果，union语句中第二个select开始后面所有select）。</li>
<li>SUBQUERY（子查询中的第一个SELECT，结果不依赖于外部查询）。</li>
<li>DEPENDENT SUBQUERY（子查询中的第一个SELECT，依赖于外部查询）。</li>
<li>DERIVED（派生表的SELECT, FROM子句的子查询）。</li>
<li>UNCACHEABLE SUBQUERY（一个子查询的结果不能被缓存，必须重新评估外链接的第一行）。</li>
</ol>
</li>
<li><p><font color='orange'>TABLE</font></p>
<p>显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的），有时不是真实的表名字，可能是简称，例如可能是e，d，也可能是第几步执行的结果的简称。</p>
</li>
<li><p><font color='orange'>PARTITIONS</font></p>
<p>官方定义为The matching partitions（匹配的分区），该字段应该是看table所在分区。值为NULL表示表未被分区。</p>
</li>
<li><p><font color='orange'>TYPE</font></p>
<p>索取数据方式，又称“访问类型”。常用类型有： Null、system、const、eq_ref、ref、range、index、all（从左到右，性能从好到差），各项定义如下：</p>
<ol>
<li><p>NULL</p>
<p>MySQL优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p>
</li>
<li><p><strong>system（查询系统表）</strong></p>
<p>表只有一行记录（等于系统表），是const的特例类型，平时不会出现，可以忽略不计。对于system，官网的解释：The table has only one row(&#x3D;system table). This is a special case of the const join type.</p>
<p>当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system。</p>
</li>
<li><p><strong>const（主键查询）</strong></p>
<p>表示通过一次索引就找到了结果，常出现于primary key或unique索引。因为只匹配一行数据，所以查询非常快。如将主键置于where条件中，MySQL就能将查询转换为一个常量。</p>
</li>
<li><p><strong>eq_ref（主键索引或唯一索引查询）</strong></p>
<p>类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</p>
</li>
<li><p><strong>ref（索引查询）</strong></p>
<p>非唯一索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回匹配某值（某条件）的多行值，属于查找和扫描的混合体。</p>
</li>
<li><p><strong>range（范围查询）</strong></p>
<p>只检索给定范围的行，使用一个索引来检索行，可以在key列中查看使用的索引，一般出现在where语句的条件中，如使用between、&gt;、&lt;、in等查询。</p>
</li>
<li><p><strong>index（索引树扫描）</strong></p>
<p>Full Index Scan（全索引扫描），index与ALL的区别为 index类型只遍历索引树，通常比ALL快，因为索引文件通常比数据文件小。虽说index和ALL都是全表扫描，但是index是从索引中读取，ALL是从磁盘中读取。</p>
</li>
<li><p><strong>ALL（全盘扫描）</strong></p>
<p>Full Table Scan（全表扫描）， MySQL将遍历全表以找到匹配的行。注：一般来说，需保证查询至少达到range级别，最好能达到ref。</p>
</li>
</ol>
</li>
<li><p><font color='orange'>POSSIBLE_KEYS</font></p>
<p>显示可能应用在表中的索引，可能一个或多个。查询涉及到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用。</p>
</li>
<li><p><font color='orange'>KEY</font></p>
<p>实际中使用的索引，如为NULL，则表示未使用索引。若查询中使用了覆盖索引，则该索引和查询的select字段重叠。</p>
</li>
<li><p><font color='orange'>KEY_LEN</font></p>
<p>表示索引中所使用的字节数，可通过该列计算查询中使用的索引长度。在不损失精确性的情况下，长度越短越好。key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，并不是通过表内检索出的。</p>
</li>
<li><p><font color='orange'>REF</font></p>
<p>显示关联的字段。如果使用常数等值查询，则显示const，如果是连接查询，则会显示关联的字段。</p>
</li>
<li><p><font color='orange'>ROWS</font></p>
<p>根据表统计信息及索引选用情况大致估算出找到所需记录所要读取的行数。当然该值越小越好。</p>
</li>
<li><p><font color='orange'>FILTERED</font></p>
<p>百分比值，表示存储引擎返回的数据经过滤后，剩下多少满足查询条件记录数量的比例。</p>
</li>
<li><p><font color='orange'>EXTRA</font></p>
<p>额外信息。取值范围如下：</p>
<ol>
<li><p><strong>Using filesort</strong>：使用外部索引排序，并没有走表索引。需要优化。</p>
</li>
<li><p><strong>Using temporary</strong>：使用临时表保存中间结果。常见于order by、group by，需要优化。</p>
</li>
<li><p><strong>Using where</strong>：存储引擎层返回行数据后，服务器层再通过WHERE条件进行过滤。需要优化。</p>
</li>
<li><p>Using index</p>
<p>使用了覆盖索引。</p>
<p>如果同时出现了Using where，表明索引被用来执行索引键值的查找。（where deptid&#x3D;1）。</p>
<p>如果没有同时出现Using where，表明索引用来读取数据而非执行查找动作。</p>
</li>
<li><p>Using join buffer</p>
<p>表示在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进。</p>
</li>
<li><p>Impossible where</p>
<p>where没有匹配到任何数据。</p>
</li>
<li><p>Select tables optimized away</p>
<p>表示仅通过使用索引，优化器可能仅从聚合函数结果中返回一行。</p>
</li>
<li><p>Using MRR</p>
<p>使用了 Multi Range Read 优化。</p>
</li>
<li><p>Using index condition</p>
<p>使用了 Index Condition Pushdown 优化。</p>
</li>
</ol>
</li>
</ul>
<h1 id="6、锁"><a href="#6、锁" class="headerlink" title="6、锁"></a>6、锁</h1><h2 id="6-1、锁结构"><a href="#6-1、锁结构" class="headerlink" title="6.1、锁结构"></a>6.1、锁结构</h2><h3 id="6-1-1、简介"><a href="#6-1-1、简介" class="headerlink" title="6.1.1、简介"></a>6.1.1、简介</h3><p><strong>对一条记录加锁，本质上是在内存中创建一个锁结构与之关联</strong>。</p>
<p>一个事务对多条记录加锁是否需要创建多个锁结构呢？理论上可以，但实际要分情况。符合以下条件的记录会被放在一个锁结构中：</p>
<ul>
<li>同一个事务中进行加锁操作。</li>
<li>被加锁的记录在同一个页面中。</li>
<li>加锁类型一样。</li>
<li>等待状态一样。</li>
</ul>
<h3 id="6-1-2、InnoDB锁结构"><a href="#6-1-2、InnoDB锁结构" class="headerlink" title="6.1.2、InnoDB锁结构"></a>6.1.2、InnoDB锁结构</h3><p>InnoDB锁结构图如下：</p>
<img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/InnoDB%E9%94%81%E7%BB%93%E6%9E%84%E5%9B%BE.png" style="zoom: 60%;" />

<h4 id="锁所在的事务信息"><a href="#锁所在的事务信息" class="headerlink" title="锁所在的事务信息"></a>锁所在的事务信息</h4><p>不论是 表锁 还是 行锁 ，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构 ，这里就记录这个 事务的信息。 此 锁所在的事务信息 在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p>
<h4 id="索引信息"><a href="#索引信息" class="headerlink" title="索引信息"></a>索引信息</h4><p>对于 行锁 来说，需要记录一下加锁的记录属于哪个索引。这里也是一个指针。 </p>
<h4 id="表锁行锁信息"><a href="#表锁行锁信息" class="headerlink" title="表锁行锁信息"></a>表锁行锁信息</h4><p>表锁结构 和 行锁结构 在这个位置的内容是不同的： </p>
<ul>
<li><p>表锁： 记载着是对哪个表加的锁，还有其他的一些信息。 </p>
</li>
<li><p>行锁： 记载了三个重要的信息：</p>
<ul>
<li>Space ID ：记录所在表空间。</li>
</ul>
</li>
<li><p>Page Number ：记录所在页号。</p>
<ul>
<li>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同 的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个 n_bits 属性代表使用了多少比特位。</li>
</ul>
</li>
</ul>
<h4 id="type-mode"><a href="#type-mode" class="headerlink" title="type_mode"></a>type_mode</h4><p>这是一个32位数，被<strong>分成了<code>lock_mode</code>、<code>lock_type</code>和<code>rec_lock_type</code>三个部分</strong>，</p>
<p>如图所示： </p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/InnoDB%E9%94%81%E7%BB%93%E6%9E%84-typemodel%E5%90%84%E4%B8%AA%E4%BD%8D%E4%BD%9C%E7%94%A8%E8%A7%A3%E6%9E%90.png"></p>
<ul>
<li><p><strong>锁的模式（ lock_mode ），占用低4位</strong>，可选值如下：</p>
<ul>
<li>LOCK_IS （十进制的 0 ）：表示共享意向锁，也就是 IS锁 。 </li>
<li>LOCK_IX （十进制的 1 ）：表示独占意向锁，也就是 IX锁 。</li>
<li>LOCK_S （十进制的 2 ）：表示共享锁，也就是 S锁 。</li>
<li>LOCK_X （十进制的 3 ）：表示独占锁，也就是 X锁 。</li>
<li>LOCK_AUTO_INC （十进制的 4 ）：表示 AUTO-INC锁 。</li>
</ul>
<p>InnoDB引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p>
</li>
<li><p><strong>锁的类型（ lock_type ），占用第5～8位</strong>，不过现阶段只有第5位和第6位被使用：</p>
<ul>
<li>LOCK_TABLE （十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁。</li>
<li>LOCK_REC （十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁。</li>
</ul>
</li>
<li><p><strong>行锁具体类型（ rec_lock_type ）使用其余位来表示</strong>。lock_type 是 LOCK_REC 时，也就是该锁为行级锁时才会被细分为更多类型：</p>
<ul>
<li>LOCK_ORDINARY （十进制的 0 ）：表示 next-key锁 。</li>
<li>LOCK_GAP （十进制的 512 ）：也就是当第10个比特位置为1时，表示 gap锁 。</li>
<li>LOCK_REC_NOT_GAP （十进制的 1024 ）：也就是当第11个比特位置为1时，表示正经记录锁 。 </li>
<li>LOCK_INSERT_INTENTION （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li>
</ul>
</li>
<li><p>is_waiting，为节省内存空间，把 is_waiting 属性放到了 type_mode 这个32 位的数字中： </p>
<ul>
<li>LOCK_WAIT （十进制的 256 ） ：当第9个比特位置为 1 时，表示 is_waiting 为 true ，也 就是当前事务尚未获取到锁，现处于等待状态；当这个比特位为 0 时，表示 is_waiting 为 false ，也就是当前事务获取锁成功。</li>
</ul>
</li>
</ul>
<h4 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h4><p>为更好的管理系统运行过程中生成的各种锁结构，设计了各种哈希表和链表。</p>
<h4 id="一堆比特位"><a href="#一堆比特位" class="headerlink" title="一堆比特位"></a>一堆比特位</h4><p>行锁结构末尾会放置一堆比特位，比特位的数量是由上边提到的 n_bits 属性值决定。InnoDB数据页中每条记录的记录头中都包含一个 heap_no 属性，伪记录 Infimum 的 heap_no 值为 0 ， Supremum 的 heap_no 值为 1 ，之后每插入一条记录heap_no 值就增1。 锁结构最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个 heap_no ，即一个比特位 映射 页内一条记录。</p>
<h2 id="6-2、锁实现"><a href="#6-2、锁实现" class="headerlink" title="6.2、锁实现"></a>6.2、锁实现</h2><h3 id="6-2-1、锁分类"><a href="#6-2-1、锁分类" class="headerlink" title="6.2.1、锁分类"></a>6.2.1、锁分类</h3><h4 id="整体划分"><a href="#整体划分" class="headerlink" title="整体划分"></a>整体划分</h4><p>从不同角度来划分不同类型的锁，其详细表示如下：</p>
<ul>
<li>基于 操作类型 可划分为 2 种：<ul>
<li>读锁 &#x2F; 共享锁</li>
<li>写锁 &#x2F; 排它锁。</li>
</ul>
</li>
<li>基于 锁粒度 可划分为 3 种：<ul>
<li>表锁：表级别S锁、X锁；意向锁；自增锁；MDL锁；</li>
<li>行锁：Record Locks；Gap Locks；Next-Key Locks；插入意向锁；</li>
<li>页锁</li>
</ul>
</li>
<li>基于 锁态度 可划分为 2 种：<ul>
<li>悲观锁</li>
<li>乐观锁</li>
</ul>
</li>
<li>基于 加锁方式 可划分为 2 种：<ul>
<li>隐式锁</li>
<li>显式锁</li>
</ul>
</li>
</ul>
<h4 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h4><p>InnoDB引擎支持【表锁、行锁、页锁】。</p>
<ul>
<li>行锁<ol>
<li>共享锁，允许事务读一行数据。</li>
<li>排他锁，允许事务删除或更新一行数据。</li>
</ol>
</li>
<li>表锁<ol>
<li>意向共享锁，事务想要获得一张表中某几行的共享锁。</li>
<li>意向排他锁，事务想要获得一张表中某几行的排他锁。</li>
</ol>
</li>
</ul>
<p>行锁与表锁兼容性如下：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200814173602295.png" alt="image-20200814173602295"></p>
<blockquote>
<p>InnoDB 1.0开始，INFORMATION_SCHEMA 架构下新增了三张表：INNODB_TRX、INNODB_LOCKS、INNODB_LOCK_WAITS。通过这三张表可以监控当前事务并分析可能存在的问题。</p>
</blockquote>
<h4 id="MyISAM锁"><a href="#MyISAM锁" class="headerlink" title="MyISAM锁"></a>MyISAM锁</h4><p><strong>MyISAM引擎支持表锁</strong>。</p>
<h3 id="6-2-2、表锁"><a href="#6-2-2、表锁" class="headerlink" title="6.2.2、表锁"></a>6.2.2、表锁</h3><h4 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h4><p>表锁会锁定整张表，它是MySQL锁的基本策略，不依赖于存储引擎。表锁可以避免死锁问题，但同时降低了并发。</p>
<h4 id="表级S锁-X锁"><a href="#表级S锁-X锁" class="headerlink" title="表级S锁&#x2F;X锁"></a>表级S锁&#x2F;X锁</h4><p>表级别的S锁、X锁一般不会使用，只会在 崩溃恢复 等特殊场景中使用。</p>
<p>对于InnoDB引擎来说，表级别的S锁和X锁不仅不会提供保护，反而会降低并发能力。</p>
<p>表级别S锁&#x2F;X锁使用方式如下：</p>
<ul>
<li><p>表级S锁</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">LOCK TABLES T READ<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>表级X锁</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">LOCK TABLES T WRITE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h4 id="意向锁（自动）"><a href="#意向锁（自动）" class="headerlink" title="意向锁（自动）"></a>意向锁（自动）</h4><p>InnoDB引擎支持多粒度锁，它允许行锁与表锁共存，而意向锁就是表锁的一种。</p>
<p>意向锁作用如下：</p>
<ul>
<li>协调行锁与读锁的关系，支持多粒度锁并存。</li>
<li>表明表中已经有事务正在获取锁，或已经获取了锁，其它线程无需再尝试。</li>
</ul>
<p>意向锁由存储引擎维护，用户无需干预。在对数据行加共享锁、排它锁之前，InnoDB引擎会先获取该表的意向锁。</p>
<p>意向锁分为两种：</p>
<ul>
<li>意向共享锁：事务对表中行记录加共享锁时，InnoDB会自动为表级别加意向共享锁。</li>
<li>意向排它锁：事务对表中行记录加排它锁时，InnoDB会自动为表级别加意向排它锁。</li>
</ul>
<h4 id="自增锁（自动）"><a href="#自增锁（自动）" class="headerlink" title="自增锁（自动）"></a>自增锁（自动）</h4><h5 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h5><p><strong>InnoDB的内存结构中，每个含有自增长值的表都有一个自增长计数器。当对含有计数器的表执行插入操作时，这个计数器会被初始化</strong>。执行下列语句来得到计数器的值：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>auto_inc_col<span class="token punctuation">)</span> <span class="token keyword">FROM</span> t <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>插入操作 会初始化 自增长列的 计数器值，这种方式称为【AUTO-INC Locking】。这种锁其实采用的是一种特殊的表锁机制，为了提高插入性能，锁不是在一个事务完成后才释放，而是执行完SQL后立即释放。</p>
<p>AUTO-INC Locking缺点：</p>
<ol>
<li>对于有自增长值的列的并发插入性能较差，事务必须等待前一个插入的完成。</li>
<li>对于INSERT … SELECT的大数据量的插入会影响插入性能，因为另一个事务会被阻塞。</li>
</ol>
<h5 id="自增长模式"><a href="#自增长模式" class="headerlink" title="自增长模式"></a>自增长模式</h5><p>MySQL 5.1.22开始，InnoDB提供了一种轻量级互斥量的自增长实现机制，该机制极大提高了自增长值的插入性能。其可以通过参数<code>innodb_autoinc_lock_mode</code>来控制自增长模式，参数默认值为1，可选值有0、1、2。</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20201214194656633.png" alt="image-20201214194656633"></p>
<p>InnoDB引擎和MyISAM的自增长实现不同，InnoDB中，自增长值的列必须是索引，同时必须是索引的第一个列，否则会抛出错误。而MyISAM没有这个问题。</p>
<h4 id="元数据锁（自动）"><a href="#元数据锁（自动）" class="headerlink" title="元数据锁（自动）"></a>元数据锁（自动）</h4><p><strong>MySQL 5.7 引入了 meta data lock，简称 MDL 锁，属于表锁范畴</strong>。</p>
<p>MDL锁会自动添加，无需显式使用，MDL锁作用是保证读写正确性。当对一个表执行 增删改查 操作时会加 MDL 读锁；当对 表结构 做改变时会加 MDL 写锁。读锁之间不互斥，写锁之间、写读锁之间是互斥的。</p>
<h3 id="6-2-3、行锁"><a href="#6-2-3、行锁" class="headerlink" title="6.2.3、行锁"></a>6.2.3、行锁</h3><h4 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h4><p>行锁有如下特点：</p>
<ul>
<li><strong>两个“原则”</strong><ol>
<li>加锁的基本单位是next-key lock，next-key lock是前开后闭区间。</li>
<li>查找过程中访问到的对象才会加锁。</li>
</ol>
</li>
<li><strong>两个“优化”</strong><ol>
<li>索引上的等值查询，给唯一索引加锁时，next-key lock会退化为Record Lock（记录锁）。</li>
<li>索引上的等值查询，向右遍历时且最后一个值不满足等值条件时，next-key lock会退化为间隙锁。</li>
</ol>
</li>
<li><strong>一个“bug”</strong><ol>
<li>唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ol>
</li>
</ul>
<h4 id="记录锁（Record-Lock）"><a href="#记录锁（Record-Lock）" class="headerlink" title="记录锁（Record Lock）"></a>记录锁（Record Lock）</h4><p><strong>记录锁，仅仅锁住索引记录的一行，在单条索引记录上加锁</strong>。</p>
<p>record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。</p>
<p>所以说当一条sql没有走任何索引时，那么将会在每一条聚合索引后面加X锁，这个类似于表锁，但原理上和表锁应该是完全不同的。</p>
<h4 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h4><p><strong>间隙锁，仅仅锁住一个索引区间（开区间，不包括双端端点）</strong>。在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。</p>
<p>间隙锁可用于防止幻读，保证索引间不会插入新数据。</p>
<p><strong>显式关闭 Gap Lock 的两种方式</strong>：</p>
<ol>
<li>将事务的隔离级别设为 READ COMMITED。</li>
<li>将参数 <code>innodb_locks_unsafe_for-binlog</code> 设为1。</li>
</ol>
<h4 id="临键锁（Next-Key-Lock）"><a href="#临键锁（Next-Key-Lock）" class="headerlink" title="临键锁（Next-Key Lock）"></a>临键锁（Next-Key Lock）</h4><p><strong>Next-Key Lock &#x3D; Gap Lock + Record Lock，锁定一个范围，且锁定记录本身， 左开右闭区间</strong>。</p>
<p>默认情况下，innodb使用next-key locks来锁定记录。当查询的索引含有唯一属性时，Next-Key Lock 会进行优化，将其降级为Record Lock。</p>
<p>Next-Key Lock在不同场景中会退化：</p>
<ol>
<li>使用 unique index 精确匹配，且记录存在，则会退化为 记录锁。</li>
<li>使用 unique index 精确匹配，但记录不存在，则会退化为 间隙锁。</li>
<li>使用 unique index 范围匹配，则会退化为 临键锁。</li>
</ol>
<h4 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><h5 id="简介-12"><a href="#简介-12" class="headerlink" title="简介"></a>简介</h5><p><strong>一个事务插入一条记录时会判断插入位置是否被加了GAP锁（next-key 包含 gap 锁），如果存在 gap 锁，则插入操作需要等待，直到 gap 锁被释放。InnoDB规定事务等待时需要在内存中生成一个锁结构，表明有事务想在某个间隙插入新记录，但目前处于等待状态。InnoDB称该种锁为<code>LOCK_INSERT_TNTENTION</code>，意为插入意向锁</strong>。</p>
<p>插入意向锁是一种GAP锁，而不是意向锁，在插入时产生。</p>
<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><p>插入意向锁是插入一条记录前，由插入操作产生的一种间隙锁。插入意向锁的特性分为两种：</p>
<ul>
<li>插入意向锁是一种特殊的间隙锁。</li>
<li>插入意向锁之间不互斥。</li>
</ul>
<p>插入意向锁不会排斥其它任何类型的锁。</p>
<h3 id="6-2-4、页锁"><a href="#6-2-4、页锁" class="headerlink" title="6.2.4、页锁"></a>6.2.4、页锁</h3><h4 id="简介-13"><a href="#简介-13" class="headerlink" title="简介"></a>简介</h4><p>页锁开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁与行锁之间，并发度一般。</p>
<h3 id="6-2-5、读写锁"><a href="#6-2-5、读写锁" class="headerlink" title="6.2.5、读写锁"></a>6.2.5、读写锁</h3><h4 id="简介-14"><a href="#简介-14" class="headerlink" title="简介"></a>简介</h4><p>读写锁可以加在表上，也可以加在行上。</p>
<h4 id="加读锁"><a href="#加读锁" class="headerlink" title="加读锁"></a>加读锁</h4><p>在 SELECT 语句后加上 LOCK IN SHARE MODE，即可实现为读取的记录加 读锁（共享锁）。</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT ... FROM TABLE_NAME WHERE ... LOCK IN SHARE MODE;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>当指定记录被加上S锁后，其它事务可继续对该记录加S锁，但不可加X锁。其它事务加X锁会被阻塞，直到当前记录上的S锁被释放。</p>
<h4 id="加写锁"><a href="#加写锁" class="headerlink" title="加写锁"></a>加写锁</h4><p>在 SELECT 语句后加上 FOR UPDATE，即可实现为读取的记录加 写锁（排它锁）。</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT ... FROM TABLE_NAME WHERE ... FOR UPDATE;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>当指定记录被加上X锁后，其它事务不能加X锁，也不能加S锁。其他事务加X锁、S锁都会被阻塞，知道当前记录上的X锁被释放。</p>
<blockquote>
<p>MySQL 5.7 之前，SELECT…FOR UPDATE 获取不到锁时会一直等待，直到参数<code>innodb_lock_wait_timeout</code>设置的超时时间。MySQL 8.0中，SELECT…FOR UPDATE、SELECT…FOR SHARE 添加了NOWAIT、SKIP LOCKED语法，可跳过锁等待。</p>
<p>如果当前记录已经加了锁，那么NOWAIT会跳过锁等待立即返回；SKIP LOCKED也会立即返回，但返回结果中不包含被锁定的记录。</p>
</blockquote>
<h3 id="6-2-6、全局锁"><a href="#6-2-6、全局锁" class="headerlink" title="6.2.6、全局锁"></a>6.2.6、全局锁</h3><p><strong>全局锁是对整个数据库实例加锁，当需要让整个库为只读状态时，就需要使用全局锁</strong>。</p>
<p>全局锁典型使用场景：全库逻辑备份。</p>
<p>全局锁命令如下：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">FLUSH TABLES WITH READ LOCK;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="6-2-7、一致性读"><a href="#6-2-7、一致性读" class="headerlink" title="6.2.7、一致性读"></a>6.2.7、一致性读</h3><h4 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h4><p>一致性非锁定读是指： InnoDB从 行的多个版本 中读取数据。如果正在被读取的行正在被执行 DELETE、UPDATE 操作，此时读取操作不会阻塞，它会去读取行的一个快照数据。</p>
<p>快照数据是行数据之前的版本，其通过undo段来实现。undo用来在事务中回滚数据，因此快照数据没有额外开销。<strong>一个行记录可能不止一个快照数据，我们称之为行多版本技术，由此带来的控制，称为多版本并发控制（Multi Version Concurrency Control, MVCC）</strong>。</p>
<p>不同事务隔离级别下，InnoDB一致性非锁定读 的 读取方式不同：</p>
<ol>
<li><p>READ COMMITTED：读取最新快照数据。</p>
</li>
<li><p>REPEATABLE READ：读取事务开始时的行数据版本。</p>
</li>
</ol>
<h4 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h4><p>InnoDB对于SELECT语句支持两种一致性锁定读操作：</p>
<ol>
<li><p><font color='orange'>SELECT … FOR UPDATE</font></p>
<p>对读取的行加一个X锁，同时其它事务不能加任何锁。</p>
</li>
<li><p><font color='orange'>SELECT … LOCK IN SHARE MODE</font></p>
<p>对读取的行加一个S锁，同时其它事务可以加S锁，但不能加X锁。</p>
</li>
</ol>
<p><font color='red'>注意：以上两种操作必须在一个事务中，当事务提交了，锁也就释放了。因此在使用以上两种操作时，务必加上BEGIN、START TRANSACTION 或 SET AUTOCOMMIT &#x3D; 0。</font></p>
<h3 id="6-2-8、外键和锁"><a href="#6-2-8、外键和锁" class="headerlink" title="6.2.8、外键和锁"></a>6.2.8、外键和锁</h3><p>对于一个外键列，如果没有加索引，InnoDB会自动为其添加一个索引，这样可以避免表锁。</p>
<p>对外键插入或更新时，会先查询父表记录，且会使用SELECT … LOCK IN SHARE MODE 为父表加S锁。</p>
<h3 id="6-2-9、lock与latch"><a href="#6-2-9、lock与latch" class="headerlink" title="6.2.9、lock与latch"></a>6.2.9、lock与latch</h3><p>数据库中lock与latch都可以称为“锁”，但两者有着截然不同的含义。</p>
<h4 id="Latch"><a href="#Latch" class="headerlink" title="Latch"></a>Latch</h4><p>latch称为闩锁（轻量级锁），因要求锁定时间要短，若时间长则会降低应用性能。InnoDB中，latch又分为mutex（互斥量）和rwlock（读写锁），其目的是用来保证并发线程操作临界资源的正确性，且通常没有死锁检测机制。</p>
<p>InnoDB中可以通过参数 <code>SHOW ENGINE INNODB MUTEX</code>来查看latch状况。输出结果说明如下：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20201214164811212.png" alt="image-20201214164811212"></p>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p><strong>lock的对象是事务，且lock的对象仅在事务commit或rollback后释放。此外，lock没有死锁机制</strong>。</p>
<h4 id="Lock-VS-Latch"><a href="#Lock-VS-Latch" class="headerlink" title="Lock VS Latch"></a>Lock VS Latch</h4><p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200814172748394.png" alt="image-20200814172748394"></p>
<h2 id="6-3、锁问题"><a href="#6-3、锁问题" class="headerlink" title="6.3、锁问题"></a>6.3、锁问题</h2><h3 id="6-3-1、脏读"><a href="#6-3-1、脏读" class="headerlink" title="6.3.1、脏读"></a>6.3.1、脏读</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>脏页是指缓冲池中已修改但没有刷新到磁盘中的页。</p>
<p>脏数据是指：事务对缓冲池中行记录的修改，且还没有提交。</p>
<p>脏读是指：在不同事务下，当前事务可以读到其他事务未提交的数据，简单来说就是可以读到脏数据。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>使用 READ COMMITTED 隔离级别 可解决脏读问题。 </p>
<h3 id="6-3-2、不可重复度"><a href="#6-3-2、不可重复度" class="headerlink" title="6.3.2、不可重复度"></a>6.3.2、不可重复度</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>不可重复读是指：同一事务下的同一SQL，两次执行返回的结果不同。</p>
<h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>使用 REPEATABLE READ 隔离级可解决 不可重复读问题。</p>
<h3 id="6-3-3、幻读"><a href="#6-3-3、幻读" class="headerlink" title="6.3.3、幻读"></a>6.3.3、幻读</h3><h4 id="啥是幻读"><a href="#啥是幻读" class="headerlink" title="啥是幻读"></a>啥是幻读</h4><p>幻读（Phantom Problem）指：在同一事物下，两次执行同一句SQL，其结果不同，第二次执行结果中存在第一次执行后不存在的行。</p>
<h4 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h4><p>默认事务隔离级别下，即REPEATABLE READ下，InnoDB引擎采用【Next-Key Locking】机制来避免Phantom Problem（幻读问题）。</p>
<h3 id="6-3-4、丢失更新"><a href="#6-3-4、丢失更新" class="headerlink" title="6.3.4、丢失更新"></a>6.3.4、丢失更新</h3><p>丢失更新是指：<strong>一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致</strong>。</p>
<h3 id="6-3-5、阻塞"><a href="#6-3-5、阻塞" class="headerlink" title="6.3.5、阻塞"></a>6.3.5、阻塞</h3><p>因为不同锁之间的兼容性关系，一个事务中的锁需要等待另一个事务中的锁释放占用的资源，该场景被称为阻塞。阻塞并不是一件坏事，其是为了确保事务并发且正常的执行。</p>
<p>InnoDB引擎中，动态参数<code>innodb_lock_wait_timeout</code>用来控制等待时间（默认50s），静态参数<code>innodb_rollback_on_timeout</code>用来设定是否在等待超时时对执行中的事务执行回滚操作（默认OFF，不回滚）。</p>
<h3 id="6-3-6、死锁"><a href="#6-3-6、死锁" class="headerlink" title="6.3.6、死锁"></a>6.3.6、死锁</h3><h4 id="简介-15"><a href="#简介-15" class="headerlink" title="简介"></a>简介</h4><p>死锁是指：<strong>两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象</strong>。除了超时机制，当前数据库普遍采用<code>wait-for-graph</code>（等待图）方式来执行死锁检测。InnoDB引擎也采用这种方式。</p>
<p>wait-for graph 的死锁检测通常采用 深度优先算法实现。InnoDB 1.2之前，采用递归方式实现，1.2开始，将递归用非递归的方式实现。</p>
<p><code>wait-forgraph</code>要求数据库保存以下两种信息：</p>
<ol>
<li>锁的信息链表。</li>
<li>事务等待链表。</li>
</ol>
<h4 id="死锁概率"><a href="#死锁概率" class="headerlink" title="死锁概率"></a>死锁概率</h4><p>死锁应该较少发生才合适，若经常性发生，则系统是不可用的。此外死锁次数还要少于等待次数。</p>
<p>事务发生死锁的概率与以下几点相关：</p>
<ol>
<li>系统中事务的数量，事务越多发生死锁的概率越大。</li>
<li>每个事务操作的数量（r），每个事务操作的数量越多，其概率越大。</li>
<li>操作数据的集合，越小则概率越大。</li>
</ol>
<h2 id="6-4、锁升级"><a href="#6-4、锁升级" class="headerlink" title="6.4、锁升级"></a>6.4、锁升级</h2><p><strong>每个层级的锁数量是有限制的，锁空间大小也有限。当某个层级的锁数量超过该层级阈值时会进行锁升级</strong>。</p>
<p><strong>锁升级就是用更大粒度的锁 替代 更小粒度的锁。比如行锁升级为表锁</strong>。</p>
<p>升级可以降低锁空间占用，但同时会降低并发度。</p>
<p><font color='red'>注意：InnoDB中不存在锁升级。因为行锁的产生不依赖于每一条数据记录，而是根据每个事务访问的每个页对锁进行管理，采用的是“位图”方式，因此不管事务锁住页中一个记录还是多个记录，其开销通常都是一样的。</font></p>
<h2 id="6-5、锁监控"><a href="#6-5、锁监控" class="headerlink" title="6.5、锁监控"></a>6.5、锁监控</h2><h3 id="6-5-1、innodb-row-lock监控"><a href="#6-5-1、innodb-row-lock监控" class="headerlink" title="6.5.1、innodb_row_lock监控"></a>6.5.1、innodb_row_lock监控</h3><p><strong>一般可以通过检查 InnoDB_row_lock 状态变量来监控锁使用情况</strong>。</p>
<p>对各个状态量的说明如下： </p>
<ul>
<li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</li>
<li>Innodb_row_lock_time_max：系统启动到现在等待最常的一次所花的时间；</li>
<li>Innodb_row_lock_waits ：系统启动后到现在总共等待的次数；（等待总次数） </li>
<li>Innodb_row_lock_time ：系统启动到现在锁定总时间长度；（等待总时长）</li>
<li>Innodb_row_lock_time_avg ：每次等待所花平均时间；（等待平均时长）</li>
</ul>
<h3 id="6-5-2、其它监控"><a href="#6-5-2、其它监控" class="headerlink" title="6.5.2、其它监控"></a>6.5.2、其它监控</h3><p><strong>MySQL把事务和锁的信息记录在了<code>information_schema</code>库中，涉及到的三张表分别是 INNODB_TRX 、 INNODB_LOCKS 和 INNODB_LOCK_WAITS</strong> 。</p>
<p>MySQL5.7及之前 ，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。</p>
<p>MySQL8.0删除了<code>information_schema.INNODB_LOCKS</code>，可通过<code>performance_schema.data_locks</code>查看事务的锁情况，<code>performance_schema.data_locks</code>不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p>
<h1 id="7、事务"><a href="#7、事务" class="headerlink" title="7、事务"></a>7、事务</h1><p><strong>事务是数据库区别于文件系统的重要特性之一。InnoDB中的事务完全符合ACID特性</strong>。</p>
<h2 id="7-1、认识事务"><a href="#7-1、认识事务" class="headerlink" title="7.1、认识事务"></a>7.1、认识事务</h2><h3 id="7-1-1、概述"><a href="#7-1-1、概述" class="headerlink" title="7.1.1、概述"></a>7.1.1、概述</h3><p><strong>事务由一条非常简单的SQL语句组成，也可以由一组非常复杂的SQL语句组成。事务是访问并更新数据库中各数据项的一个程序执行单元。事务中的操作要么都执行，要么都不执行</strong>。</p>
<p>事务有着严格的定义，它必须满足四个特性：</p>
<ul>
<li><strong>A（Atomicity）</strong>：原子性。是指整个数据库事务是不可再分割的工作单位。</li>
<li><strong>C（Consistency）</strong>：一致性。是指事务将数据库从一种状态转为另一种状态，且事务开始前和结束后，数据库的完整性约束没有被破坏。</li>
<li><strong>I（Isolation）</strong>：隔离性。也可被称为并发控制、科串行化、锁等。事务间相互隔离，谁也不影响谁。</li>
<li><strong>D（Durability）</strong>：持久性。事务一旦提交就是永久性的。</li>
</ul>
<h3 id="7-1-2、分类"><a href="#7-1-2、分类" class="headerlink" title="7.1.2、分类"></a>7.1.2、分类</h3><p>理论角度来说，可把事务分为以下几种类型：</p>
<ol>
<li><p><strong>扁平事务（Flat Transactions）</strong></p>
<p>最简单的一种事务，生产环境中使用较频繁的事务。扁平事务中，所有操作都处于一层，由<code>BEGIN WORK</code>开始，由<code>COMMIT WORK</code>或<code>ROLLBACK WORK</code>结束，期间的操作都是原子的，要么都执行，要么都回滚。</p>
<p>扁平事务的限制是不能提交或者回滚事务的一部分，或几个步骤进行提交。</p>
</li>
<li><p><strong>带有保存点的扁平事务（Flat Transaction With Savepoints）</strong></p>
<p>支持扁平事务的所有功能外，还允许在事务执行过程中回滚到同一事物中较早的一个状态。某些事务在执行过程中出现的错误并不会导致所有操作都无效，放弃整个事务的话就不太现实。保存点用来通知系统应该记住事务当前状态，以便发生错误时，能回到保存点当时的状态。</p>
</li>
<li><p><strong>链事务</strong></p>
<p>该事务可以看作是保存点模式的一种变种。有保存点的扁平事务，在系统崩溃时，其保存点都将消失，这意味着进行恢复时，会从开始处重新执行，而不能从最近的一个保存点继续执行。</p>
<p>链事务的思想：提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。要注意的是——提交事务操作和开始下一个事务操作将合并为一个原子操作。</p>
</li>
<li><p><strong>嵌套事务</strong></p>
<p>是一个层次结构框架。由一个顶层事务控制着各个层次的事务。顶层事务下嵌套的事务被称为子事务，其控制着每一个局部的变换。</p>
</li>
<li><p><strong>分布式事务</strong></p>
<p>通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置来访问网络中的不同节点。</p>
</li>
</ol>
<h2 id="7-2、事务实现"><a href="#7-2、事务实现" class="headerlink" title="7.2、事务实现"></a>7.2、事务实现</h2><p>原子性、一致性、持久性通过数据库的<code>redo log</code>和<code>undo log</code>来完成。</p>
<p><font color='orange'><code>redo log</code>称为重做日志，是物理日志。保证了事务的原子性和持久性。</font></p>
<p><font color='orange'><code>undo log</code>称为回滚日志，是逻辑日志。保证了事务的一致性。实现了事务回滚 和 MVCC功能。</font></p>
<h3 id="7-2-1、redo"><a href="#7-2-1、redo" class="headerlink" title="7.2.1、redo"></a>7.2.1、redo</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><font color='orange'>重做日志 用来实现 事务持久性。其由两部分组成：</font></p>
<ol>
<li>内存中的重做日志缓冲，是易失的。</li>
<li>重做日志文件（redo log file），是持久的。</li>
</ol>
<p>InnoDB引擎通过Force Log at Commit机制实现事务的持久性，即当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待COMMIT操作完成才算完成。</p>
<p><strong>为确保日志每次都能被正确写入重做日志文件，则每次将缓冲数据写入文件时都要调用一次 fsync操作。由于重做日志文件的打开没有使用 O_DIRECT选项，因此重做日志缓冲先写入文件系统缓存。为了确保写入磁盘，必须进行一次 fsync操作</strong>。</p>
<p><strong>参数 <code>innodb_flush_log_at_trx_commit</code> 用来控制重做日志刷新到磁盘的策略</strong>，可选值有0、1、2：</p>
<ul>
<li>0：事务提交时不会立即执行重做日志写操作，而是以 Master Thread的每秒调用fsync进行刷盘为主。</li>
<li>1 ：事务提交时必须调用一次 fsync操作。</li>
<li>2：事务提交时将重做日志写入重做日志文件，但仅写入文件系统的缓存，不进行fsync操作。</li>
</ul>
<h4 id="log-buffer"><a href="#log-buffer" class="headerlink" title="log buffer"></a>log buffer</h4><h5 id="log-block"><a href="#log-block" class="headerlink" title="log block"></a>log block</h5><p><strong>InnoDB中，重做日志以 块 的方式进行保存，称之为重做日志块，每块大小 512 字节。其大小和磁盘扇区大小一样，因此重做日志写入可以保证原子性，无需 doublewrite技术</strong>。</p>
<p>重做日志块由3部分组成：</p>
<ol>
<li><p><strong>日志块头（12字节）</strong></p>
<p>日志块头由4部分组成：</p>
<ol>
<li><p><font color='orange'>LOG_BLOCK_HDR_NO（4字节）：</font></p>
<p>log buffer由log block组成，log buffer内部好似一个数组，因此该选项用来标记log block在数组中的位置。</p>
</li>
<li><p><font color='orange'>LOG_BLOCK_HDR_DATA_LEN（2字节）：</font></p>
<p>表示log block所占用的大小。</p>
</li>
<li><p><font color='orange'>LOG_BLOCK_FIRST_REC_GROUP（2字节）：</font></p>
<p>表示 log block 中第一个日志所在的偏移量，如果和2标题相同，表示当前 log block 不包含新的日志。</p>
</li>
<li><p><font color='orange'>LOG_BLOCK_CHECKPOINT_NO（4字节）：</font></p>
<p>表示 log block 最后被写入时的检查点第 4 字节的值。</p>
</li>
</ol>
</li>
<li><p><strong>日志内容（492字节）</strong></p>
</li>
<li><p><strong>日志块尾（8字节</strong>）</p>
<p>由 1个部分组成：LOG_BLOCK_TRL_NO（4字节），其值和LOG_BLOCK_HDR_NO相同（在函数 log_block_init中被初始化）。</p>
</li>
</ol>
<h4 id="redo-log-文件"><a href="#redo-log-文件" class="headerlink" title="redo log 文件"></a>redo log 文件</h4><h5 id="redo-log-格式"><a href="#redo-log-格式" class="headerlink" title="redo log 格式"></a>redo log 格式</h5><p>不同的数据库操作会有对应的重做日志格式，InnoDB的存储管理是基于页的，故格式也是基于页的。虽然格式不同，但有着通用的头部格式。</p>
<img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20201214212237416.png" alt="image-20201214212237416" style="zoom:150%;" />

<p>通用头部格式由3部分组成：</p>
<ol>
<li>redo_log_type：重做日志的类型。</li>
<li>space：表空间ID。</li>
<li>page_no：页的偏移量。</li>
<li>redo log body：重做日志体</li>
</ol>
<p>InnoDB 1.2.x 时，一共有51种重做日志类型。</p>
<h5 id="redo-log-group"><a href="#redo-log-group" class="headerlink" title="redo log group"></a>redo log group</h5><p><strong>log group为重做日志组，其中有多个重做日志文件。虽然源码中支持 log group 的镜像功能，但在 ha_innobase.cc 文件中禁止了该功能。因此InnoDB实际只有一个 log group</strong>。</p>
<p>log group由多个重做日志文件组成，其中每个日志文件的大小一样，且在InnoDB 1.2.x 前，重做日志文件的总大小要小于 4G（不能等于4G），1.2.x开始重做日志文件总大小提高为 512G.</p>
<p>InnoDB运行中，log buffer会将内存中的 log block以一种规则刷新到磁盘，这个规则如下：</p>
<ol>
<li>事务提交时。</li>
<li>当 log buffer 中有一半的内存空间已经被使用时。</li>
<li>log checkpoint时。</li>
</ol>
<p><strong>log block 的写入追加在 redo log file 的最后部分，当一个 redo log file 被写满时，会接着写下一个 redo log file，其使用的方式为 round-robin（轮询调度）</strong>。</p>
<p>可能认为 redo log file 的写入是顺序的，其实不然，因为每个 redo log file 的前2K部分不保存 log block 信息，而是4个512字节的块，4个块的内容如下：</p>
<ol>
<li>log file header（512字节）</li>
<li>checkpoint1（512字节）</li>
<li>空（512字节）</li>
<li>checkpoint2（512字节）</li>
</ol>
<p><font color='red'>注意：上述这几项信息仅在每个 log group 中的第一个 redo log file中进行存储，其它redo log file中仅保留这些空间，但不保存上述这些信息。</font></p>
<h4 id="LSN"><a href="#LSN" class="headerlink" title="LSN"></a>LSN</h4><p><strong>LSN是 Log Sequence Number 的缩写，代表日志序列号。InnoDB中，LSN占用 8 字节，且单调递增</strong>。</p>
<p>LSN含义有：</p>
<ol>
<li>重做日志写入总量。</li>
<li>checkpoint位置。</li>
<li>页的版本。</li>
</ol>
<p><strong>Log sequence number 表示当前的LSN，Log flushed up to 表示刷新到重做日志文件的LSN，Last checkpoint at 表示刷新到磁盘的LSN</strong>。</p>
<h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p><strong>InnoDB在启动时会尝试进行恢复操作。因为重做日志是物理日志，因此恢复的速度比逻辑日志要快。与此同时InnoDB自身也对此进行了优化，如顺序读取及并行应用重做日志</strong>。</p>
<p>由于 checkpoint 表示已经刷新到磁盘页上的LSN，因此恢复时只需恢复LSN开始的日志部分。</p>
<h3 id="7-2-2、undo"><a href="#7-2-2、undo" class="headerlink" title="7.2.2、undo"></a>7.2.2、undo</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p><font color='orange'>undo日志为事务回滚提供服务。</font></p>
<p><strong>redo存放于日志文件中，undo存放在数据库内部一个段中，这个段称为 undo段。undo段位于共享表空间中</strong>。</p>
<p>InnoDB回滚时，实际上做的是与先前相反的工作。每个INSERT，会有一个DELETE；每个DELETE，会有一个INSERT；对于UPDATE，会执行一个相反的UPDATE，将修改前的行放回去。</p>
<p><strong>除了回滚，undo另一个作用是MVCC。undo log会产生redo log，undo log也需要持久性保护</strong>。</p>
<h4 id="undo存储管理"><a href="#undo存储管理" class="headerlink" title="undo存储管理"></a>undo存储管理</h4><p><strong>InnoDB对undo的管理方式同样采用段的方式，该段和之前介绍的段有所不同。首先InnoDB有rollback segment，每个回滚段中记录了1024个undo log segment，而在每个undo log segment中进行undo页的申请</strong>。共享表空间偏移量为 5 的页记录了所有rollback segement header所在的页，这个页的类型为<code>FIL_PAGE_TYPE_SYS</code>。</p>
<p>InnoDB 1.1之前只有一个回滚段，因此同时在线事务限制为1024。从 1.1开始支持128个rollback segment，故同时在线事务数提高为128 * 1024。但是这些回滚段都存储于共享表空间中。从InnoDB 1.2版本开始，可通过参数对回滚段做进一步的设置。这些参数如下：</p>
<ol>
<li><p><strong>innodb_undo_directory</strong></p>
<p>设置回滚段文件所在的路径。意味着可以存放在共享表空间以外的位置，即可以设置为独立表空间。参数默认值为“.”，表示当前InnoDB的目录。</p>
</li>
<li><p><strong>innodb_undo_logs</strong></p>
<p>设置回滚段的个数，默认值为128。InnoDB 1.2版本中，该参数用来替换之前版本的参innodb_rollback_segments。</p>
</li>
<li><p><strong>innodb_undo_tablespaces</strong></p>
<p>设置构成 回滚段 文件的数量，默认值为2。设置该参数后，会在路径 innodb_undo_directory看到undo为前缀的文件，该文件代表 回滚段 文件。</p>
</li>
</ol>
<p>要注意，事务在 undo log segment 中分配页并写入 undo log 的同时需要写入重做日志。当事务提交时，InnoDB会做以下两件事：</p>
<ol>
<li>将 undo log 放入列表中，以供之后的 purge操作。</li>
<li>然后判断 undo页的使用空间是否小于3&#x2F;4，若小于，则表示该undo页可以重用。</li>
</ol>
<p>事务提交后不能马上删除 undo log 及 undo log 所在的页，因为此时可能还有其它事务需要通过 undo log 来获取行记录的旧版本。故事务提交时将 undo log 放入一个链表中，然后判断 undo页的使用空间是否小于3&#x2F;4，若小于，则表示该undo页可以重用，之后新的undo log记录在当前undo log的后面。是否可以最终删除 undo log 及 undo log 所在的页将由 purge线程来判断。purge操作需要涉及磁盘的离散读取操作，是一个比较慢的过程。</p>
<p>可以通过命令<code>SHOW ENGINE INNODB STATUS</code>来查看链表中 undo log 的数量。</p>
<h4 id="undo-log格式"><a href="#undo-log格式" class="headerlink" title="undo log格式"></a>undo log格式</h4><p>InnoDB中，undo log分为：</p>
<ol>
<li><p><strong>insert undo log</strong></p>
<p>指 insert操作中产生的 undo log，因为 insert操作的记录只对事务本身可见，故该 undo log 可以在事务提交后直接删除。无需进行 purge操作。</p>
<p>下图中显示了 insert undo log的格式，其中 * 代表对存储的字段进行了压缩。nex记录的是下一个 undo log 的位置，通过该next可知一个 undo log 所占空间字节数；type_cmpl占用1个字节，记录的是 undo 的类型，对于 insert undo log，该值总为11；undo_no记录事务的ID；table_id记录 undo log 所对应的表对象；</p>
</li>
<li><p><strong>update undo log</strong>（记录内容多，占用空间大）</p>
<p>记录的是对 delete 和 update 操作产生的 undo log。该 undo log 可能需要提供 MVCC机制，因此不能在事务提交时就删除。提交时放入 undo log 链表，等待 purge线程进行最后的删除。</p>
<p>next、start、undo、undo_no、table_id与上面的insert undo log相同，这里的 type_cmpl 由于update undo log 本身还有分类，故可能的值如下：</p>
<ul>
<li>12：TRX_UNDO_UPD_EXIST_REC 更新 non-delete-mark 的记录。</li>
<li>13：TRX_UNDO_UPD_DEL_REC 将 delete的记录标记为 not delete。</li>
<li>14：TRX_UNDO_DEL_MARK_REC 将记录标记为 delete。</li>
</ul>
</li>
</ol>
<p>两种log的格式如下：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20201215172344342.png" alt="image-20201215172344342"></p>
<h4 id="查看undo信息"><a href="#查看undo信息" class="headerlink" title="查看undo信息"></a>查看undo信息</h4><ol>
<li>通过查看数据字典表<code>INNODB_TRX_ROLLBACK_SEGMENT</code>来获取。该表记录了回滚段信息。</li>
<li>通过查看数据字典表<code>INNODB_TRX_UNDO</code>来获取，该表记录了事务对应的 undo log。</li>
</ol>
<h3 id="7-2-3、purge"><a href="#7-2-3、purge" class="headerlink" title="7.2.3、purge"></a>7.2.3、purge</h3><h4 id="purge职责"><a href="#purge职责" class="headerlink" title="purge职责"></a>purge职责</h4><p><strong>delete和update操作可能并不直接删除原有的数据，而真正的删除由purge线程来完成</strong>。</p>
<p>InnoDB支持MVCC，故记录不能在事务提交时立即被处理，因为此时该记录可能正在被其它事务使用，所以是否可以真正删除可以交给purge来判断。</p>
<h4 id="purge原理"><a href="#purge原理" class="headerlink" title="purge原理"></a>purge原理</h4><p><strong>InnoDB中有一个 history 列表，它根据 事务提交顺序 将 undo log 进行链接</strong>。</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20201215201507990.png" alt="image-20201215201507990"></p>
<p>purge执行过程中，InnoDB会先从 history list 中找到第一个需要被清理的记录，这里为 trx1，清理后InnoDB会在 trx1 的 undo log 所在的页中继续寻找是否存在其它可以被清理的记录，这里会找到事务 trx3，接着找到 trx5，但发现 trx5 被其他事务所引用而不能清理，故会再次去 history list 中按顺序继续查找，发现了 trx2，接着找到 trx2所在的页，然后再把事务trx6、trx4的记录进行处理。由于 undo page2 中所有的页都被清理了，因此该 undo page 可以被重用。</p>
<h4 id="purge相关参数"><a href="#purge相关参数" class="headerlink" title="purge相关参数"></a>purge相关参数</h4><ol>
<li><p><font color='orange'>innodb_purge_batch_size</font></p>
<p>全局动态参数，用来设置每次 purge 操作清理的 undo  page 数量。InnoDB 1.2之前，默认值为20。从 1.2 开始，默认值为300（MySQL5.7.33）。</p>
</li>
<li><p><font color='orange'>innodb_max_purge_lag</font></p>
<p>该参数用来控制 history list 的长度，若实际长度超过该值，会“延缓”DML操作。默认值为0，表示不对 history list 做任何限制，当大于0时，就会延缓 DML操作，延缓算法如下：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">delay(毫秒)</span> <span class="token punctuation">=</span> <span class="token value attr-value">((length(history_list) - innodb_max_purge_lag) * 10) - 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><font color='orange'>delay对象是行，而并非是一个DML操作。delay的统计会在每一次 purge 操作完成后，重新进行计算。</font></p>
</li>
<li><p><font color='orange'>innodb_max_purge_lag_delay</font></p>
<p>InnoDB 1.2 新增该参数，用来控制 delay 的最大毫秒数。当小标题2中的公式计算后的delay值大于该参数值时，以该参数值为准。进而避免 由于 purge 操作缓慢导致其它 SQL 线程出现无限制的等待。</p>
</li>
</ol>
<h3 id="7-2-4、group-commit"><a href="#7-2-4、group-commit" class="headerlink" title="7.2.4、group commit"></a>7.2.4、group commit</h3><h4 id="group-commit定义"><a href="#group-commit定义" class="headerlink" title="group commit定义"></a>group commit定义</h4><p><strong>若事务是非只读事务，则每次事务提交时需要执行一次fsync操作，来保证重做日志准确写入磁盘。fsync性能有限，为提高磁盘fsync性能，提供了group commit功能，即一次fsync可以刷新多个日志至文件</strong>。</p>
<p>InnoDB下的事务提交会执行两个阶段操作：</p>
<ol>
<li>修改内存中事务对应的信息，并且将日志写入重做日志缓冲。</li>
<li>调用fsync将确保日志都从重做日志缓冲写入磁盘。</li>
</ol>
<p>第二步较第一步是一个更慢的过程，因为该过程需要与磁盘打交道。当事务A执行第二步时事务B可以同时继续执行第一步，事务B执行完第一步后，事务A和事务B的重做日志就可以通过一次fsync操作即可全部刷新到磁盘，大大提高了数据库整体的性能。</p>
<h4 id="group-commit问题"><a href="#group-commit问题" class="headerlink" title="group commit问题"></a>group commit问题</h4><p><font color='orange'>注意：InnoDB 1.2之前，开启二进制日志会使group commit功能失效。原因是：为了保证存储引擎层事务和二进制日志的一致性，二者之间使用了两阶段事务，</font>其步骤如下：</p>
<ol>
<li>当事务提交时，InnoDB进行prepare操作。</li>
<li>MySQL上层写入二进制日志。</li>
<li>InnoDB引擎将日志写入重做日志文件。<ol>
<li>修改内存中事务对应的信息，且将日志写入重做日志缓冲。</li>
<li>调用fsync将确保日志都从重做日志缓冲写入磁盘。</li>
</ol>
</li>
</ol>
<p><font color='red'>注意：每个步骤都需要进行一次 fsync 操作才能保证上下两层数据的一致性。步骤2的 fsync 由参数 <code>sync_binlog</code>控制，步骤3的 fsync 由参数 <code>innodb_flush_log_at_trx_commit</code>控制。</font></p>
<p>为了保证二进制日志写入顺序和InnoDB层事务提交顺序一致，提供 prepare_commit_mutex 锁，但开启该锁后，步骤3中的步骤1 不能在其他事务执行步骤3中的步骤2时执行，进而导致 group commit 失效。</p>
<p>那为何要保证两者的一致性呢？因为备份及恢复的需要。</p>
<p><strong>最终解决方法为 Binary Log Group Commit。</strong></p>
<p><strong>MySQL数据库上层进行提交时按顺序将其放入一个队列中，队列中第一个事务是leader，其它事务是follower，leader控制其它follower的行为。</strong>BLGC的步骤分为三步：</p>
<ol>
<li><font color='orange'>Flush阶段</font>：将每个事务的二进制日志写入内存中的队列中。</li>
<li><font color='orange'>Sync阶段</font>：将队列中的二进制日志刷新到磁盘，若队列中有多个事务，则一次fsync操作就可以完成所有二进制日志的写入，这就是BLGC。</li>
<li><font color='orange'>Commit阶段</font>：从leader开始根据顺序调用存储引擎层事务的提交，InnoDB本身就支持GroupCommit，因此修复了之前GroupCommit失效的问题。</li>
</ol>
<h4 id="group-commit参数"><a href="#group-commit参数" class="headerlink" title="group commit参数"></a>group commit参数</h4><p>group commit 效果 依赖于 队列中的事务数量，队列事务数量多，效果就会好。参数 <code>binlog_max_flush_queue_time</code>用来控制 Flush 阶段 事务等待的时间，即事务完成提交后不会立即进入 Sync阶段，而是等待 事务数量增多后一同处理。参数默认为0，推荐为0，除非数据中有大量连接，且不断进行事务的写入或更新。</p>
<h2 id="7-3、事务隔离级别"><a href="#7-3、事务隔离级别" class="headerlink" title="7.3、事务隔离级别"></a>7.3、事务隔离级别</h2><h3 id="7-3-1、简介"><a href="#7-3-1、简介" class="headerlink" title="7.3.1、简介"></a>7.3.1、简介</h3><p>SQL标准定义的四个隔离级别为：</p>
<ul>
<li><p><strong>READ UNCOMMITTED：读未提交</strong></p>
</li>
<li><p><strong>READ COMMITTED：读已提交</strong></p>
<p>MySQL 5.1中，该隔离级别只能适用于 replication 二进制日志为 ROW 的格式。如果二进制日志工作在 STATEMENT 下，则会出错。</p>
</li>
<li><p><strong>REPEATABLE READ（MySQL默认）：可重复读</strong></p>
<p>InnoDB在该隔离级别下，使用Next-Key Lock锁算法，因此可避免幻读发生。</p>
</li>
<li><p><strong>SERIALIZABLE：串行化</strong></p>
<p>该隔离级别下，InnoDB会对每个 SELECT 语句后自动加上 LOCK IN SHARE MODE，即加一个共享锁。通常该隔离级别被用于分布式事务。</p>
</li>
</ul>
<blockquote>
<p><font color='red'>Oracle并不支持<code>读未提交</code>和<code>可重复读</code>隔离级别。</font></p>
</blockquote>
<h3 id="7-3-2、配置隔离级别"><a href="#7-3-2、配置隔离级别" class="headerlink" title="7.3.2、配置隔离级别"></a>7.3.2、配置隔离级别</h3><p>在InnoDB中，可以使用以下命令来设置当前会话或全局的事务隔离级别：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token punctuation">[</span><span class="token keyword">GLOBAL</span> <span class="token operator">|</span> <span class="token keyword">SESSION</span><span class="token punctuation">]</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span>
<span class="token punctuation">(</span>
	<span class="token keyword">READ</span> <span class="token keyword">UNCOMMITTED</span> <span class="token operator">|</span>
	<span class="token keyword">READ</span> <span class="token keyword">COMMITTED</span> <span class="token operator">|</span>
	<span class="token keyword">REPEATABLE</span> <span class="token keyword">READ</span> <span class="token operator">|</span>
	<span class="token keyword">SERIALIZABLE</span>
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>设置隔离级别的示例如下：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 配置当前会话隔离级别</span>
<span class="token keyword">set</span> <span class="token keyword">session</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> <span class="token keyword">read</span> <span class="token keyword">committed</span><span class="token punctuation">;</span>
<span class="token comment"># 配置全局隔离级别</span>
<span class="token keyword">set</span> <span class="token keyword">global</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> <span class="token keyword">read</span> <span class="token keyword">committed</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><font color='orange'>如果想在 MySQL启动时就设置事务的隔离级别，则需要修改MySQL配置文件，</font>加入如下内容：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">[mysqld]
<span class="token key attr-name">transaction-isolation</span> <span class="token punctuation">=</span> <span class="token value attr-value">READ-COMMITTED</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="7-3-3、查看隔离级别"><a href="#7-3-3、查看隔离级别" class="headerlink" title="7.3.3、查看隔离级别"></a>7.3.3、查看隔离级别</h3><p>查看当前会话的隔离级别，可以使用：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> @<span class="token variable">@transaction_isolation</span><span class="token punctuation">;</span> 
<span class="token comment">-- 或者</span>
<span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%transaction_isolation%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>查看全局隔离级别，可以通过如下方式：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> @<span class="token variable">@global.transaction_isolation</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="7-4、分布式事务"><a href="#7-4、分布式事务" class="headerlink" title="7.4、分布式事务"></a>7.4、分布式事务</h2><h3 id="7-4-1、MySQL分布式事务"><a href="#7-4-1、MySQL分布式事务" class="headerlink" title="7.4.1、MySQL分布式事务"></a>7.4.1、MySQL分布式事务</h3><p>InnoDB引擎提供了对XA事务的支持，并通过XA事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源参与到一个安全的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有事务要么都提交，要么都回滚，这对于事务原有的ACID要求又有了提高。另外，在使用分布式事务时，InnoDB引擎的事务隔离级别必须设置为SERIALIZABLE。</p>
<p><font color='orange'>XA事务由一个或多个资源管理器、一个事务管理器以及一个应用程序组成。</font></p>
<ol>
<li>资源管理器：提供访问事务资源的方法，通常一个数据库就是一个资源管理器。</li>
<li>事务管理器：协调参与全局事务中的各个事务。需要和参与全局事务的所有资源管理器进行通信。</li>
<li>应用程序：定义事务的边界，指定全局事务中的操作。</li>
</ol>
<p>在MySQL数据库的分布式事务中，资源管理器就是MySQL数据库，事务管理器为连接MySQL的客户端。</p>
<h3 id="7-4-2、内部XA事务"><a href="#7-4-2、内部XA事务" class="headerlink" title="7.4.2、内部XA事务"></a>7.4.2、内部XA事务</h3><p>内部XA事务存在于 引擎与插件 之间，或引擎与引擎之间。常见的是内部XA事务存在于 binlog 与 InnoDB 引擎之间。</p>
<h2 id="7-5、长事务"><a href="#7-5、长事务" class="headerlink" title="7.5、长事务"></a>7.5、长事务</h2><p>长事务是执行时间较长的事务。可能需要1个小时，也可能需要4、5个小时，这取决于数据库的硬件配置。</p>
<p>长事务可以通过转化为小批量的事务来进行处理。当事务发生错误时，只需恢复一部分数据。</p>
<h2 id="7-6、MVCC"><a href="#7-6、MVCC" class="headerlink" title="7.6、MVCC"></a>7.6、MVCC</h2><h3 id="7-6-1、定义"><a href="#7-6-1、定义" class="headerlink" title="7.6.1、定义"></a>7.6.1、定义</h3><p><strong>MVCC （Multiversion Concurrency Control）意为多版本并发控制。MVCC 通过数据记录的多个版本来实现并发控制，且保证了InnoDB引擎下的一致性读</strong>。</p>
<h3 id="7-6-2、快照读与当前读"><a href="#7-6-2、快照读与当前读" class="headerlink" title="7.6.2、快照读与当前读"></a>7.6.2、快照读与当前读</h3><p>InnoDB引擎下，MVCC较好的处理了读写冲突，提高了数据库并发性能。即使存在读写冲突也无需加锁，还可以非阻塞并发读 ，这里的读指的是【快照读】。当前读需要加锁，是悲观锁的一种体现。MVCC本质是乐观锁的一种体现。</p>
<h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>快照读又叫一致性读，读取的是快照数据。不加锁的 SELECT 都属于快照读，即不加锁的非阻塞读。</p>
<p>快照读基于MVCC实现，避免加锁，降低了开销。 </p>
<p>快照读的前提是不能设置隔离级别为串行级别，串行级别下的快照读会退化成当前读。</p>
<h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>当前读读取的是最新数据，且会对记录加锁，加锁的SELECT及普通的增删改都会执行当前读。</p>
<h3 id="7-6-3、隐藏字段"><a href="#7-6-3、隐藏字段" class="headerlink" title="7.6.3、隐藏字段"></a>7.6.3、隐藏字段</h3><p>InnoDB 引擎的聚簇索引中包含两个必要的隐藏列。</p>
<ul>
<li><font color='orange'>trx_id</font>：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 事务id 赋值给trx_id 隐藏列。 </li>
<li><font color='orange'>roll_pointer</font>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/undo%E6%97%A5%E5%BF%97-%E7%89%88%E6%9C%AC%E9%93%BE%E5%9B%BE1.png"></p>
<blockquote>
<p>除了以上两个隐藏字段外，还有一个隐藏字段<code>row_id</code>。当一个表中没有主键时会使用Unique列来做主键，若没有Unique列，那么会生成一个row_id来作为主键。</p>
<p>insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。</p>
</blockquote>
<h3 id="7-6-4、版本链"><a href="#7-6-4、版本链" class="headerlink" title="7.6.4、版本链"></a>7.6.4、版本链</h3><p>假设之后两个事务id分别为 10 、 20 的事务对这条记录进行 UPDATE 操作，操作流程如下：</p>
<table>
<thead>
<tr>
<th align="center">时间顺序</th>
<th align="left">事务10</th>
<th align="left">事务20</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">BEGIN;</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"></td>
<td align="left">BEGIN;</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">UPDATE student SET name&#x3D;”李四” WHERE id&#x3D;1</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">UPDATE student SET name&#x3D;”王五” WHERE id&#x3D;1;</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">COMMIT;</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">6</td>
<td align="left"></td>
<td align="left">UPDATE student SET name&#x3D;”钱七” WHERE id&#x3D;1;</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left"></td>
<td align="left">UPDATE student SET name&#x3D;”宋八” WHERE id&#x3D;1;</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left"></td>
<td align="left">COMMIT;</td>
</tr>
</tbody></table>
<p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个 roll_pointer 属性 （ INSERT 操作对应的undo日志没有该属性，因为该记录并没有更早的版本），将这些 undo日志 连起来会形成一个链表：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/undo%E6%97%A5%E5%BF%97-%E7%89%88%E6%9C%AC%E9%93%BE%E5%9B%BE2.png"></p>
<p>对该记录每次更新后，都会将旧值放到一条 undo日志中，就算是该记录的一个旧版本，随着更新次数 的增多，所有的版本都会被 roll_pointer 属性连接成一个链表，这个链表称为【版本链】 ，版 本链的头节点就是当前记录最新的值。</p>
<p>每个版本中还包含生成该版本时对应的 事务id 。</p>
<h3 id="7-6-5、实现原理"><a href="#7-6-5、实现原理" class="headerlink" title="7.6.5、实现原理"></a>7.6.5、实现原理</h3><p><font color='orange'>MVCC 的实现依赖于：隐藏字段、Undo Log、Read View。</font></p>
<h4 id="Read-View简介"><a href="#Read-View简介" class="headerlink" title="Read View简介"></a>Read View简介</h4><p>READ UNCOMMITTED 隔离级别的事务可以读取最新数据。SERIALIZABLE 隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。READ COMMITTED 和 REPEATABLE READ 隔离级别的事务可以读到 已提交 的最新数据。</p>
<p><font color='orange'>undo日志版本链中，哪个版本当前事务可见，哪个版本当前事务不可见。这些问题都由ReadView来解决。</font></p>
<p>ReadView中主要包含4个重要内容：</p>
<ul>
<li><font color='orange'>creator_trx_id </font>：创建这个 Read View 的事务 ID。</li>
<li><font color='orange'>trx_ids</font>：生成ReadView时当前系统中活跃的读写事务的事务id列表 。</li>
<li><font color='orange'>up_limit_id</font>：活跃事务中最小事务 ID。</li>
<li><font color='orange'>low_limit_id</font>：表示生成ReadView时系统中应该分配给下一个事务的 id 值。low_limit_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。</li>
</ul>
<blockquote>
<p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1， 2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时， trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</p>
</blockquote>
<h4 id="Read-View规则"><a href="#Read-View规则" class="headerlink" title="Read View规则"></a>Read View规则</h4><p>有了ReadView，在访问某条记录时，只需要按照如下逻辑顺序来判断就可知道某个版本是否可见。</p>
<ol>
<li>如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问 它自己修改过的记录，所以该版本【可以】被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id 值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本【可以】被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id 值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本【不可以】被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。<ul>
<li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本【不可以】被访问。</li>
<li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本【可以】被访问。</li>
</ul>
</li>
</ol>
<h3 id="7-6-6、MVCC操作流程"><a href="#7-6-6、MVCC操作流程" class="headerlink" title="7.6.6、MVCC操作流程"></a>7.6.6、MVCC操作流程</h3><p>当查询一条记录的时候，系统如何通过MVCC找到它： </p>
<ol>
<li>首先获取事务自己的版本号，也就是事务 ID；</li>
<li>获取 ReadView；</li>
<li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li>
<li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</li>
<li>最后返回符合规则的数据。</li>
</ol>
<p><strong>当隔离级别是读已提交（Read Committed）时，每一次 SELECT 都会重新获取一次 Read View</strong>。</p>
<blockquote>
<p>注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生 不可重复读或者幻读的情况。</p>
</blockquote>
<p><strong>当隔离级别是可重复读时，仅在第一次 SELECT 时获取一次Read View，后面所有SELECT都会复用这个Read View</strong>。这也就解决了不可重复读的问题。</p>
<h3 id="7-6-7、总结"><a href="#7-6-7、总结" class="headerlink" title="7.6.7、总结"></a>7.6.7、总结</h3><p><strong>MVCC仅在 READ COMMITTD、REPEATABLE READ两种隔离级别下会执行快照读</strong>，进而提高并发性能。 </p>
<p>核心在于ReadView，READ COMMITTD、REPEATABLE READ 两个隔离级别的最大不同点就是ReadView生成时机不同：</p>
<ul>
<li>READ COMMITTD 会在每一次普通SELECT操作前生成一个ReadView。</li>
<li>REPEATABLE READ 仅在第一次普通SELECT操作前生成一个ReadView，之后查询都会复用这一个ReadView。</li>
</ul>
<p>通过MVCC可解决：</p>
<ul>
<li>读写阻塞问题。</li>
<li>降低死锁概率。</li>
<li>解决快照读问题。</li>
</ul>
<h2 id="7-7、总结"><a href="#7-7、总结" class="headerlink" title="7.7、总结"></a>7.7、总结</h2><h3 id="7-7-1、事务使用禁忌"><a href="#7-7-1、事务使用禁忌" class="headerlink" title="7.7.1、事务使用禁忌"></a>7.7.1、事务使用禁忌</h3><ul>
<li>严禁 循环中提交。</li>
<li>严禁 使用自动提交。</li>
<li>严禁 使用自动回滚。</li>
</ul>
<h1 id="8、备份与恢复"><a href="#8、备份与恢复" class="headerlink" title="8、备份与恢复"></a>8、备份与恢复</h1><h2 id="8-1、备份与恢复概述"><a href="#8-1、备份与恢复概述" class="headerlink" title="8.1、备份与恢复概述"></a>8.1、备份与恢复概述</h2><h3 id="8-1-1、根据备份方法的不同，备份可分为："><a href="#8-1-1、根据备份方法的不同，备份可分为：" class="headerlink" title="8.1.1、根据备份方法的不同，备份可分为："></a>8.1.1、根据备份方法的不同，备份可分为：</h3><ol>
<li><strong>Hot Backup（热备）</strong>：指在数据库运行中直接备份，对正在运行的数据库操作没有任何的影响。</li>
<li><strong>Cold Backup（冷备）</strong>：指在数据库停止的情况下，一般只需要复制相关的数据库物理文件即可。</li>
<li><strong>Warm Backup（温备）</strong>：指在数据库运行中进行的，但是会对当前数据库的操作有所影响，如加一个全局读锁以保证备份数据的完整性。</li>
</ol>
<p>		</p>
<h3 id="8-1-2、按照备份后文件的内容，备份又可分为："><a href="#8-1-2、按照备份后文件的内容，备份又可分为：" class="headerlink" title="8.1.2、按照备份后文件的内容，备份又可分为："></a>8.1.2、按照备份后文件的内容，备份又可分为：</h3><ol>
<li><strong>逻辑备份</strong>：指备份出的文件内容是可读的，一般是文本文件，内容一般是由一条条SQL语句，或表内实际数据组成。</li>
<li><strong>裸文件备份</strong>：指复制数据库的物理文件，既可以是在数据库运行中的复制，也可以是在数据库停止时直接的数据文件复制。</li>
</ol>
<h3 id="8-1-3、按照备份数据库的内容，备份可分为："><a href="#8-1-3、按照备份数据库的内容，备份可分为：" class="headerlink" title="8.1.3、按照备份数据库的内容，备份可分为："></a>8.1.3、按照备份数据库的内容，备份可分为：</h3><ol>
<li><strong>完全备份</strong>：对数据库进行一个完整备份。</li>
<li><strong>增量备份</strong>：在上次完全备份的基础上，对于更改的数据进行备份。</li>
<li><strong>日志备份</strong>：对于MySQL数据库二进制日志的备份，通过对一个完全备份进行二进制日志的重做来完成数据库的point-in-time的恢复工作。</li>
</ol>
<h2 id="8-2、逻辑备份与恢复"><a href="#8-2、逻辑备份与恢复" class="headerlink" title="8.2、逻辑备份与恢复"></a>8.2、逻辑备份与恢复</h2><h3 id="8-2-1、备份"><a href="#8-2-1、备份" class="headerlink" title="8.2.1、备份"></a>8.2.1、备份</h3><h4 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h4><h5 id="简介-16"><a href="#简介-16" class="headerlink" title="简介"></a>简介</h5><p><strong>mysqldump工具最初由Igor Romanenko编写，通常用来完成数据库备份的转存及不同数据库间的移植</strong>。</p>
<p>mysqldump语法如下：</p>
<pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">mysqldump <span class="token punctuation">[</span>arguments<span class="token punctuation">]</span> > file_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><ol>
<li><p>仅导出结构，不导出数据</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysqldump <span class="token operator">-</span>uroot <span class="token operator">-</span>p <span class="token comment">--opt -d 数据库名 > xxx-schema.sql　　</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>仅导出数据，不导出结构</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysqldump <span class="token operator">-</span>uroot <span class="token operator">-</span>p <span class="token operator">-</span>t 数据库名 <span class="token operator">></span> xxx<span class="token operator">-</span><span class="token keyword">data</span><span class="token punctuation">.</span><span class="token keyword">sql</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>导出表结构和数据</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysqldump <span class="token operator">-</span>uroot <span class="token operator">-</span>p 数据库名 <span class="token operator">></span> xxx<span class="token operator">-</span><span class="token keyword">all</span><span class="token punctuation">.</span><span class="token keyword">sql</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>导出某个表的表结构</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysqldump <span class="token operator">-</span>uroot <span class="token operator">-</span>p <span class="token operator">-</span>B 数据库名 <span class="token comment">--table 表名 > xxx-table-schema.sql</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>导出指定的数据库</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysqldump <span class="token comment">--databases db1 db2 db3 > dump.sql</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>导出所有数据库</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysqldump <span class="token comment">--all-databases > dump.sql</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>对 test 这个架构进行备份</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysqldump <span class="token comment">--single-transaction test > test_backup.sql</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<h4 id="select…into-outfile"><a href="#select…into-outfile" class="headerlink" title="select…into outfile"></a>select…into outfile</h4><h5 id="简介-17"><a href="#简介-17" class="headerlink" title="简介"></a>简介</h5><p>SELECT…INTO语句也是一种逻辑备份的方法，准确的说是导出一张表中的数据。</p>
<h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><p>select into outfile 用法如下：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FROM</span> TABLE_A
<span class="token keyword">INTO</span> <span class="token keyword">OUTFILE</span> <span class="token string">"/path/to/file"</span>
<span class="token keyword">FIELDS</span> <span class="token keyword">TERMINATED</span> <span class="token keyword">BY</span> <span class="token string">','</span> 
<span class="token keyword">OPTIONALLY</span> <span class="token keyword">ENCLOSED</span> <span class="token keyword">BY</span> <span class="token string">'"'</span>
<span class="token keyword">LINES</span> <span class="token keyword">TERMINATED</span> <span class="token keyword">BY</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>load data infile 用法如下：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">LOAD</span> <span class="token keyword">DATA</span> <span class="token keyword">INFILE</span> <span class="token string">"/path/to/file"</span> <span class="token keyword">INTO</span> <span class="token keyword">TABLE</span> table_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>注意：如果导出时使用了<code>(FIELDS TERMINATED BY &#39;,&#39;)</code>、<code>(OPTIONALLY ENCLOSED BY &#39;&quot;&#39;)</code>、<code>(LINES TERMINATED BY &#39;\n&#39;)</code>语句，那么LODA时也要加上同样的分隔限制语句。</p>
<h3 id="8-2-2、恢复"><a href="#8-2-2、恢复" class="headerlink" title="8.2.2、恢复"></a>8.2.2、恢复</h3><h4 id="mysqlimport"><a href="#mysqlimport" class="headerlink" title="mysqlimport"></a>mysqlimport</h4><p><strong>mysqlimport是MySQL数据库提供的一个命令行程序，本质上是 LOAD DATA INFILE 的命令接口，而且大多数的选项都和 LOAD DATA INFILE 语法相同</strong>，其语法格式如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysqlimport <span class="token punctuation">[</span>option<span class="token punctuation">]</span> db_name textfile1 <span class="token punctuation">[</span>textfile2 <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><font color='red'>注意：与 LOAD DATA INFILE不同的是，mysqlimport命令可以用来导入多张表。并且通过<code>-user-thread</code>参数并发地导入不同的文件，这里的并发指的是并发导入多个文件，而并非并发地导入一个文件，这是明显区别。</font></p>
<p>mysqldump的恢复操作较简单，备份文件就是导出的SQL语句，一般只要执行该文件即可。可通过如下方法实现该操作：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-p</span> <span class="token operator">&lt;</span> test_backup.sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>因为逻辑备份的文件是由 SQL 语句组成，故可以通过 SOURCE 命令来执行逻辑备份文件，命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /home/mysql/test_backup.sql<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="load-data-infile"><a href="#load-data-infile" class="headerlink" title="load data infile"></a>load data infile</h4><p><strong>通过<code>mysqldump-tab</code>或<code>SELECT INTO OUTFILE</code>导出的数据可通过命令<code>LOAD DATA INFILE</code>来进行导入</strong>。</p>
<p>要对服务器文件使用<code>LOAD DATA INFILE</code>，必须拥有FILE权。使用该命令导入文件的示例如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">load data infile <span class="token string">'/home/mysql/a.txt'</span> into table a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>为了加快 InnoDB 的导入，可以在导入时忽略对外键的检查</strong>，具体操作如下：</p>
<ol>
<li>导入前修改: set @@foreign_key_checks&#x3D;0;</li>
<li>执行导入操作：…………….</li>
<li>导入后恢复：set @@foreign_key_checks&#x3D;1;</li>
</ol>
<h2 id="8-3、二进制日志备份与恢复"><a href="#8-3、二进制日志备份与恢复" class="headerlink" title="8.3、二进制日志备份与恢复"></a>8.3、二进制日志备份与恢复</h2><h3 id="8-3-1、二进制日志备份"><a href="#8-3-1、二进制日志备份" class="headerlink" title="8.3.1、二进制日志备份"></a>8.3.1、二进制日志备份</h3><p><strong>二进制日志非常关键，用户可以通过它完成 point-in-time 恢复工作</strong>。MySQL replication 同样需要二进制日志。</p>
<p>如需使用二进制日志，则必须开启并配置：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">[mysqld]
<span class="token key attr-name">log-bin</span> <span class="token punctuation">=</span> <span class="token value attr-value">mysql-bin</span>
<span class="token key attr-name">sync_binlog</span> <span class="token punctuation">=</span> <span class="token value attr-value">1</span>
<span class="token key attr-name">innodb_support_xa</span> <span class="token punctuation">=</span> <span class="token value attr-value">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在备份二进制日志文件前，可通过 <code>FLUSH LOGS</code> 命令来生成一个新的二进制日志文件，然后备份之前的二进制日志。</p>
<h3 id="8-3-2、二进制日志恢复"><a href="#8-3-2、二进制日志恢复" class="headerlink" title="8.3.2、二进制日志恢复"></a>8.3.2、二进制日志恢复</h3><p><strong>要通过二进制日志恢复数据很简单，使用命令 mysqlbinlog 即可实现</strong>，使用方法如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysqlbinlog <span class="token punctuation">[</span>options<span class="token punctuation">]</span> log_file <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>例如，要恢复还原 binlog.0000001，可以使用如下命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysqlbinlog binlog.0000001 <span class="token operator">|</span> mysql <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-p</span> <span class="token builtin class-name">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如需恢复多个二进制日志文件，最好是同时恢复多个，不建议一个一个恢复。方法如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysqlbinlog binlog.<span class="token punctuation">[</span><span class="token number">0</span>-10<span class="token punctuation">]</span>* <span class="token operator">|</span> mysql <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-p</span> <span class="token builtin class-name">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="8-4、冷备与热备"><a href="#8-4、冷备与热备" class="headerlink" title="8.4、冷备与热备"></a>8.4、冷备与热备</h2><h3 id="8-4-1、冷备"><a href="#8-4-1、冷备" class="headerlink" title="8.4.1、冷备"></a>8.4.1、冷备</h3><h4 id="简介-18"><a href="#简介-18" class="headerlink" title="简介"></a>简介</h4><p><strong>对于InnoDB引擎的冷备，只需要备份MySQL数据库的frm文件，共享表空间文件，独立表空间文件，重做日志文件。另外建议定期备份MySQL数据库的配置文件my.cnf，这有利于恢复</strong>。</p>
<h4 id="冷备优点"><a href="#冷备优点" class="headerlink" title="冷备优点"></a>冷备优点</h4><ol>
<li>备份简单，只要复制相关文件即可。</li>
<li>备份文件易于在不同操作系统，不同MySQL版本上进行恢复。</li>
<li>恢复相当简单，只需要把文件恢复到指定位置即可。</li>
<li>恢复速度快，不需要执行任何SQL语句，也不需要重建索引。</li>
</ol>
<h4 id="冷备缺点"><a href="#冷备缺点" class="headerlink" title="冷备缺点"></a>冷备缺点</h4><ol>
<li>InnoDB引擎冷备的文件通常比逻辑文件大很多，因为表空间中存放着很多其他的数据，如undo段等。</li>
<li>冷备也不总是可以轻易地跨平台。操作系统、MySQL版本、文件大小写敏感和浮点数格式都会成为问题。</li>
</ol>
<h3 id="8-4-2、热备"><a href="#8-4-2、热备" class="headerlink" title="8.4.2、热备"></a>8.4.2、热备</h3><h4 id="ibbackup"><a href="#ibbackup" class="headerlink" title="ibbackup"></a>ibbackup</h4><p><strong>ibbackup是InnoDB官方提供的热备工具，可同时备份MyISAM引擎和InnoDB引擎表</strong>，对InnoDB表备份工作的原理如下：</p>
<ol>
<li>记录备份的开始，InnoDB存储引擎重做日志文件检查点的LSN。</li>
<li>复制共享表空间以及独立表空间文件。</li>
<li>记录复制完表空间文件后，InnoDB引擎重做日志文件检查点的LSN。</li>
<li>复制在备份时产生的重做日志。</li>
</ol>
<p>ibackup优点如下：</p>
<ol>
<li>在线备份，不阻塞任何的SQL语句。</li>
<li>备份性能好，备份的实质是复制数据库文件和重做日志文件。</li>
<li>支持压缩备份，通过选项，可以支持不同级别的压缩。</li>
<li>跨平台支持，ibbackup可以运行在Linux、Windows以及主流的UNIX系统平台上。</li>
</ol>
<p>ibbackup对InnoDB引擎表的恢复步骤：</p>
<ol>
<li>恢复表空间文件。</li>
<li>应用重做日志文件。</li>
</ol>
<p>ibbackup收费，Percona公司提供了开源、免费的XtraBackup工具，它实现了 ibbackup 所有功能，且扩展支持了真正的增量备份功能。故可使用该产品。</p>
<h4 id="XtraBackup"><a href="#XtraBackup" class="headerlink" title="XtraBackup"></a>XtraBackup</h4><p>XtraBackup 是Percona公司的开源热备工具。支持MySQL5.0以上版本。XtraBackup在GPL v2开源下发布。</p>
<p>xtrabackup包含两个工具：xtrabackup 和 innobackupex，二者区别如下：</p>
<ol>
<li>xtrabackup：只能备份innodb和xtradb两种引擎的表；</li>
<li>innobackupex：是一个封装了xtrabackup的Perl脚本，支持同时备份innodb和myisam，但备份myisam时要加一个全局读锁。且myisam不支持增量备份。</li>
</ol>
<h4 id="XtraBackup增量备份"><a href="#XtraBackup增量备份" class="headerlink" title="XtraBackup增量备份"></a>XtraBackup增量备份</h4><p><strong>StraBackup工具支持对于 InnoDB 的增量备份</strong>，其工作原理如下：</p>
<ol>
<li>首选完成一个全备，并记录下此时检查点的LSN。</li>
<li>在进行增量备份时，比较表空间中每个页的LSN是否大于上次备份时的LSN，如果是，则备份该页，同时记录当前检查点的LSN。</li>
</ol>
<h2 id="8-5、快照备份"><a href="#8-5、快照备份" class="headerlink" title="8.5、快照备份"></a>8.5、快照备份</h2><h3 id="8-5-1、简介"><a href="#8-5-1、简介" class="headerlink" title="8.5.1、简介"></a>8.5.1、简介</h3><p><strong>MySQL不支持快照功能，因此快照备份指：通过 文件系统支持的快照功能 对数据库进行备份</strong>。</p>
<h3 id="8-5-2、备份方法"><a href="#8-5-2、备份方法" class="headerlink" title="8.5.2、备份方法"></a>8.5.2、备份方法</h3><p>备份前提是将所有数据库文件放在同一文件分区中，然后对该分区进行快照操作。</p>
<blockquote>
<p><font color='orange'>LVM是Linux系统下对磁盘分区进行管理的一种机制。LVM使用 写时复制技术 来创建快照。</font></p>
</blockquote>
<h2 id="8-6、复制"><a href="#8-6、复制" class="headerlink" title="8.6、复制"></a>8.6、复制</h2><h3 id="8-6-1、复制工作原理"><a href="#8-6-1、复制工作原理" class="headerlink" title="8.6.1、复制工作原理"></a>8.6.1、复制工作原理</h3><p><strong>复制是MySQL数据库提供的一种高可用解决方案，一般用来建立大型应用</strong>。replication工作过程分3个步骤：</p>
<ol>
<li>主服务器把数据更改记录到二进制日志中。</li>
<li>从服务器把主服务器的二进制日志复制到自己的中继日志中。</li>
<li>从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。</li>
</ol>
<h3 id="8-6-2、快照加复制"><a href="#8-6-2、快照加复制" class="headerlink" title="8.6.2、快照加复制"></a>8.6.2、快照加复制</h3><p>复制可以用来作为备份，但功能不仅限于备份，其主要功能如下：</p>
<ol>
<li><p><strong>数据分布</strong></p>
<p>由于MySQL的复制并不需要很大的带宽，因此可以在不同的数据中心之间实现数据的复制。</p>
</li>
<li><p><strong>读取的负载平衡</strong></p>
<p>通过建立多个从服务器，可以将读取平均分布到这些从服务器中，且减少了主服务器的压力。一般通过 DNS 的 Round-Robin 和 Linux 的 LVS 功能都可以实现负载平衡。</p>
</li>
<li><p><strong>数据库备份</strong></p>
<p>复制对备份很有帮助，但从服务器不是备份，不能完全代替备份。</p>
</li>
<li><p><strong>高可用性和故障转移</strong></p>
<p>通过复制建立的从服务器有助于故障转移，减少故障的停机时间和恢复时间。</p>
</li>
</ol>
<p><strong>建议在从服务器上启用<code>read-only</code> 选项，这可以保证从服务器上的数据仅与主服务器进行同步，避免其他线程修改数据</strong>。如：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">[mysqld]
<span class="token key attr-name">read-only</span> <span class="token punctuation">=</span> <span class="token value attr-value">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>设置该选项后，如果操作从服务器的用户没有 SUPER 权限，则对从服务器的任何修改操作都会抛出一个错误。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">豪哥</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://hshz21.gitee.io/2023/08/07/mysql-ji-zhu-nei-mu/">https://hshz21.gitee.io/2023/08/07/mysql-ji-zhu-nei-mu/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">豪哥</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/MySQL/">
                                    <span class="chip bg-color">MySQL</span>
                                </a>
                            
                                <a href="/tags/MySQL%E5%9F%BA%E7%A1%80/">
                                    <span class="chip bg-color">MySQL基础</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wxpay.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/08/07/mysql-jing-dian-sql-lian-xi-ti-di-er-pian/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="MySQL系列-MySQL经典SQL练习题第二篇">
                        
                        <span class="card-title">MySQL系列-MySQL经典SQL练习题第二篇</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-08-07
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/MySQL/" class="post-category">
                                    MySQL
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/SQL%E7%BB%83%E4%B9%A0/">
                        <span class="chip bg-color">SQL练习</span>
                    </a>
                    
                    <a href="/tags/MySQL%E7%BB%83%E4%B9%A0/">
                        <span class="chip bg-color">MySQL练习</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/08/07/mysql-huan-jing-da-jian/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="MySQL系列-MySQL环境搭建">
                        
                        <span class="card-title">MySQL系列-MySQL环境搭建</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-08-07
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/MySQL/" class="post-category">
                                    MySQL
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/MySQL/">
                        <span class="chip bg-color">MySQL</span>
                    </a>
                    
                    <a href="/tags/MySQL%E7%8E%AF%E5%A2%83/">
                        <span class="chip bg-color">MySQL环境</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">豪哥</a>
            |&nbsp;Powered by&nbsp;<a href="https://github.com/lucky2shh" target="_blank">豪哥</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">


    <a href="mailto:3577293158@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=3577293158" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 3577293158" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
