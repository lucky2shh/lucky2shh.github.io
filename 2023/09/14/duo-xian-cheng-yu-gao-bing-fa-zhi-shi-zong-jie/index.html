<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Java系列-多线程与高并发, 豪哥博客">
    <meta name="description" content="豪哥个人博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Java系列-多线程与高并发 | 豪哥博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">豪哥博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">豪哥博客</div>
        <div class="logo-desc">
            
            豪哥个人博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/12.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Java系列-多线程与高并发</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%B9%B6%E5%8F%91/">
                                <span class="chip bg-color">并发</span>
                            </a>
                        
                            <a href="/tags/%E7%BA%BF%E7%A8%8B/">
                                <span class="chip bg-color">线程</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%B9%B6%E5%8F%91/" class="post-category">
                                并发
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-09-14
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-10-05
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    45.2k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="1、并发编程基础"><a href="#1、并发编程基础" class="headerlink" title="1、并发编程基础"></a>1、并发编程基础</h1><h2 id="1-1、线程简介"><a href="#1-1、线程简介" class="headerlink" title="1.1、线程简介"></a>1.1、线程简介</h2><h3 id="1-1-1、重要概念"><a href="#1-1-1、重要概念" class="headerlink" title="1.1.1、重要概念"></a>1.1.1、重要概念</h3><h4 id="1-1-1-1、进程"><a href="#1-1-1-1、进程" class="headerlink" title="1.1.1.1、进程"></a>1.1.1.1、进程</h4><p><strong>系统资源分配的基本单位</strong>。</p>
<p>若要实现多程序并发执行，操作系统需要一个结构来抽象和表示程序的运行。</p>
<ul>
<li>进程 是 操作系统 对正在运行程序的一种抽象。</li>
<li>进程 是 由一组机器指令、数据和堆栈等组成的能独立运行的活动实体。</li>
<li>操作系统 可以 同时运行多个进程，多个进程可并发执行和交换信息。</li>
<li>进程 在运行时需要资源，如CPU、存储空间和I&#x2F;O设备等。</li>
</ul>
<blockquote>
<p>并发：同一时刻 只有一个进程或线程 在运行，但因 切换较快 而带给人的感觉像同时在运行。</p>
<p>并行：同一时刻 有多个进程或线程 在运行。</p>
</blockquote>
<h4 id="1-1-1-2、线程"><a href="#1-1-1-2、线程" class="headerlink" title="1.1.1.2、线程"></a>1.1.1.2、线程</h4><p><strong>CPU调度的基本单位</strong>。</p>
<p>进程调度成本较高（存储空间，CPU，I&#x2F;O资源等，进程现场保护）并发切换效率较低。为提高调度效率，提出了比进程更轻量的线程。</p>
<ul>
<li>线程较进程更轻量。</li>
<li>线程能独立运行，独立调度，拥有资源（CPU资源，程序计数器等）。</li>
<li>线程调度成本较低（相对于进程来说），线程切换 不会导致 进程切换。</li>
<li>线程能并发执行，进一步提高系统并发性。</li>
<li>同一个进程的多个线程可以共享进程资源。</li>
</ul>
<h4 id="1-1-1-3、协程（coroutine）"><a href="#1-1-1-3、协程（coroutine）" class="headerlink" title="1.1.1.3、协程（coroutine）"></a>1.1.1.3、协程（coroutine）</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p><strong>最初多数用户线程被设计成协同式调度 （Cooperative Scheduling），故起名为协程（Coroutine）</strong>。由于协程会做调用栈保护、恢复工作，故又称为【有栈协程（Stackfull Coroutine）】，相反也有【无栈协程（Stackless Coroutine）】。</p>
<p>无栈协程的典型应用是各种语言中的await、async、yield等关键字。无栈协程本质上是一种有限状态机，状态保存在闭包里，比有栈协程恢复调用栈要轻量，但功能也相对有限。</p>
<p>协程主要优势是轻量，无论是有栈协程还是无栈协程，都要比传统内核线程要轻量得多。</p>
<blockquote>
<p>有栈协程有一种实现称为 纤程（Fiber）。</p>
</blockquote>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>协程特点如下：</p>
<ul>
<li>协程是【用户模式】下的【轻量级线程】，操作系统内核对协程一无所知。</li>
<li>协程调度 由 应用程序控制。</li>
<li>一个线程可以包含一个或多个协程。</li>
<li>协程有自己的寄存器上下文和栈，协程在调度切换时会将之保存，切换回来时可恢复至保存的状态。</li>
<li>协程可以保存上次的调用状态。</li>
<li>Windows下的实现叫【纤程】。</li>
<li>子程序调用总是一个入口对应一次返回，调用顺序明确。而协程的调用和子程序不同。</li>
</ul>
<p>协程主要一个线程执行，与多线程比，协程有如下优势：</p>
<ul>
<li>执行效率极高：子程序切换由程序控制，【没有线程切换】。</li>
<li>无需多线程锁机制：因为只有一个线程，也不存在同时写变量冲突。协程中操作共享资源无需加锁，只判断状态即可，故 执行效率 较 多线程 要高。</li>
</ul>
<h4 id="1-1-1-4、仟程（fiber）"><a href="#1-1-1-4、仟程（fiber）" class="headerlink" title="1.1.1.4、仟程（fiber）"></a>1.1.1.4、仟程（fiber）</h4><p>代码移植性一直是平台间交互考虑的重点，将应用程序从Unix移植到Windows的过程中会存在一系列问题，增加了移植难度和成本。</p>
<p><strong>为了更正确地将代码移植到Windows，Microsoft 在操作系统中增加了纤程（Fiber）</strong>。纤程与线程对比，有如下特性：</p>
<ul>
<li>线程在Windows内核中实现，操作系统会根据系统的调度算法对线程进行调度；纤程在用户模式下实现，内核对纤程一无所知。</li>
<li>纤程是【轻量级线程】，一个线程可包含一个或多个纤程。</li>
<li>内核会对线程进行抢占式调度，线程一次只能执行一个纤程代码（具体执行哪一个纤程由用户调度算法决定）。</li>
<li>纤程调度与线程调度没有直接关系，操作系统随时可能会夺取纤程所在线程的运行权。</li>
<li>正在运行的纤程显式切换到另一个纤程时这个纤程才可以运行。</li>
<li>Windows有一套API来实现线程转纤程或在一个线程里面创建多个纤程。</li>
</ul>
<h4 id="1-1-1-5、管程"><a href="#1-1-1-5、管程" class="headerlink" title="1.1.1.5、管程"></a>1.1.1.5、管程</h4><p>临界资源 定义如下：</p>
<ul>
<li>一次只允许一个进程访问的资源；</li>
<li>多个进程只能互斥访问的资源；</li>
</ul>
<p>访问临界资源需要同步，比如 信号量 就是一种 进程同步机制。信号量要求每个访问临界资源的进程都具有wait和signal操作。这样使大量的同步操作分散在各个进程中，不仅给系统管理带来了麻烦，且会因同步操作使用不当而导致死锁。为了解决这些问题，管程出现了。</p>
<blockquote>
<p>操作系统中管理的各种软件和硬件资源，均可用 数据结构 抽象地描述其资源特性。利用共享数据结构抽象地表示系统中的共享资源。而把对共享数据结构实施的操作定义为一组过程，如资源的请求和释放过程request和release。进程对共享资源的申请、释放和其他操作，都是通过这组过程来实现，这组过程还可以根据资源情况来选择接受或阻塞进程的访问，确保每次仅有一个进程使用该共享资源，实现临界资源互斥访问。</p>
</blockquote>
<p>管程 就是 共享资源的数据结构 和 对该共享数据结构实施的操作 两者组成的 【资源管理程序】。管程 由 【请求和释放临界资源的进程】 所调用。</p>
<p><strong>管程定义了一个数据结构和管理该数据结构的一组操作</strong>。</p>
<h3 id="1-1-2、超线程"><a href="#1-1-2、超线程" class="headerlink" title="1.1.2、超线程"></a>1.1.2、超线程</h3><p><strong>超线程（Hyper-Threading，简写HT）是Intel公司为CPU设计的一项技术，旨在提高每个处理器核心的性能</strong>。超线程技术允许单个物理核心模拟多个逻辑核心，从而能够并行处理多个线程。</p>
<p>背景：传统单核CPU中，当一个线程等待数据时核心会处于闲置状态。超线程的出现就是为了利用这种等待时间，使得CPU可以处理另一个线程，提高CPU的利用率。</p>
<p>工作原理：</p>
<ol>
<li>超线程技术允许CPU具有多于一个的线程执行单元，使得单个物理核心可以执行多个线程。</li>
<li>当一个线程因等待数据或其它原因被阻塞时，另一个线程可以使用该核心的资源，增加了核心利用率。</li>
<li>通过超线程技术进一步提升了处理器的工作效率和吞吐量。</li>
</ol>
<h3 id="1-1-3、线程优先级"><a href="#1-1-3、线程优先级" class="headerlink" title="1.1.3、线程优先级"></a>1.1.3、线程优先级</h3><p>如今的操作系统基本<strong>采用时间片规则来调度运行线程</strong>，操作系统会分出一个个时间片，然后分配给每个线程，当线程的时间片用完了就会发生线程调度，并等待着下次分配。线程得到时间片的多少就决定了线程能使用处理器资源的多少，而线程优先级就可以一定程度上决定线程得到时间片的多少。</p>
<p><strong>Java线程可通过变量<code>priority</code>来控制优先级，优先级范围从1至10。创建线程时可通过方法<code>setPriority(int)</code>来设置优先级，默认优先级为5，优先级高的线程得到时间片的数量要多于优先级低的线程</strong>。</p>
<p>针对频繁阻塞（休眠或I&#x2F;O操作）的线程需要设置较高的优先级，而偏重计算（需要较多CPU时间）的线程则可以设置较低的优先级，确保处理器不会被独占。</p>
<p><font color="red">注意：线程优先级的设定并非一定起作用，因为操作系统不一定会重视。</font></p>
<h3 id="1-1-4、线程状态"><a href="#1-1-4、线程状态" class="headerlink" title="1.1.4、线程状态"></a>1.1.4、线程状态</h3><p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210426211305027.png?token=AIGEF3PT62JG3PZWEBS73BLEZZXC4" alt="image-20210426211305027"></p>
<p>Java线程在整个生命周期中有6种不同的状态，某一个时间， 线程只能处于其中的一个状态。</p>
<ol>
<li><p><strong>NEW（初始状态）</strong>：线程被构建，但没有调用start方法。</p>
</li>
<li><p><strong>RUNNABLE（运行状态）</strong>：Java线程将就绪和运行两种状态统称为“运行中”。</p>
</li>
<li><p><strong>BLOCKED（阻塞状态）</strong>：表示线程阻塞于锁。</p>
</li>
<li><p><strong>WAITING（等待状态）</strong>：表示当前线程需要等待其它线程做出一些特定操作（通知或中断）。</p>
</li>
<li><p><strong>TIME_WAITING（超时等待状态）</strong>：该状态不同于WAITING，它可以在指定时间内自动返回。</p>
</li>
<li><p><strong>TERMINATED（终止状态）</strong>：表示当前线程已经执行完毕。</p>
</li>
</ol>
<h3 id="1-1-5、daemon线程"><a href="#1-1-5、daemon线程" class="headerlink" title="1.1.5、daemon线程"></a>1.1.5、daemon线程</h3><p>Daemon（守护）线程是一种支持型线程，主要被用于程序后台调度及支持性工作。当Java虚拟机中不存在非Daemon线程时，Java虚拟机将会退出。可通过调用<code>Thread.setDaemon(true)</code>将线程设置为Daemon线程。</p>
<p><font color='red'>注意：Daemon属性需要在线程启动之前设置。且Java虚拟机退出时Daemon线程中的finally块并不一定会执行。</font></p>
<h2 id="1-2、启动终止线程"><a href="#1-2、启动终止线程" class="headerlink" title="1.2、启动终止线程"></a>1.2、启动终止线程</h2><h3 id="1-2-1、启动线程"><a href="#1-2-1、启动线程" class="headerlink" title="1.2.1、启动线程"></a>1.2.1、启动线程</h3><h4 id="1-2-1-1、启动线程的方式"><a href="#1-2-1-1、启动线程的方式" class="headerlink" title="1.2.1.1、启动线程的方式"></a>1.2.1.1、启动线程的方式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Callable</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ExecutorService</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Executors</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">FutureTask</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">T02_HowToCreateThread</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello MyThread!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyRun</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello MyRun!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyCall</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello MyCall"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">//启动线程的5种方式</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello Lambda!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyCall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello ThreadPool"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        service<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="1-2-1-2、Callable的使用"><a href="#1-2-1-2、Callable的使用" class="headerlink" title="1.2.1.2、Callable的使用"></a>1.2.1.2、Callable的使用</h4><h5 id="相关类结构图"><a href="#相关类结构图" class="headerlink" title="相关类结构图"></a>相关类结构图</h5><p>接口Callable是一个单独的接口，与之相关的类内部结构图可参考如下：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210706113047202.png?token=AIGEF3IIKOSDUDGRO73RRQTEZZXEK" alt="image-20210706113047202"></p>
<h5 id="Callable使用实例"><a href="#Callable使用实例" class="headerlink" title="Callable使用实例"></a>Callable使用实例</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StartThreadByCallable</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">MyCallable</span> callable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">FutureTask</span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">Object</span> result <span class="token operator">=</span> futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result: "</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> <span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">MyCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-2-2、理解中断"><a href="#1-2-2、理解中断" class="headerlink" title="1.2.2、理解中断"></a>1.2.2、理解中断</h3><p>中断可理解为线程的标识位属性，它表示一个运行中的线程是否被其他线程执行了中断操作。通过调用线程的<code>interrupt()</code>方法可以实现中断线程的操作。</p>
<p>线程通过检查自身是否被中断来进行响应，方法<code>isInterrupted()</code>返回线程是否被中断，静态方法<code>Thread.interrupted()</code>返回当前中断状态，并将中断标识设为false。</p>
<p><font color='red'>注意：终结状态下的线程，即使曾经被中断过，那么方法 isInterrupted() 依旧会返回false。</font></p>
<h3 id="1-2-3、过期方法"><a href="#1-2-3、过期方法" class="headerlink" title="1.2.3、过期方法"></a>1.2.3、过期方法</h3><p>suspend()、resume() 和 stop()方法可以实现线程的暂停、恢复和终止。但这些API已经过期，不建议使用。</p>
<p>不推荐原因：<font color='red'>调用方法suspend()后线程会占用资源进入睡眠状态，易引发死锁问题。stop()方法在终结线程时不能保证正常释放线程资源。</font></p>
<blockquote>
<p>暂停和恢复操作可以用 等待&#x2F;通知 机制来替代。</p>
</blockquote>
<h3 id="1-2-4、安全终止线程"><a href="#1-2-4、安全终止线程" class="headerlink" title="1.2.4、安全终止线程"></a>1.2.4、安全终止线程</h3><p><strong>通过 标识位或中断操作  可以实现线程终止时有机会清理资源，而非立即停止。这种方法更加安全和优雅</strong>。</p>
<h3 id="1-2-5、小结"><a href="#1-2-5、小结" class="headerlink" title="1.2.5、小结"></a>1.2.5、小结</h3><p>可中断的场景如下：</p>
<ol>
<li>Lock</li>
<li>Object相关方法（wait）</li>
<li>Thread相关方法（join、sleep）</li>
</ol>
<p>不可中断场景如下：</p>
<ol>
<li>synchronized锁</li>
</ol>
<h2 id="1-3、线程间通信"><a href="#1-3、线程间通信" class="headerlink" title="1.3、线程间通信"></a>1.3、线程间通信</h2><h3 id="1-3-1、volatile-synchronized"><a href="#1-3-1、volatile-synchronized" class="headerlink" title="1.3.1、volatile &#x2F; synchronized"></a>1.3.1、volatile &#x2F; synchronized</h3><ul>
<li><p>volatile</p>
<p>关键字volatile 可修饰字段，访问该变量时需要从共享内存中获取，对该变量的修改必须同步刷新至共享内存，它能保证所有线程对变量访问的可见性。</p>
</li>
<li><p>synchronized</p>
<p>关键字synchronized可修饰方法 或 以同步块形式使用，可保证多个线程在同一时刻只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p>
</li>
</ul>
<h3 id="1-3-2、等待-通知机制及范式"><a href="#1-3-2、等待-通知机制及范式" class="headerlink" title="1.3.2、等待&#x2F;通知机制及范式"></a>1.3.2、等待&#x2F;通知机制及范式</h3><h4 id="1-3-2-1、等待通知机制"><a href="#1-3-2-1、等待通知机制" class="headerlink" title="1.3.2.1、等待通知机制"></a>1.3.2.1、等待通知机制</h4><p>等待&#x2F;通知机制是指：<strong>线程A调用对象O的wait()方法后会进入等待状态，线程B调用对象O的notify()或notifyAll()方法后会通知线程A结束等待继续执行</strong>。</p>
<p>调用wait()、notify()、notifyAll()时的注意事项如下：</p>
<ol>
<li>使用 wait()、notify() 和 notifyAll() 时需要先对调用对象加锁。</li>
<li>调用 wait() 方法后，会将当前线程放入对象的 等待队列，线程状态由RUNNING变为WAITING。</li>
<li>调用 notify()、notifyAll() 方法的线程释放锁之后，等待线程才会从wait()返回。</li>
<li>notify()方法会将等待队列中的一个等待线程移到同步队列中，而notifyAll() 方法会作用于全部线程，被移动线程的状态会由WAITING变为 BLOCKED。</li>
<li>获得调用对象的锁后才能从wait()方法返回。</li>
</ol>
<h4 id="1-3-2-2、等待通知范式"><a href="#1-3-2-2、等待通知范式" class="headerlink" title="1.3.2.2、等待通知范式"></a>1.3.2.2、等待通知范式</h4><p><strong>范式分为两部分：等待方（消费者）、通知方（生产者）</strong>。</p>
<p>（1）等待方</p>
<ol>
<li>获取对象的锁；</li>
<li>如果条件不满足，那么调用对象的wait方法，被通知后仍要检查条件；</li>
<li>条件满足则执行对应的逻辑；</li>
</ol>
<p>（2）通知方</p>
<ol>
<li>获得对象的锁；</li>
<li>改变条件；</li>
<li>通知所有等待在对象上的线程；</li>
</ol>
<h3 id="1-3-3、管道输入-输出流"><a href="#1-3-3、管道输入-输出流" class="headerlink" title="1.3.3、管道输入&#x2F;输出流"></a>1.3.3、管道输入&#x2F;输出流</h3><p><strong>管道输入&#x2F;输出流和普通的文件输入&#x2F;输出流或者网络输入&#x2F;输出流的不同之处在于，基于内存实现线程间的数据传输</strong>。</p>
<p>管道输入&#x2F;输出流主要包括了4种具体实现：</p>
<ul>
<li>面向字节：PipedInputStream、PipedOutputStream；</li>
<li>面向字符：PipedReader、PipedWriter；</li>
</ul>
<h3 id="1-3-4、Thread-join"><a href="#1-3-4、Thread-join" class="headerlink" title="1.3.4、Thread.join"></a>1.3.4、Thread.join</h3><p><strong>线程A执行thread.join()方法表示：线程A等待thread线程终止之后才从thread.join()返回</strong>。</p>
<p>除了<code>join()</code>方法外，还提供了<code>join(long millis)</code>和<code>join(long millis, int nanos)</code>两个超时方法。两个超时方法作用：如果线程在给定的超时时间内没有终止，那么会直接返回。</p>
<h3 id="1-3-5、ThreadLocal"><a href="#1-3-5、ThreadLocal" class="headerlink" title="1.3.5、ThreadLocal"></a>1.3.5、ThreadLocal</h3><p>ThreadLocal是一个以ThreadLocal对象为键、任意对象为值的存储结构。该结构存在于线程上，故一个线程可以根据一个ThreadLocal对象来查询绑定在该线程上的数据。</p>
<p>对于线程A，可以通过A.set(T)方法来设置一个值，然后通过A.get()方法获取到原先设置的值。</p>
<h1 id="2、CPU"><a href="#2、CPU" class="headerlink" title="2、CPU"></a>2、CPU</h1><h2 id="2-1、缓存行"><a href="#2-1、缓存行" class="headerlink" title="2.1、缓存行"></a>2.1、缓存行</h2><h3 id="2-1-1、概述"><a href="#2-1-1、概述" class="headerlink" title="2.1.1、概述"></a>2.1.1、概述</h3><p><strong>CPU缓存行是计算机体系架构中的一个概念，用于描述主存储器和CPU缓存之间的数据传输单位</strong>。缓存行是CPU缓存中最小的可寻址单位，也是一次从主存储器中读取数据块的大小。</p>
<p><strong>缓存行的大小是固定的，通常为32字节或64字节，具体取决于CPU设计。缓存行是按连续的内存地址来分割主存储器，且在CPU缓存中以相同方式进行组织。</strong></p>
<blockquote>
<p>为何CPU缓存行大小通常为64字节？原因分析有以下几点：</p>
<ul>
<li><strong>空间局部性</strong>。相邻数据被访问的可能性较大，一次加载连续的内存数据到缓存行中，可以利用这种局部性，减少对主存储器的访问次数，提高数据访问效率。</li>
<li><strong>数据传输效率</strong>。CPU与主存储器之间的数据传递是通过总线进行了，总线传输带宽是有限的，一次性加载较大的缓存行可以充分利用总线的宽度，减少数据传输的次数，提高数据传输效率。</li>
<li><strong>缓存行对齐</strong>。通常来说，数据的访问需要满足对齐要求。对齐要求是指数据存储在内存中的起始地址必需是某个值（缓存行大小）的倍数。如果不满足对齐要求，CPU需要做额外的工作来获取正确的数据，这增加了访问延迟。通过设定缓存行大小为64字节，可以确保大多数数据类型都能满足对齐要求。</li>
<li><strong>缓存容量与成本均衡</strong>。增加缓存行的大小可以提高缓存命中率，提高数据访问效率。但较大的缓存行也会占用更多的缓存容量。通过选择适当的缓存行大小，可以在缓存容量和性能之间取得平衡。</li>
</ul>
</blockquote>
<p>当CPU需要从主存储器中读取数据时，它会以缓存行为单位进行操作。如果要读取的数据位于缓存行中，CPU会一次性将整个缓存行加载到CPU缓存中，后期需要读取相邻数据时可直接从缓存中读取，提高了读取效率。</p>
<p>缓存行的引入是为了解决主存储器与CPU之间速度差异的问题。但缓存行的引入也带来了一些问题，第一个问题就是缓存行对内存的占用，加载到缓存的数据可能只使用了部分，而剩余的空间被浪费了，这也被称为缓存行浪费或缓存行膨胀。第二个问题就是缓存一致性问题，当多个CPU访问共享内存时，由于每个CPU都有自己的缓存，可能造成缓存的不一致，而这可以通过缓存一致性协议来解决。</p>
<h3 id="2-1-2、四个状态"><a href="#2-1-2、四个状态" class="headerlink" title="2.1.2、四个状态"></a>2.1.2、四个状态</h3><p><strong>Modified（修改）、Exclusive（独占）、Shared（共享）、Invalid（无效）。</strong></p>
<h2 id="2-2、用户态与内核态"><a href="#2-2、用户态与内核态" class="headerlink" title="2.2、用户态与内核态"></a>2.2、用户态与内核态</h2><h3 id="2-2-1、概述"><a href="#2-2-1、概述" class="headerlink" title="2.2.1、概述"></a>2.2.1、概述</h3><p><strong>用户态与内核态是操作系统中的两种执行模式，用于区分运行在不同特权级别下的程序和系统内核。</strong></p>
<p><strong>用户态是为用户应用程序提供的一种执行缓存。</strong>用户态下的程序只能访问有限的资源和执行有限的操作。</p>
<p><strong>内核态是操作系统的特权执行模式，拥有对操作系统核心和硬件资源的完全控制权。</strong>内核态下的系统内核程序可以执行任何指令和访问任何资源。内核态程序可以执行特权指令、管理内存、调度任务等。</p>
<p>当用户程序需要执行特权操作时，会触发一次用户态到内核态的转变，系统内核会接管特权并执行相关操作，操作完成后，再交给用户程序，用户程序继续执行。</p>
<h3 id="2-2-2、ring-0-1-2-3"><a href="#2-2-2、ring-0-1-2-3" class="headerlink" title="2.2.2、ring 0  1  2  3"></a>2.2.2、ring 0  1  2  3</h3><p><strong>CPU Ring 0、1、2、3是一种权限级别划分，这种划分通常用于X86体系结构中的操作系统和处理器。</strong></p>
<p>X86体系结构中，特权级别使用4个环（Ring）来表示，每个环对应一种特权级别，这些环被称为Ring0、1、2、3，也被称为内核态、系统态、用户态、应用态。</p>
<ul>
<li><p><strong>Ring 0（内核态）</strong>：是操作系统内核运行的特权级别，拥有最高的特权和访问权限。系统内核可以执行所有指令，访问系统的所有资源和硬件设备。</p>
</li>
<li><p><strong>Ring 1（系统态）</strong>：是保留给操作系统的第二特权级别，拥有较高的特权和访问权限。系统可以执行受限的指令集和访问部分授权的资源。</p>
</li>
<li><p><strong>Ring 2（用户态）</strong>：是保留给操作系统的第三特权级别，比Ring 3有更高的特权。系统可以执行受限的指令集和访问部分授权的资源。</p>
</li>
<li><p><strong>Ring 3（应用态）</strong>：是用户程序运行的特权级别，拥有最低的特权和访问权限。程序只能执行授权的指令集，访问有限的资源和执行授权动作。</p>
</li>
</ul>
<p><strong>CPU运行级别在 Ring3 和 Ring0 间的切换称为用户态和内核态的切换</strong>。   </p>
<h3 id="2-2-3、上下文切换"><a href="#2-2-3、上下文切换" class="headerlink" title="2.2.3、上下文切换"></a>2.2.3、上下文切换</h3><h4 id="2-2-3-1、简介"><a href="#2-2-3-1、简介" class="headerlink" title="2.2.3.1、简介"></a>2.2.3.1、简介</h4><p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个 任务。在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以<strong>任务从保存到再加载的过程就是一次上下文切换。</strong></p>
<p>上下文切换 会影响 多线程执行速度。</p>
<h4 id="2-2-3-2、测试上下文切换"><a href="#2-2-3-2、测试上下文切换" class="headerlink" title="2.2.3.2、测试上下文切换"></a>2.2.3.2、测试上下文切换</h4><p>使用<code>Lmbench3</code>可以测量上下文切换时长。使用<code>vmstat</code>可以测量上下文切换次数。</p>
<h4 id="2-2-3-3、减少上下文切换"><a href="#2-2-3-3、减少上下文切换" class="headerlink" title="2.2.3.3、减少上下文切换"></a>2.2.3.3、减少上下文切换</h4><p><strong>减少上下文切换的方法：无锁并发编程、CAS算法、使用最少线程和使用协程。</strong></p>
<p>实战示例：</p>
<ol>
<li><p>用<code>jstack</code>命令 dump 线程信息，看看 pid 为 3117 的进程中的线程在做什么。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token parameter variable">-u</span> admin /opt/ifeve/java/bin/jstack <span class="token number">31177</span> <span class="token operator">></span> /home/tengfei.fangtf/dump17<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>统计所有线程分别处于什么状态，发现300多个线程处于 WAITING 状态。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> java.lang.Thread.State dump17 <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&#123;print $2$3$4$5&#125;'</span> <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> <span class="token parameter variable">-c</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>打开dump文件查看处于 WAITING 线程在做什么。发现线程池中的线程接收任务太少，大量线程都闲着。</p>
</li>
<li><p>减少线程池中的线程数量。</p>
</li>
<li><p>重新启动服务并测试查看效果。</p>
</li>
</ol>
<h2 id="2-3、缓存一致性协议"><a href="#2-3、缓存一致性协议" class="headerlink" title="2.3、缓存一致性协议"></a>2.3、缓存一致性协议</h2><h3 id="2-3-1、种类"><a href="#2-3-1、种类" class="headerlink" title="2.3.1、种类"></a>2.3.1、种类</h3><p>协议类型主要有：MSI、MESI、MOSI、Synapse Firefly Dragon。<strong>intel CPU 使用的是MESI协议</strong>。</p>
<h3 id="2-3-2、MESI"><a href="#2-3-2、MESI" class="headerlink" title="2.3.2、MESI"></a>2.3.2、MESI</h3><p>M、E、S、I 标记 高速缓存行 四种独占状态（使用两个附加位编码）：</p>
<ol>
<li><strong>修改（M）</strong>：高速缓存行仅存在于当前高速缓存中，并且是脏的 - 它已从主存储器中的值修改（M状态）。在允许对（不再有效）主存储器状态的任何其他读取之前，需要高速缓存在将来的某个时间将数据写回主存储器。回写将该行更改为共享状态（S）。</li>
<li><strong>独占（E）</strong>：缓存行仅存在于当前缓存中，但是干净 - 它与主内存匹配。它可以随时更改为共享状态，以响应读取请求。或者，可以在写入时将其改变为修改状态。</li>
<li><strong>共享（S）</strong>：表示此高速缓存行可能存储在计算机的其他高速缓存中并且是干净的 - 它与主存储器匹配。可以随时丢弃该行（更改为无效状态）。</li>
<li><strong>无效（I）</strong>：表示此缓存行无效（未使用）。</li>
</ol>
<p>对于任何给定的高速缓存对，给定高速缓存行的允许状态如图：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20201008205937219.png?token=AIGEF3IXUJ63WEXUW5FGKLDEZZXHC" alt="image-20201008205937219"></p>
<p><strong>当块被标记为M（已修改）时，其他高速缓存中关于该块的副本将会被标记为I（无效）</strong>。</p>
<h3 id="2-3-3、优缺点"><a href="#2-3-3、优缺点" class="headerlink" title="2.3.3、优缺点"></a>2.3.3、优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>MESI多了一个E——“独占”状态。独占状态有许多优点。</p>
<p>加入独占状态的缘由：</p>
<ol>
<li>对于“某个处理器需要读取其他处理器没有的块然后写入它”这种情况，会导致 MSI 下发生的两个总线事务（首先是BusRd请求，然后是BusRdX请求）中的第二个请求事务失效。而 MESI 通过添加Exclusive状态解决了这个问题。</li>
<li>MSI不适用于顺序执行的应用程序，MESI适用于高度并行的应用程序。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p><font color='red'>如果由特定块上的各种高速缓存执行 连续读取和写入 操作，则必须每次都将数据刷新到总线上。MOESI协议克服了这一问题。</font></p>
<h2 id="2-4、内存屏障"><a href="#2-4、内存屏障" class="headerlink" title="2.4、内存屏障"></a>2.4、内存屏障</h2><h3 id="2-4-1、硬件屏障"><a href="#2-4-1、硬件屏障" class="headerlink" title="2.4.1、硬件屏障"></a>2.4.1、硬件屏障</h3><ul>
<li>sfence：sava，sfence指令前写 先于 sfence指令后写。</li>
<li>lfence：load，lfence指令前读 先于 lfence指令后读。</li>
<li>mfence：modify&#x2F;mix，mfence指令前读写 先于 mfence指令后读写。</li>
</ul>
<h3 id="2-4-2、JVM内存屏障"><a href="#2-4-2、JVM内存屏障" class="headerlink" title="2.4.2、JVM内存屏障"></a>2.4.2、JVM内存屏障</h3><p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200902211143739.png?token=AIGEF3JUF3VDP2K4ZX3FWR3EZZXII" alt="image-20200902211143739"></p>
<h1 id="3、JAVA对象"><a href="#3、JAVA对象" class="headerlink" title="3、JAVA对象"></a>3、JAVA对象</h1><h2 id="3-1、JAVA对象组成"><a href="#3-1、JAVA对象组成" class="headerlink" title="3.1、JAVA对象组成"></a>3.1、JAVA对象组成</h2><h3 id="3-1-1、对象结构"><a href="#3-1-1、对象结构" class="headerlink" title="3.1.1、对象结构"></a>3.1.1、对象结构</h3><p>Java对象保存在内存中时，由以下三部分组成：</p>
<p><strong>（1）对象头</strong></p>
<ul>
<li>普通对象头：无压缩16字节，压缩后12字节；</li>
<li>数组对象头：无压缩24字节，压缩后16字节；</li>
</ul>
<p><strong>（2）实例数据</strong></p>
<p>HotSpot中，对象的实例数据会在对象头后分配空间。</p>
<p>字段的分配顺序受源码声明顺序以及HotSpot分配策略的影响。无论哪种分配策略，宽度相同的字段总是相邻分配的；不同宽度间的字段可能存在对其填充；</p>
<p>笼统说，基类声明的实例字段会出现在派生类声明的实例字段之前。但开启指针压缩后，派生类的较窄字段可能会插入到基类实例字段之间的对其填充部分。</p>
<p>相关参数：FieldsAllocationStyle CompactFields。</p>
<p><strong>（3）对齐填充（使得最终对象大小是8的倍数）</strong></p>
<p>HotSpot中，GC堆上的对象要求在8字节边界上分配；也就是说对象的起始地址必须是8的倍数，对象占用的空间也必须是8的倍数。</p>
<p>若对象时机需要的大小不足8的倍数，则用0填充不足的部分，直到8字节边界为止。</p>
<p>对齐填充可能出现在不同宽度的字段之间，也可能出现在对象的末尾；或者当不存在未对齐的数据时则不会出现对齐填充。</p>
<p>Java对象头由三部分组成：</p>
<p><strong>（1）Mark Word（普通对象头无压缩为8字节，压缩后不变；数组对象头为8字节；）</strong></p>
<p>HotSpot中，GC堆上的对象需要维持一些状态信息，如：</p>
<ul>
<li>身份哈希码（identity hash code）</li>
<li>是否已被GC标记（GC过程中需要）</li>
<li>当前对象年龄</li>
<li>当前是否被当作锁同步</li>
<li>持有对象锁的线程ID（用于偏向锁）</li>
<li>…….</li>
</ul>
<p>该部分会根据对象当前状态有选择性的记录其中一部分。</p>
<p><strong>（2）Klass Point（普通对象头无压缩为8字节，压缩后4字节；数组对象头4字节）</strong></p>
<p>开启压缩功能参数：<code>-XX:+UseCompressedClassPointers</code>。</p>
<p>HotSpot中，堆中的对象从C++角度看都是oopDesc子类的实例。每个对象都有一个_klass字段，指向一个描述自身的元数据的对象。</p>
<p>Java对象与数组的Klass并不是Java语言级的java.lang.class。Klass用于运行，而java.lang.class用于Java的反射API；前者中有_java_mirror字段指向后者。</p>
<p><strong>（3）数组长度（数组对象才会存在该项）（数组对象长度占用4字节）</strong></p>
<h3 id="3-1-2、Mark-Word"><a href="#3-1-2、Mark-Word" class="headerlink" title="3.1.2、Mark Word"></a>3.1.2、Mark Word</h3><p>64位如下：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805145739393.png?token=AIGEF3L3JWHMKR3UAOTMM33EZZXJU" alt="image-20230805145739393"></p>
<p>32位如下：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/32%E4%BD%8DJava%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%9B%BE01.png?token=AIGEF3PUMAZYIJ32BFWNLNDEZZXLO" alt="32位Java对象内存布局图01"></p>
<p>对于hashcode值来说，存在两种情况：</p>
<p><strong>（1）没有重写hashcode方法</strong></p>
<p>没有重写过hashcode方法时调用System.identityHashCode(…)方法可以拿到由os:random生成的hashcode。</p>
<p>os::random生成hashcode的规则为：<code>next_rand = (16807seed) mod (2^31 - 1)</code>，因此可以在对象的markword中用31位空间存储它。</p>
<p><strong>（2）重写过hashcode方法</strong></p>
<p>重写过的hashcode方法其计算结果不会存储在这里。</p>
<h3 id="3-1-3、测试案例"><a href="#3-1-3、测试案例" class="headerlink" title="3.1.3、测试案例"></a>3.1.3、测试案例</h3><p>工具：JOL（Java Object Layout）</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>
    <span class="token comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core --></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.openjdk.jol<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jol-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>jdk8u: markOop.hpp</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Bit-format of an object header (most significant first, big endian layout below):</span>
<span class="token comment">//</span>
<span class="token comment">//  32 bits:</span>
<span class="token comment">//  --------</span>
<span class="token comment">//             hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)</span>
<span class="token comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span>
<span class="token comment">//             size:32 ------------------------------------------>| (CMS free block)</span>
<span class="token comment">//             PromotedObject*:29 ---------->| promo_bits:3 ----->| (CMS promoted object)</span>
<span class="token comment">//</span>
<span class="token comment">//  64 bits:</span>
<span class="token comment">//  --------</span>
<span class="token comment">//  unused:25 hash:31 -->| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span>
<span class="token comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span>
<span class="token comment">//  PromotedObject*:61 --------------------->| promo_bits:3 ----->| (CMS promoted object)</span>
<span class="token comment">//  size:64 ----------------------------------------------------->| (CMS free block)</span>
<span class="token comment">//</span>
<span class="token comment">//  unused:25 hash:31 -->| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span>
<span class="token comment">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span>
<span class="token comment">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 ----->| (COOPs &amp;&amp; CMS promoted object)</span>
<span class="token comment">//  unused:21 size:35 -->| cms_free:1 unused:7 ------------------>| (COOPs &amp;&amp; CMS free block)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="3-2、Java数据类型"><a href="#3-2、Java数据类型" class="headerlink" title="3.2、Java数据类型"></a>3.2、Java数据类型</h2><h3 id="3-2-1、类型占用字节"><a href="#3-2-1、类型占用字节" class="headerlink" title="3.2.1、类型占用字节"></a>3.2.1、类型占用字节</h3><p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200915220817535.png?token=AIGEF3LFVBZGJEJXP4OIP4LEZZXNK" alt="类型占用字节大小"></p>
<h4 id="3-2-1-1、扩展"><a href="#3-2-1-1、扩展" class="headerlink" title="3.2.1.1、扩展"></a>3.2.1.1、扩展</h4><p>32位操作系统可以寻址到4G内存，因为 2^32 &#x3D; 4 * 1024 * 1024 &#x3D; 4G。64位近似无穷大（18EB）。</p>
<p>使用64位会有新问题：<strong>64位过长，给我们寻址带宽和对象内引用造成了负担。故引出了指针压缩技术。</strong></p>
<h3 id="3-2-2、指针压缩"><a href="#3-2-2、指针压缩" class="headerlink" title="3.2.2、指针压缩"></a>3.2.2、指针压缩</h3><h4 id="3-2-2-1、底层实现"><a href="#3-2-2-1、底层实现" class="headerlink" title="3.2.2.1、底层实现"></a>3.2.2.1、底层实现</h4><p><strong>JVM实现指针压缩的原理就是：不再保存所有引用，而是每隔8个字节保存一个引用。</strong>例如，原来保存每个引用0、1、2…，现在只保存0、8、16…。因此，指针压缩后，并不是所有引用都保存在堆中，而是以8个字节为间隔保存引用。</p>
<p>当引用被存入64位寄存器时，JVM会将其左移3位（相当于末尾添加3个0），例如0x0、0x1、0x2…分别被转换为0x0、0x8、0x10。当从寄存器中读出时，JVM又可以右移3位，丢弃末尾的0。（oop在堆中是32位，在寄存器中是35位，2的35次方&#x3D;32G。也就是说，使用32位，来达到35位oop所能引用的堆内存空间）。</p>
<h4 id="3-2-2-2、指针压缩失效"><a href="#3-2-2-2、指针压缩失效" class="headerlink" title="3.2.2.2、指针压缩失效"></a>3.2.2.2、指针压缩失效</h4><p>32G指针压缩失效问题：<strong>因为寄存器中2的35次方只能寻址到32G左右(不一定是32G，可能31G就会发生指压缩失效)，所以当内存超过32G时，JVM就默认停用压缩指针，进而改用64位寻址来寻址所有内存。改用64位寻址会导致对象变大，测试发现40G内存可以存储的对象个数要比30G内存少。</strong></p>
<h4 id="3-2-2-3、被压缩的数据"><a href="#3-2-2-3、被压缩的数据" class="headerlink" title="3.2.2.3、被压缩的数据"></a>3.2.2.3、被压缩的数据</h4><ol>
<li>对象的全局静态变量(即类属性)。</li>
<li>对象头信息：64位平台下，原生对象头大小为16字节，压缩后为12字节。</li>
<li>对象引用：64位平台下，引用本身大小为8字节，压缩后为4字节。</li>
<li>对象数组：64位平台下，数组本身大小为24字节，压缩后16字节。</li>
</ol>
<h4 id="3-2-2-4、不会被压缩的数据"><a href="#3-2-2-4、不会被压缩的数据" class="headerlink" title="3.2.2.4、不会被压缩的数据"></a>3.2.2.4、不会被压缩的数据</h4><ol>
<li>指向非Heap的对象指针。</li>
<li>局部变量、传参、返回值、NULL指针。</li>
</ol>
<h2 id="3-3、Java集合容器"><a href="#3-3、Java集合容器" class="headerlink" title="3.3、Java集合容器"></a>3.3、Java集合容器</h2><h3 id="3-3-1、概述"><a href="#3-3-1、概述" class="headerlink" title="3.3.1、概述"></a>3.3.1、概述</h3><p>Java集合容器整体结构如下图：</p>
<p>版本1：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Collection%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%8401.png?token=AIGEF3IOEOZ2Y5TSXSC4OSDEZZXP4" alt="Collection体系架构01"></p>
<p>版本2：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84%E5%9B%BE.jpg?token=AIGEF3POOXUNH77WTUNZZZTEZZXRS" alt="集合结构图"></p>
<h3 id="3-3-2、Collection"><a href="#3-3-2、Collection" class="headerlink" title="3.3.2、Collection"></a>3.3.2、Collection</h3><h4 id="3-3-2-1、List"><a href="#3-3-2-1、List" class="headerlink" title="3.3.2.1、List"></a>3.3.2.1、List</h4><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><ol>
<li>数据结构：动态数组，需要连续内存。</li>
<li>元素特点：<ul>
<li>数组定义：<code>transient Object[] elementData;</code> 序列化时不考虑其存储元素；</li>
<li>允许为null值；</li>
</ul>
</li>
<li>增删改查：<ul>
<li>随机访问快；</li>
<li>首部插入速度较linkedlist要慢40%左右，尾部插入较linkedlist要快10%左右，中间插入较linkedlist要快65%左右，其它部分插入删除都会移动数据，性能较低；</li>
<li>可以利用CPU缓存，局部性原理。</li>
</ul>
</li>
<li>初始容量：<ul>
<li>JDK7：初始容量为10。</li>
<li>JDK8：初始为0，当第一次执行添加操作后才会扩容，扩容后容量为10；</li>
</ul>
</li>
<li>扩容：添加数据前已存在元素数量 等于 数组长度时，则扩大为原来的1.5倍，但底层并非是乘上1.5，而是根据公式：<code>原容量&gt;&gt;1+原容量</code>获得。</li>
<li>是否同步：非同步，线程不安全；但可以通过<code>Collections.synchronizedList(list)</code>返回一个线程安全的ArrayList，也可以使用concurrent包下的<code>CopyOnWriteArrayList</code>；</li>
<li>复杂度：添加n个元素需要O(n)时间；</li>
<li>使用场景：快速访问数据；单线程环境；</li>
</ol>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><ol>
<li>数据结构：双向链表，不需要连续内存。</li>
<li>元素特点：<ul>
<li>链表节点底层实现就是内部类Node，变量Node first、Node last；</li>
<li>允许为null值；占用内存多；</li>
</ul>
</li>
<li>增删改查：<ul>
<li>随机访问慢，顺序访问性能还行；</li>
<li>首尾插入删除快，中间插入删除慢；</li>
</ul>
</li>
<li>初始容量：不需要指定容量；</li>
<li>扩容：随插入数据数量扩大；</li>
<li>是否同步：非同步，线程不安全；</li>
<li>复杂度：</li>
<li>使用场景：快速频繁增删数据场景；按顺序访问数据的场景；单线程环境；</li>
<li>扩展：可以实现栈、队列和双向队列；</li>
</ol>
<h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><ol>
<li>底层数据结构：动态数组；</li>
<li>元素特点：数组定义如：<code>Object[] elementData</code>；允许有空值；不支持序列化；</li>
<li>增删改查：插入删除效率低，查询效率高；</li>
<li>初始容量：默认10；</li>
<li>扩容：添加数据前先判断已存在元素数量 是否等于 数组长度，若等于则默认扩大为原来的2倍，如果显式设置了扩容量则按指定的扩容量来扩容，如果扩容后还是不够用，则直接根据要插入的元素数量长度来扩容；（默认容量为10，若首次发生扩容，则默认扩容后的容量为20。如果初始容量为10，然后直接一次性添加21个元素，那么扩容后的容量为21，而并非是40。容量21空闲为0的环境下，此时再添加1个元素，那么会再次扩容为原来的2倍，也即扩容为42）</li>
<li>是否同步：同步，线程安全，因其基于synchronized实现线程安全，故效率较差；可以使用concurrent包下的CopyOnWriteArrayList 来代替 Vector；</li>
<li>复杂度：</li>
<li>使用场景：多线程环境；</li>
</ol>
<h6 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h6><ol>
<li><p>底层数据结构：数组</p>
</li>
<li><p>元素特点：先进后出；</p>
</li>
<li><p>增删改查：</p>
<ol>
<li>push方法：将元素推入栈底，即数组末尾；</li>
<li>pop方法：取出栈顶元素后并删除栈顶元素。</li>
<li>peek方法：取出栈顶元素，即数组首个元素。</li>
<li>empty方法：判断栈是否为空。</li>
<li>search方法：获取指定元素在栈中的位置。</li>
</ol>
<p>注意：因其继承于Vector，所以其拥有Vector全部功能；</p>
</li>
<li><p>初始容量：空栈。</p>
</li>
<li><p>扩容：继承于vector，与之相同；</p>
</li>
<li><p>是否同步：线程安全；</p>
</li>
<li><p>复杂度：</p>
</li>
<li><p>使用场景：</p>
</li>
</ol>
<h5 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h5><ol>
<li>简介：写操作时（写操作加了锁，否则会拷贝多个副本），将原数组拷贝一份出来，然后在拷贝的新数组中执行写操作，操作完后再将原数组引用指向新数组；</li>
<li>底层数据结构：动态数组；</li>
<li>元素特点：</li>
<li>增删改查：</li>
<li>初始容量：</li>
<li>扩容：</li>
<li>是否同步：线程安全；</li>
<li>复杂度：</li>
<li>使用场景：读多写少，比如缓存；</li>
<li>注意事项：<ol>
<li>写操作需要拷贝数组，比较消耗内存，如果原数组容量比较大，则可能频繁发生YGC和FGC；</li>
<li>不能保证实时一致性，只能保证最终一致性；</li>
</ol>
</li>
</ol>
<h4 id="3-3-2-2、Set"><a href="#3-3-2-2、Set" class="headerlink" title="3.3.2.2、Set"></a>3.3.2.2、Set</h4><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><ol>
<li>底层数据结构：基于HashMap和LinkedHashMap实现。具体实现方式：通过一个HashMap存储元素，元素存放在HashMap的key中，而value统一使用一个Object对象。</li>
<li>元素特点：<ol>
<li>无序不重复；</li>
<li>只允许1个null元素；</li>
</ol>
</li>
<li>增删改查：</li>
<li>初始容量：因基于HashMap实现，故规则参考HashMap实现规则；</li>
<li>扩容：因基于HashMap实现，故规则参考HashMap实现规则；</li>
<li>是否同步：线程不安全；</li>
<li>复杂度：</li>
<li>使用场景：去重，无需排序场景；</li>
</ol>
<h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><ol>
<li>底层数据结构：<ol>
<li>数组+双向链表；</li>
<li>基于LinkedHashMap和HashSet机制实现，所以可保证迭代顺序和元素的不重复；</li>
</ol>
</li>
<li>元素特点：<ol>
<li>Entry结构：before&#x2F;hash&#x2F;key&#x2F;value&#x2F;next&#x2F;after；before和after用于维护整个双向链表；</li>
<li>元素不重复；</li>
<li>可以保证插入顺序和访问顺序；</li>
</ol>
</li>
<li>增删改查：</li>
<li>初始容量：因基于LinkedHashMap实现，参考其实现规则；</li>
<li>扩容：因基于LinkedHashMap实现，参考其实现规则；</li>
<li>是否同步：线程不安全；</li>
<li>复杂度：</li>
<li>使用场景：去重，需要保证插入或访问顺序；</li>
</ol>
<h5 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h5><ul>
<li>TreeSet<ol>
<li>底层实现：基于TreeMap实现。</li>
<li>元素特点：元素有序。支持两种排序方式：自然排序和定制排序，默认是自然排序。使用 无参构造时 默认自然排序；当需要使用定制排序时，需要使用 有参构造 来显式指定。</li>
<li>存储：通过compare和compareTo来判断是否相等。compare通过判断两个对象的id，相同id则认为是重复元素，不会加入到集合中。</li>
</ol>
</li>
</ul>
<h5 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h5><h5 id="CopyOnWriteSet"><a href="#CopyOnWriteSet" class="headerlink" title="CopyOnWriteSet"></a>CopyOnWriteSet</h5><ol>
<li>简介：写操作时（写操作加了锁，否则会拷贝多个副本），将原数组拷贝一份，然后在拷贝的那份数组中执行写操作，操作完后再将原数组引用指向新数组；</li>
<li>数组结构：动态数组；</li>
<li>原理：通过CopyOnWriteList机制实现；</li>
<li>是否同步：线程安全；</li>
<li>使用场景：读多写少，比如缓存；</li>
<li>注意事项：<ol>
<li>写操作需要拷贝数组，比较消耗内存，如果原数组容量比较大，则可能频繁发生YGC和FGC；</li>
<li>不能保证实时一致性（读取到的数据可能是旧的），只能保证最终一致性；</li>
</ol>
</li>
</ol>
<h5 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h5><ol>
<li>底层数据结构：动态数组；并非是散列表；</li>
<li>元素特点：不能存储重复元素；</li>
<li>增删改查&gt;：</li>
<li>初始容量：</li>
<li>扩容：</li>
<li>是否同步：线程安全；</li>
<li>复杂度：</li>
<li>使用场景：读多写少，比如缓存；</li>
</ol>
<h5 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h5><h4 id="3-3-2-3、Queue"><a href="#3-3-2-3、Queue" class="headerlink" title="3.3.2.3、Queue"></a>3.3.2.3、Queue</h4><p>简介：offer()-添加数据后会返回一个布尔类型来表示是否添加成功；peek()-取数据；poll()-取数据后进行remove；</p>
<h5 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h5><ul>
<li>ArrayDeque</li>
<li>BlockingDeque<ul>
<li>LinkedBlockingDeque</li>
</ul>
</li>
</ul>
<h5 id="BlockingQueue（阻塞队列）"><a href="#BlockingQueue（阻塞队列）" class="headerlink" title="BlockingQueue（阻塞队列）"></a>BlockingQueue（阻塞队列）</h5><p>简介：在Queue的基础上添加<code>put()</code>和<code>take()</code>方法，这两个是阻塞方法。put装数据装满了会阻塞当前线程，take拿数据拿完了会阻塞当前线程。</p>
<ul>
<li><p>ArrayBlockingQueue</p>
<p>简介：它是一个有界阻塞队列，且可以设置有界值，也就是容器的容量。注意本类实现的offer方法可以设置时间，在指定时间过后还是添加不进去再返回。</p>
</li>
<li><p>PriorityBlockingQueue</p>
</li>
<li><p>LinkedBlockingQueue</p>
<p>简介：基于链表实现的无界阻塞队列，它可以一直装数据到你内存满为止。</p>
</li>
<li><p>TransferQueue</p>
<p>简介：传递的意思，实际上是其它各种Queue的一个组合，它可以给线程传递任务且可以通过列表传递多个。该Queue新增了一个transfer()方法——其逻辑就是装完数据得等着，有线程把它拿走我才可以回去继续干我的事。</p>
<p>应用场景：做了一件事，该事需要一个结果才能继续做下一件事。比如网购，我付钱成功后才能给发货，不成功不能发货。</p>
<ul>
<li>LinkedTransferQueue</li>
</ul>
</li>
<li><p>SynchronousQueue</p>
<p>简介：容量为0，它并非用来装数据，而是专门用来两个线程间传递数据和线程下达任务。该Queue用来进行阻塞式put调用，要求有线程从里面取数据时才能往里面装，相当于直接把数据递给取数据线程的手中。该Queue看似无用，其实不然，其在线程池中用处非常大，多线程取任务，互相间进行任务调度时用的就是这个Queue。</p>
</li>
</ul>
<h5 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h5><p>简介：内部结构是一个二叉树，该二叉树可以认为是堆排序里面的小顶堆（最小值为根节点）。PriorityQueue的特点是向里面装数据时不是按顺序装的，而是在内部进行了一个排序，按照优先级，最小的优先。</p>
<h5 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h5><h5 id="DelayQueue（双端队列）"><a href="#DelayQueue（双端队列）" class="headerlink" title="DelayQueue（双端队列）"></a>DelayQueue（双端队列）</h5><p>简介：DelayQueue可以基于时间排序。它是阻塞的队列的一种实现，这个阻塞队列在装数据时必须实现Delayed接口，也要实现Comparable接口并重写compareTo方法来实现任务排序的自定义逻辑；</p>
<h3 id="3-3-3、Map"><a href="#3-3-3、Map" class="headerlink" title="3.3.3、Map"></a>3.3.3、Map</h3><h4 id="3-3-3-1、HashMap"><a href="#3-3-3-1、HashMap" class="headerlink" title="3.3.3.1、HashMap"></a>3.3.3.1、HashMap</h4><ol>
<li><p>底层数据结构：JDK7是数组+单链表；JDK8是数组+单链表+红黑树；</p>
</li>
<li><p>元素特点：无序的key-value键值对；允许null key和null value；</p>
</li>
<li><p>增删改：插入、删除、查询效率较高；</p>
</li>
<li><p>初始容量：默认16（2的N次方）；</p>
</li>
<li><p>扩容：put后判断是否需要扩容；负载因子0.75，当容量 &#x3D; (总容量*0.75)时触发扩容，扩大为原来的2倍；</p>
</li>
<li><p>是否同步：线程不安全；</p>
</li>
<li><p>复杂度：</p>
</li>
<li><p>使用场景：快速增删改查；随机读取；缓存；</p>
</li>
<li><p>哈希冲突对策：</p>
<ul>
<li>开放定址法；</li>
<li>再散列函数法；</li>
<li>链地址法（拉链法，HashMap基于此实现）；</li>
</ul>
</li>
</ol>
<h5 id="3-3-3-1-1、LinkedHashMap"><a href="#3-3-3-1-1、LinkedHashMap" class="headerlink" title="3.3.3.1.1、LinkedHashMap"></a>3.3.3.1.1、LinkedHashMap</h5><ol>
<li>底层数据结构：数组+双向链表；</li>
<li>元素特点：<ol>
<li>entry结构：before&#x2F;hash&#x2F;key&#x2F;value&#x2F;next&#x2F;after，before和after用于维护整个双向链表；</li>
<li>允许一个null key（多个覆盖），允许多个null value；</li>
</ol>
</li>
<li>增删改查：<ol>
<li>在HashMap基础上添加before和after两个属性保证迭代顺序；</li>
<li>迭代顺序可以是插入顺序，也可以是访问顺序；</li>
<li>使用LRU算法实现访问顺序排序；</li>
</ol>
</li>
<li>初始容量：</li>
<li>扩容：</li>
<li>是否同步：线程不安全；</li>
<li>复杂度：</li>
<li>使用场景：保证插入和访问顺序；</li>
</ol>
<h4 id="3-3-3-2、IdentityHashMap"><a href="#3-3-3-2、IdentityHashMap" class="headerlink" title="3.3.3.2、IdentityHashMap"></a>3.3.3.2、IdentityHashMap</h4><h4 id="3-3-3-3、TreeMap"><a href="#3-3-3-3、TreeMap" class="headerlink" title="3.3.3.3、TreeMap"></a>3.3.3.3、TreeMap</h4><ol>
<li><p><font color='orange'>底层数据结构</font>：红黑树（高效检索二叉树）；</p>
</li>
<li><p><font color='orange'>元素特点</font>：</p>
<ol>
<li>有序的key-value集合，每一个元素都存储于红黑树的一个节点上；</li>
<li>Entry结构：key&#x2F;value&#x2F;left&#x2F;right&#x2F;parent&#x2F;color；</li>
<li>不允许null key，但可允许多个null value；</li>
</ol>
</li>
<li><p><font color='orange'>增删改查</font>：默认自然排序，也可定制排序；</p>
</li>
<li><p><font color='orange'>初始容量</font>：</p>
</li>
<li><p><font color='orange'>扩容</font>：</p>
</li>
<li><p><font color='orange'>是否同步</font>：线程不安全；</p>
</li>
<li><p><font color='orange'>复杂度</font>：</p>
</li>
<li><p><font color='orange'>使用场景</font>：</p>
</li>
<li><p><font color='orange'>存储</font>：TreeMap存储时会进行排序，会根据key来对key-value键值对进行排序，其排序方式分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。</p>
<p><font color='orange'>自然排序</font>：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。</p>
<p><font color='orange'>定制排序</font>：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。</p>
</li>
<li><p><font color='orange'>获取</font>：</p>
</li>
<li><p><font color='orange'>检测元素异同</font>：TreeMap判断两个元素相等的标准：两个key执行equals返回true，且执行<code>compareTo()</code>方法返回0，则认为这两个key相等。</p>
</li>
<li><p><font color='orange'>是否同步</font>：非同步。</p>
</li>
<li><p><font color='orange'>注意事项</font>：如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的<code>equals()</code>方法，TreeMap中判断相等的标准是：两个key通过<code>equals()</code>方法返回为true，并且通过<code>compareTo()</code>方法比较应该返回为0。</p>
</li>
</ol>
<h4 id="3-3-3-4、WeakHashMap"><a href="#3-3-3-4、WeakHashMap" class="headerlink" title="3.3.3.4、WeakHashMap"></a>3.3.3.4、WeakHashMap</h4><h4 id="3-3-3-5、HashTable"><a href="#3-3-3-5、HashTable" class="headerlink" title="3.3.3.5、HashTable"></a>3.3.3.5、HashTable</h4><ol>
<li><font color='orange'>底层数据结构</font>：数组 + 链表；</li>
<li><font color='orange'>元素特点</font>：无序的key-value键值对，不允许null key 和 null value；</li>
<li><font color='orange'>增删改查</font>：插入、删除、查询效率较低，因为被synchronized修饰；</li>
<li><font color='orange'>初始容量</font>：默认11；</li>
<li><font color='orange'>扩容</font>：put前判断是否需要扩容；负载因子0.75，当容量 &gt;&#x3D; (总容量*0.75)时触发扩容，扩大为2倍+1；</li>
<li><font color='orange'>是否同步</font>：线程安全；基于重入锁synchronized实现线程安全；</li>
<li><font color='orange'>复杂度</font>：</li>
<li><font color='orange'>使用场景</font>：无序、不重复元素的存储。</li>
</ol>
<h4 id="3-3-3-6、IdentityHashMap"><a href="#3-3-3-6、IdentityHashMap" class="headerlink" title="3.3.3.6、IdentityHashMap"></a>3.3.3.6、IdentityHashMap</h4><h4 id="3-3-3-7、ConcurrentHashMap（JDK8）"><a href="#3-3-3-7、ConcurrentHashMap（JDK8）" class="headerlink" title="3.3.3.7、ConcurrentHashMap（JDK8）"></a>3.3.3.7、ConcurrentHashMap（JDK8）</h4><ol>
<li><font color='orange'>底层数据结构</font>：数组+单链表+红黑树；</li>
<li><font color='orange'>锁实现</font>：CAS+Synchronized；</li>
<li><font color='orange'>元素特点</font>：Node改名为HashEntry；</li>
<li><font color='orange'>增删改查</font>：</li>
<li><font color='orange'>初始容量</font>：默认16；</li>
<li><font color='orange'>扩容</font>：数据等于容量3&#x2F;4时就扩容为原容量的2倍。</li>
<li><font color='orange'>是否同步</font>：线程安全；基于 CAS+Synchronized 实现安全；</li>
<li><font color='orange'>复杂度</font>：</li>
<li><font color='orange'>使用场景</font>：多线程，高并发场景；</li>
</ol>
<h4 id="3-3-3-8、ConcurrentKipListMap"><a href="#3-3-3-8、ConcurrentKipListMap" class="headerlink" title="3.3.3.8、ConcurrentKipListMap"></a>3.3.3.8、ConcurrentKipListMap</h4><h3 id="3-3-4、Iterator"><a href="#3-3-4、Iterator" class="headerlink" title="3.3.4、Iterator"></a>3.3.4、Iterator</h3><ul>
<li><p>Iterator</p>
<ol>
<li>简介：是接口，是集合迭代器。</li>
<li>API：<ol>
<li>boolean hashNext()：判断集合中是否存在下一个元素，若存在，则返回true。</li>
<li>Object next()：返回集合中下一个元素。</li>
<li>void remove()：删除集合上一次next方法返回的元素。</li>
</ol>
</li>
<li>注意事项：<ol>
<li>iterator()只能单向移动。</li>
<li>iterator.remove()可以唯一安全修改迭代过程中集合元素的方法；如果在迭代过程中以任何其它的方式修改了集合，那么将会产生未知行为。且每调用一次<code>next()</code>方法，<code>remove()</code>方法只能被调用一次，如果违反这个规则将抛出一个异常。</li>
</ol>
</li>
</ol>
<ul>
<li>ListIterator<ol>
<li>简介：是一个 功能更强 的迭代器，继承于Iterator接口，只能适用于List。可以通过调用<code>listIterator()</code>方法产生一个指向List开始处的ListIterator，还可以调用<code>listIterator(n)</code>方法创建一个一开始就指向列表索引为n的元素的ListIterator。</li>
<li>特点：<ol>
<li>双向移动（向前向后遍历）</li>
<li>产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引。</li>
<li>可以使用set方法替换它访问过的最后一个元素。</li>
<li>可以使用add方法在next方法返回的元素之前或previous方法返回元素之后插入一个元素。</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="3-3-5、Collection-Collections"><a href="#3-3-5、Collection-Collections" class="headerlink" title="3.3.5、Collection &#x2F; Collections"></a>3.3.5、Collection &#x2F; Collections</h3><h4 id="3-3-5-1、Collection"><a href="#3-3-5-1、Collection" class="headerlink" title="3.3.5.1、Collection"></a>3.3.5.1、Collection</h4><p><strong>Collection是集合类顶级接口。提供操作集合的通用方法，其继承接口有List与Set</strong>。</p>
<h4 id="3-3-5-2、Collections"><a href="#3-3-5-2、Collections" class="headerlink" title="3.3.5.2、Collections"></a>3.3.5.2、Collections</h4><p>java.util.Collections 是<strong>集合工具类</strong>。拥有多种操作集合的静态方法，可对集合中的元素执行排序、搜索以及线程安全等操作，服务于Java的Collection框架。</p>
<h3 id="3-3-6、总结"><a href="#3-3-6、总结" class="headerlink" title="3.3.6、总结"></a>3.3.6、总结</h3><h4 id="3-3-6-1、HashMap原理"><a href="#3-3-6-1、HashMap原理" class="headerlink" title="3.3.6.1、HashMap原理"></a>3.3.6.1、HashMap原理</h4><h5 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h5><p>（1）JDK7</p>
<p>JDK7底层基于数组 + 单链表实现。</p>
<p>JDK7中底层使用HashMap的静态内部类Entry来存储数据：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>
    <span class="token class-name">V</span> value<span class="token punctuation">;</span>
    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>
    <span class="token keyword">int</span> hash<span class="token punctuation">;</span>
    <span class="token comment">// method...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>（2）JDK8</p>
<p>JDK8底层基于数组 + 单链表 + 红黑树实现。</p>
<p>JDK8中底层使用HashMap的静态内部类Node来存储数据：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>
    <span class="token class-name">V</span> value<span class="token punctuation">;</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>
    <span class="token comment">// method...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>解决哈希冲突的常见方法：开放地址法、链地址法等。HashMap采用了链地址法。</p>
</blockquote>
<h5 id="元素特点"><a href="#元素特点" class="headerlink" title="元素特点"></a>元素特点</h5><p><strong>HashMap支持一个null key 和多个 null value</strong>，原因如下：</p>
<ol>
<li><p>对于 null key 来说，在求hash值时会直接返回0，故只能有一个 null key。</p>
</li>
<li><p>对于 null value 来说，在执行put方法时不会对之进行校验，故可以有多个 null value。</p>
<p>这里要注意，HashMap 的get方法执行逻辑是：如果没有查询到指定key的键值对时会返回 null 对象。故get(key)方法的返回结果为null有两种可能：</p>
<ol>
<li>HashMap中不存在这个 key 对应的键值对；</li>
<li>HashMap中这个key对应的value为null；</li>
</ol>
<p>故，在判断HashMap中是否存在某个key时，应该使用containsKey方法；</p>
</li>
</ol>
<h5 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** 保存Node&lt;K,V>节点的数组，该表在首次使用时初始化，并根据需要调整大小。 分配时，长度始终是2的幂。 */</span>
<span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>
<span class="token comment">/** 存放具体元素的集合 */</span>
<span class="token keyword">transient</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span><span class="token punctuation">></span></span> entrySet<span class="token punctuation">;</span>

<span class="token comment">/** 默认初始容量16 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token comment">/** 最大容量 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>
<span class="token comment">/** 加载因子，用来计算threshold */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>
<span class="token comment">/** 触发扩容的阈值，实际大小（容量*加载因子）超过该阈值时会触发扩容  */</span>
<span class="token keyword">int</span> threshold<span class="token punctuation">;</span>
<span class="token comment">/** 负载因子：要调整大小的下一个大小值（容量*加载因子）。
通过调节负载因子，可使 HashMap 在时间和空间复杂度上有不同表现。调低负载因子时，扩容效率增高，扩容过程中hash碰撞减少、链表长度变短，这是典型的拿空间换时间； 调高负载因子时，容纳键值对数量变多、空间利用率增高，但碰撞也增高了，最终效率下降。故一般使用默认值即可。*/</span>
<span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>

<span class="token comment">/** 进行resize操作时，若桶中数量少于6则从树转成链表 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">UNTREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
<span class="token comment">/** 链表长度大于8时转化为红黑树 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
<span class="token comment">/** 链表转为红黑树时，需先判断当前数组容量是否小于64。若小于64且hash冲突太多，则不进行红黑树转化，而要通过resize函数继续扩容。 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MIN_TREEIFY_CAPACITY</span> <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>

<span class="token comment">/** 记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。 */</span>
<span class="token keyword">int</span> modCount<span class="token punctuation">;</span>  
<span class="token comment">/** HashMap当前存储的元素数量  */</span>
<span class="token keyword">int</span> size<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>HashMap中哈希桶数组table的长度length大小必须为2的n次方（合数）</strong>。</p>
<h5 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h5><ul>
<li><p>key为空，则hashcode为0，这也是HashMap只允许存在一个key为null的原因。</p>
</li>
<li><p>key不为空，则计算公式如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">// 求hash值</span>
<span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">;</span> 					<span class="token comment">// 定位下标</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
<h5 id="put-操作"><a href="#put-操作" class="headerlink" title="put()操作"></a>put()操作</h5><p><strong>JDK1.7采用头插法，JDK1.8采用尾插法</strong>。</p>
<p>JDK8执行流程如下：</p>
<ol>
<li>计算待新增数据key的hash值；</li>
<li>判断Node[]是否为空，若为空需要进行初始化；</li>
<li>通过运算(hash &amp;(len-e))得出待插入元素要存储在数组中的下标位置idx，如果该位置idx没有数据，那么该元素数据添加成功。如果该位置idx有数据，则继续判断：<ol>
<li>如果该位置idx处Node节点的key与待插入数据的key相等，则直接覆盖已存在的值，然后返回旧值；</li>
<li>如果该结构是树形，则按照树的方式插入数据；</li>
<li>如果该结构是链表，则从上到下遍历该链表。如果当前节点的下一节点为null，则将待插入数据放在这个null位置，然后判断链表长度是否大于阈值8，如果 &gt;&#x3D; 8 且数组长度 &gt;&#x3D; 64 才转为红黑树，如果 &gt;&#x3D; 8 且数组长度 &lt; 64 则仅仅进行链表的扩容；如果当前节点的下一个节点不为null，且该节点hash、key与待插入元素数据的hash和key都相同，则将待插入数据替换该节点，然后返回旧值。如果该节点hash、key与待插入数据的hash和key不一样，那就继续遍历该链表。</li>
</ol>
</li>
<li>判断数组长度是否大于阈值，如果是则进入扩容阶段；</li>
</ol>
<h5 id="resize-操作"><a href="#resize-操作" class="headerlink" title="resize()操作"></a>resize()操作</h5><p><strong>当数组元素数量 &#x3D; 数组长度*0.75时触发扩容，扩容后数组长度是旧的2倍。</strong></p>
<p>Java8与Java7的迁移算法不一样，Java8不需要每一个元素都重新计算hash值；JDK8只需根据原hash值新增的那个bit是1还是0来判断，是0的话索引没变，是1的话索引变成：(原索引+oldCap)。</p>
<p><font color='red'>注意：JDK1.7中旧链表迁移至新链表时，如果与新表数组索引位置相同，则链表元素会倒置；而JDK1.8不会倒置。</font></p>
<h5 id="get-key-操作"><a href="#get-key-操作" class="headerlink" title="get(key)操作"></a>get(key)操作</h5><ol>
<li>根据put()方法中计算hash的方式得到一个数组下标index；</li>
<li>遍历数组下标为index所对应的链表，若找到key和hash值同时相等的就返回该值，否则返回null；</li>
</ol>
<h5 id="remove-操作"><a href="#remove-操作" class="headerlink" title="remove()操作"></a>remove()操作</h5><ol>
<li>根据get()方法中的方式计算出要删除的key对应的Node节点；</li>
<li>如果待删除节点是头节点，则将它的next节点作为头节点；</li>
<li>如果待删除节点是红黑树，则直接调用红黑树的删除算法进行删除；</li>
<li>如果待删除节点是链表中的一个节点，则将待删除节点的前一个节点的next属性指向待删除节点的下一个节点即可；</li>
<li>如果删除成功则返回被删除节点的value，否则返回null；</li>
</ol>
<p><font color='red'>注意：删除单个key时，返回的是键值对中的value；</font></p>
<h5 id="iterator迭代器"><a href="#iterator迭代器" class="headerlink" title="iterator迭代器"></a>iterator迭代器</h5><p><code>Hashtable</code> 和 <code>HashMap</code> 有相同的迭代器 Iterator，<code>HashMap</code>和<code>Hashtable</code>  的 Iterator 都是快速失败 fail-fast。但<code>Hashtable</code> 还有另外一个迭代器 Enumeration，该迭代器是 安全失败 fail-safe，<code>HashTable</code> 中有一个 keys 方法可以返回 Enumeration 迭代器。</p>
<blockquote>
<p><strong>fail-safe 和 fail-fast 是一种思想，一种机制，属于系统设计范畴，并非 Java 集合所特有</strong>。</p>
<p><strong>（1）快速失败 fail-fast</strong></p>
<p>一种快速发现系统故障的机制。一旦发生异常，立即停止当前操作，并上报给上层的系统来处理这些故障。</p>
<p>当 Iterator 这个迭代器被创建后，除了迭代器本身的方法 remove 可以改变集合的结构外，其他的因素若改变了集合的结构（改变只包含插入和删除），都将会抛出 <code>ConcurrentModificationException</code> 异常。</p>
<p><strong>java.util 包下的集合类都是 fail-fast 的</strong>。</p>
<p><strong>（2）安全失败 fail-safe</strong></p>
<p>在故障发生之后会维持系统继续运行。 fail-safe 不会抛出异常的原因如下：</p>
<ol>
<li>当集合的结构被改变时，fail-safe 机制会复制一份原集合数据，然后在复制的那份数据上进行遍历。</li>
</ol>
<p>虽然 fail-safe 不会抛出异常，但存在以下缺点：</p>
<ol>
<li>不能保证遍历的是最新内容。也就是说迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的；</li>
<li>复制时需要额外的空间和时间开销。</li>
</ol>
<p>顾名思义，和 fail-fast 恰恰相反，当我们对集合的结构做出改变的时候，fail-safe 机制不会抛出异常。</p>
<p><strong>java.util.concurrent 包下的容器都是 fail-safe 的。</strong></p>
</blockquote>
<h5 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h5><p>HashMap非线程安全，而ConcurrentHashMap线程安全。</p>
<p>ConcurrentHashMap底层结构在JDK1.7和1.8中也不同：</p>
<ul>
<li>JDK1.7： 分段锁；</li>
<li>JDK1.8：CAS + Synchronized；</li>
</ul>
<h5 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h5><p>常见问题如下：</p>
<ol>
<li>多线程扩容，引起死循环问题；</li>
<li>多线程put时可能导致元素丢失；</li>
<li>put非null元素后get出来的是null；</li>
</ol>
<p>应对措施：使用HashTable 或者 ConcurrentHashMap。</p>
<h5 id="Key取值问题"><a href="#Key取值问题" class="headerlink" title="Key取值问题"></a>Key取值问题</h5><ol>
<li><p>key只允许有一个null，value允许有多个null；（key为null的hashcode总是0）</p>
</li>
<li><p>key取值范围有哪些？</p>
<p>一般使用String、Integer，且String最常用。原因如下：</p>
<ol>
<li>字符串是不可变的，它在被创建时其hashcode就缓存了，无需计算，且效率要比其它对象高。</li>
<li>获取对象时需要用到equals方法和hashCode方法，而String已经规范的重写过了。</li>
</ol>
</li>
<li><p>可变类可以作为key使用吗？</p>
<p>不可以，因为hashcode可能会发生变化，导致put进去的值，无法get出来。</p>
</li>
<li><p>如何自定义一个类，其可以作为HashMap的key？</p>
<p>该问题考察两个知识点：</p>
<ol>
<li><p>如何重写equals方法和hashCode方法？</p>
<p>根据如下4条规则来设计即可：</p>
<ol>
<li>两个对象相等，hashcode⼀定相等；</li>
<li>两个对象不等，hashcode不⼀定不等；</li>
<li>hashcode相等，两个对象不⼀定相等；</li>
<li>hashcode不等，两个对象⼀定不等；</li>
</ol>
</li>
<li><p>如何设计一个不变类？</p>
<ol>
<li>使用final修饰类，保证类不能被继承。</li>
<li>将所有成员变量访问权限设为私有，且加上final修饰，保证成员变量不可变；</li>
<li>不提供修改成员变量的方法；</li>
<li>通过构造器初始化所有成员，进行深拷贝；</li>
<li>getter方法中不要直接返回对象本身，而要返回克隆对象，防止逃逸。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="位运算-VS-取模运算"><a href="#位运算-VS-取模运算" class="headerlink" title="位运算 VS 取模运算"></a>位运算 VS 取模运算</h5><p>HashMap采用 位运算 的原因如下</p>
<ol>
<li><strong>效率高。</strong>位运算直接对内存数据进行操作，不需要转换为十进制，因此处理速度快；</li>
<li><strong>可以解决取模运算的负数问题。</strong>比如：-15 % 10 &#x3D; -5；</li>
</ol>
<h5 id="JDK7和JDK8下HashMap的异同"><a href="#JDK7和JDK8下HashMap的异同" class="headerlink" title="JDK7和JDK8下HashMap的异同"></a>JDK7和JDK8下HashMap的异同</h5><ol>
<li>存放数据的节点名称不同；JDK7使用 Entry 命名；JDK8使用 Node 命名；</li>
<li>定位数组下标位置方法不同；<ul>
<li>JDK7：计算key的hash，然后进行四次扰动，再与数组长度取模得出；</li>
<li>JDK8：计算key的hash，将hash值进行高低16位异或操作，再与数组长度取模得出；</li>
</ul>
</li>
<li>扩容时机不同：JDK7添加数据前先判断是否需要扩容；JDK8添加数据后再判断是否需要扩容；</li>
<li>扩容迁移定位方法不同；<ul>
<li>JDK7：扩容后需要重新计算hash；</li>
<li>JDK8：扩容后不需要重新计算hash；</li>
</ul>
</li>
<li>put方法插入链表位置不同：<ul>
<li>JDK7：头插法；</li>
<li>JDK8：尾插法；</li>
</ul>
</li>
<li>红黑树升级和退化<ul>
<li>链表升级为红黑树：<strong>JDK8引入红黑树，当链表长度 &gt;&#x3D; 8 且 数组长度 &gt;&#x3D; 64 时，链表转为红黑树；</strong></li>
<li>红黑树退化为链表：有两个地方会判断并退化成链表：<ol>
<li><strong>remove时退化；</strong></li>
<li><strong>扩容时会调用<code>split()</code>进行红黑树的扩容移动处理。</strong>split方法中，会将当前红黑树左右子树分别放入low，high两个w变量（treeNode类型）中。可理解为两条链表，当low链表中元素&lt;&#x3D;6时会将low转换为真正的链表（Node类型），当low链表中元素&gt;6时会进行树化处理， 例如对链表中节点的left、right等进行赋值，high链表同理。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h5 id="HashMap-VS-HashTable"><a href="#HashMap-VS-HashTable" class="headerlink" title="HashMap VS HashTable"></a>HashMap VS HashTable</h5><ol>
<li>初始容：HashMap是16；HashTable是11；</li>
<li>定位数组下标位置：<ul>
<li>HashMap：key.hashcode()后 通过 位运算 定位下标；</li>
<li>HashTable：key.hashcode()后 通过 取模运算 定位下标；</li>
</ul>
</li>
<li>判断扩容时机：HashMap在put后判断；HashTable在put前判断；</li>
<li>扩容大小：HashMap扩大为原容量的2倍；HashTable扩大为原容量的2倍+1；</li>
<li>null key 和 null value<ul>
<li>HashMap：允许1个null key（多个覆盖）和 多个null value；</li>
<li>HashTable：不允许null key 和 null value；</li>
</ul>
</li>
<li>线程安全：HashMap线程不安全；HashTable线程安全；</li>
<li>接口实现：HashMap实现Map接口且继承AbstractMap类；HashTable实现Map接口且继承Dictionary类；</li>
</ol>
<h5 id="HashMap-VS-TreeMap"><a href="#HashMap-VS-TreeMap" class="headerlink" title="HashMap VS TreeMap"></a>HashMap VS TreeMap</h5><ol>
<li>数据结构：HashMap是数组+链表+红黑树；TreeMap是红黑树；</li>
<li>存储方式：HashMap是随机存储；TreeMap是按key的字典升序排序存储；</li>
<li>null key 和 null value<ul>
<li>HashMap：允许1个null key（多个覆盖），允许多个null value；</li>
<li>TreeMap：不允许null key，但允许多个null value；</li>
</ul>
</li>
<li>效率高低：HashMap效率高；TreeMap效率低；</li>
</ol>
<h4 id="3-3-6-2、HashTable原理"><a href="#3-3-6-2、HashTable原理" class="headerlink" title="3.3.6.2、HashTable原理"></a>3.3.6.2、HashTable原理</h4><h5 id="底层数据结构-1"><a href="#底层数据结构-1" class="headerlink" title="底层数据结构"></a>底层数据结构</h5><p>使用哈希表来存储键值对，数据结构创建了一个继承<code>Map.Entry</code>的私有静态内部类<code>Entry</code>，每一个Entry对象表示存储在哈希表中的一个键值对。</p>
<h5 id="元素特点-1"><a href="#元素特点-1" class="headerlink" title="元素特点"></a>元素特点</h5><p><strong>HashTable不支持 null key和null value</strong>，原因如下：</p>
<ol>
<li>对于 null value 来说，在执行put方法时会直接抛出异常NullPointerException。</li>
<li>对于 null key 来说，在定位元素时会执行key.hashCode方法，会抛出NullPointerException。</li>
<li>若允许 null key 和 null value，则多线程环境下会出现问题。（ConcurrentHashMap也不允许null key 和 null value。）</li>
</ol>
<h5 id="rehash方法（扩容）"><a href="#rehash方法（扩容）" class="headerlink" title="rehash方法（扩容）"></a>rehash方法（扩容）</h5><p><strong>当前容量 &gt;&#x3D;（总容量 * 负载因子）时，Hashtable 扩大为旧容量的2倍+1；</strong></p>
<h4 id="3-3-6-3、ArrayList原理"><a href="#3-3-6-3、ArrayList原理" class="headerlink" title="3.3.6.3、ArrayList原理"></a>3.3.6.3、ArrayList原理</h4><h5 id="add-element-操作"><a href="#add-element-操作" class="headerlink" title="add(element)操作"></a>add(element)操作</h5><ol>
<li><p>判断当前数组是否为空，若是则创建长度为10的数组，因为new ArrayList 时没有初始化；</p>
</li>
<li><p>判断是否需要扩容，即：当前数组中元素数+1后（size+1）判断其是否大于当前数组长度，是则进行扩容（执行grow()方法）;</p>
<p>grow()方法流程如下：</p>
<ol>
<li>创建新数组，其长度为原数组长度的1.5倍；</li>
<li>如果扩大1.5倍后依然不够，则根据实际长度来扩容，比如addAll()场景；</li>
<li>将原数组的数据通过<code>System.arraycopy</code>方法（native方法）复制到新数组中；</li>
</ol>
</li>
<li><p>在数组末尾添加数据，并将size+1；</p>
</li>
</ol>
<h5 id="add-index-element-操作"><a href="#add-index-element-操作" class="headerlink" title="add(index, element)操作"></a>add(index, element)操作</h5><ol>
<li>检查index是否在数组范围内，假如数组长度是2，则index必须 &gt;&#x3D; 0 且 &lt;&#x3D; 2，否则抛出异常IndexOutOfBoundsException异常；</li>
<li>扩容检查；</li>
<li>通过拷贝方式，把数组位置为index至size-1的元素都往后移动一位，腾出位置后放入元素，并将size+1；</li>
</ol>
<h5 id="set-index-element-操作"><a href="#set-index-element-操作" class="headerlink" title="set(index, element)操作"></a>set(index, element)操作</h5><ol>
<li>检查index是否在数组范围内，加入数组长度为2，则index必须 &gt;&#x3D; 0 且 &lt; 2；</li>
<li>保存被覆盖的值，因为最终需要返回旧值；</li>
<li>新元素放至index位置，并返回该位置旧值；</li>
</ol>
<h5 id="remove-index-操作"><a href="#remove-index-操作" class="headerlink" title="remove(index)操作"></a>remove(index)操作</h5><ol>
<li>检查index是否在数组范围内，假如数组长度是2，则index必须 &gt;&#x3D; 0 且 &lt;&#x3D; 2；</li>
<li>保留要删除的值，因为最终要返回该值（旧值）；</li>
<li>计算需要移动元素的个数，再通过拷贝使数组中位置为 index+1 到 size-1 的元素向前移动一位，然后把数组最后一位元素设为null，返回旧值；</li>
</ol>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ol>
<li><strong>new ArrayList创建对象时，如果没有指定容量则初始化为0；如果有指定，则按照指定大小进行初始化；</strong></li>
<li><strong>扩容时，将容量扩大1.5倍，如果还是不够则根据实际元素数量来扩大，保证能存储所有数据，比如addAll场景；</strong></li>
<li><strong>若扩容后数组长度大于 (Integer.MAX_VALUE - 8)，则抛出异常OutOfMemoryError。</strong></li>
</ol>
<h5 id="ArrayList-VS-Vector"><a href="#ArrayList-VS-Vector" class="headerlink" title="ArrayList VS Vector"></a>ArrayList VS Vector</h5><ol>
<li>线程安全：ArrayList不安全；Vector安全；</li>
<li>扩容倍数：ArrayList默认1.5倍；Vector默认扩大为原容量的2倍，创建时也可显式设置扩容量；</li>
<li>支持序列化：ArrayList支持序列化；Vector不支持；</li>
<li>indexOf()接口支持：ArrayList提供了indexOf(obj, start)接口；Vector没有提供；</li>
<li>指定扩容系数：ArrayList不可以指定；Vector可以指定；</li>
</ol>
<h5 id="ArrayList-VS-LinkedList"><a href="#ArrayList-VS-LinkedList" class="headerlink" title="ArrayList VS LinkedList"></a>ArrayList VS LinkedList</h5><ol>
<li>底层数据结构：ArrayList是动态数组；LinkedList是双向链表；</li>
<li>增删改查特点：ArrayList查询快增删慢；LinkedList随机查询慢，顺序查询快，增删快；</li>
<li>空间浪费：ArrayList会在数组末尾保留一定空间；LinkedList会在每一个节点都要消耗空间来存储prev、next信息；</li>
</ol>
<h4 id="3-3-6-4、LinkedList原理"><a href="#3-3-6-4、LinkedList原理" class="headerlink" title="3.3.6.4、LinkedList原理"></a>3.3.6.4、LinkedList原理</h4><h5 id="add-操作"><a href="#add-操作" class="headerlink" title="add()操作"></a>add()操作</h5><ol>
<li>创建一个新节点，节点元素为传入的参数，前继节点是 当前节点的last节点，后继节点next为null；</li>
<li>判断当前链表last节点是否为null，如果是，则把新建的节点作为头节点，否则把新建的节点作为last节点；</li>
<li>最后返回true；</li>
</ol>
<h5 id="get-index-element-操作"><a href="#get-index-element-操作" class="headerlink" title="get(index, element)操作"></a>get(index, element)操作</h5><ol>
<li>检擦index是否在数组长度范围内，假如数组长度为2，则index必须 &gt;&#x3D; 0 且 &lt; 2；</li>
<li>如果 index 小于 (双向链表长度的1&#x2F;2)，则从头开始遍历查找，否则从链表末尾向前遍历查找；</li>
</ol>
<h5 id="remove-操作-1"><a href="#remove-操作-1" class="headerlink" title="remove()操作"></a>remove()操作</h5><ol>
<li>判断first节点是否为空，如果是则抛出异常NoSuchElementException；</li>
<li>如果不为空，则把待删除节点的next节点的prev属性值设为null，达到 删除头节点的效果；</li>
<li>返回删除值；</li>
</ol>
<h4 id="3-3-6-5、ConcurrentHashMap"><a href="#3-3-6-5、ConcurrentHashMap" class="headerlink" title="3.3.6.5、ConcurrentHashMap"></a>3.3.6.5、ConcurrentHashMap</h4><h5 id="put-操作-1"><a href="#put-操作-1" class="headerlink" title="put()操作"></a>put()操作</h5><ol>
<li>判断待插入数据key和value是否为空，如果是则抛出空指针异常；</li>
<li>判断Node[] 数组是否为空，若是则需要初始化；</li>
<li>根据hash值通过位运算计算出Node数组的下标，判断该数组第一个Node节点是否有数据，如果没有数据则通过CAS将新值插入；</li>
<li>如果有数据则判断头节点的hashcode是否等于MOVED（即-1），即检查是否正在扩容，如果等于-1则帮助扩容；</li>
<li>若有数据，则对头节点进行加锁，如果头节点的hashcode &gt;&#x3D; 0，则说明是链表，遍历链表。如果找到key和hahs同时相等，则进行覆盖；若没有找到，则将新值插入到链表的最后面；如果hashCode &lt; 0，说明红黑树，调用红黑树的 插值方法 插入新节点；</li>
<li>插值完成后，判断链表元素是否 &gt;&#x3D; 8，如果 &gt;&#x3D;8 且数组长度 &gt; 64则转为红黑树。如果 &gt;&#x3D; 8 且数组长度 &lt; 64 则仅仅进行扩容；</li>
</ol>
<h5 id="resize-操作-1"><a href="#resize-操作-1" class="headerlink" title="resize()操作"></a>resize()操作</h5><p>创建新数组，其长度为原数组长度的2倍；多线程环境下旧数组迁移至新数组时会发生线程安全问题；</p>
<h5 id="get-操作"><a href="#get-操作" class="headerlink" title="get()操作"></a>get()操作</h5><ol>
<li>计算获取数据key的hash值；</li>
<li>根据hashCode并通过位运算得到Node数组的下标，即得到头节点；</li>
<li>如果头节点为空，则返回null；</li>
<li>如果头节点的key与参数key可以相等，则返回头节点的值；</li>
<li>如果头节点的hashcode小于0，说明是红黑树，则调用find方法按照树的方式获取值；</li>
<li>如果不满足3、4、5条件，说明是链表，则按照链表的方式遍历获取值，整个过程不需要加锁；</li>
</ol>
<p>注意：整个过程无需加锁，因为读取的数据被volatile修饰，实现线程可见性；</p>
<h5 id="remove-操作-2"><a href="#remove-操作-2" class="headerlink" title="remove()操作"></a>remove()操作</h5><ol>
<li>计算待插入数据key的hash值；</li>
<li>判断Node[]数组是否为空，如果是则返回null；如果不是，则根据hashCode通过位运算定位到数组下标，即得到头节点；</li>
<li>判断头节点hashCode是否等于MOVED（即-1），检查是否正在扩容，如果是则帮助扩容；</li>
<li>如果2、3条件都不满足，则加锁进行删除操作；</li>
<li>首先判断头节点有无发生变化，如果有改变则返回null；</li>
<li>如果头节点hashCode大于0，说明是链表，则按照链表方式遍历删除值；</li>
<li>如果头节点是TreeBin类型，说明是红黑树，则按照红黑树方式删除值；</li>
</ol>
<p><font color='red'>注意：remove()底层是调用replaceNode()函数实现节点删除；</font></p>
<h5 id="JDK7、JDK8-下ConcurrentHashMap的区别"><a href="#JDK7、JDK8-下ConcurrentHashMap的区别" class="headerlink" title="JDK7、JDK8 下ConcurrentHashMap的区别"></a>JDK7、JDK8 下ConcurrentHashMap的区别</h5><ol>
<li><font color='orange'>底层结构</font><ul>
<li>JDK7：<strong>以 segment 作为每组数据的容器，对segment加锁只能锁住当前segment，segment数量等于并发度。 segment数组 + entry数组 + 链表。</strong></li>
<li>JDK8：<strong>没有segment数组。 直接 entry数组 + 链表，锁粒度为entry数组中每个索引节点。</strong></li>
</ul>
</li>
<li><font color='orange'>初始化</font>：JDK7直接初始化。JDK8会在第一次put时初始化。</li>
<li><font color='orange'>锁实现</font>：JDK7<strong>使用分段锁Segment；</strong>JDK8<strong>使用CAS+Synchronized；</strong></li>
<li><font color='orange'>查询遍历</font>：JDK7基于链表实现，遍历效率低；JDK8基于红黑树实现，遍历效率高；</li>
<li><font color='orange'>数据存放命名</font>：JDK7使用HashEntry容器来存储数据；JDK8改名为Node容器来存储数据；</li>
<li><font color='orange'>数据插入</font><ul>
<li>JDK7：<strong>头插法</strong>；<ol>
<li>segment下标位置：并发度为16，因 2^4 &#x3D; 16，故下标位置就是二次hash值的二进制位的 高4位 对应的 十进制数值。</li>
<li>数组索引位置：数组长度为8，因2^3 &#x3D; 8，故索引位置就是二次hash值的二进制位的 低3位 对应的 十进制数值。</li>
</ol>
</li>
<li>JDK8：<strong>尾插法；</strong><ol>
<li>1.8 中的capacity不再表示全部容量，而是一定会放入的数据数量。如果capacity为16，那么第一次会初始化一个容量为32的数组，因为容量为16，加载因子为0.75，超过12（16*0.75）才扩容，而你直接放入16个元素，那更应该扩容了。</li>
</ol>
</li>
</ul>
</li>
<li><font color='orange'>扩容</font><ul>
<li>JDK7：<strong>容量超过3&#x2F;4时才扩容，先扩容再插入值；</strong>在其它segment中创建数组时会以segment[0]中的数组大小为原型来创建。segment[0]位置初始容量：总容量 &#x2F; 并发度。</li>
<li>JDK8：<strong>容量等于3&#x2F;4时就扩容，先插入值再扩容；</strong>迁移数据时，从旧数组中拿数据的顺序是从右到左。</li>
</ul>
</li>
<li><font color='orange'>锁的粒度</font><ul>
<li>JDK7：<strong>最大并发数是Segment的个数，默认16，锁住整个段，不影响其它段；</strong></li>
<li>JDK8：<strong>去掉分段锁，更细粒度，只锁住一个Node节点，不影响其它Node节点；</strong></li>
</ul>
</li>
<li><font color='orange'>读写限制及扩容</font><ul>
<li>JDK7：扩容时锁住一个段，当前段可读不可写，其它段可读写，只开启1个线程进行扩容；</li>
<li>JDK8：锁住一个Node节点，当前节点可读不可写，其它节点可读写，1个线程+可能多个put&#x2F;remove线程帮助扩容；</li>
</ul>
</li>
</ol>
<h4 id="3-3-6-6、TreeMap"><a href="#3-3-6-6、TreeMap" class="headerlink" title="3.3.6.6、TreeMap"></a>3.3.6.6、TreeMap</h4><h5 id="put-操作-2"><a href="#put-操作-2" class="headerlink" title="put()操作"></a>put()操作</h5><p>主要分为两个步骤：</p>
<ol>
<li><strong>构建排序二叉树</strong><ol>
<li>从根节点root开始查找；</li>
<li>如果root节点比待插入节点值小，则在root节点左子树查找，如果大于，则在右子树查找；</li>
<li>递归循步骤2，找到合适节点为止；</li>
<li>把待插入节点与步骤3中查找到的节点进行对比，如果待插入节点小于找到节点，则把待插入节点作为找到节点的左子树，否则作为右子树；</li>
</ol>
</li>
<li><strong>构建平衡二叉树</strong></li>
</ol>
<h5 id="remove-操作-3"><a href="#remove-操作-3" class="headerlink" title="remove()操作"></a>remove()操作</h5><p>比put操作复杂，同样分为两个步骤：</p>
<ol>
<li><strong>删除节点</strong><ol>
<li>待删除节点，如果没有左和右子树时，则直接删除；</li>
<li>待删除节点，如果有一个字节点时，则把它的子节点指向它的上级节点（父节点）；</li>
<li>待删除节点，如果有两个非空的子节点时，流程复杂，暂不解释；</li>
</ol>
</li>
<li><strong>着色旋转</strong><ol>
<li>进行颜色对调和旋转，达到红黑树的特征；</li>
</ol>
</li>
</ol>
<h2 id="3-4、JAVA引用"><a href="#3-4、JAVA引用" class="headerlink" title="3.4、JAVA引用"></a>3.4、JAVA引用</h2><h3 id="3-4-1、引用类型"><a href="#3-4-1、引用类型" class="headerlink" title="3.4.1、引用类型"></a>3.4.1、引用类型</h3><h4 id="3-4-1-1、强引用"><a href="#3-4-1-1、强引用" class="headerlink" title="3.4.1.1、强引用"></a>3.4.1.1、强引用</h4><ul>
<li><p>定义：new一个对象就是强引用。</p>
</li>
<li><p>回收时机：<strong>引用为null时就可以回收它。</strong></p>
</li>
<li><p>代码实现</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
<blockquote>
<p>new一个对象，这个引用就是强引用。代码中的<code>p</code>就是一个强引用。当p &#x3D; null时，GC就可以回收它了。</p>
</blockquote>
<h4 id="3-4-1-2、软引用"><a href="#3-4-1-2、软引用" class="headerlink" title="3.4.1.2、软引用"></a>3.4.1.2、软引用</h4><ul>
<li><p>定义：被SoftReference类对象指向的引用。</p>
</li>
<li><p>回收时机：<strong>内存不够时才会回收。</strong></p>
</li>
<li><p>代码实现</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> softReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>只有在内存不够时，才会回收 byte字节数组。</p>
</li>
<li><p>应用场景：做缓存使用。</p>
</li>
</ul>
<h4 id="3-4-1-3、弱引用"><a href="#3-4-1-3、弱引用" class="headerlink" title="3.4.1.3、弱引用"></a>3.4.1.3、弱引用</h4><ul>
<li><p>定义：被WeakReference类对象指向的引用。</p>
</li>
<li><p>回收时机：<strong>GC看到就回收（下次gc时回收）。</strong></p>
</li>
<li><p>代码实现</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">></span></span> weakReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>应用场景：用在容器中。</p>
</li>
</ul>
<h4 id="3-4-1-4、虚引用"><a href="#3-4-1-4、虚引用" class="headerlink" title="3.4.1.4、虚引用"></a>3.4.1.4、虚引用</h4><ul>
<li><p>定义：被PhantomReference类对象指向的应用。相当于不存在，get操作不能获取到值。</p>
</li>
<li><p>回收时机：<strong>GC看到就回收。（队列不为null，说明已经被回收了）。</strong></p>
</li>
<li><p>代码实现</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">></span></span> rq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">></span></span> phantomReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rq<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>PhantomReference的构造函数有两个参数，第二个参数必须是一个队列。虚引用就是给你一个通知，通知时放在队列中，你只需判断队列中是否为null，如果队列不为 null 说明虚引用已被回收。</p>
</li>
<li><p>应用场景：处理堆外内存。（参考NIO中的DirectByteBuffer，意为直接内存，直接内存不受JVM管理，而是被系统管理，故又叫堆外内存。堆外内存的回收可以使用虚引用来实现。）</p>
</li>
</ul>
<h1 id="4、Java内存模型"><a href="#4、Java内存模型" class="headerlink" title="4、Java内存模型"></a>4、Java内存模型</h1><h2 id="4-1、简介"><a href="#4-1、简介" class="headerlink" title="4.1、简介"></a>4.1、简介</h2><h3 id="4-1-1、前言"><a href="#4-1-1、前言" class="headerlink" title="4.1.1、前言"></a>4.1.1、前言</h3><p>并发编程中，需要处理两个关键问题：<strong>线程之间如何通信及线程之间如何同步。</strong></p>
<ul>
<li><p>通信</p>
<p>通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：</p>
<ul>
<li><p>共享内存</p>
<p>在共享内存的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状态 进行隐式通信。</p>
</li>
<li><p>消息传递。</p>
<p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。</p>
</li>
</ul>
</li>
<li><p>同步</p>
<p>同步是指程序中用于控制不同线程间操作发生相对顺序的机制。</p>
<p>在共享内存并发模型 里，同步显式进行。在消息传递的并发模型里，由于消息发送必须在消息接收前，因此同步是隐式进行的。</p>
</li>
</ul>
<p><strong>Java并发采用的是共享内存模型，Java线程间的通信是隐式进行，整个通信过程对程序员完全透明。</strong></p>
<h3 id="4-1-2、认识JMM"><a href="#4-1-2、认识JMM" class="headerlink" title="4.1.2、认识JMM"></a>4.1.2、认识JMM</h3><p><strong>Java内存模型是根据英文Java Memory Model（JMM）翻译过来。其实JMM并不像JVM内存结构一样真实存在。他只是一个抽象概念。</strong></p>
<p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了主内存变量的副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间无法直接访问对方工作内存中的变量，线程间的通信需要通过主内存来实现。</p>
<p><strong>JMM作用于工作内存和主存之间的数据同步过程。它规定了如何做数据同步以及什么时候做数据同步。</strong></p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210424211138529.png?token=AIGEF3JZVGM2SSRA5JMZNGDEZZXWK" alt="image-20210424211138529"></p>
<p>Java内存模型的相关知识在<code>JSR-133: Java Memory Model and Thread Specification</code>中有描述。JMM是和多线程相关，它描述了一组规则或规范，这个规范规定了一个线程对共享变量的写入对另一个线程是可见的。</p>
<p><strong>Java内存模型（Java Memory Model，JMM）就是一种符合内存模型规范，屏蔽了各种硬件和操作系统访问差异，保证了Java程序在各种平台下对内存的访问都能得到一致效果的机制及规范。目的是解决多线程环境中基于共享内存进行通信时，存在的原子性、可见性（缓存一致性）以及有序性问题。</strong></p>
<h2 id="4-2、重要概念"><a href="#4-2、重要概念" class="headerlink" title="4.2、重要概念"></a>4.2、重要概念</h2><h3 id="4-2-1、原子性问题"><a href="#4-2-1、原子性问题" class="headerlink" title="4.2.1、原子性问题"></a>4.2.1、原子性问题</h3><p><strong>线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。</strong>所以在多线程场景下，就会发生原子性问题。</p>
<p>例如：线程要完成一个读、改、写操作，但在执行完读、改之后，时间片耗完了，此时就要放弃CPU，并等待重新调度。这种情况下，读改写就不是一个原子操作。即存在原子性问题。</p>
<h3 id="4-2-2、一致性问题"><a href="#4-2-2、一致性问题" class="headerlink" title="4.2.2、一致性问题"></a>4.2.2、一致性问题</h3><p><strong>多核CPU 和 多线程场景中，每个核都至少有一个L1 缓存。</strong>多个线程访问进程中的某个共享内存，且多个线程分别在不同的核心上执行，则每个核心都会在各自的cache中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自缓存的情况，而各自cache之间的数据就有可能不同。</p>
<p>在CPU和主存之间增加缓存可能导致在多线程场景下出现缓存一致性问题，多核CPU的每个核的缓存中，对于同一数据可能有不同的副本。</p>
<h3 id="4-2-3、有序性问题"><a href="#4-2-3、有序性问题" class="headerlink" title="4.2.3、有序性问题"></a>4.2.3、有序性问题</h3><p><strong>现代的处理器使用 写缓冲区 临时保存向内存写入的数据。</strong>写缓冲区可以保证指令流水线持续运行，可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。它可以通过 批处理 刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写来减少对内存总线的占用。</p>
<p>但要注意，<strong>每个处理器上的写缓冲区，仅仅对它所在的处理器可见。</strong>这个特性会对内存操作的执行顺序产生重要影响：<strong>处理器对内存读&#x2F;写操作的执行顺序不一定与内存实际发生的读&#x2F;写操作顺序一致。</strong></p>
<p>由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的 顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此 现代的处理器都会允许对写-读操作进行重排序。</p>
<p>为提高性能，编译器和处理器会对指令做重排序。重排序分3种类型：</p>
<ol>
<li>编译器优化重排序。（编译器重排序）</li>
<li>指令级并行重排序。（处理器重排序）</li>
<li>内存系统重排序。（处理器重排序）</li>
</ol>
<p>从Java源代码到最终执行的指令序列，会经历下面3种重排序：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-1.1-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F-%E6%BA%90%E7%A0%81%E5%88%B0%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4%E9%97%B4%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B.png?token=AIGEF3PREC67A44L2UZB5ADEZZX4Q" alt="Java内存模型-1.1-指令重排序-源码到执行指令间的重排序过程"></p>
<p><strong>重排序可能会导致多线程程序出现内存可见性问题。</strong></p>
<h3 id="4-2-4、内存模型"><a href="#4-2-4、内存模型" class="headerlink" title="4.2.4、内存模型"></a>4.2.4、内存模型</h3><p><strong>CPU多级缓存导致的一致性问题、CPU时间片机制导致的原子性问题、以及处理器优化和指令重排导致的有序性问题等，都是由硬件不断升级导致。</strong></p>
<p>为了保证并发编程中可以满足原子性、可见性及有序性，内存模型 就出现了。</p>
<p>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器、缓存、并发、编译器有关。它解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p>
<p><strong>Java语言为了屏蔽掉底层差异，定义了一套属于Java语言的内存模型规范，即Java内存模型。</strong></p>
<h2 id="4-3、底层实现"><a href="#4-3、底层实现" class="headerlink" title="4.3、底层实现"></a>4.3、底层实现</h2><h3 id="4-3-1、happens-before"><a href="#4-3-1、happens-before" class="headerlink" title="4.3.1、happens-before"></a>4.3.1、happens-before</h3><p>happens-before的概念最初由<em><strong>Leslie Lamport</strong></em>在其一篇影响深远的论文（《Time，Clocks and the Ordering of Events in a Distributed System》）中提出。</p>
<p>从JDK 5开始，Java使用新的JSR-133内存模型。JSR-133使用happens-before的概念来指定两个操作之间的执行顺序。</p>
<p>在JMM中，<strong>如果一 个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。</strong>这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p>
<p><strong>happens-before规则有8个</strong>，详情如下：</p>
<ul>
<li><strong>程序次序规则</strong>：一个线程中的每个操作，happens-before于该线程中的任意后续操作。（线程中的代码顺序执行）</li>
<li><strong>管程锁定规则</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。（先解锁后加锁）</li>
<li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的 读。（先volatile写后volatile读）</li>
<li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
<li><strong>对象终结规则</strong>：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize()方法的开始。</li>
<li><strong>线程启动规则</strong>：Thread对象的start()方法先行发生于此线程的每一个动作。</li>
<li><strong>线程中断规则</strong>：对线程interrupt()方法的调用先行发生于被中断线程 的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。</li>
<li><strong>线程终止规则</strong>：线程中的所有操作都先行发生于对此线程的终止检 测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。</li>
</ul>
<p>JMM把happens-before 要求禁止的重排序分为下面两种：</p>
<ul>
<li><p><strong>会改变程序执行结果的重排序</strong>。</p>
<p>对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。</p>
</li>
<li><p><strong>不会改变程序执行结果的重排序</strong>。</p>
<p>对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种 重排序）。</p>
</li>
</ul>
<blockquote>
<p>两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个 操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一 个操作按顺序排在第二个操作之前。</p>
<p>如果前一个操作的结果不需要对后一个操作可见，且前后两个操作按happens-before关系来执行 与 不按照happens-before关系来执行的结果如果完全一致，那么JMM允许这种重排序。</p>
</blockquote>
<h3 id="4-3-2、as-if-serial"><a href="#4-3-2、as-if-serial" class="headerlink" title="4.3.2、as-if-serial"></a>4.3.2、as-if-serial</h3><p>as-if-serial语义是：<strong>不管怎么重排序（编译器和处理器为了提高并行度），（单线程） 程序的执行结果不能被改变。</strong>编译器、runtime和处理器都必须遵守as-if-serial语义。</p>
<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。</p>
<p>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证了正确同步的多线程程序执行结果的正确性。</p>
<h3 id="4-3-3、volatile内存语义"><a href="#4-3-3、volatile内存语义" class="headerlink" title="4.3.3、volatile内存语义"></a>4.3.3、volatile内存语义</h3><h4 id="volatile写内存语义"><a href="#volatile写内存语义" class="headerlink" title="volatile写内存语义"></a>volatile写内存语义</h4><p><strong>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</strong></p>
<h4 id="volatile读内存语义"><a href="#volatile读内存语义" class="headerlink" title="volatile读内存语义"></a>volatile读内存语义</h4><p><strong>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</strong></p>
<h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p><strong>为了实现volatile内存语义，JMM会限制 编译器重排序 和 处理器重排序。</strong></p>
<p>JMM禁止 编译器重排序 的规则如下：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805235157835.png?token=AIGEF3KZOENBUAHU2SOPZ2DEZZYFW" alt="image-20230805235157835"></p>
<blockquote>
<p>在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量重排序。</p>
</blockquote>
<h3 id="4-3-4、锁内存语义"><a href="#4-3-4、锁内存语义" class="headerlink" title="4.3.4、锁内存语义"></a>4.3.4、锁内存语义</h3><h4 id="锁获取内存语义"><a href="#锁获取内存语义" class="headerlink" title="锁获取内存语义"></a>锁获取内存语义</h4><p><strong>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的 临界区代码必须从主内存中读取共享变量。</strong></p>
<h4 id="锁释放内存语义"><a href="#锁释放内存语义" class="headerlink" title="锁释放内存语义"></a>锁释放内存语义</h4><p><strong>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。</strong></p>
<blockquote>
<p>对比锁释放-获取的内存语义与volatile写-读的内存语义可以看出：锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。</p>
</blockquote>
<h4 id="公平锁和非公平锁内存语义"><a href="#公平锁和非公平锁内存语义" class="headerlink" title="公平锁和非公平锁内存语义"></a>公平锁和非公平锁内存语义</h4><ul>
<li>公平锁和非公平锁释放时，最后都要写一个volatile变量state。</li>
<li>公平锁获取时，首先会去读volatile变量。 </li>
<li>非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile 写的内存语义。</li>
</ul>
<h3 id="4-3-4、final域内存语义"><a href="#4-3-4、final域内存语义" class="headerlink" title="4.3.4、final域内存语义"></a>4.3.4、final域内存语义</h3><p>对于final域，编译器和处理器要遵守两个重排序规则：</p>
<ol>
<li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两者不能重排序。</li>
<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能 重排序。</li>
</ol>
<h3 id="4-4-1、原子性"><a href="#4-4-1、原子性" class="headerlink" title="4.4.1、原子性"></a>4.4.1、原子性</h3><p><strong>Java为了保证原子性，提供了两个高级字节码指令<code>monitorenter</code>和<code>monitorexit</code>。在Java中对应的关键字就是synchronized。</strong></p>
<p>Java中可以使用synchronized来保证方法和代码块内操作的原子性。</p>
<h3 id="4-4-2、可见性"><a href="#4-4-2、可见性" class="headerlink" title="4.4.2、可见性"></a>4.4.2、可见性</h3><p>Java中的关键字volatile有一个功能：<strong>被其修饰的变量在被修改后必须立即同步到主内存，被其修饰的变量在每次使用时都必须从主内存获取。</strong>因此，可以使用volatile来保证多线程操作时变量的可见性。</p>
<p>除了volatile，Java中的synchronized和final关键字也可以实现可见性。只不过实现方式不同。 </p>
<h3 id="4-4-3、有序性"><a href="#4-4-3、有序性" class="headerlink" title="4.4.3、有序性"></a>4.4.3、有序性</h3><p><strong>Java在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。</strong>JMM把内存屏障指令分为4类：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-1.2-%E5%8F%AF%E8%A7%81%E6%80%A7-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E7%B1%BB%E5%9E%8B.png?token=AIGEF3LKY332SGI2CDZSVN3EZZYI2" alt="Java内存模型-1.2-可见性-内存屏障类型"></p>
<p><strong>StoreLoad Barriers是一个全能型屏障，它同时具有其他3个屏障的效果。</strong>目前 处理器大多支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为 处理器 要把 写缓冲区数据 全部刷新到内存中（Buffer Fully Flush）。</p>
<p>Java中的 synchronized 和 volatile 都可以保证多线程之间操作的有序性。区别：</p>
<ul>
<li>volatile关键字 能 禁止指令重排。</li>
<li>synchronized关键字 能 保证同一时刻只有一条线程运行。</li>
</ul>
<h1 id="5、JAVA并发"><a href="#5、JAVA并发" class="headerlink" title="5、JAVA并发"></a>5、JAVA并发</h1><h2 id="5-1、Synchronized"><a href="#5-1、Synchronized" class="headerlink" title="5.1、Synchronized"></a>5.1、Synchronized</h2><h3 id="5-1-1、简介"><a href="#5-1-1、简介" class="headerlink" title="5.1.1、简介"></a>5.1.1、简介</h3><p>synchronized一直被认为是重量级锁。随着Java SE 1.6对<code>synchronized</code>进行了各种优化之后，它就并不那么重了。</p>
<p><strong>Java SE 1.6中，锁共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，这几个状态会随着竞争情况逐渐升级。</strong>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<h3 id="5-1-2、底层实现"><a href="#5-1-2、底层实现" class="headerlink" title="5.1.2、底层实现"></a>5.1.2、底层实现</h3><ul>
<li><p>Java源码层级：synchronized(o)。</p>
</li>
<li><p>字节码层级：</p>
<ul>
<li>synchronized修饰方法（包括实例方法和静态方法）：添加访问标志<code>ACC_SYNCHRONIZED</code>。</li>
<li>synchronized修饰同步块：一般情况下都是添加 1个monitor enter 和 2个monitor exit，如果在同步方法中显式抛出异常，那么只会有1个monitor enter 和 1个monitor exit。</li>
</ul>
</li>
<li><p>JVM层级：基于操作系统提供的同步机制。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jol<span class="token punctuation">.</span>info<span class="token punctuation">.</span></span><span class="token class-name">ClassLayout</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">T01_Sync1</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span></span>T01_Sync1</span>$<span class="token class-name">Lock</span> object internals<span class="token operator">:</span>
 <span class="token constant">OFFSET</span>  <span class="token constant">SIZE</span>   <span class="token constant">TYPE</span> <span class="token constant">DESCRIPTION</span>                               <span class="token constant">VALUE</span>
      <span class="token number">0</span>     <span class="token number">4</span>   <span class="token punctuation">(</span>object header<span class="token punctuation">)</span>  <span class="token number">05</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token punctuation">(</span><span class="token number">00000101</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
      <span class="token number">4</span>     <span class="token number">4</span>   <span class="token punctuation">(</span>object header<span class="token punctuation">)</span>  <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token punctuation">(</span><span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token number">8</span>     <span class="token number">4</span>   <span class="token punctuation">(</span>object header<span class="token punctuation">)</span>  <span class="token number">49</span> ce <span class="token number">00</span> <span class="token number">20</span> <span class="token punctuation">(</span><span class="token number">01001001</span> <span class="token number">11001110</span> <span class="token number">00000000</span> <span class="token number">00100000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">536923721</span><span class="token punctuation">)</span>
     <span class="token number">12</span>     <span class="token number">4</span>        <span class="token punctuation">(</span>loss due <span class="token keyword">to</span> <span class="token namespace">the</span> next object alignment<span class="token punctuation">)</span>
<span class="token class-name">Instance</span> size<span class="token operator">:</span> <span class="token number">16</span> bytes
<span class="token class-name">Space</span> losses<span class="token operator">:</span> <span class="token number">0</span> bytes internal <span class="token operator">+</span> <span class="token number">4</span> bytes external <span class="token operator">=</span> <span class="token number">4</span> bytes total<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span></span>T02_Sync2</span>$<span class="token class-name">Lock</span> object internals<span class="token operator">:</span>
 <span class="token constant">OFFSET</span>  <span class="token constant">SIZE</span>   <span class="token constant">TYPE</span> <span class="token constant">DESCRIPTION</span>                               <span class="token constant">VALUE</span>
      <span class="token number">0</span>     <span class="token number">4</span>   <span class="token punctuation">(</span>object header<span class="token punctuation">)</span>  <span class="token number">05</span> <span class="token number">90</span> <span class="token number">2</span>e <span class="token number">1</span>e <span class="token punctuation">(</span><span class="token number">00000101</span> <span class="token number">10010000</span> <span class="token number">00101110</span> <span class="token number">00011110</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">506368005</span><span class="token punctuation">)</span>
      <span class="token number">4</span>     <span class="token number">4</span>   <span class="token punctuation">(</span>object header<span class="token punctuation">)</span>  <span class="token number">1</span>b <span class="token number">02</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token punctuation">(</span><span class="token number">00011011</span> <span class="token number">00000010</span> <span class="token number">00000000</span> <span class="token number">00000000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">539</span><span class="token punctuation">)</span>
      <span class="token number">8</span>     <span class="token number">4</span>   <span class="token punctuation">(</span>object header<span class="token punctuation">)</span>  <span class="token number">49</span> ce <span class="token number">00</span> <span class="token number">20</span> <span class="token punctuation">(</span><span class="token number">01001001</span> <span class="token number">11001110</span> <span class="token number">00000000</span> <span class="token number">00100000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">536923721</span><span class="token punctuation">)</span>
     <span class="token number">12</span>     <span class="token number">4</span>        <span class="token punctuation">(</span>loss due <span class="token keyword">to</span> <span class="token namespace">the</span> next object alignment<span class="token punctuation">)</span>
<span class="token class-name">Instance</span> size<span class="token operator">:</span> <span class="token number">16</span> bytes
<span class="token class-name">Space</span> losses<span class="token operator">:</span> <span class="token number">0</span> bytes internal <span class="token operator">+</span> <span class="token number">4</span> bytes external <span class="token operator">=</span> <span class="token number">4</span> bytes tota<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>OS&#x2F;硬件层面</p>
<ul>
<li>X86：使用指令 lock cmpxchg xxx 来实现。</li>
</ul>
</li>
</ul>
<h3 id="5-1-3、锁优化"><a href="#5-1-3、锁优化" class="headerlink" title="5.1.3、锁优化"></a>5.1.3、锁优化</h3><h4 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h4><p><strong>JDK 1.4.2引入了自旋锁，默认关闭，可使用参数<code>-XX:+UseSpinning</code>开启，JDK 6中改为默认开启。</strong></p>
<p>自旋等待不能代替阻塞，自旋等待虽然避免了线程切换的开销，但它要占用处理器时间，如果锁被占用的时间很短，自旋等待效果就会非常好，反之如果锁被占用时间很长，那么自旋线程只会白白消耗处理器资源，这会带来性能的浪费。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍没有获得锁，就应当使用传统方式挂起线程。<strong>自旋次数默认是十次，也可以使用参数<code>-XX:PreBlockSpin</code>来修改。</strong></p>
<p><strong>JDK 6对自旋锁做了优化，引入了自适应自旋。</strong>自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待更长时间。另一方面，如果对于某个锁，自旋很少成功获得锁，那么后期再获取这个锁时可能直接省略自旋过程，以避免浪费处理器资源。</p>
<p><strong>JDK7之后就不能控制是否开启自旋功能了。</strong></p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p><strong>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但实际不会发生共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span> str1<span class="token punctuation">,</span><span class="token class-name">String</span> str2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>StringBuffer是线程安全的，因为它的关键方法被<code>synchronized</code>修饰。引用sb只会在<code>add</code>方法中使用，不会发生方法逃逸和线程逃逸，故JVM会自动消除掉StringBuffer对象内部的锁。</p>
<blockquote>
<p>在JDK 5之前，字符串加法会转化为StringBuffer 对象的连续append()操作，在JDK 5及以后的版本中，会转化为StringBuilder对象的连续append()操作。</p>
</blockquote>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>原则上，在编写代码时，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了尽可能减少需要同步的操作数量，即使存在锁竞争，等待锁的线程也能尽快地拿到锁。</p>
<p>大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作出现在循环体之中，那即使没有线程竞争，频繁进行互斥同步操作也会导致不必要的性能损耗。</p>
<p>比如以下代码，没有锁粗化时需要执行100次加锁&#x2F;解锁操作，执行 锁粗化 优化后只需要加一次锁即可。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    	sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p><strong>JDK 6引入偏向锁，目的是消除数据在无竞争情况下的同步原语， 进一步提高程序运行性能。</strong>如果说轻量级锁是在无竞争情况下 使用CAS 来替换 使用互斥量，那偏向锁就是在无竞争情况下去掉同步和CAS。</p>
<p>偏向锁中的“偏”，就是偏心的“偏”、偏袒的“偏”。它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，没有其它线程来获取这个锁，则持有偏向锁的线程将永远不需要再进行同步。</p>
<h5 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h5><p><strong>当锁对象第一次被线程获取时，虚拟机会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后再次进入同步块时，就不需要再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作 等）。</strong></p>
<p>若有其它线程尝试获取锁，偏向模式会马上结束。根据锁对象目前是否处于被锁定的状态来决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位 为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照轻量级锁工作流程来执行。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>当对象进入偏向状态时，Mark Word大部分的空间（23个比特）都用于存储持有锁的线程ID了，这部分空间占用了原有存储对象哈希码的位置，那原来对象的哈希码怎么办呢？</p>
<p>一个对象如果计算过哈希码，就应该一直保持该值不变（推荐但不强制，因为用户可以重载hashCode()方法），否则很多依赖对象哈希码的API都可能存在出错风险。而作为绝大多数对象哈希码来源的Object::hashCode()方法，返回的是对象的一致性哈希码（Identity Hash Code），这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一 次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。因此，<strong>当一个对象已经计算过一 致性哈希码后，它就再也无法进入偏向锁状态了</strong>；而<strong>当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁</strong>。在重量级锁实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。 </p>
<blockquote>
<p><font color='red'>注意：如果请求获取的hashcode值来源于对Object::hashCode()或者System::identityHashCode(Object)方法的调用，那么才会撤销偏向锁并升级为重量级锁；反之，如果重写了对象的hashCode()方法，计算哈希码时并不会触发偏向锁的撤销和重量级锁的升级。</font></p>
</blockquote>
<p>偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个带有效益权衡（Trade Off）性质的优化，也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数<code>-XX:-UseBiasedLocking</code>来禁止偏向锁优化反而可以提升性能。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h5 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h5><p><strong>JDK 6引入了轻量级锁。</strong>“轻量级”是相对于使用操作系统互斥量来实现锁而言，因此传统锁机制被称为“重量级”锁。轻量级锁并不能代替重量级锁，它设计的初衷是在没有多线程竞争的前提下，减少重量级锁使用操作系统互斥量产生的性能消耗。</p>
<h5 id="工作过程-1"><a href="#工作过程-1" class="headerlink" title="工作过程"></a>工作过程</h5><p><strong>在代码即将进入同步块时，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word）。</strong></p>
<p>然后，虚拟机将<strong>使用CAS操作尝试把锁对象的Mark Word更新为指向Lock Record的指针</strong>。</p>
<ul>
<li>如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且锁对象Mark Word的锁标志位（Mark Word的 最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。</li>
<li>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志状态值变为“10”，此时锁对象Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。</li>
</ul>
<p>上面描述的是轻量级锁的加锁过程，它的解锁过程也同样是通过CAS操作来进行，如果对象的 Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，那么就要在释放锁的同时，唤醒被挂起的线程。</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>轻量级锁能提升程序同步性能的依据是”对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下， 轻量级锁反而会比传统的重量级锁更慢。</p>
<p>偏向锁、轻量级锁的状态转化及对象Mark Word的关系如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E4%B8%8EMarkWord%E7%9A%84%E5%85%B3%E7%B3%BB.png?token=AIGEF3IKANGCKSJOPH3WQ2LEZZYK6" alt="偏向锁、轻量级锁与MarkWord的关系"></p>
<h3 id="5-1-4、锁升级"><a href="#5-1-4、锁升级" class="headerlink" title="5.1.4、锁升级"></a>5.1.4、锁升级</h3><h4 id="5-1-4-1、无锁状态"><a href="#5-1-4-1、无锁状态" class="headerlink" title="5.1.4.1、无锁状态"></a>5.1.4.1、无锁状态</h4><p><strong>new一个对象，默认就是无锁状态。</strong></p>
<h4 id="5-1-4-2、偏向锁"><a href="#5-1-4-2、偏向锁" class="headerlink" title="5.1.4.2、偏向锁"></a>5.1.4.2、偏向锁</h4><h5 id="偏向锁来历"><a href="#偏向锁来历" class="headerlink" title="偏向锁来历"></a>偏向锁来历</h5><p>HotSpot作者研究发现，通常不存在锁竞争，而是一个线程经常多次获得同一个锁。所以每次都要竞争锁会消耗很多资源，为了降低获取锁的代价就引入了偏向锁。</p>
<h5 id="偏向锁获取"><a href="#偏向锁获取" class="headerlink" title="偏向锁获取"></a>偏向锁获取</h5><p><strong>首次访问锁的线程，偏向锁会偏向于该线程。有其它线程争夺锁时会撤销偏向锁，然后升级为轻量级锁。</strong></p>
<p>偏向锁 获取和撤销 过程描述如下：</p>
<p>当锁对象首次被线程获取时，会将获取到该锁的线程ID记录在锁对象的Mark Word中，以后该线程在进入和退出 同步块时不需要执行CAS操作来加锁和解锁：</p>
<ul>
<li>如果一致（依然是线程1获取锁对象），则无需通过CAS进行加锁、解锁；</li>
<li>如果不一致（其他线程（线程2）要竞争锁对象），则需要检查Java对象头中记录的线程1是否存活：<ul>
<li>如果没有存活，那么锁状态将被重置为无锁状态，其它线程（线程2）可以将其设为偏向锁；</li>
<li>如果存活，那么检查该线程（线程1）的栈帧信息，如果线程1依然需要这个锁，则暂停当前线程1并撤销偏向锁，然后升级为轻量级锁。如果线程1 不再使用该锁对象，那么锁状态将被设为无锁状态，然后重新偏向新的线程。</li>
</ul>
</li>
</ul>
<p>获取偏向锁详细步骤 参考如下：</p>
<ol>
<li>验证对象的bias位。如果是0，则表示该对象不可偏向，应该使用轻量级锁算法。</li>
<li>验证对象所属InstanceKlass的prototype的bias位是否被设置。如果没有设置，则该类所有对象全部不允许被偏向锁定，且所有对象的bias位都需要被重置，使用轻量级锁来替换。</li>
<li>校验epoch位。校验对象头中MarkWord的epoch位是否与该对象所属InstanceKlass的prototype的MarkWord的epoch匹配。如果不匹配，则表明偏向已过期，需要重新偏向。偏向线程可以通过CAS指令重新偏向于这个锁对象。</li>
<li>校验owner线程。比较偏向线程ID与当前线程ID。如果匹配，则表明当前线程已经获得了偏向，可以安全返回。如果不匹配，对象锁被假定为匿名偏向状态，当前线程应该尝试使用CAS指令获得偏向。如果失败的话，就尝试撤销(很可能引入安全点)，然后回退到轻量级锁；如果成功，当前线程成功获得偏向，可直接返回。</li>
</ol>
<h5 id="偏向锁关闭"><a href="#偏向锁关闭" class="headerlink" title="偏向锁关闭"></a>偏向锁关闭</h5><p><strong>偏向锁在Java 6和Java 7中默认启用，但它仅在程序启动几秒后才激活，可通过JVM参数<code>-XX:BiasedLockingStartupDelay=0</code>来关闭该延迟。</strong></p>
<p><strong>如果程序线程通常处于竞争状态，可以通过JVM参数<code>-XX:-UseBiasedLocking</code>关闭偏向锁，那么程序默认会直接进入轻量级锁状态。</strong></p>
<p>HotSpot支持 存储&#x2F;释放 偏向锁，以及偏向锁的批量重偏向和撤销。这个特性可以通过JVM参数进行切换，且默认支持。Unlock状态下MarkWord的一个比特位用于标识该对象偏向锁是否被使用或者是否被禁止。如果该bit位为0，则该对象未被锁定，并且禁止偏向；如果该bit位为1，则意味着该对象处于以下三种状态：</p>
<ol>
<li><font color='orange'>匿名偏向(Anonymously Biased)</font></li>
<li><font color='orange'>可重偏向(Rebiasable)</font></li>
<li><font color='orange'>已偏向(Biased)</font></li>
</ol>
<h4 id="5-1-4-3、轻量级锁"><a href="#5-1-4-3、轻量级锁" class="headerlink" title="5.1.4.3、轻量级锁"></a>5.1.4.3、轻量级锁</h4><h5 id="轻量级锁来历"><a href="#轻量级锁来历" class="headerlink" title="轻量级锁来历"></a>轻量级锁来历</h5><p><strong>轻量级锁适用于 并发高但执行时间短的场景。</strong>线程阻塞将导致用户态与内核态的切换，若阻塞时间很短后锁就被释放了，那么代价会更大。为解决该问题，轻量级锁就出现了。</p>
<h5 id="轻量级锁加锁"><a href="#轻量级锁加锁" class="headerlink" title="轻量级锁加锁"></a>轻量级锁加锁</h5><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用 CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<h5 id="轻量级锁解锁"><a href="#轻量级锁解锁" class="headerlink" title="轻量级锁解锁"></a>轻量级锁解锁</h5><p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p>
<h5 id="轻量级锁升级"><a href="#轻量级锁升级" class="headerlink" title="轻量级锁升级"></a>轻量级锁升级</h5><p>轻量级锁的升级过程描述如下：</p>
<ol>
<li>线程1获取轻量级锁时会先把锁对象对象头的MarkWord拷贝一份放到线程1栈帧中（称为DisplacedMarkWord），然后通过CAS方式把对象头中的内容替换为指向线程1中锁记录（DisplacedMarkWord）的指针。</li>
<li>线程1在修改替换对象头时，线程2进来也需要执行相关操作，但线程2在执行CAS时发现线程1已经把对象头换了，此时线程2的CAS会失败，然后线程2会尝试使用自旋锁来等待线程1释放锁。</li>
<li>线程2自旋次数达到上限时还没有获取锁，那么线程2就会将轻量级锁升级为重量级锁，然后线程2会进入到重量级锁的等待队列中进行等待，后续来的线程也会进入该队列进行等待，直到线程1执行完毕释放了锁，然后唤醒等待队列中的线程。</li>
</ol>
<blockquote>
<p>自旋达到上限时会升级到重量级锁，这里的上限分两种情况：</p>
<ul>
<li><p>Java6之前</p>
<ol>
<li>默认启用，自旋次数的默认值是10次，也可以使用参数<code>-XX：PreBlockSpin</code>来修改。</li>
<li>或者，自旋线程数量超过CPU核数一半时升级为重量级锁。</li>
</ol>
</li>
<li><p>Java6之后，引入自适应自旋，自旋次数不再固定，而是根据：同一把锁上次的自旋时间 和 拥有锁的线程的状态来决定。</p>
<ol>
<li>如果线程自旋成功，那么下次自旋的最大次数就会增加，因为JVM会认为上次都已经成功了，那么这次一定也会成功。</li>
<li>如果自旋很少成功，那么下次会减少自旋次数甚至是不再自旋，避免CPU空转，消费资源。</li>
</ol>
</li>
</ul>
</blockquote>
<p><font color='red'>注意：</font></p>
<p>使用CAS自旋去争夺锁，会导致无意义的CPU占用。所以，<strong>轻量级锁适用于 线程少且执行时间短 的场景。</strong></p>
<h4 id="5-1-4-4、重量级锁"><a href="#5-1-4-4、重量级锁" class="headerlink" title="5.1.4.4、重量级锁"></a>5.1.4.4、重量级锁</h4><p>重量级锁竞争时，可以使用自旋来优化。如果当前线程自旋成功（其它线程释放了锁，当前线程获取了锁），那么就可以避免当前线程被阻塞。如果自旋次数达到上限时还没有获取锁，那么就会将轻量级锁升级为重量级锁，然后当前线程会进入到重量级锁的等待队列中进行等待，后续来的线程也会进入该队列进行等待，直到拿到锁的线程执行完毕释放了锁，然后才会唤醒等待队列中的线程。</p>
<p><strong>重量级锁底层实现是一个Monitor对象，俗称Monitor锁，该对象有WaitSet、EntryList、Owner等重要成员。</strong></p>
<p><strong>获取轻量级锁失败的线程会将轻量级锁升级为重量级锁，此时会创建Monitor锁对象，然后会在synchronized修饰的锁对象头的markword中存入Monitor对象的地址并设置锁标识位为10，并设置Monitor锁对象的Owner指向获取锁的线程，获取锁失败的线程会进入到Monitor锁对象的EntryList中进行等待，直到获取锁的线程释放了锁，并将Owner设置为null，然后会唤醒EntryList中等待的线程来重新竞争锁。</strong></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>锁升级注意事项：</p>
<ol>
<li>为了避免无用自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁；</li>
<li>偏向锁升级为轻量级锁也不能再降级为偏向锁；</li>
<li>偏向锁状态可以被重置为无锁状态；</li>
</ol>
<p>锁优缺点对比：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Synachonized-1.1-%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png?token=AIGEF3NTWUVMKCIFTZIAWITEZZYNA" alt="Synachonized-1.1-锁的优缺点"></p>
<h3 id="5-1-5、锁降级"><a href="#5-1-5、锁降级" class="headerlink" title="5.1.5、锁降级"></a>5.1.5、锁降级</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28505703">https://zhuanlan.zhihu.com/p/28505703</a></p>
<p><strong>只被<code>VM Thread</code>访问，降级也就没啥意义了。所以可以认为锁降级不存在！</strong></p>
<h4 id="降级目的和过程"><a href="#降级目的和过程" class="headerlink" title="降级目的和过程"></a>降级目的和过程</h4><p>因为BasicLocking的实现优先于重量级锁的使用，JVM会尝试在STW的停顿中对处于“空闲(idle)”状态的重量级锁进行降级(deflate)。我们知道在STW时，所有的Java线程都会暂停在“安全点(SafePoint)”，此时VM Thread通过对所有Monitor进行遍历，或者通过对所有依赖于<code>MonitorInUseLists</code>值的当前正在“使用”中的<code>Monitor</code>子序列进行遍历，从而得到那些未被使用的“Monitor”并将之作为降级对象。</p>
<h4 id="降级对象"><a href="#降级对象" class="headerlink" title="降级对象"></a>降级对象</h4><p><strong>重量级锁的降级发生于STW阶段，降级对象就是那些仅仅能被 VM Thread 访问而没有被其它 Java Thread 访问的Monitor对象。</strong></p>
<h4 id="HotSpot-VM实现"><a href="#HotSpot-VM实现" class="headerlink" title="HotSpot VM实现"></a>HotSpot VM实现</h4><p>HotSpot VM锁降级底层实现，可以参考：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token class-name">ObjectSynchronizer</span><span class="token operator">::</span><span class="token function">deflate_idle_monitors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">assert</span><span class="token punctuation">(</span><span class="token class-name">SafepointSynchronize</span><span class="token operator">::</span><span class="token function">is_at_safepoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"must be at safepoint"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> nInuse <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>              <span class="token comment">// currently associated with objects</span>
  <span class="token keyword">int</span> nInCirculation <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>      <span class="token comment">// extant</span>
  <span class="token keyword">int</span> nScavenged <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>          <span class="token comment">// reclaimed</span>
  bool deflated <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

  <span class="token class-name">ObjectMonitor</span> <span class="token operator">*</span> <span class="token class-name">FreeHead</span> <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>  <span class="token comment">// Local SLL of scavenged monitors</span>
  <span class="token class-name">ObjectMonitor</span> <span class="token operator">*</span> <span class="token class-name">FreeTail</span> <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>

  <span class="token constant">TEVENT</span> <span class="token punctuation">(</span>deflate_idle_monitors<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token comment">// Prevent omFlush from changing mids in Thread dtor's during deflation</span>
<span class="token comment">// And in case the vm thread is acquiring a lock during a safepoint</span>
<span class="token comment">// See e.g. 6320749</span>
  <span class="token class-name">Thread</span><span class="token operator">::</span><span class="token function">muxAcquire</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token class-name">ListLock</span><span class="token punctuation">,</span> <span class="token string">"scavenge - return"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">MonitorInUseLists</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> inUse <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">JavaThread</span><span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token class-name">Threads</span><span class="token operator">::</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cur <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> cur <span class="token operator">=</span> cur<span class="token operator">-></span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      nInCirculation<span class="token operator">+=</span> cur<span class="token operator">-></span>omInUseCount<span class="token punctuation">;</span>
      <span class="token keyword">int</span> deflatedcount <span class="token operator">=</span> <span class="token function">walk_monitor_list</span><span class="token punctuation">(</span>cur<span class="token operator">-></span><span class="token function">omInUseList_addr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token class-name">FreeHead</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token class-name">FreeTail</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      cur<span class="token operator">-></span>omInUseCount<span class="token operator">-=</span> deflatedcount<span class="token punctuation">;</span>
<span class="token comment">// verifyInUse(cur);</span>
      nScavenged <span class="token operator">+=</span> deflatedcount<span class="token punctuation">;</span>
      nInuse <span class="token operator">+=</span> cur<span class="token operator">-></span>omInUseCount<span class="token punctuation">;</span>
     <span class="token punctuation">&#125;</span>

<span class="token comment">// For moribund threads, scan gOmInUseList</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>gOmInUseList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
     nInCirculation <span class="token operator">+=</span> gOmInUseCount<span class="token punctuation">;</span>
     <span class="token keyword">int</span> deflatedcount <span class="token operator">=</span> <span class="token function">walk_monitor_list</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ObjectMonitor</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>gOmInUseList<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token class-name">FreeHead</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token class-name">FreeTail</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     gOmInUseCount<span class="token operator">-=</span> deflatedcount<span class="token punctuation">;</span>
     nScavenged <span class="token operator">+=</span> deflatedcount<span class="token punctuation">;</span>
     nInuse <span class="token operator">+=</span> gOmInUseCount<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ObjectMonitor</span><span class="token operator">*</span> block <span class="token operator">=</span> gBlockList<span class="token punctuation">;</span> block <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> block <span class="token operator">=</span> <span class="token function">next</span><span class="token punctuation">(</span>block<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// Iterate over all extant monitors - Scavenge all idle monitors.</span>
    <span class="token keyword">assert</span><span class="token punctuation">(</span>block<span class="token operator">-></span><span class="token function">object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">CHAINMARKER</span><span class="token punctuation">,</span> <span class="token string">"must be a block header"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    nInCirculation <span class="token operator">+=</span> _BLOCKSIZE <span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _BLOCKSIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token class-name">ObjectMonitor</span><span class="token operator">*</span> mid <span class="token operator">=</span> <span class="token operator">&amp;</span>block<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      oop obj <span class="token operator">=</span> <span class="token punctuation">(</span>oop<span class="token punctuation">)</span> mid<span class="token operator">-></span><span class="token function">object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          <span class="token comment">// The monitor is not associated with an object.</span>
          <span class="token comment">// The monitor should either be a thread-specific private</span>
          <span class="token comment">// free list or the global free list.</span>
          <span class="token comment">// obj == NULL IMPLIES mid->is_busy() == 0</span>
        guarantee <span class="token punctuation">(</span><span class="token operator">!</span>mid<span class="token operator">-></span><span class="token function">is_busy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"invariant"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token keyword">continue</span> <span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
      deflated <span class="token operator">=</span> <span class="token function">deflate_monitor</span><span class="token punctuation">(</span>mid<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token class-name">FreeHead</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token class-name">FreeTail</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>deflated<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        mid<span class="token operator">-></span><span class="token class-name">FreeNext</span> <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>
        nScavenged <span class="token operator">++</span> <span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        nInuse <span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token class-name">MonitorFreeCount</span> <span class="token operator">+=</span> nScavenged<span class="token punctuation">;</span>

	<span class="token comment">// Consider: audit gFreeList to ensure that MonitorFreeCount and list agree.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ObjectMonitor</span><span class="token operator">::</span><span class="token class-name">Knob_Verbose</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">::</span><span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"Deflate: InCirc=%d InUse=%d Scavenged=%d ForceMonitorScavenge=%d : pop=%d free=%d\n"</span><span class="token punctuation">,</span>
        nInCirculation<span class="token punctuation">,</span> nInuse<span class="token punctuation">,</span> nScavenged<span class="token punctuation">,</span> <span class="token class-name">ForceMonitorScavenge</span><span class="token punctuation">,</span>
        <span class="token class-name">MonitorPopulation</span><span class="token punctuation">,</span> <span class="token class-name">MonitorFreeCount</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token operator">::</span><span class="token function">fflush</span><span class="token punctuation">(</span>stdout<span class="token punctuation">)</span> <span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token class-name">ForceMonitorScavenge</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// Reset</span>

<span class="token comment">// Move the scavenged monitors back to the global free list.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">FreeHead</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
     guarantee <span class="token punctuation">(</span><span class="token class-name">FreeTail</span> <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> nScavenged <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"invariant"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
     <span class="token keyword">assert</span> <span class="token punctuation">(</span><span class="token class-name">FreeTail</span><span class="token operator">-></span><span class="token class-name">FreeNext</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"invariant"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token comment">// constant-time list splice - prepend scavenged segment to gFreeList</span>
     <span class="token class-name">FreeTail</span><span class="token operator">-></span><span class="token class-name">FreeNext</span> <span class="token operator">=</span> gFreeList <span class="token punctuation">;</span>
     gFreeList <span class="token operator">=</span> <span class="token class-name">FreeHead</span> <span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token class-name">Thread</span><span class="token operator">::</span><span class="token function">muxRelease</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token class-name">ListLock</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ObjectMonitor</span><span class="token operator">::</span><span class="token function">_sync_Deflations</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token class-name">ObjectMonitor</span><span class="token operator">::</span><span class="token function">_sync_Deflations</span><span class="token operator">-></span><span class="token function">inc</span><span class="token punctuation">(</span>nScavenged<span class="token punctuation">)</span> <span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ObjectMonitor</span><span class="token operator">::</span><span class="token function">_sync_MonExtant</span>  <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token class-name">ObjectMonitor</span><span class="token operator">::</span><span class="token function">_sync_MonExtant</span> <span class="token operator">-></span><span class="token function">set_value</span><span class="token punctuation">(</span>nInCirculation<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// TODO: Add objectMonitor leak detection.</span>
<span class="token comment">// Audit/inventory the objectMonitors -- make sure they're all accounted for.</span>
  <span class="token class-name">GVars</span><span class="token punctuation">.</span>stwRandom <span class="token operator">=</span> os<span class="token operator">::</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
  <span class="token class-name">GVars</span><span class="token punctuation">.</span>stwCycle <span class="token operator">++</span> <span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-1-6、注意事项"><a href="#5-1-6、注意事项" class="headerlink" title="5.1.6、注意事项"></a>5.1.6、注意事项</h3><ol>
<li>synchronized(Object)模式下，不能用String常量、Integer、Long等类型来作为锁角色。</li>
<li>锁定方法与非锁定方法可同时执行。</li>
<li>多个线程必须锁定同一个锁（对象）。（需用final修饰锁对象，防止修改）</li>
<li>自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。JDK 6 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</li>
<li>自适应自旋锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</li>
<li>偏向锁由于有锁撤销的过程，会消耗系统资源，所以，在锁争用特别激烈的时候，用偏向锁未必效率高。还不如直接使用轻量级锁。</li>
</ol>
<h2 id="5-2、CAS"><a href="#5-2、CAS" class="headerlink" title="5.2、CAS"></a>5.2、CAS</h2><h3 id="5-2-1、简介"><a href="#5-2-1、简介" class="headerlink" title="5.2.1、简介"></a>5.2.1、简介</h3><p><strong>CAS是 Compare And Set&#x2F;Swap&#x2F;exchange 的简写，意为比较并交换。</strong></p>
<p>cas(V, Expected, NewValue)：V为原值，Expected为期望值。NewValue为新值。在修改原值为新值时，判断原值是否与期望值相同，相同则修改，否则拿到和期望值不同的原值再次进行相同逻辑的修改，一直到修改成功为止，这个过程就称为“自旋”。自旋会无意义消耗CPU，故是否选择使用CAS自旋技术，要根据实际场景来选择：</p>
<ul>
<li>线程数量多且执行时间长，就要避免使用CAS自旋，而要选用重量级锁来代替，因为重量级锁使用的是等待队列，不会消耗CPU。</li>
<li>线程数量少且执行时间短，选用CAS自旋会较好。</li>
</ul>
<h3 id="5-2-2、底层实现"><a href="#5-2-2、底层实现" class="headerlink" title="5.2.2、底层实现"></a>5.2.2、底层实现</h3><ol>
<li>底层指令实现：<ul>
<li>IA64、X86下：通过<code>lock、cmpxchg</code>指令实现。单纯的<code>cmpxchg</code>不能保证原子性。</li>
<li>sparc-TSO下：通过<code>case</code>指令实现。</li>
<li>ARM和PowerPC下：通过一对<code>Idrex/strex</code>指令实现。</li>
</ul>
</li>
<li>硬件情况下：lock指令在执行后面指令的时候锁定一个北桥信号。</li>
<li>拓展知识：处理器 使用总线锁和缓存锁来实现原子操作。</li>
</ol>
<h3 id="5-2-3、CAS缺点"><a href="#5-2-3、CAS缺点" class="headerlink" title="5.2.3、CAS缺点"></a>5.2.3、CAS缺点</h3><ol>
<li><p>ABA问题。解决方法：加版本号。</p>
</li>
<li><p>自旋时间长。解决方法：如果JVM支持处理器提供的pause指令，那么效率会有一点提升。</p>
<ul>
<li><p>PAUSE指令作用：</p>
<ol>
<li>提升<code>spin-wait loops(自旋锁循环等待)</code>的性能。在执行一个<code>spin-wait loop</code>时，Pentium4 处理器会遇到严重的性能损失，PAUSE 指令会向处理器发起提醒：告诉处理器所执行的代码序列是一个 spin-wait loop。处理器会根据这个提醒而避开内存序列冲突(memory order violation)，也就是说对 spin-wait loop 不做缓存，不做指令重新排序等动作。这样就可以大大的提高了处理器的性能。正是基于此，才建议在 spin-wait loops 中使用 pasuse 指令。</li>
<li>减少 Pentium4 处理器在执行 spin-wait loop 时的电源消耗。在等待资源而执行自旋锁等待时，Pentium4 处理器会极速执行从而导致消耗很多电能，而<code>pause</code>指令则可以极大的减少处理器的电能消耗。</li>
</ol>
</li>
<li><p>PAUSE指令拓展：</p>
<p>PAUSE 指令在 Pentium4 处理器中引入，但它也是向前兼容的。在早先的 IA-32 处理器中，PAUSE 指令实际上就相当于 NOP 指令。</p>
<p>Pentium4 处理器以一种 预延迟(pre-defined delay)的技术来实现 PAUSE 指令。这种延迟是有限度的，且在一些处理器上是零延迟。该指令不会改变处理器的处理器状态。</p>
</li>
</ul>
</li>
<li><p>只能保证一个共享变量的原子操作。解决方法：加锁；AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象中执行CAS操作。</p>
</li>
</ol>
<h3 id="5-2-4、自增操作"><a href="#5-2-4、自增操作" class="headerlink" title="5.2.4、自增操作"></a>5.2.4、自增操作</h3><ul>
<li><p>Synchronized操作：执行时间长，因为需要用户态与内核态的切换，从而降低了执行效率。</p>
</li>
<li><p>AtomicXXX操作：执行时间较Synch要少，因为使用了CAS自旋&#x2F;无锁操作。</p>
</li>
<li><p>LongAdder操作：执行时间长，因为使用了分段锁。 适用于并发量大的情况。</p>
</li>
</ul>
<h2 id="5-3、Volatile"><a href="#5-3、Volatile" class="headerlink" title="5.3、Volatile"></a>5.3、Volatile</h2><h3 id="5-3-1、简介"><a href="#5-3-1、简介" class="headerlink" title="5.3.1、简介"></a>5.3.1、简介</h3><p>volatile是轻量级的 synchronized，它在多处理器开发中保证了共享变量的“可见性”。<strong>可见性指的是 当一个线程修改了一个共享变量后，另外一个线程能读到这个共享变量被修改后的值。</strong></p>
<p><strong>volatile比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</strong></p>
<p>几个重要的CPU术语如下：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/CPU%E6%9C%AF%E8%AF%AD001.png?token=AIGEF3NKAFXF6QJXCEDLJ63EZZYPO" alt="CPU术语001"></p>
<p>volatile变量自身具有如下特性。</p>
<ul>
<li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li>
<li>原子性：对任意单个volatile变量的读&#x2F;写具有原子性，但类似于volatile++这种复合操作不具有原子性。</li>
</ul>
<h3 id="5-3-2、底层实现"><a href="#5-3-2、底层实现" class="headerlink" title="5.3.2、底层实现"></a>5.3.2、底层实现</h3><h4 id="字节码层面"><a href="#字节码层面" class="headerlink" title="字节码层面"></a>字节码层面</h4><p>在volatile修饰的元素前加了一个访问标志：ACC_VOLATILE。</p>
<h4 id="JVM层面（规范）"><a href="#JVM层面（规范）" class="headerlink" title="JVM层面（规范）"></a>JVM层面（规范）</h4><ol>
<li><p>StoreStore Barriers - volatile写 - StoreLoad Barriers。</p>
</li>
<li><p>volatile读 - LoadLoad Barriers - LoadStore Barriers。</p>
</li>
</ol>
<h4 id="hotspot"><a href="#hotspot" class="headerlink" title="hotspot"></a>hotspot</h4><p><strong>底层基于大多数CPU都支持的 lock addl 汇编代码指令来实现。</strong></p>
<p>Lock前缀的指令在多核处理器下的作用：</p>
<ul>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>
</ul>
<blockquote>
<p>对volatile修饰的变量执行写操作时会向处理器发送一条Lock前缀指令，将该变量所在缓存行的数据【写回到系统内存】。但要注意，虽然已经写回内存但其它处理器中关于该变量的缓存依然是旧的，对旧的数据执行操作就会有问题。所以，多处理器下，为了保证各个处理器缓存的一致性，就会实现【缓存一 致性协议】，每个处理器通过嗅探总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作时会重新从系统内存中把数据读到处理器缓存里。</p>
<p>volatile有两个实现原则：</p>
<ol>
<li>Lock前缀指令会引起处理器缓存回写到内存。</li>
<li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</li>
</ol>
</blockquote>
<h4 id="CPU层面"><a href="#CPU层面" class="headerlink" title="CPU层面"></a>CPU层面</h4><ul>
<li><p>X86 CPU内存屏障（有序性保证）</p>
<ol>
<li><font color='orange'>sfence指令</font>：sfence指令前写 优先于 sfence指令后写。</li>
<li><font color='orange'>lfence指令</font>：lfence指令前读 优先于 lfence指令后读。</li>
<li><font color='orange'>mfence指令</font>：mfence指令前读写 优先于 sfence指令后读写。</li>
</ol>
<p>可惜大多数CPU并不支持这种指令，故hotspor并没有选择这种方案来实现有序性，而是采用大多数CPU都支持的其它指令：lock addl 来实现。</p>
</li>
</ul>
<h3 id="5-3-3、实现一致性-可见性"><a href="#5-3-3、实现一致性-可见性" class="headerlink" title="5.3.3、实现一致性&#x2F;可见性"></a>5.3.3、实现一致性&#x2F;可见性</h3><ol>
<li>MESI能解决就用MESI。</li>
<li>锁总线。</li>
</ol>
<p>为了保证内存可见性，Java编译器会在生成指令序列的适当位置插入 内存屏障指令 来禁止特定类型的处理器重排序。</p>
<p><strong>JMM把内存屏障指令分为4类：LoadLoad屏障、StoreStore屏障、LoadStore屏障、StoreLoad屏障。</strong>（详情参考本教程2.4.2节）</p>
<h3 id="5-3-4、实现有序性"><a href="#5-3-4、实现有序性" class="headerlink" title="5.3.4、实现有序性"></a>5.3.4、实现有序性</h3><ol>
<li>内存屏障、sfence mfence lfence等系统原语&#x2F;指令。sfence mfence lfence为什么不用？因为可移植性差。</li>
<li>锁总线。</li>
</ol>
<h3 id="5-3-5、解决指令重排序"><a href="#5-3-5、解决指令重排序" class="headerlink" title="5.3.5、解决指令重排序"></a>5.3.5、解决指令重排序</h3><ol>
<li><p>代码级别：volatile修饰变量。</p>
</li>
<li><p>字节码级别：加访问修饰符 ACC_VOLATILE。</p>
</li>
<li><p>JVM级别：JVM内存屏障。（屏障两边的指令禁止重排）</p>
</li>
<li><p>Hotspot实现：lock addl指令。</p>
<p>为何lock指令可以解决重排序和可见性问题？因为：lock用于在多处理器中执行指令时会对共享内存进行独占使用，其能够将当前处理器对应的缓存的内容刷新到内存中，并使其它处理器相同缓存中的内容失效。此外还提供有序指令无法越过内存屏障的作用。</p>
</li>
<li><p>系统级别：load fence、store fence原语指令。</p>
</li>
</ol>
<blockquote>
<p>编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。 </p>
<p>这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作， 不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>
<p>处理器对读&#x2F;写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守as-if-serial语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。 </p>
<p>as-if-serial语义：不管怎么重排序（编译器和处理器为了提高并行度），（单线程） 程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p>
<p><font color='red'>注意：在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但允许volatile变量与普通变量重排序。</font></p>
</blockquote>
<p>bytecodeinterpreter.cpp</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int field_offset &#x3D; cache-&gt;f2_as_index();
if (cache-&gt;is_volatile()) &#123;
    if (support_IRIW_for_not_multiple_copy_atomic_cpu) &#123;
        OrderAccess::fence();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>orderaccess_linux_x86.inline.hpp</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">inline void OrderAccess::fence() &#123;
  if (os::is_MP()) &#123;
    &#x2F;&#x2F; always use locked addl since mfence is sometimes expensive
	#ifdef AMD64
    	__asm__ volatile (&quot;lock; addl $0,0(%%rsp)&quot; : : : &quot;cc&quot;, &quot;memory&quot;);
	#else
    	__asm__ volatile (&quot;lock; addl $0,0(%%esp)&quot; : : : &quot;cc&quot;, &quot;memory&quot;);
	#endif
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-3-6、volatile优化"><a href="#5-3-6、volatile优化" class="headerlink" title="5.3.6、volatile优化"></a>5.3.6、volatile优化</h3><h4 id="追加到64字节"><a href="#追加到64字节" class="headerlink" title="追加到64字节"></a>追加到64字节</h4><p><strong>著名的Java并发编程大师Doug lea在JDK 7的并发包里新增一个队列集合类LinkedTransferQueue，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** 队列中的头部节点 */</span> 
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">final</span> <span class="token class-name">PaddedAtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">QNode</span><span class="token punctuation">></span></span> head<span class="token punctuation">;</span> 
<span class="token comment">/** 队列中的尾部节点 */</span> 
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">final</span> <span class="token class-name">PaddedAtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">QNode</span><span class="token punctuation">></span></span> tail<span class="token punctuation">;</span> 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span> 
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">V</span> value<span class="token punctuation">;</span> 
    <span class="token comment">// 省略其他代码 </span>
｝
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">PaddedAtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span> 
    <span class="token comment">// 使用很多4个字节的引用追加到64个字节 </span>
    <span class="token class-name">Object</span> p0<span class="token punctuation">,</span> p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">,</span> p4<span class="token punctuation">,</span> p5<span class="token punctuation">,</span> p6<span class="token punctuation">,</span> p7<span class="token punctuation">,</span> p8<span class="token punctuation">,</span> p9<span class="token punctuation">,</span> pa<span class="token punctuation">,</span> pb<span class="token punctuation">,</span> pc<span class="token punctuation">,</span> pd<span class="token punctuation">,</span> pe<span class="token punctuation">;</span> 
    <span class="token class-name">PaddedAtomicReference</span><span class="token punctuation">(</span><span class="token class-name">T</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">&#125;</span> 
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="为何追加到64字节？"><a href="#为何追加到64字节？" class="headerlink" title="为何追加到64字节？"></a>为何追加到64字节？</h4><p>因为对于英特尔酷睿i7、酷睿、Atom和 NetBurst，以及Core Solo和Pentium M处理器的L1、L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行。这意味着，如果队列的头节点和尾节点都不足64字节，则处理器会将它们都读到同一个高速缓存行中，多处理器环境下的每个处理器都会缓存同样的头、尾节点，当一 个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致 其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作则需要不断修改头节点，这样一来效率就会大大降低。</p>
<p>为解决这种问题，就可以把不足64字节的数据后面追加到64字节，也就是说让队列的头节点和尾节点各占一个缓存行，这样就避免了阻塞节点操作，大大提高效率。</p>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><p>使用volatile变量时一定要追加至64字节的说法并非一定成立。在以下两种场景中不适合：</p>
<ol>
<li><strong>缓存行非64字节宽的处理器</strong>。如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个 字节宽。 </li>
<li><strong>共享变量不会被频繁地写</strong>。因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。</li>
</ol>
<blockquote>
<p><font color='red'>注意：追加字节的方式在Java 7下可能不生效，因为Java 7更加智慧，它会淘汰或重新排列无用字段，所以，需要使用其它追加字节的方式。除了volatile，Java并发编程中应用较多的是synchronized。</font></p>
</blockquote>
<h3 id="5-3-7、volatile使用指南"><a href="#5-3-7、volatile使用指南" class="headerlink" title="5.3.7、volatile使用指南"></a>5.3.7、volatile使用指南</h3><p>使用volatile时可参考如下两条规则：</p>
<ul>
<li>写后加写屏障，阻止写屏障前代码跑到后面。（写屏障箭头朝上）</li>
<li>读前加读屏障，防止读屏障后面代码跑到前面。（读屏障箭头朝下）</li>
</ul>
<p>代码示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token keyword">volatile</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token keyword">int</span> b<span class="token punctuation">;</span>
<span class="token keyword">int</span> c<span class="token punctuation">;</span>

a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>	
<span class="token comment">// 屏障^^^^^^</span>
b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">// 屏障vvvvvv</span>
c <span class="token operator">=</span> a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="5-4、Lock（锁）"><a href="#5-4、Lock（锁）" class="headerlink" title="5.4、Lock（锁）"></a>5.4、Lock（锁）</h2><h3 id="5-4-1、简介"><a href="#5-4-1、简介" class="headerlink" title="5.4.1、简介"></a>5.4.1、简介</h3><h4 id="锁类架构图"><a href="#锁类架构图" class="headerlink" title="锁类架构图"></a>锁类架构图</h4><p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%92%8CAQS%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE01.png?token=AIGEF3KXLEK2VZACCYGNWBDEZZYRQ" alt="Java中的锁和AQS类结构图01"></p>
<h4 id="Lock接口特性"><a href="#Lock接口特性" class="headerlink" title="Lock接口特性"></a>Lock接口特性</h4><p>Lock接口提供了synchronized不具备的特性，详情如下：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E9%94%81-1.1-Lock%E6%8E%A5%E5%8F%A3%E6%8F%90%E4%BE%9B%E4%BA%86synchronized%E4%B8%8D%E5%85%B7%E5%A4%87%E7%9A%84%E7%89%B9%E6%80%A7.png?token=AIGEF3PVCAV2TJT2GI66CC3EZZYTA" alt="锁-1.1-Lock接口提供了synchronized不具备的特性"></p>
<h3 id="5-4-2、乐观锁"><a href="#5-4-2、乐观锁" class="headerlink" title="5.4.2、乐观锁"></a>5.4.2、乐观锁</h3><h4 id="5-4-2-1、简介"><a href="#5-4-2-1、简介" class="headerlink" title="5.4.2.1、简介"></a>5.4.2.1、简介</h4><p><strong>乐观锁代表是 AtomicInteger，使用 CAS 保证原子性。</strong></p>
<p>乐观锁 核心思想：无需加锁，每次只有一个线程能 成功修改 共享变量，其它线程会不断重试直到成功。</p>
<blockquote>
<p>乐观锁常见实现就是CAS算法，java java.util.concurrent包下原子类(例如<code>AtomicBoolean</code>，<code>AtomicInteger</code>，<code>AtomicLong</code>)中的递增操作就是通过CAS自旋来实现。</p>
</blockquote>
<h4 id="5-4-2-2、特点"><a href="#5-4-2-2、特点" class="headerlink" title="5.4.2.2、特点"></a>5.4.2.2、特点</h4><ul>
<li>线程一直运行，不会阻塞，故不存在线程上下文切换。</li>
<li>需要多核CPU支持，线程数不应该超过 CPU核心数量。</li>
</ul>
<h4 id="5-4-2-3、适用场景"><a href="#5-4-2-3、适用场景" class="headerlink" title="5.4.2.3、适用场景"></a>5.4.2.3、适用场景</h4><p><strong>乐观锁适用于多读场景，不加锁可以提高读操作性能。</strong></p>
<h3 id="5-4-3、悲观锁"><a href="#5-4-3、悲观锁" class="headerlink" title="5.4.3、悲观锁"></a>5.4.3、悲观锁</h3><h4 id="5-4-3-1、简介"><a href="#5-4-3-1、简介" class="headerlink" title="5.4.3.1、简介"></a>5.4.3.1、简介</h4><p><strong>悲观锁代表是 synchronized 和 Lock 锁。</strong></p>
<p>悲观锁核心思想：线程占有了锁，才能操作共享变量，每次只能有一个线程占有锁，其它获线程都要等待。</p>
<h4 id="5-4-3-2、特点"><a href="#5-4-3-2、特点" class="headerlink" title="5.4.3.2、特点"></a>5.4.3.2、特点</h4><ul>
<li>线程从运行到阻塞，再从阻塞到唤醒，期间经历 线程上下文切换，若频繁发生，则会严重影响性能。</li>
<li>获取 synchronized 和 Lock 锁时，若锁已被占用，那么会默认重试几次，减少阻塞机会。</li>
</ul>
<h4 id="5-4-3-3、适用场景"><a href="#5-4-3-3、适用场景" class="headerlink" title="5.4.3.3、适用场景"></a>5.4.3.3、适用场景</h4><p><strong>悲观锁适用于多写场景，先加锁可以保证写操作时数据的正确性。</strong></p>
<h3 id="5-4-4、重入锁"><a href="#5-4-4、重入锁" class="headerlink" title="5.4.4、重入锁"></a>5.4.4、重入锁</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对 资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。</p>
<p>ReentrantLock虽然没能像synchronized关键字一样支持隐式的重进入，但是在调用lock()方 法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。</p>
<h4 id="重入锁特点"><a href="#重入锁特点" class="headerlink" title="重入锁特点"></a>重入锁特点</h4><ol>
<li>线程A获取锁L后，可以在不释放锁L的同时再次获取锁L，且不会出现死锁现象；</li>
<li>线程A释放掉锁L后，其它线程才能获取锁L；</li>
</ol>
<p><strong>可重入锁的使命就是防止自己锁自己，进而提高程序执行性能。</strong></p>
<p>Java中可重入锁的常见实现如下：</p>
<ol>
<li>Synchronized</li>
<li>ReentrantLock</li>
</ol>
<h3 id="5-4-5、ReentrantLock"><a href="#5-4-5、ReentrantLock" class="headerlink" title="5.4.5、ReentrantLock"></a>5.4.5、ReentrantLock</h3><h4 id="5-4-5-1、简介"><a href="#5-4-5-1、简介" class="headerlink" title="5.4.5.1、简介"></a>5.4.5.1、简介</h4><p><strong>ReentrantLock是一个可重入锁、独占式锁，与synchronized关键字相比，它更灵活、更强大，增加了轮询、超时、中断等高级功能。除此外，还提供了对公平锁与非公平锁的选择。</strong></p>
<p>ReentrantLock的内部类Sync继承了AQS，分为公平锁FairSync和非公平锁NonfairSync。ReentrantLock使用公平锁还是非公平锁，可以通过它的构造函数来决定。</p>
<blockquote>
<p>公平锁：按照请求的顺序来获取锁；非公平锁：不管请求顺序的先后，谁抢到锁，这把锁就是谁的。</p>
</blockquote>
<p>事实上，公平锁往往没有非公平锁的效率高，但是，并不是任何场景都是以TPS作为唯一指标，公平锁能够减少“饥饿”发生的概率，等待越久的请求越能够得到优先满足。</p>
<h4 id="5-4-5-2、原理"><a href="#5-4-5-2、原理" class="headerlink" title="5.4.5.2、原理"></a>5.4.5.2、原理</h4><p><strong>ReentrantLock 主要通过unsafe的 CAS 和 park 两个功能实现锁机制。</strong></p>
<p>Sync类是ReentrantLock自定义同步组件，它是ReentrantLock的一个内部类，其继承自AQS，它有两个子类：公平锁FairSync和非公平锁NonfairSync。ReentrantLock的获取与释放锁操作都是委托给该同步组件来实现。</p>
<h3 id="5-4-6、读写锁"><a href="#5-4-6、读写锁" class="headerlink" title="5.4.6、读写锁"></a>5.4.6、读写锁</h3><h4 id="5-4-6-1、简介"><a href="#5-4-6-1、简介" class="headerlink" title="5.4.6.1、简介"></a>5.4.6.1、简介</h4><p><strong>读多写少情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。读写锁的实现是 ReentrantReadWriteLock。</strong></p>
<p>ReadWriteLock仅定义了获取读锁和写锁的两个方法，其实现ReentrantReadWriteLock，除了接口方法之外，还提供了一些便于外界监控内部工作状态的方法。</p>
<h4 id="5-4-6-2、特点"><a href="#5-4-6-2、特点" class="headerlink" title="5.4.6.2、特点"></a>5.4.6.2、特点</h4><p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E9%94%81-1.2-%E8%AF%BB%E5%86%99%E9%94%81%E7%89%B9%E6%80%A7.png?token=AIGEF3MBYW4434TSKNMP7ULEZZYVI" alt="锁-1.2-读写锁特性"></p>
<h4 id="5-4-6-3、底层实现"><a href="#5-4-6-3、底层实现" class="headerlink" title="5.4.6.3、底层实现"></a>5.4.6.3、底层实现</h4><h5 id="读写状态"><a href="#读写状态" class="headerlink" title="读写状态"></a>读写状态</h5><p>读写锁 同样依赖 自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。ReentrantLock中自定义同步器的同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状 态，使得该状态的设计成为读写锁实现的关键。</p>
<p><strong>如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将 变量切分成了两个部分，高16位表示读，低16位表示写</strong>，划分方式如下图：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E9%94%81-1.3-%E8%AF%BB%E5%86%99%E9%94%81%E7%8A%B6%E6%80%81%E5%88%92%E5%88%86%E8%AE%BE%E8%AE%A1%E5%9B%BE.png?token=AIGEF3KMLEL744A7NPZTJKLEZZYXY" alt="锁-1.3-读写锁状态划分设计图"></p>
<p>读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。假设当前同步状态 值为S，写状态等于S&amp;0x0000FFFF（将高16位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号补0右移 16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是 S+0x00010000。</p>
<h5 id="写锁获取与释放"><a href="#写锁获取与释放" class="headerlink" title="写锁获取与释放"></a>写锁获取与释放</h5><p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程， 则当前线程进入等待状态。</p>
<blockquote>
<p>如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果 允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。</p>
</blockquote>
<p>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0 时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对 后续读写线程可见。</p>
<h5 id="读锁获取与释放"><a href="#读锁获取与释放" class="headerlink" title="读锁获取与释放"></a>读锁获取与释放</h5><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问 （或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程 获取，则进入等待状态。</p>
<p>读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少值是（1&lt;&lt;16）。</p>
<h4 id="5-4-6-4、锁升级-降级"><a href="#5-4-6-4、锁升级-降级" class="headerlink" title="5.4.6.4、锁升级&#x2F;降级"></a>5.4.6.4、锁升级&#x2F;降级</h4><h5 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h5><p><strong>锁降级指的是写锁降级成为读锁。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</strong></p>
<h5 id="锁升级（不存在）"><a href="#锁升级（不存在）" class="headerlink" title="锁升级（不存在）"></a>锁升级（不存在）</h5><p><font color="red">RentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。</font>目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。</p>
<h3 id="5-4-10、小总结"><a href="#5-4-10、小总结" class="headerlink" title="5.4.10、小总结"></a>5.4.10、小总结</h3><h4 id="5-4-10-1、Synchronized和ReentrantLock区别"><a href="#5-4-10-1、Synchronized和ReentrantLock区别" class="headerlink" title="5.4.10.1、Synchronized和ReentrantLock区别"></a>5.4.10.1、Synchronized和ReentrantLock区别</h4><h5 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h5><ol>
<li>都是用来协调多线程对共享对象、变量的访问。</li>
<li>都是可重入锁，即同一线程可以多次获得同一个锁。</li>
<li>都保证了可见性和互斥性。</li>
</ol>
<h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h5><ol>
<li><p>API方面</p>
<ul>
<li>Synchronized：可修饰方法、代码块。隐式获取&#x2F;释放锁。</li>
<li>ReentrantLock：显式获取&#x2F;释放锁。（获取锁：ReentrantLock.lock；释放锁：ReentrantLock.unlock）</li>
</ul>
</li>
<li><p>等待可中断</p>
<p>有两个线程：T1、T2，假设T1获取了对象object的锁，T2将等待T1释放object的锁。则：</p>
<ul>
<li>Synchronized：T2会一直等待下去，不可被中断。</li>
<li>ReentrantLock：T2等待一定时间后，会中断操作，转而去做其它事。</li>
</ul>
</li>
<li><p>公平锁</p>
<ul>
<li>Synchronized：是非公平锁。</li>
<li>ReenTrantLock：默认是非公平锁，可通过布尔值来控制使用公平锁。</li>
</ul>
</li>
<li><p>绑定多个条件</p>
<ul>
<li>Synchronized：锁对象的wait和notify() 或notifyAll()方法可以实现一个隐含的条件。</li>
<li>ReenTrantLock：可以同时绑定多个Condition对象，只需多次调用newCondition方法即可。</li>
</ul>
</li>
<li><p>性能</p>
<p>JDK1.5中的Synchronized有很大优化余地。JDK 1.6 中加入了很多针对锁的优化措施，故synchronized与ReentrantLock在性能方面基本持平。</p>
</li>
<li><p>其它</p>
<ul>
<li>Synchronized是关键字，是内置语言的实现。Lock是一个接口。</li>
<li>Synchronized在发生异常时，会自动释放线程占有的锁，不会导致死锁发生。Lock必须通过unlock方法释放锁，否则会造成死锁。</li>
<li>Synchronized无法判断是否获取到锁；Lock可以。</li>
<li>Synchronized不管读写，都会阻塞线程，读效率低；Lock可以提供读写锁，可提高并发读的效率。</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">比较方面</th>
<th align="center">synchronized</th>
<th align="center">ReenTrantLock</th>
</tr>
</thead>
<tbody><tr>
<td align="center">原始构成</td>
<td align="center">Java关键字，原生语法层面的互斥，需要JVM支持。</td>
<td align="center">JDK1.5之后提供的互斥锁</td>
</tr>
<tr>
<td align="center">实现</td>
<td align="center">通过JVM自动加锁&#x2F;解锁</td>
<td align="center">显式加锁&#x2F;解锁</td>
</tr>
<tr>
<td align="center">代码实现</td>
<td align="center">隐式自动获取锁&#x2F;释放锁</td>
<td align="center">显式获取锁&#x2F;释放锁</td>
</tr>
<tr>
<td align="center">灵活性</td>
<td align="center">锁的范围可以随意控制</td>
<td align="center">Lock是方法调用，可跨方法，灵活性更大</td>
</tr>
<tr>
<td align="center">等待可中断</td>
<td align="center">不可中断，除非抛出异常。</td>
<td align="center">可中断</td>
</tr>
<tr>
<td align="center">公平</td>
<td align="center">非公平锁</td>
<td align="center">默认非公平锁，但可通过布尔值控制使用公平锁</td>
</tr>
<tr>
<td align="center">条件Condition</td>
<td align="center"></td>
<td align="center">通过多次newCondition可以获得多个Condition对象，可以简单的实现比较复杂的线程同步功能。</td>
</tr>
<tr>
<td align="center">高级功能</td>
<td align="center"></td>
<td align="center">getHoldCount()、getQueueLength()、isFair()、isHeldByCurrentThread()、isLocked()</td>
</tr>
<tr>
<td align="center">便利性</td>
<td align="center">会自动释放获取锁，便利性好。</td>
<td align="center">需要手动获取释放锁，便利性差。</td>
</tr>
<tr>
<td align="center">适用情况</td>
<td align="center">适用于并发度低的情况。</td>
<td align="center">适用于并发度高的情况。</td>
</tr>
</tbody></table>
<h4 id="5-4-10-2、Lock-VS-Synchronized"><a href="#5-4-10-2、Lock-VS-Synchronized" class="headerlink" title="5.4.10.2、Lock VS Synchronized"></a>5.4.10.2、Lock VS Synchronized</h4><p><strong>Lock可以非阻塞获取锁、被中断地获取锁、超时获取锁。</strong></p>
<h2 id="5-5、原子操作"><a href="#5-5、原子操作" class="headerlink" title="5.5、原子操作"></a>5.5、原子操作</h2><h3 id="5-5-1、简介"><a href="#5-5-1、简介" class="headerlink" title="5.5.1、简介"></a>5.5.1、简介</h3><p><strong>原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。</strong></p>
<p>原子操作相关术语如下：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-1.1-%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD.png?token=AIGEF3KT2PLCG34WR36C2ZLEZZYZ2" alt="原子操作-1.1-相关术语"></p>
<h3 id="5-5-2、处理器原子操作"><a href="#5-5-2、处理器原子操作" class="headerlink" title="5.5.2、处理器原子操作"></a>5.5.2、处理器原子操作</h3><p>首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。</p>
<p>为保证复杂内存操作的原子性，处理器提供了两种机制：</p>
<ul>
<li><p>总线锁</p>
<p>所谓总线锁就是使用处理器提供的一个 LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该 处理器可以独占共享内存。</p>
</li>
<li><p>缓存锁</p>
<p>总线锁定把CPU和内存之间的通信锁住了，开销较大，所以使用缓存锁定代替总线锁定来进行优化。</p>
<p>有两种情况下处理器不会使用缓存锁定：</p>
<ol>
<li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，处理器会调用总线锁定。</li>
<li>有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的 内存区域在处理器的缓存行中也会调用总线锁定。</li>
</ol>
</li>
</ul>
<h3 id="5-5-3、Java原子操作"><a href="#5-5-3、Java原子操作" class="headerlink" title="5.5.3、Java原子操作"></a>5.5.3、Java原子操作</h3><p><strong>Java中可以通过 锁、循环CAS 方式来实现原子操作。</strong></p>
<h4 id="CAS实现原子操作"><a href="#CAS实现原子操作" class="headerlink" title="CAS实现原子操作"></a>CAS实现原子操作</h4><p><strong>JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的</strong>。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。从Java 1.5开始，JDK的并发包里提供了一些原子操作类来支持原子操作。</p>
<p>CAS实现原子操作的三大问题：</p>
<ol>
<li>ABA问题。</li>
<li>循环时间长开销大。</li>
<li>只能保证一个共享变量的原子操作。</li>
</ol>
<h4 id="锁实现原子操作"><a href="#锁实现原子操作" class="headerlink" title="锁实现原子操作"></a>锁实现原子操作</h4><p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁 机制，有偏向锁、轻量级锁和互斥锁。除了偏向锁，JVM实现锁的方式都用了循环 CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时 候使用循环CAS释放锁。</p>
<h4 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h4><p><strong>JDK 5开始提供了java.util.concurrent.atomic包，Atomic包里一共提供了13个类，属于4种类型的原子更新方式</strong>，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。Atomic包里的类基本都是使用Unsafe实现的包装类。</p>
<h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><ul>
<li>AtomicBoolean：原子更新布尔类型。 </li>
<li>AtomicInteger：原子更新整型。 </li>
<li>AtomicLong：原子更新长整型。</li>
</ul>
<p>Java的基本类型里还有char、float和double等，对其这些基本类型，可以将它们转换成整型后，再使用compareAndSwapInt进行CAS更新。</p>
<h5 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h5><ul>
<li>AtomicIntegerArray：原子更新整型数组里的元素。 </li>
<li>AtomicLongArray：原子更新长整型数组里的元素。 </li>
<li>AtomicReferenceArray：原子更新引用类型数组里的元素。</li>
</ul>
<h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><ul>
<li>AtomicReference：原子更新引用类型。 </li>
<li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。 </li>
<li>AtomicMarkableReference：原子更新带有标记位的引用类型。</li>
</ul>
<h5 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h5><ul>
<li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。 </li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。 </li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。</li>
</ul>
<h2 id="5-6、并发工具类"><a href="#5-6、并发工具类" class="headerlink" title="5.6、并发工具类"></a>5.6、并发工具类</h2><h3 id="5-6-1、CountDownLatch"><a href="#5-6-1、CountDownLatch" class="headerlink" title="5.6.1、CountDownLatch"></a>5.6.1、CountDownLatch</h3><p><strong>CountDownLatch允许一个或多个线程等待其他线程完成操作。</strong></p>
<p><strong>调用CountDownLatch的countDown方法时，N会减1，CountDownLatch的await方法会阻塞当前线程，直到N变成零。</strong>由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程中时，只需要把这个 CountDownLatch的引用传递到线程里即可。 </p>
<p><font color='red'>注意：计数器必须大于等于0，如果等于0，则调用await方法时不会阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值。一个线程调用countDown方法happen-before另外一个线程调用await方法。</font></p>
<h3 id="5-6-2、CyclicBarrier"><a href="#5-6-2、CyclicBarrier" class="headerlink" title="5.6.2、CyclicBarrier"></a>5.6.2、CyclicBarrier</h3><p><strong>CyclicBarrier是可循环使用的屏障。它的目的：让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</strong></p>
<p>CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p>
<p>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier（int parties，Runnable barrierAction），用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景。</p>
<ul>
<li>CyclicBarrier VS CountDownLatch</li>
</ul>
<p><strong>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。</strong></p>
<h3 id="5-6-3、Semaphore"><a href="#5-6-3、Semaphore" class="headerlink" title="5.6.3、Semaphore"></a>5.6.3、Semaphore</h3><p><strong>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</strong></p>
<p>Semaphore的构造方法Semaphore(int permits) 接受一个整型的数字，表示可用的许可证数量。Semaphore(10) 表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用 Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。</p>
<h3 id="5-6-4、Exchanger"><a href="#5-6-4、Exchanger" class="headerlink" title="5.6.4、Exchanger"></a>5.6.4、Exchanger</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p><strong>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于线程间的数据交换。</strong>它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。<strong>两个线程通过 exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</strong></p>
<p><font color='red'>注意：如果两个线程有一个没有执行exchange()方法则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange(V x, longtimeout, TimeUnit unit)设置最大等待时长。</font></p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>Exchanger可以用于遗传算法，遗传算法中需要选出两个人作为交换对象，这时候会交换两人的数据，并使用交叉规则得出2个结果。</li>
<li>Exchanger也可以用于校对工作。</li>
</ol>
<h2 id="5-7、并发容器及框架"><a href="#5-7、并发容器及框架" class="headerlink" title="5.7、并发容器及框架"></a>5.7、并发容器及框架</h2><h3 id="5-7-1、阻塞队列"><a href="#5-7-1、阻塞队列" class="headerlink" title="5.7.1、阻塞队列"></a>5.7.1、阻塞队列</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><p>JDK 7提供了7个阻塞队列，如下。 </p>
<ul>
<li>ArrayBlockingQueue：一个由<strong>数组结构</strong>组成的<strong>有界阻塞</strong>队列。 </li>
<li>LinkedBlockingQueue：一个由<strong>链表结构</strong>组成的<strong>有界阻塞</strong>队列。 </li>
<li>PriorityBlockingQueue：一个<strong>支持优先级排序的无界阻塞</strong>队列。 </li>
<li>DelayQueue：一个使用<strong>优先级队列</strong>实现的<strong>无界阻塞</strong>队列。 </li>
<li>SynchronousQueue：一个<strong>不存储元素的阻塞队列</strong>。 </li>
<li>LinkedTransferQueue：一个由<strong>链表结构</strong>组成的<strong>无界阻塞</strong>队列。 </li>
<li>LinkedBlockingDeque：一个由<strong>链表结构</strong>组成的<strong>双向阻塞</strong>队列。</li>
</ul>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><p><strong>此队列按照先进先出（FIFO）的原则对元素进行排序，默认情况下不保证线程访问队列的公平性。</strong></p>
<p>为了保证公平性，通常会降低吞吐量。可以使用以下代码创建一个公平的阻塞队列：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ArrayBlockingQueue</span> fairQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><p><strong>此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</strong></p>
<h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h5><p><strong>默认情况下元素采取自然顺序 升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则</strong>，或者初始化 PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p>
<h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h5><p>DelayQueue是一个<strong>支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现</strong>。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。 只有在延迟期满时才能从队列中提取元素。</p>
<p>应用场景：</p>
<ul>
<li>缓存系统的设计</li>
<li>定时任务调度</li>
</ul>
<h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h5><p><strong>每一个put操作必须等待一个take操作， 否则不能继续添加元素。</strong></p>
<p>它支持公平访问队列，默认情况下线程采用非公平性策略访问队列。</p>
<p>SynchronousQueue的吞吐量高于 LinkedBlockingQueue和ArrayBlockingQueue。</p>
<h5 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h5><p>相对于其它 阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</p>
<ul>
<li><p>transfer方法</p>
<p>如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法 时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等 待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。</p>
</li>
<li><p>tryTransfer方法</p>
<p>tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等 待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法 立即返回，而transfer方法是必须等到消费者消费了才返回。</p>
</li>
</ul>
<h5 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h5><p>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以 从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。</p>
<p>初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中</p>
<h4 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h4><p><strong>阻塞队列底层主要使用 通知模式 来实现生产者与消费者间的通信。</strong></p>
<p>ArrayBlockingQueue使用了Condition来实现，当往队列里插入一个元素时，如果队列不可用，那么阻塞生产者主要通过 LockSupport.park（this）来实现。</p>
<p>park这个方法会阻塞当前线程，但以下4种情况中的任何一种发生时，该方法就会返回：</p>
<ul>
<li>与park对应的unpark执行或已经执行过时。</li>
<li>线程被中断时。</li>
<li>等待完time参数指定的毫秒数时。</li>
<li>异常现象发生时，这个异常现象没有任何原因。</li>
</ul>
<h3 id="5-7-2、ForkJoin框架"><a href="#5-7-2、ForkJoin框架" class="headerlink" title="5.7.2、ForkJoin框架"></a>5.7.2、ForkJoin框架</h3><h4 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h4><p><strong>Fork&#x2F;Join框架是Java 7提供的一个用于 并行执行任务 的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</strong></p>
<h4 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h4><p><strong>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。</strong></p>
<p>工作窃取算法的优缺点如下：</p>
<ul>
<li><p>优点：充分利用线程进行并行计算，减少了线程间的竞争</p>
</li>
<li><p>缺点：某些情况下还是存在竞争，比如双端队列里只有一个任务时。并 且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>
</li>
</ul>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消，且可以通过ForkJoinTask的getException方法获取异常。</p>
<p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或没有抛出异常则返回null。</p>
<h4 id="底层设计"><a href="#底层设计" class="headerlink" title="底层设计"></a>底层设计</h4><ul>
<li>步骤1，分割任务。</li>
<li>步骤2，执行任务并合并结果。</li>
</ul>
<p>Fork&#x2F;Join使用两个类来完成以上两件事情：</p>
<ul>
<li><p><strong>ForkJoinTask</strong>：使用ForkJoin框架，必须首先创建一个ForkJoin任务。</p>
<p>通常情况下，我们不需要直接继承ForkJoinTask类，只需要继 承它的子类：</p>
<ul>
<li>RecursiveAction：用于没有返回结果的任务。 </li>
<li>RecursiveTask：用于有返回结果的任务。</li>
</ul>
</li>
<li><p><strong>ForkJoinPool</strong>：ForkJoinTask需要通过ForkJoinPool来执行。</p>
</li>
</ul>
<p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责将存放程序提交给ForkJoinPool的任务，而ForkJoinWorkerThread数组负责执行这些任务。</p>
<ul>
<li><p>ForkJoinTask的fork方法</p>
<p>调用ForkJoinTask的fork方法时，会异步调用ForkJoinWorkerThread的pushTask方法将任务放到ForkJoinTask数组中，然后调用ForkJoinPool的signalWork方法唤醒或创建一个线程去执行该任务。</p>
</li>
<li><p>ForkJoinTask的join方法</p>
<p>调用Join方法会调用doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有4种：已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常 （EXCEPTIONAL）。</p>
</li>
</ul>
<h2 id="5-8、并发底层原理"><a href="#5-8、并发底层原理" class="headerlink" title="5.8、并发底层原理"></a>5.8、并发底层原理</h2><h3 id="5-8-1、LockSupport工具"><a href="#5-8-1、LockSupport工具" class="headerlink" title="5.8.1、LockSupport工具"></a>5.8.1、LockSupport工具</h3><p><strong>LockSupport是构建同步组件的基础工具。</strong>LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread) 方法来唤醒一个被阻塞的线程。</p>
<p>Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos) 和parkUntil(Object blocker,long deadline)3个方法，用于实现阻塞当前线程的功能，其中参数 blocker是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和 系统监控。</p>
<h3 id="5-8-2、Condition接口"><a href="#5-8-2、Condition接口" class="headerlink" title="5.8.2、Condition接口"></a>5.8.2、Condition接口</h3><h4 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h4><p><strong>Java对象（wait&#x2F;notify）配合Synchronized可以实现等待&#x2F;通知模式。Condition接口配合Lock同样可以实现等待&#x2F;通知模式，但是两者的使用方式和功能特性是有差别的。</strong></p>
<p>Object监视器 VS Condition接口：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200620151112096.png?token=AIGEF3LU66ZLAJQGHYYX6EDEZZY4A" alt="image-20200620151112096"></p>
<p>Condition对象由Lock对象（调用Lock对象的newCondition()方法）创建出来，即通过Lock的newCondition()方法可以获取一个Condition。</p>
<p>Condition使用方式比较简单。当前线程调用await()方法后会释放锁并在此等待，其它线程调用Condition对象的signal()方法会导致当前线程获取锁并从await()方法返回。</p>
<h4 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h4><p>ConditionObject是同步器AbstractQueuedSynchronizer的内部类，每个Condition对象都包含一个等待队列，该队列是Condition对象实现等待&#x2F;通知功能的关键。</p>
<p><strong>Condition的实现主要包括：等待队列、等待和通知，下面提到的Condition，如果不加说明均指的是ConditionObject。</strong></p>
<p><strong>（1）等待队列</strong></p>
<p>等待队列是一个FIFO单向队列，队列中的每个节点都包含一个线程引用，该线程就是 在Condition对象上等待的线程，<strong>一个线程调用Condition.await()方法后会释放锁并被构造成节点放入到等待队列，然后进入等待状态</strong>。事实上，节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中的节点类型都是同步器的静态内部类 AbstractQueuedSynchronizer.Node。</p>
<p><strong>一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点 （lastWaiter）。</strong></p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210221163426067.png?token=AIGEF3OTFQWKT5ZQHHM4UODEZZY6G" alt="image-20210221163426067"></p>
<p><strong>Object监视器模型中，一个对象拥有一个同步队列和等待队列，而并发包中的 Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列。</strong></p>
<p>Condition是同步器的内部类，因此每个Condition实例都能够访问 同步器提供的方法，相当于每个Condition都拥有所属同步器的引用。</p>
<p><strong>（2）等待</strong></p>
<p>调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</p>
<p>如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同 步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。</p>
<p><strong>（3）通知</strong></p>
<p>调用Condition的signal()方法会导致：将等待队列的首节点移至同步队列中，然后唤醒该节点中的线程，被唤醒的线程会通过调用同步器的acquireQueued()方法来尝试获取同步状态。成功获取同步状态（锁）后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功获取了锁。</p>
<blockquote>
<p><font color='red'>注意事项：</font></p>
<ol>
<li>当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</li>
<li>调用signal()方法的前提是当前线程必须获取了锁；</li>
<li>如果节点不是通过Condition.signal()方法被唤醒，而是通过中断被唤醒的话，会抛出异常 InterruptedException。</li>
</ol>
</blockquote>
<p>Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点中的线程。</p>
<h4 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h4><p><strong>为什么wait()、notyfy()、notifyAll()要放在同步块中？</strong></p>
<ol>
<li>调用wait()就是释放锁，释放锁的前提必须要先获得锁，先获得锁才能释放锁。</li>
<li>notify()、notifyAll()是将锁交给调用wait()方法的线程，让其继续执行下去，如果自身没有锁，怎么叫把锁交给其他线程呢；（本质是让处于入口队列的线程竞争锁）。</li>
</ol>
<h3 id="5-8-3、AQS（CLH）"><a href="#5-8-3、AQS（CLH）" class="headerlink" title="5.8.3、AQS（CLH）"></a>5.8.3、AQS（CLH）</h3><h4 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h4><p><strong>AQS（Abstract Queued Synchronizer）：简称抽象队列同步器。</strong></p>
<p>CLH（Craig Landin and Hagersten locks）：是一种基于链表的可扩展、高性能、公平的自旋锁，能确保无饥饿性、公平性。申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。</p>
<h4 id="底层实现-2"><a href="#底层实现-2" class="headerlink" title="底层实现"></a>底层实现</h4><p><strong>基于volatile + CAS + 队列来实现。</strong></p>
<h5 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h5><p><strong>同步器依赖内部的 同步队列（FIFO双向队列）来完成同步状态管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node），然后基于CAS的方式放入到同步队列尾部，同时会阻塞当前线程，当同步队列首节点释放同步状态时，会唤醒后继节点来获取同步状态，后继节点获取同步状态成功后会将自己设置为首节点。</strong></p>
<p>同步队列中的节点（Node）保存的内容：<strong>获取同步状态失败的线程引用、等待状态以及前驱和后继节点。</strong></p>
<p>同步队列的基本结构如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200721002028762.png?token=AIGEF3K7UBTFCK3VU76IGCTEZZY7U" alt="image-20200721002028762"></p>
<p>同步器拥有首节点（head） 和尾节点（tail）。 当一个线程无法获取到同步状态时，会被构造成节点并放入到同步队列末尾。放入队列末尾的操作将通过调用CAS方法：<code>compareAndSetTail(Node expect,Node update)</code>来实现，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。 插入过程如图所示：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200721002419902.png?token=AIGEF3KHSKMLNT7SRLOKJKTEZZZA2" alt="image-20200721002419902"></p>
<p>同步队列遵循FIFO规则，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点来获取同步状态，而后继节点在获取同步状态成功时会将自己设置为首节点。</p>
<p>注意：<strong>由于只有一个线程能够成功获取到同步状态，因此设置头节点的操作并不需要通过CAS来保证。</strong> </p>
<h5 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h5><p><strong>等待队列是一个FIFO单向队列。线程A调用Condition.await()方法将会导致线程A释放锁并被构造成节点放入到等待队列末尾，同时线程A进入等待状态。</strong></p>
<p>等待队列基本结构如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200721004540435.png?token=AIGEF3NQLSRDPSWZXDGZACLEZZZEI" alt="image-20200721004540435"></p>
<p><strong>Object监视器模型中，一个对象拥有一个同步队列和等待队列，而并发包中的 Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列，</strong>其对应关系如图所示：</p>
<p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200721004716947.png?token=AIGEF3IGGKYM4Z4T7SDOZYDEZZZFK" alt="image-20200721004716947"></p>
<h5 id="独占式获取与释放"><a href="#独占式获取与释放" class="headerlink" title="独占式获取与释放"></a>独占式获取与释放</h5><p><strong>调用同步器的acquire(int arg)方法可以获取同步状态，该方法对中断不敏感。</strong></p>
<p>当前线程调用<code>acquireQueued(final Node node,int arg)</code>方法会在“死循环”中尝试获取同步状态，而只有前驱节点是头节点才能够尝试获取同步状态，这是为什么？原因有两个：</p>
<ol>
<li>头节点是成功获取到同步状态的节点，头节点中的线程释放同步状态后会唤醒后继节点来获取同步状态，后继节点中的线程被唤醒后还需要检查自己的前驱节点是否是头节点。 </li>
<li>维护同步队列的FIFO原则。</li>
</ol>
<p><strong>调用同步器的<code>release(int arg)</code>方法会释放同步状态，释放同步状态后会唤醒后继节点来尝试获取同步状态。</strong></p>
<h5 id="共享式获取与释放"><a href="#共享式获取与释放" class="headerlink" title="共享式获取与释放"></a>共享式获取与释放</h5><p>共享式获取与独占式获取最主要的区别在于：<strong>同一时刻能否有多个线程同时获取到同步状态。</strong></p>
<p><strong>通过调用同步器的acquireShared(int arg)方法可以共享式获取同步状态。</strong>共享式成功获取到同步状态并退出自旋的条件是<code>tryAcquireShared(int arg)</code>方法返回值大于等于0。其具体过程：如果当前节点的前驱节点是头节点，则尝试获取同步状态，返回值大于等于0时标志着获取同步状态成功并从自旋过程中退出。</p>
<p>与独占式一样，共享式获取也需要释放同步状态，<strong>通过调用releaseShared(int arg)方法可以释放同步状态。</strong></p>
<h3 id="5-8-4、Unsafe"><a href="#5-8-4、Unsafe" class="headerlink" title="5.8.4、Unsafe"></a>5.8.4、Unsafe</h3><h4 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h4><ol>
<li>主要用来操作JVM中的内存。</li>
<li>直接操作内存：allocateMemory、putXX、freeMemory、pageSize</li>
<li>直接生成实例：allocateInstance。</li>
<li>直接操作类或实例变量：objectFieldOffset、getInt、getObject。</li>
<li>CAS相关：weakCompareAndSetObject &#x2F; int &#x2F; Long。</li>
<li>Unsafe相当于C&#x2F;C++中的指针。</li>
</ol>
<blockquote>
<p>注意：<strong>C分配&#x2F;释放内存使用malloc&#x2F;free，C++分配&#x2F;释放内存使用new&#x2F;delete。</strong></p>
</blockquote>
<h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><p>Atomicinteger：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    	<span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token keyword">int</span> next <span class="token operator">=</span> current <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span>
    	<span class="token keyword">return</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Unsafe:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">,</span> <span class="token keyword">int</span> var5<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>运用：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span><span class="token class-name">Unsafe</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Field</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">T02_TestUnsafe</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">T02_TestUnsafe</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T02_TestUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//Unsafe unsafe = Unsafe.getUnsafe();</span>

        <span class="token class-name">Field</span> unsafeField <span class="token operator">=</span> <span class="token class-name">Unsafe</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        unsafeField<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Unsafe</span> unsafe <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Unsafe</span><span class="token punctuation">)</span> unsafeField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Field</span> f <span class="token operator">=</span> <span class="token class-name">T02_TestUnsafe</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"i"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> offset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">boolean</span> success <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//unsafe.compareAndSwapInt()</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>jdk8u: unsafe.cpp:</p>
<p>cmpxchg &#x3D; compare and exchange</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))
  UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;);
  oop p &#x3D; JNIHandles::resolve(obj);
  jint* addr &#x3D; (jint *) index_oop_from_field_offset_long(p, offset);
  return (jint)(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e;
UNSAFE_END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>jdk8u: atomic_linux_x86.inline.hpp</p>
<p>is_MP &#x3D; Multi Processor  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">inline jint Atomic::cmpxchg(jint exchange_value, volatile jint*dest, jint compare_value) &#123;
  int mp &#x3D; os::is_MP();
  __asm__ volatile (LOCK_IF_MP(%4) &quot;cmpxchgl %1,(%3)&quot;
                    : &quot;&#x3D;a&quot; (exchange_value)
                    : &quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp)
                    : &quot;cc&quot;, &quot;memory&quot;);
  return exchange_value;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>jdk8u: os.hpp is_MP()</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static inline bool is_MP() &#123;
  &#x2F;&#x2F; During bootstrap if _processor_count is not yet initialized
  &#x2F;&#x2F; we claim to be MP as that is safest. If any platform has a
  &#x2F;&#x2F; stub generator that might be triggered in this phase and for
  &#x2F;&#x2F; which being declared MP when in fact not, is a problem - then
  &#x2F;&#x2F; the bootstrap routine for the stub generator needs to check
  &#x2F;&#x2F; the processor count directly and leave the bootstrap routine
  &#x2F;&#x2F; in place until called after initialization has ocurred.
  return (_processor_count !&#x3D; 1) || AssumeMP;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>jdk8u: atomic_linux_x86.inline.hpp</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define LOCK_IF_MP(mp) &quot;cmp $0, &quot; #mp &quot;; je 1f; lock; 1: &quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>最终实现：cmpxchg &#x3D; cas修改变量值</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lock cmpxchg 指令<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>硬件：lock指令在执行后面指令的时候锁定一个北桥信号（不采用锁总线的方式）。</p>
<h1 id="6、Java线程池"><a href="#6、Java线程池" class="headerlink" title="6、Java线程池"></a>6、Java线程池</h1><h2 id="6-1、认识线程池"><a href="#6-1、认识线程池" class="headerlink" title="6.1、认识线程池"></a>6.1、认识线程池</h2><h3 id="6-1-1、线程池优点"><a href="#6-1-1、线程池优点" class="headerlink" title="6.1.1、线程池优点"></a>6.1.1、线程池优点</h3><p>合理地使用线程池能够带来3个好处：</p>
<ol>
<li>降低资源消耗。</li>
<li>提高响应速度。</li>
<li>提高线程的可管理性。</li>
</ol>
<h3 id="6-1-2、提交任务"><a href="#6-1-2、提交任务" class="headerlink" title="6.1.2、提交任务"></a>6.1.2、提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。</p>
<p>两者区别如下：</p>
<ol>
<li>execute方法没有返回值，submit方法有返回值；</li>
<li>execute方法会抛出异常，submit方法不会抛出异常，但可通过Future.get方法打印异常；</li>
<li>execute方法入参为Runnable，submit方法入参可以是Runnable，也可以是Callable；</li>
</ol>
<h3 id="6-1-3、执行任务"><a href="#6-1-3、执行任务" class="headerlink" title="6.1.3、执行任务"></a>6.1.3、执行任务</h3><p>当提交一个新任务到线程池时，线程池的处理流程如下。</p>
<ol>
<li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li>
<li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li>
<li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li>
</ol>
<h3 id="6-1-4、关闭线程池"><a href="#6-1-4、关闭线程池" class="headerlink" title="6.1.4、关闭线程池"></a>6.1.4、关闭线程池</h3><p>调用线程池的shutdown或shutdownNow方法可以关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务 可能 永远无法终止。</p>
<p>shutdown和shutdownNow两者有区别：</p>
<ul>
<li><p><strong>shutdown</strong>：将线程池状态设置成SHUTDOWN状态，然后中断所有空闲线程。</p>
</li>
<li><p><strong>shutdownNow</strong>：先将线程池状态设置成STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。</p>
</li>
</ul>
<p>只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后才表示线程池关闭成功，这时调用isTerminaed方法会返回true。</p>
<h2 id="6-2、线程池实现"><a href="#6-2、线程池实现" class="headerlink" title="6.2、线程池实现"></a>6.2、线程池实现</h2><h3 id="6-2-1、WorkStealingPool"><a href="#6-2-1、WorkStealingPool" class="headerlink" title="6.2.1、WorkStealingPool"></a>6.2.1、WorkStealingPool</h3><h4 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h4><p><strong>WorkStealingPool是一种特殊线程池，核心很简单，和其它线程池的区别是：每一个线程都有自己单独的队列，任务会不断的插入到每一个线程对应的队列中，某个线程执行完自己队列中的任务后，会尝试从其它线程的队列中取出任务来执行，这个就是WorkStealingPool。</strong></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>本质上是一个ForkJoinPool。</p>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>针对通常意义上的线程池来说，如果某一个线程任务量非常庞大，一直占据着CPU，与此同时其它线程就算是闲着也不能去帮忙——无能为力；而WorkStealingPool就灵活了许多，遇到任务量庞大的线程，其它线程如果执行完了自己的任务后，可以帮忙执行这个任务量庞大的线程，提高了执行效率。</p>
<h3 id="6-2-2、ForkJoinPool"><a href="#6-2-2、ForkJoinPool" class="headerlink" title="6.2.2、ForkJoinPool"></a>6.2.2、ForkJoinPool</h3><h4 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h4><p><strong>ForkJoinPool适合把大任务切分成一个个小任务去执行，如果觉得小任务还是太大，那就再切，切到满意为止。每一个小任务执行完成后需要进行汇总——小任务汇总到父任务，父任务最终汇总到根任务，最后得到最终期望的结果，这个汇总合并的过程叫join，故该线程池称为ForkJoinPool。</strong></p>
<p>Fork&#x2F;Join默认会创建与CPU核数数量相同的线程池。</p>
<h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><p>一般实现ForkJoinPool的时候需要定义为特定的类型——能进行切分的任务，故出现了该种类型的任务——ForkJoinTask。但ForkJoinTask太过于原始，我们可以使用RecursiveAction，其有两种形式：</p>
<ol>
<li>RecursiveAction递归：大任务可以切分成小任务，小任务还可以再切分成更小的任务，其隐含了一个递归过程，因此叫RecursiveAction递归，不带返回值。</li>
<li>从RecursiveTask继承，有返回值。</li>
</ol>
<h2 id="6-3、默认线程池"><a href="#6-3、默认线程池" class="headerlink" title="6.3、默认线程池"></a>6.3、默认线程池</h2><p>Class Executors中提供了默认线程池创建API，不过最终还是会通过ThreadPoolExecutor去实现。</p>
<p>Executors常用线程池实现有：</p>
<ol>
<li>SingleThreadExecutor</li>
<li>CachedThreadPool</li>
<li>FixedThreadPool</li>
<li>ScheduledThreadPool</li>
</ol>
<h3 id="6-3-1、SingleThreadExecutor"><a href="#6-3-1、SingleThreadExecutor" class="headerlink" title="6.3.1、SingleThreadExecutor"></a>6.3.1、SingleThreadExecutor</h3><ul>
<li><p>简介：线程池中只有一个线程，一个线程的线程池可以保证扔进去的任务是顺序执行的。</p>
</li>
<li><p>特点（默认）：核心1，最大1，空闲0L，单位毫秒，队列LinkedBlockingQueue，工厂DefaultThreadFactory，拒绝策略AbortPolicy；</p>
</li>
<li><p>实例</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="6-3-2、CachedThreadPool"><a href="#6-3-2、CachedThreadPool" class="headerlink" title="6.3.2、CachedThreadPool"></a>6.3.2、CachedThreadPool</h3><ul>
<li><p>简介：提交一个任务时，若线程池中没有线程则创建一个线程来执行该任务，若有则不创建。</p>
</li>
<li><p>特点（默认）：核心0，最大Integer.MAX_VALUE，空闲60，单位秒，队列SynchronousQueue(默认false非公平；fair ? new TransferQueue<E>() : new TransferStack<E>();)，工厂DefaultThreadFactory，拒绝策略AbortPolicy；</p>
</li>
<li><p>实例</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1 service: "</span> <span class="token operator">+</span> service<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>
        <span class="token function">shhSleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2 service: "</span> <span class="token operator">+</span> service<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">shhSleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3 service: "</span> <span class="token operator">+</span> service<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">--</span><span class="token operator">-</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shhSleep</span><span class="token punctuation">(</span><span class="token keyword">long</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="6-3-3、FixedThreadPool"><a href="#6-3-3、FixedThreadPool" class="headerlink" title="6.3.3、FixedThreadPool"></a>6.3.3、FixedThreadPool</h3><ul>
<li><p>简介：固定的线程数，核心线程数和最大线程数都一样，因此没有回收之说，故就指定为0。</p>
</li>
<li><p>特点（默认）：核心、最大显式指定且一样，空闲0，单位毫秒，队列LinkedBlockingQueue，工厂DefaultThreadFactory，拒绝策略AbortPolicy；</p>
</li>
<li><p>实例</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">FixedThreadPoolTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">long</span> start<span class="token punctuation">,</span> end<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> cpuCoreNum <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span>cpuCoreNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Task</span> task1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">80000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Task</span> task2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token number">80001</span><span class="token punctuation">,</span> <span class="token number">130000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Task</span> task3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token number">130001</span><span class="token punctuation">,</span> <span class="token number">170000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Task</span> task4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token number">170001</span><span class="token punctuation">,</span> <span class="token number">200000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> f1 <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> f2 <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> f3 <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> f4 <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task4<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span><span class="token punctuation">&#123;</span>
        start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        f1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        f2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        f3<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        f4<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token operator">--</span><span class="token operator">-</span>

<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Task</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> startPos<span class="token punctuation">,</span> endPos<span class="token punctuation">;</span>
    <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>startPos <span class="token operator">=</span> s<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>endPos <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> r <span class="token operator">=</span> <span class="token function">getPrime</span><span class="token punctuation">(</span>startPos<span class="token punctuation">,</span> endPos<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> r<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">getPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> results <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPrime</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
                results<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> results<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="6-3-4、ScheduledThreadPool"><a href="#6-3-4、ScheduledThreadPool" class="headerlink" title="6.3.4、ScheduledThreadPool"></a>6.3.4、ScheduledThreadPool</h3><ul>
<li><p>简介：定时任务池，本质上还是ThreadPoolExecutor。</p>
</li>
<li><p>特点（默认）：核心指定，最大Integer.MAX_VALUE，空闲0，单位纳秒，队列DelayedWorkQueue，工厂DefaultThreadFactory，拒绝策略AbortPolicy；</p>
</li>
<li><p>实例</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">ScheduledThreadPoolTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token class-name">ScheduledExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>
            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h2 id="6-4、自定义线程池"><a href="#6-4、自定义线程池" class="headerlink" title="6.4、自定义线程池"></a>6.4、自定义线程池</h2><h3 id="6-4-1、简介"><a href="#6-4-1、简介" class="headerlink" title="6.4.1、简介"></a>6.4.1、简介</h3><p>自定义线程池可通过ThreadPoolExecutor来实现，其相关参数如下：</p>
<ol>
<li><p>corePoolSize（核心线程数）</p>
</li>
<li><p>maximumPoolSize（最大线程数）</p>
</li>
<li><p>keepAliveTime（空闲时间）</p>
</li>
<li><p>TimeUnit unit（空闲时间单位）</p>
</li>
<li><p>BlockingQueue workQueue（阻塞队列）</p>
</li>
<li><p>ThreadFactory threadFactory（线程工厂）</p>
</li>
<li><p>RejectedExecutionHandler handler（拒绝策略）：拒绝策略有四种</p>
<ol>
<li>AbortPolicy（默认）：抛异常RejectedExecutionException</li>
<li>DiscardPolicy：扔掉，不抛异常。</li>
<li>DiscardOldestPolicy：扔掉排队时间最久的。但是线程池如果关闭了，任务就会被丢弃。</li>
<li>CallerRunsPolicy：调用者来处理被拒绝的任务，比如主线程调用submit方法任务，但任务被拒绝，则主线程直接执行。但是线程池如果关闭了，任务就会被丢弃。</li>
</ol>
<p>除此之外还可以自定义拒绝策略，方式为：实现接口<code>RejectedExecutionHandler</code>，并重写其<code>rejectedExecution(Runnable r, ThreadPoolExecutor executor)</code>方法。</p>
</li>
<li><p>boolean allowCoreThreadTimeOut：是否允许核心线程超时销毁，该参数不在构造函数中，但也极其重要。</p>
<p><font color="orange">取值定义</font>：如果为false（默认），则表示即使处于空闲状态，核心线程也保持活动状态（不销毁）。如果为true，则核心线程使用keepAliveTime来超时等待工作（时间过后就销毁）。</p>
</li>
</ol>
<h3 id="6-4-2、使用示例"><a href="#6-4-2、使用示例" class="headerlink" title="6.4.2、使用示例"></a>6.4.2、使用示例</h3><p>拒绝策略使用示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ThreadPoolExecutor</span> executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="6-4-3、最合适的线程数量"><a href="#6-4-3、最合适的线程数量" class="headerlink" title="6.4.3、最合适的线程数量"></a>6.4.3、最合适的线程数量</h3><h4 id="6-4-3-1、CPU密集型运算"><a href="#6-4-3-1、CPU密集型运算" class="headerlink" title="6.4.3.1、CPU密集型运算"></a>6.4.3.1、CPU密集型运算</h4><p><strong>CPU密集型业务通常采用 cpu核数+1 的数量值作为合适的线程数量。</strong>这样可以实现最优的CPU利用率，加1是保证当线程由于页缺失或其它问题导致暂停时，额外的线程就能顶上去，保证CPU时钟周期不浪费。</p>
<h4 id="6-4-3-2、IO密集型运算"><a href="#6-4-3-2、IO密集型运算" class="headerlink" title="6.4.3.2、IO密集型运算"></a>6.4.3.2、IO密集型运算</h4><p>CPU不总是处于繁忙状态，例如，当执行业务计算时会使用CPU资源，但当执行IO操作、RPC远程调用、数据库操作时，CPU不会工作会空闲下来，此时可以利用多线程来提高CPU利用率。</p>
<p>经验公式如下：<br>$$<br>线程数量 &#x3D; 核数 * CPU期望利用率 * 总时间(CPU计算时间+等待时间) &#x2F; CPU计算时间。<br>$$<br>例如：4核CPU计算时间50%，其它等待时间是50%，期望CPU被100%利用，则</p>
<p>线程数量 &#x3D; 4 * 100% * 100% &#x2F; 50% &#x3D; 8个。</p>
<p>例如：4核 CPU计算时间10%，其它等待时间是90%，期望CPU被100%利用，则</p>
<p>线程数量 &#x3D; 4 * 100% * 100% &#x2F; 10% &#x3D; 40个。</p>
<h2 id="6-5、线程池监控"><a href="#6-5、线程池监控" class="headerlink" title="6.5、线程池监控"></a>6.5、线程池监控</h2><h3 id="6-5-1、简介"><a href="#6-5-1、简介" class="headerlink" title="6.5.1、简介"></a>6.5.1、简介</h3><p><strong>如果在系统中大量使用线程池，则有必要对线程池进行监控</strong>，方便在出现问题时，可以根据线程池的使用状况快速定位问题。</p>
<h3 id="6-5-2、监控方式"><a href="#6-5-2、监控方式" class="headerlink" title="6.5.2、监控方式"></a>6.5.2、监控方式</h3><h4 id="参数监控"><a href="#参数监控" class="headerlink" title="参数监控"></a>参数监控</h4><p><strong>可以通过线程池提供的参数进行监控</strong>，监控线程池时可以使用以下属性。</p>
<ul>
<li>taskCount：线程池需要执行的任务数量。 </li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。 </li>
<li>largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是 否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。 </li>
<li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。 </li>
<li>getActiveCount：获取活动的线程数。</li>
</ul>
<h4 id="扩展监控"><a href="#扩展监控" class="headerlink" title="扩展监控"></a>扩展监控</h4><p>通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的 beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执 行一些代码来进行监控。</p>
<p>例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。 这几个方法在线程池里是空方法。</p>
<h2 id="6-6、Executor框架"><a href="#6-6、Executor框架" class="headerlink" title="6.6、Executor框架"></a>6.6、Executor框架</h2><h3 id="6-6-1、Executor类结构图"><a href="#6-6-1、Executor类结构图" class="headerlink" title="6.6.1、Executor类结构图"></a>6.6.1、Executor类结构图</h3><p><img src="https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/Executor%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE01.png?token=AIGEF3NWRCARP7IVE37JHV3EZZZKE" alt="Executor类结构图01"></p>
<h3 id="6-6-2、ThreadPoolExecutor源码解析（JDK8）"><a href="#6-6-2、ThreadPoolExecutor源码解析（JDK8）" class="headerlink" title="6.6.2、ThreadPoolExecutor源码解析（JDK8）"></a>6.6.2、ThreadPoolExecutor源码解析（JDK8）</h3><h4 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h4><p>addWorker的源码分两部分：</p>
<ol>
<li>上面的嵌套for死循环，目的就是把worker数量加1。<ol>
<li>外层for循环：遍历检测状态值是否符合条件，如果状态值 &gt;&#x3D; shutdown，说明不符合条件，执行return false退出。</li>
<li>内层for循环：添加线程。先判断当前WC线程数量是否超过上限（数量 &gt; 536870911或者 &gt;&#x3D; (corePoolSize &#x2F;maximumPoolSize)），如果超过就不再添加，否则通过CAS方式进行添加。如果添加成功了，则执行break retr跳出双层循环，这说明第一步算是完成了；如果没有添加成功就继续AtomicInteger的get方法，然后跳到最外层循环处进行重新处理；</li>
</ol>
</li>
<li>创建一个Worker并执行这个Worker。</li>
</ol>
<h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><ol>
<li><p>如果任务为null，则抛出异常。</p>
</li>
<li><p>工作线程数 是否小于 核心线程数，若小于则直接创建核心线程。否则将任务放入队列中。</p>
</li>
<li><p>如果线程池不是运行状态，或者任务进入队列失败了，则创建非核心线程执行任务。</p>
</li>
</ol>
<p><font color='red'>注意事项：</font></p>
<ol>
<li>线程非运行状态时，addWorker内部会判断线程池状态。</li>
<li>addWorker的第二个参数表示是否创建核心线程。</li>
<li>addWorker返回false，说明任务执行失败，需要进行reject操作。</li>
</ol>
<h4 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h4><p><strong>启动线程后会通过该方法去执行任务，期间需要加锁</strong>。</p>
<ol>
<li><p>先执行Worker.unlock()方法来允许中断操作；变量boolean completedAbruptly 用于表示是否自旋。</p>
</li>
<li><p>自旋过程。如果firstTask不为null 或者 任务队列不为空，则从队列拿任务来执行，否则将 completedAbruptly设为false; 且最终执行processWorkerExit(w, completedAbruptly);</p>
<p>从队列拿到任务后，执行任务的过程如下：</p>
<ol>
<li>w.lock()加锁，任务执行的原子性。</li>
<li>如果线程池正在停止，则对当前线程进行中断操作。</li>
<li>执行任务的前后通过beforeExecute()、afterExecute()来扩展功能。但要注意这两个方法在该类中默认是空实现。</li>
<li>执行 completedAbruptly &#x3D; false;  和  processWorkerExit(w, completedAbruptly);</li>
</ol>
</li>
</ol>
<h3 id="6-6-3、ScheduledThreadPoolExecutor"><a href="#6-6-3、ScheduledThreadPoolExecutor" class="headerlink" title="6.6.3、ScheduledThreadPoolExecutor"></a>6.6.3、ScheduledThreadPoolExecutor</h3><h4 id="简介-12"><a href="#简介-12" class="headerlink" title="简介"></a>简介</h4><p>继承自ThreadPoolExecutor，<strong>可在指定延迟之后运行任务，或者定期执行任务。</strong>其功能与Timer类似，但 ScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而 ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。</p>
<h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><p>ScheduledThreadPoolExecutor的执行主要分为两大部分：</p>
<ol>
<li>当调用ScheduledThreadPoolExecutor的scheduleAtFixedRate()方法或者scheduleWithFixedDelay()方法时，会向ScheduledThreadPoolExecutor的DelayQueue添加一个实现了 RunnableScheduledFutur接口的ScheduledFutureTask。</li>
<li>线程池中的线程从DelayQueue中获取ScheduledFutureTask，然后执行任务。</li>
</ol>
<h4 id="底层实现-3"><a href="#底层实现-3" class="headerlink" title="底层实现"></a>底层实现</h4><p>ScheduledThreadPoolExecutor会把待调度的任务（ScheduledFutureTask） 放到一个DelayQueue中。</p>
<p>ScheduledFutureTask主要包含3个成员变量：</p>
<ul>
<li>long型成员变量time，表示这个任务将要被执行的具体时间。 </li>
<li>long型成员变量sequenceNumber，表示这个任务被添加到ScheduledThreadPoolExecutor中的序号。 </li>
<li>long型成员变量period，表示任务执行的间隔周期。</li>
</ul>
<h3 id="6-6-4、FutureTask"><a href="#6-6-4、FutureTask" class="headerlink" title="6.6.4、FutureTask"></a>6.6.4、FutureTask</h3><p>Future接口和实现Future接口的FutureTask类，代表异步计算的结果。</p>
<h4 id="简介-13"><a href="#简介-13" class="headerlink" title="简介"></a>简介</h4><p>FutureTask除了实现Future接口外，还实现了Runnable接口。因此，<strong>FutureTask可以交给 Executor执行，也可以由调用线程直接执行（FutureTask.run()）。</strong></p>
<p>根据FutureTask.run()方法被执行的时机，FutureTask可处于3种状态：</p>
<ul>
<li>未启动<ol>
<li>FutureTask.get()方法将导致调用线程阻塞；</li>
<li>FutureTask.cancel()方法将导致此任务永远不会被执行；</li>
</ol>
</li>
<li>已启动<ol>
<li>FutureTask.get()方法将导致调用线程阻塞；</li>
<li>FutureTask.cancel（true）方法将以中断执行此任务线程 的方式来试图停止任务；</li>
<li>FutureTask.cancel（false）方法将 不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）；</li>
</ol>
</li>
<li>已完成<ol>
<li>FutureTask.get()方法将导致调用线程立即返回结果或抛出异常；</li>
<li>FutureTask.cancel（…）方法将返回false。</li>
</ol>
</li>
</ul>
<h4 id="底层实现-4"><a href="#底层实现-4" class="headerlink" title="底层实现"></a>底层实现</h4><p>FutureTask的实现基于AbstractQueuedSynchronizer。</p>
<p>AQS被作为“模板方法模式”的基础类提供给FutureTask的内部子类Sync，这个内部子类只需要实现状态检查和状态更新的方法即可，这些方法将控制FutureTask的获取和释放操作。具体来说，Sync实现了AQS的tryAcquireShared(int) 方法和 tryReleaseShared(int) 方法，Sync通过这两个方法来检查和更新同步状态。</p>
<h2 id="6-7、总结"><a href="#6-7、总结" class="headerlink" title="6.7、总结"></a>6.7、总结</h2><h3 id="6-7-1、建议使用ThreadPoolExecutor创建线程池？"><a href="#6-7-1、建议使用ThreadPoolExecutor创建线程池？" class="headerlink" title="6.7.1、建议使用ThreadPoolExecutor创建线程池？"></a>6.7.1、建议使用ThreadPoolExecutor创建线程池？</h3><ol>
<li><p>Executors提供的线程池使用场景有限。</p>
</li>
<li><p>Executors底层还是调用ThreadPoolExecutor创建线程池。</p>
</li>
<li><p>OOM问题（阿里手册）</p>
<ol>
<li><p>FixedThreadPool 和 SingleThreadPool</p>
<p>两者允许的队列长度为Integer.MAX_VALUE，可能堆积大量请求，进而导致OOM。</p>
</li>
<li><p>CachedThreadPool</p>
<p>允许创建的线程数量为Integer.MAX_VALUE，可能创建大量的线程，进而导致OOM。</p>
</li>
</ol>
</li>
</ol>
<h3 id="6-7-2、生产中如何选择使用正确的队列？"><a href="#6-7-2、生产中如何选择使用正确的队列？" class="headerlink" title="6.7.2、生产中如何选择使用正确的队列？"></a>6.7.2、生产中如何选择使用正确的队列？</h3><p>根据实际情况来选择：</p>
<ol>
<li>高峰期的任务，建议使用LinkedBlockingQueue，这个是无界队列，不限制任务数量。</li>
<li>重要性较低的任务，建议使用ArrayBlockingQueue，这个队列需要指定大小，如果任务超出，会创建非核心线程执行任务。</li>
</ol>
<h3 id="6-7-3、生产中如何保证线程池队列的可用性？"><a href="#6-7-3、生产中如何保证线程池队列的可用性？" class="headerlink" title="6.7.3、生产中如何保证线程池队列的可用性？"></a>6.7.3、生产中如何保证线程池队列的可用性？</h3><ol>
<li>设计一个线程管理器，通过一个定时任务 定时检测 Map中线程池当前任务队列的状态，会设置一个报警阈值（waterThreshold - 水位线），超过该阈值就会报警，然后根据实际情况去应对。</li>
<li>线程池压测，如果发生超水位现象，就对线程按线程名做降级，动态调整核心线程数和队列，当然还有限流等保障。</li>
</ol>
<h3 id="6-7-4、如何拆分线程池、核心任务数、队列大小呢？"><a href="#6-7-4、如何拆分线程池、核心任务数、队列大小呢？" class="headerlink" title="6.7.4、如何拆分线程池、核心任务数、队列大小呢？"></a>6.7.4、如何拆分线程池、核心任务数、队列大小呢？</h3><ol>
<li><p>按照 任务类型 拆分任务，使用不同的线程池，分别命名。</p>
</li>
<li><p>区分 任务类型。其是 CPU密集型 还是 IO密集型，CPU密集型 可以设置 核心线程数为CPU核心数，上下文切换少；IO密集型则可以设置核心线程数大一点。</p>
</li>
<li><p>压测并估算，可以参考线程池变量largestPoolSize，它表示线程池达到过的最大线程任务。</p>
</li>
<li><p>设置核心线程数参考公式如下：</p>
<p><strong>最佳线程数 &#x3D; ((线程等待时间 + 线程CPU时间) &#x2F; 线程CPU时间) * CPU数量;</strong></p>
</li>
</ol>
<h1 id="7、高效存储工具"><a href="#7、高效存储工具" class="headerlink" title="7、高效存储工具"></a>7、高效存储工具</h1><h2 id="7-1、Disruptor"><a href="#7-1、Disruptor" class="headerlink" title="7.1、Disruptor"></a>7.1、Disruptor</h2><h3 id="7-1-1、简介"><a href="#7-1-1、简介" class="headerlink" title="7.1.1、简介"></a>7.1.1、简介</h3><p><strong>Disruptor是分裂、瓦解的意思。Disruptor是一个做金融、做股票的公司开发的，开源后受到广泛认可，2011年获得Duke奖。</strong>如果将之用作MQ的话，其是单机最快的MQ。该工具性能非常高，因为内部用了大量的CAS，另外把各种各样的性能开发到了极致。</p>
<p><strong>Disruptor存储在内存中，简单理解就是内存中用于存储元素的一个高效队列。</strong></p>
<p>Disruptor称为无锁的、高并发的、环形Buffer，直接覆盖旧数据，降低GC频率，用于生产者消费者模式。</p>
<h3 id="7-1-2、核心及特点"><a href="#7-1-2、核心及特点" class="headerlink" title="7.1.2、核心及特点"></a>7.1.2、核心及特点</h3><p><strong>Disruptor是一个环形队列、环形Buffer。</strong>Disruptor是用数组实现的一个队列，你也可以认为Disruptor就是用数组实现的ConcurrentArrayQueue，另外这个Queue是首尾相连。</p>
<h3 id="7-1-3、实现原理"><a href="#7-1-3、实现原理" class="headerlink" title="7.1.3、实现原理"></a>7.1.3、实现原理</h3><h4 id="Disruptor为啥快？"><a href="#Disruptor为啥快？" class="headerlink" title="Disruptor为啥快？"></a>Disruptor为啥快？</h4><p>环形结构 只需维护 一个位置，就是sequence序列，该序列表示下一个元素在哪里，相当于只有一个指针在移动定位。位置可以通过数值与环形队列容量取模获得。</p>
<p>由于采用覆盖方式，所以没有必要记录头指针和尾指针。我只需要一个指针就够用了，就这一点来说依然比ConcurrentLinkedQueue要快。</p>
<h4 id="生产者装满数据后继续装会覆盖吗？"><a href="#生产者装满数据后继续装会覆盖吗？" class="headerlink" title="生产者装满数据后继续装会覆盖吗？"></a>生产者装满数据后继续装会覆盖吗？</h4><p>不会覆盖的，因为有等待策略——生产者生产满了就要停止生产并进入等待状态。等待策略共有8种，详情见总结部分。</p>
<h3 id="7-1-4、开发步骤"><a href="#7-1-4、开发步骤" class="headerlink" title="7.1.4、开发步骤"></a>7.1.4、开发步骤</h3><p>开发步骤是比较固定的。</p>
<ol>
<li>定义Event：队列中需要处理的元素。</li>
<li>定义Event工厂：用于填充队列。</li>
<li>定义EventHandle（消费者）：处理容器中的元素。</li>
</ol>
<h3 id="7-1-5、入门案例"><a href="#7-1-5、入门案例" class="headerlink" title="7.1.5、入门案例"></a>7.1.5、入门案例</h3><h4 id="OrderEvent-java"><a href="#OrderEvent-java" class="headerlink" title="OrderEvent.java"></a>OrderEvent.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderEvent</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> value<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token keyword">long</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="OrderEventFactory-java"><a href="#OrderEventFactory-java" class="headerlink" title="OrderEventFactory.java"></a>OrderEventFactory.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderEventFactory</span> <span class="token keyword">implements</span> <span class="token class-name">EventFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OrderEvent</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">OrderEvent</span> <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">OrderEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="OrderEventHandler-java"><a href="#OrderEventHandler-java" class="headerlink" title="OrderEventHandler.java"></a>OrderEventHandler.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderEventHandler</span> <span class="token keyword">implements</span> <span class="token class-name">EventHandler</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OrderEvent</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onEvent</span><span class="token punctuation">(</span><span class="token class-name">OrderEvent</span> event<span class="token punctuation">,</span> <span class="token keyword">long</span> sequence<span class="token punctuation">,</span> <span class="token keyword">boolean</span> endOfBatch<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者："</span> <span class="token operator">+</span> event<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="OrderEventProducer-java"><a href="#OrderEventProducer-java" class="headerlink" title="OrderEventProducer.java"></a>OrderEventProducer.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderEventProducer</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token class-name">RingBuffer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OrderEvent</span><span class="token punctuation">></span></span> ringBuffer<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">OrderEventProducer</span><span class="token punctuation">(</span><span class="token class-name">RingBuffer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OrderEvent</span><span class="token punctuation">></span></span> ringBuffer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>ringBuffer <span class="token operator">=</span> ringBuffer<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendData</span><span class="token punctuation">(</span><span class="token class-name">ByteBuffer</span> data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">long</span> sequence <span class="token operator">=</span> ringBuffer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>
            <span class="token comment">//1. 在生产者发送消息的时候，首先需要从ringBuffer里面获取一个可用的序号</span>
            <span class="token comment">//2. 根据这个序号 找到具体的“orderEvent”元素 此时获取的OrderEvent是一个空的对象</span>
            <span class="token class-name">OrderEvent</span> event <span class="token operator">=</span> ringBuffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>sequence<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//3 进行实际的赋值操作</span>
            event<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">getLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 4 提交操作</span>
            ringBuffer<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span>sequence<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="App-java"><a href="#App-java" class="headerlink" title="App.java"></a>App.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">OrderEventFactory</span> orderEventFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderEventFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> ringBufferSize <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>

        <span class="token comment">/**
         *  1 eventFacotry 消息工厂对象
         *  2 ringBufferSize 容器的长度
         *  3 executor 线程池
         *  4 ProducerType 生产者类型
         *  5 waitStartegy 等待策略
         */</span>
        <span class="token comment">// 1 实例化一个disruptor的对象</span>
        <span class="token class-name">Disruptor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OrderEvent</span><span class="token punctuation">></span></span> disruptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Disruptor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>orderEventFactory<span class="token punctuation">,</span> ringBufferSize<span class="token punctuation">,</span> executor<span class="token punctuation">,</span> <span class="token class-name">ProducerType</span><span class="token punctuation">.</span><span class="token constant">SINGLE</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">BlockingWaitStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2 添加消费者的监听(Disruptor 与消费者的一个关联关系)</span>
        disruptor<span class="token punctuation">.</span><span class="token function">handleEventsWith</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OrderEventHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 3 启动disruptor</span>
        disruptor<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 4 获取实际存储数据的容器 RingBuffer</span>
        <span class="token class-name">RingBuffer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OrderEvent</span><span class="token punctuation">></span></span> ringBuffer <span class="token operator">=</span> disruptor<span class="token punctuation">.</span><span class="token function">getRingBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">OrderEventProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderEventProducer</span><span class="token punctuation">(</span>ringBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 生成一百个数 然后丢给producer</span>
        <span class="token class-name">ByteBuffer</span> bb <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            bb<span class="token punctuation">.</span><span class="token function">putLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            producer<span class="token punctuation">.</span><span class="token function">sendData</span><span class="token punctuation">(</span>bb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 关闭disruptor和线程池</span>
        disruptor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="7-1-6、总结"><a href="#7-1-6、总结" class="headerlink" title="7.1.6、总结"></a>7.1.6、总结</h3><h4 id="ProducerType（生产者线程模式）"><a href="#ProducerType（生产者线程模式）" class="headerlink" title="ProducerType（生产者线程模式）"></a>ProducerType（生产者线程模式）</h4><p><strong>ProducerType有两种模式：Producer.MULTI 和 Producer.SINGLE。默认为MULTI，表示在多线程模式下产生sequence。如果确定是单线程生产者，可以指定SINGLE，效率会有提升。</strong></p>
<h4 id="等待策略（8种）"><a href="#等待策略（8种）" class="headerlink" title="等待策略（8种）"></a>等待策略（8种）</h4><ol>
<li>BlockingWaitStrategy（常用）：通过线程阻塞的方式，等待生产者被唤醒，唤醒后再次检查依赖的sequence是否已经消费。</li>
<li>BusySpinWaitStrategy：线程一直自旋等待，可能比较消耗CPU。</li>
<li>LiteBlockingWaitStrategy：线程阻塞等待生产者被唤醒。与第1个的区别是——如果两个线程同时访问一个waitfor，一个访问signalAll时，可以减少lock加锁次数。</li>
<li>LiteTimeoutBlockingWaitStrategy：与第3个相比，该策略设置了阻塞时间，超过时间后抛出异常。</li>
<li>PhasedBackoffWaitStrategy：根据时间参数和等待的策略来决定使用哪种等待策略。</li>
<li>TimeoutBlockingWaitStrategy：相对于第1个来说，该策略设置了等待时间，超过后抛出异常。</li>
<li>YieldingWatitStrategy（常用）：尝试100次，然后Thread.yield()让出CPU。</li>
<li>SleepingWaitStrategy（常用）：sleep。</li>
</ol>
<h4 id="消费者异常处理"><a href="#消费者异常处理" class="headerlink" title="消费者异常处理"></a>消费者异常处理</h4><ol>
<li>默认：disruptor.setDefaultExceptionHandler()；</li>
<li>覆盖：disruptor.handleExceptionFor().wait()；</li>
</ol>
<h1 id="8、高效测试工具"><a href="#8、高效测试工具" class="headerlink" title="8、高效测试工具"></a>8、高效测试工具</h1><h2 id="8-1、JMH"><a href="#8-1、JMH" class="headerlink" title="8.1、JMH"></a>8.1、JMH</h2><h4 id="8-1-1、简介"><a href="#8-1-1、简介" class="headerlink" title="8.1.1、简介"></a>8.1.1、简介</h4><p><strong>JMH全程为 java Microbenchmark Harness，意为Java微基准测试。它测试的是一个方法的性能，换了一种实现后再次观察其性能好坏。</strong></p>
<p><font color='red'>注意：该测试框架于2013年由JLT人员开发而成，后来归到了OpenJDK下面。</font></p>
<h4 id="8-1-2、JMH相关概念"><a href="#8-1-2、JMH相关概念" class="headerlink" title="8.1.2、JMH相关概念"></a>8.1.2、JMH相关概念</h4><ol>
<li>Benchmark mode：基准测试的模式。</li>
<li>Warmup：预热，由于JVM会对特定代码进行优化，预热对于测试很重要。</li>
<li>Measurement：共执行多少次测试。</li>
<li>Timeout：超时时间。</li>
<li>Threads：线程数，由fork指定。</li>
<li>Benchmark：测试哪一段代码。</li>
</ol>
<h3 id="8-1-3、使用示例"><a href="#8-1-3、使用示例" class="headerlink" title="8.1.3、使用示例"></a>8.1.3、使用示例</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token class-name">Benchmark</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token class-name">BenchmarkMode</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token class-name">Mode</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token class-name">OutputTimeUnit</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token class-name">State</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token class-name">Scope</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token class-name">Setup</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token class-name">TearDown</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>runner<span class="token punctuation">.</span></span><span class="token class-name">Runner</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>runner<span class="token punctuation">.</span></span><span class="token class-name">RunnerException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>runner<span class="token punctuation">.</span>options<span class="token punctuation">.</span></span><span class="token class-name">Options</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>runner<span class="token punctuation">.</span>options<span class="token punctuation">.</span></span><span class="token class-name">OptionsBuilder</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span></span><span class="token punctuation">;</span>

<span class="token comment">/**
 * JMH工具测试
 */</span>
<span class="token annotation punctuation">@State</span><span class="token punctuation">(</span><span class="token class-name">Scope<span class="token punctuation">.</span>Thread</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@BenchmarkMode</span><span class="token punctuation">(</span><span class="token class-name">Mode<span class="token punctuation">.</span>AverageTime</span><span class="token punctuation">)</span>    <span class="token comment">// 测试模式</span>
<span class="token annotation punctuation">@OutputTimeUnit</span><span class="token punctuation">(</span><span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span>  <span class="token comment">// 时间单位</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JMHUseTest</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Random</span> random<span class="token punctuation">;</span>

    <span class="token comment">/**
     * 测试前的初始化
     *
     * 初始化了一个由1000个随机整数组成的List
     */</span>
    <span class="token annotation punctuation">@Setup</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * 测试后的清理动作
     */</span>
    <span class="token annotation punctuation">@TearDown</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">teardown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        list <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        random <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * 排序
     */</span>
    <span class="token annotation punctuation">@Benchmark</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        list<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">compare</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * 并行排序
     */</span>
    <span class="token annotation punctuation">@Benchmark</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testParallelSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        list<span class="token punctuation">.</span><span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">compare</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * 常用方法解析：
     * - `include(String classNameRegex)`：指定要测试的类，可以使用正则表达式来匹配多个类。
     * - `forks(int count)`：指定测试时进行的fork数量，即测试时重复运行基准测试的次数。
     * - `warmupIterations(int count)`：指定预热迭代次数，即在测量迭代次数前进行的预热迭代次数。
     * - `measurementIterations(int count)`：指定测量迭代次数，即每个基准测试运行的迭代次数。
     * - `mode(Mode mode)`：指定测试模式，包括平均时间（AverageTime）、平均吞吐量（Througput）、平均延迟（SampleTime）等。
     * - `timeUnit(TimeUnit unit)`：指定测试结果的时间单位，包括纳秒（NANOSECONDS）、微秒（MICROSECONDS）、毫秒（MILLISECONDS）等。
     * - `threads(int count)`：指定测试时使用的线程数。
     * - `verbosity(VerboseMode mode)`：指定测试结果的详细程度，包括默认（NORMAL）、详细（EXTRA）、极度详细（DEBUG）等。
     * - `jvmArgs(String... args)`：指定测试时使用的Java虚拟机参数。
     * - `addProfiler(Class&lt;? extends Profiler> profilerClass)`：指定测试时使用的分析器.
     * - `resultFormat(ResultFormatType type)`：指定测试结果的输出格式，包括文本（TEXT）、CSV、JSON等。
     *
     * 创建`Options`对象后，可以使用`Runner`类来运行基准测试。`Runner`类提供了多个方法来运行基准测试，如：
     * - `run()`：运行基准测试并输出测试结果。
     * - `runAsync()`：异步运行基准测试。
     * - `runTo(TimeValue time)`：运行基准测试并在指定时间后停止。
     * - `runTo(TimeValue time, TimeUnit timeUnit)`：运行基准测试并在指定时间后停止。
     *
     * @param args
     * @throws RunnerException
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RunnerException</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Options</span> options <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OptionsBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">include</span><span class="token punctuation">(</span><span class="token class-name">JMHUseTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">forks</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment">// 运行基准测试的次数</span>
                <span class="token punctuation">.</span><span class="token function">warmupIterations</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment">// 预热次数</span>
                <span class="token punctuation">.</span><span class="token function">measurementIterations</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>   <span class="token comment">// 基准测试执行的次数</span>
                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Runner</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">豪哥</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://hshz21.gitee.io/2023/09/14/duo-xian-cheng-yu-gao-bing-fa-zhi-shi-zong-jie/">https://hshz21.gitee.io/2023/09/14/duo-xian-cheng-yu-gao-bing-fa-zhi-shi-zong-jie/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">豪哥</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%B9%B6%E5%8F%91/">
                                    <span class="chip bg-color">并发</span>
                                </a>
                            
                                <a href="/tags/%E7%BA%BF%E7%A8%8B/">
                                    <span class="chip bg-color">线程</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wxpay.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/09/14/cun-chu-qi-zhi-shi-zong-jie/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="计算机系列-存储器">
                        
                        <span class="card-title">计算机系列-存储器</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-09-14
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="post-category">
                                    计算机
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%A3%81%E7%9B%98/">
                        <span class="chip bg-color">磁盘</span>
                    </a>
                    
                    <a href="/tags/%E5%AD%98%E5%82%A8/">
                        <span class="chip bg-color">存储</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/09/14/fen-bu-shi-shi-wu-zhi-shi-dian-zong-jie/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/23.jpg" class="responsive-img" alt="微服务系列-分布式事务">
                        
                        <span class="card-title">微服务系列-分布式事务</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-09-14
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" class="post-category">
                                    分布式事务
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E4%BA%8B%E5%8A%A1/">
                        <span class="chip bg-color">事务</span>
                    </a>
                    
                    <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">
                        <span class="chip bg-color">分布式事务</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">豪哥</a>
            |&nbsp;Powered by&nbsp;<a href="https://github.com/lucky2shh" target="_blank">豪哥</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">


    <a href="mailto:3577293158@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=3577293158" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 3577293158" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
